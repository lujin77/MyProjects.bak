/* soapC.cpp
   Generated by gSOAP 2.8.3 from soapProxy.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.3 2013-07-27 11:50:21 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__StockCardItem:
		return soap_in_ns1__StockCardItem(soap, NULL, NULL, "ns1:StockCardItem");
	case SOAP_TYPE_ns1__ArrayOfStockCardItem:
		return soap_in_ns1__ArrayOfStockCardItem(soap, NULL, NULL, "ns1:ArrayOfStockCardItem");
	case SOAP_TYPE_ns1__OtherCardItem:
		return soap_in_ns1__OtherCardItem(soap, NULL, NULL, "ns1:OtherCardItem");
	case SOAP_TYPE_ns1__ArrayOfOtherCardItem:
		return soap_in_ns1__ArrayOfOtherCardItem(soap, NULL, NULL, "ns1:ArrayOfOtherCardItem");
	case SOAP_TYPE_ns1__SellOtherCardItem:
		return soap_in_ns1__SellOtherCardItem(soap, NULL, NULL, "ns1:SellOtherCardItem");
	case SOAP_TYPE_ns1__ArrayOfSellOtherCardItem:
		return soap_in_ns1__ArrayOfSellOtherCardItem(soap, NULL, NULL, "ns1:ArrayOfSellOtherCardItem");
	case SOAP_TYPE_ns1__BusinessItem:
		return soap_in_ns1__BusinessItem(soap, NULL, NULL, "ns1:BusinessItem");
	case SOAP_TYPE_ns1__ArrayOfBusinessItem:
		return soap_in_ns1__ArrayOfBusinessItem(soap, NULL, NULL, "ns1:ArrayOfBusinessItem");
	case SOAP_TYPE_ns1__SellCardItem:
		return soap_in_ns1__SellCardItem(soap, NULL, NULL, "ns1:SellCardItem");
	case SOAP_TYPE_ns1__ArrayOfSellCardItem:
		return soap_in_ns1__ArrayOfSellCardItem(soap, NULL, NULL, "ns1:ArrayOfSellCardItem");
	case SOAP_TYPE_ns1__CardService:
		return soap_in_ns1__CardService(soap, NULL, NULL, "ns1:CardService");
	case SOAP_TYPE_ns1__ArrayOfCardService:
		return soap_in_ns1__ArrayOfCardService(soap, NULL, NULL, "ns1:ArrayOfCardService");
	case SOAP_TYPE_ns1__PayMiniCardItem:
		return soap_in_ns1__PayMiniCardItem(soap, NULL, NULL, "ns1:PayMiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfPayMiniCardItem:
		return soap_in_ns1__ArrayOfPayMiniCardItem(soap, NULL, NULL, "ns1:ArrayOfPayMiniCardItem");
	case SOAP_TYPE_ns1__MiniCardItem:
		return soap_in_ns1__MiniCardItem(soap, NULL, NULL, "ns1:MiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfMiniCardItem:
		return soap_in_ns1__ArrayOfMiniCardItem(soap, NULL, NULL, "ns1:ArrayOfMiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__PhoneNoItem:
		return soap_in_ns1__PhoneNoItem(soap, NULL, NULL, "ns1:PhoneNoItem");
	case SOAP_TYPE_ns1__ArrayOfPhoneNoItem:
		return soap_in_ns1__ArrayOfPhoneNoItem(soap, NULL, NULL, "ns1:ArrayOfPhoneNoItem");
	case SOAP_TYPE_ns1__PhoneNoList:
		return soap_in_ns1__PhoneNoList(soap, NULL, NULL, "ns1:PhoneNoList");
	case SOAP_TYPE_ns1__Result:
		return soap_in_ns1__Result(soap, NULL, NULL, "ns1:Result");
	case SOAP_TYPE_ns1__CompanyAccount:
		return soap_in_ns1__CompanyAccount(soap, NULL, NULL, "ns1:CompanyAccount");
	case SOAP_TYPE_ns1__ArrayOfCompanyAccount:
		return soap_in_ns1__ArrayOfCompanyAccount(soap, NULL, NULL, "ns1:ArrayOfCompanyAccount");
	case SOAP_TYPE_ns1__CompanyInfo:
		return soap_in_ns1__CompanyInfo(soap, NULL, NULL, "ns1:CompanyInfo");
	case SOAP_TYPE_ns1__PhoneNumberBelong:
		return soap_in_ns1__PhoneNumberBelong(soap, NULL, NULL, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong:
		return soap_in_ns1__ArrayOfPhoneNumberBelong(soap, NULL, NULL, "ns1:ArrayOfPhoneNumberBelong");
	case SOAP_TYPE_ns1__ReturnProportion:
		return soap_in_ns1__ReturnProportion(soap, NULL, NULL, "ns1:ReturnProportion");
	case SOAP_TYPE_ns1__ArrayOfReturnProportion:
		return soap_in_ns1__ArrayOfReturnProportion(soap, NULL, NULL, "ns1:ArrayOfReturnProportion");
	case SOAP_TYPE_ns1__NoticeItem:
		return soap_in_ns1__NoticeItem(soap, NULL, NULL, "ns1:NoticeItem");
	case SOAP_TYPE_ns1__ArrayOfNoticeItem:
		return soap_in_ns1__ArrayOfNoticeItem(soap, NULL, NULL, "ns1:ArrayOfNoticeItem");
	case SOAP_TYPE_ns1__Notice:
		return soap_in_ns1__Notice(soap, NULL, NULL, "ns1:Notice");
	case SOAP_TYPE_ns1__TableStatistics:
		return soap_in_ns1__TableStatistics(soap, NULL, NULL, "ns1:TableStatistics");
	case SOAP_TYPE_ns1__DIC_USCORECategory:
		return soap_in_ns1__DIC_USCORECategory(soap, NULL, NULL, "ns1:DIC_Category");
	case SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory:
		return soap_in_ns1__ArrayOfDIC_USCORECategory(soap, NULL, NULL, "ns1:ArrayOfDIC_Category");
	case SOAP_TYPE_ns1__DIC_USCOREContent:
		return soap_in_ns1__DIC_USCOREContent(soap, NULL, NULL, "ns1:DIC_Content");
	case SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent:
		return soap_in_ns1__ArrayOfDIC_USCOREContent(soap, NULL, NULL, "ns1:ArrayOfDIC_Content");
	case SOAP_TYPE_ns1__AcountPaymentItem:
		return soap_in_ns1__AcountPaymentItem(soap, NULL, NULL, "ns1:AcountPaymentItem");
	case SOAP_TYPE_ns1__ArrayOfAcountPaymentItem:
		return soap_in_ns1__ArrayOfAcountPaymentItem(soap, NULL, NULL, "ns1:ArrayOfAcountPaymentItem");
	case SOAP_TYPE_ns1__ReturnedItem:
		return soap_in_ns1__ReturnedItem(soap, NULL, NULL, "ns1:ReturnedItem");
	case SOAP_TYPE_ns1__ArrayOfReturnedItem:
		return soap_in_ns1__ArrayOfReturnedItem(soap, NULL, NULL, "ns1:ArrayOfReturnedItem");
	case SOAP_TYPE_ns1__SystemFunction:
		return soap_in_ns1__SystemFunction(soap, NULL, NULL, "ns1:SystemFunction");
	case SOAP_TYPE_ns1__ArrayOfSystemFunction:
		return soap_in_ns1__ArrayOfSystemFunction(soap, NULL, NULL, "ns1:ArrayOfSystemFunction");
	case SOAP_TYPE_ns1__Worker:
		return soap_in_ns1__Worker(soap, NULL, NULL, "ns1:Worker");
	case SOAP_TYPE_ns1__ArrayOfWorker:
		return soap_in_ns1__ArrayOfWorker(soap, NULL, NULL, "ns1:ArrayOfWorker");
	case SOAP_TYPE_ns1__ReturnInfoItem:
		return soap_in_ns1__ReturnInfoItem(soap, NULL, NULL, "ns1:ReturnInfoItem");
	case SOAP_TYPE_ns1__ArrayOfReturnInfoItem:
		return soap_in_ns1__ArrayOfReturnInfoItem(soap, NULL, NULL, "ns1:ArrayOfReturnInfoItem");
	case SOAP_TYPE_ns1__ReturnInfo:
		return soap_in_ns1__ReturnInfo(soap, NULL, NULL, "ns1:ReturnInfo");
	case SOAP_TYPE_ns1__User:
		return soap_in_ns1__User(soap, NULL, NULL, "ns1:User");
	case SOAP_TYPE_ns1__PayPublicTelItem:
		return soap_in_ns1__PayPublicTelItem(soap, NULL, NULL, "ns1:PayPublicTelItem");
	case SOAP_TYPE_ns1__ArrayOfPayPublicTelItem:
		return soap_in_ns1__ArrayOfPayPublicTelItem(soap, NULL, NULL, "ns1:ArrayOfPayPublicTelItem");
	case SOAP_TYPE_ns1__PayGameItem:
		return soap_in_ns1__PayGameItem(soap, NULL, NULL, "ns1:PayGameItem");
	case SOAP_TYPE_ns1__ArrayOfPayGameItem:
		return soap_in_ns1__ArrayOfPayGameItem(soap, NULL, NULL, "ns1:ArrayOfPayGameItem");
	case SOAP_TYPE_ns1__PayInternetItem:
		return soap_in_ns1__PayInternetItem(soap, NULL, NULL, "ns1:PayInternetItem");
	case SOAP_TYPE_ns1__ArrayOfPayInternetItem:
		return soap_in_ns1__ArrayOfPayInternetItem(soap, NULL, NULL, "ns1:ArrayOfPayInternetItem");
	case SOAP_TYPE_ns1__TransStaticsItem:
		return soap_in_ns1__TransStaticsItem(soap, NULL, NULL, "ns1:TransStaticsItem");
	case SOAP_TYPE_ns1__ArrayOfTransStaticsItem:
		return soap_in_ns1__ArrayOfTransStaticsItem(soap, NULL, NULL, "ns1:ArrayOfTransStaticsItem");
	case SOAP_TYPE_ns1__Transaction:
		return soap_in_ns1__Transaction(soap, NULL, NULL, "ns1:Transaction");
	case SOAP_TYPE_ns1__ArrayOfTransaction:
		return soap_in_ns1__ArrayOfTransaction(soap, NULL, NULL, "ns1:ArrayOfTransaction");
	case SOAP_TYPE_ns1__PaymentItem:
		return soap_in_ns1__PaymentItem(soap, NULL, NULL, "ns1:PaymentItem");
	case SOAP_TYPE_ns1__ArrayOfPaymentItem:
		return soap_in_ns1__ArrayOfPaymentItem(soap, NULL, NULL, "ns1:ArrayOfPaymentItem");
	case SOAP_TYPE_ns1__PayWithListItem:
		return soap_in_ns1__PayWithListItem(soap, NULL, NULL, "ns1:PayWithListItem");
	case SOAP_TYPE_ns1__ArrayOfPayWithListItem:
		return soap_in_ns1__ArrayOfPayWithListItem(soap, NULL, NULL, "ns1:ArrayOfPayWithListItem");
	case SOAP_TYPE_ns1__PayWithListResult:
		return soap_in_ns1__PayWithListResult(soap, NULL, NULL, "ns1:PayWithListResult");
	case SOAP_TYPE_PointerTo_ns1__GetClientVersionResponse:
		return soap_in_PointerTo_ns1__GetClientVersionResponse(soap, NULL, NULL, "ns1:GetClientVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClientVersion:
		return soap_in_PointerTo_ns1__GetClientVersion(soap, NULL, NULL, "ns1:GetClientVersion");
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccountResponse:
		return soap_in_PointerTo_ns1__DeleteCompanyAccountResponse(soap, NULL, NULL, "ns1:DeleteCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccount:
		return soap_in_PointerTo_ns1__DeleteCompanyAccount(soap, NULL, NULL, "ns1:DeleteCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccountResponse:
		return soap_in_PointerTo_ns1__UpdateCompanyAccountResponse(soap, NULL, NULL, "ns1:UpdateCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccount:
		return soap_in_PointerTo_ns1__UpdateCompanyAccount(soap, NULL, NULL, "ns1:UpdateCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccountResponse:
		return soap_in_PointerTo_ns1__AddCompanyAccountResponse(soap, NULL, NULL, "ns1:AddCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccount:
		return soap_in_PointerTo_ns1__AddCompanyAccount(soap, NULL, NULL, "ns1:AddCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccountResponse:
		return soap_in_PointerTo_ns1__GetCompanyAccountResponse(soap, NULL, NULL, "ns1:GetCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccount:
		return soap_in_PointerTo_ns1__GetCompanyAccount(soap, NULL, NULL, "ns1:GetCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfoResponse:
		return soap_in_PointerTo_ns1__UpdateCompanyInfoResponse(soap, NULL, NULL, "ns1:UpdateCompanyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfo:
		return soap_in_PointerTo_ns1__UpdateCompanyInfo(soap, NULL, NULL, "ns1:UpdateCompanyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfoResponse:
		return soap_in_PointerTo_ns1__GetCompanyInfoResponse(soap, NULL, NULL, "ns1:GetCompanyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfo:
		return soap_in_PointerTo_ns1__GetCompanyInfo(soap, NULL, NULL, "ns1:GetCompanyInfo");
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelongResponse:
		return soap_in_PointerTo_ns1__DeletePhoneNumberBelongResponse(soap, NULL, NULL, "ns1:DeletePhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelong:
		return soap_in_PointerTo_ns1__DeletePhoneNumberBelong(soap, NULL, NULL, "ns1:DeletePhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelongResponse:
		return soap_in_PointerTo_ns1__AddPhoneNumberBelongResponse(soap, NULL, NULL, "ns1:AddPhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelong:
		return soap_in_PointerTo_ns1__AddPhoneNumberBelong(soap, NULL, NULL, "ns1:AddPhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelongResponse:
		return soap_in_PointerTo_ns1__UpdatePhoneNumberBelongResponse(soap, NULL, NULL, "ns1:UpdatePhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelong:
		return soap_in_PointerTo_ns1__UpdatePhoneNumberBelong(soap, NULL, NULL, "ns1:UpdatePhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse:
		return soap_in_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(soap, NULL, NULL, "ns1:GetPhoneNumberBelongByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByCondition:
		return soap_in_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, NULL, NULL, "ns1:GetPhoneNumberBelongByCondition");
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportionResponse:
		return soap_in_PointerTo_ns1__DeletetReturnProportionResponse(soap, NULL, NULL, "ns1:DeletetReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportion:
		return soap_in_PointerTo_ns1__DeletetReturnProportion(soap, NULL, NULL, "ns1:DeletetReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportionResponse:
		return soap_in_PointerTo_ns1__UpdatetReturnProportionResponse(soap, NULL, NULL, "ns1:UpdatetReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportion:
		return soap_in_PointerTo_ns1__UpdatetReturnProportion(soap, NULL, NULL, "ns1:UpdatetReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportionResponse:
		return soap_in_PointerTo_ns1__AddtReturnProportionResponse(soap, NULL, NULL, "ns1:AddtReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportion:
		return soap_in_PointerTo_ns1__AddtReturnProportion(soap, NULL, NULL, "ns1:AddtReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecordResponse:
		return soap_in_PointerTo_ns1__GetReturnProportionRecordResponse(soap, NULL, NULL, "ns1:GetReturnProportionRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecord:
		return soap_in_PointerTo_ns1__GetReturnProportionRecord(soap, NULL, NULL, "ns1:GetReturnProportionRecord");
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOneResponse:
		return soap_in_PointerTo_ns1__InserNoticeToSomeOneResponse(soap, NULL, NULL, "ns1:InserNoticeToSomeOneResponse");
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOne:
		return soap_in_PointerTo_ns1__InserNoticeToSomeOne(soap, NULL, NULL, "ns1:InserNoticeToSomeOne");
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItemResponse:
		return soap_in_PointerTo_ns1__DeleteNoticeItemResponse(soap, NULL, NULL, "ns1:DeleteNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItem:
		return soap_in_PointerTo_ns1__DeleteNoticeItem(soap, NULL, NULL, "ns1:DeleteNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItemResponse:
		return soap_in_PointerTo_ns1__UpdateNoticeItemResponse(soap, NULL, NULL, "ns1:UpdateNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItem:
		return soap_in_PointerTo_ns1__UpdateNoticeItem(soap, NULL, NULL, "ns1:UpdateNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeoneResponse:
		return soap_in_PointerTo_ns1__AddNoticeItemToSomeoneResponse(soap, NULL, NULL, "ns1:AddNoticeItemToSomeoneResponse");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeone:
		return soap_in_PointerTo_ns1__AddNoticeItemToSomeone(soap, NULL, NULL, "ns1:AddNoticeItemToSomeone");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemResponse:
		return soap_in_PointerTo_ns1__AddNoticeItemResponse(soap, NULL, NULL, "ns1:AddNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItem:
		return soap_in_PointerTo_ns1__AddNoticeItem(soap, NULL, NULL, "ns1:AddNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeListResponse:
		return soap_in_PointerTo_ns1__GetAlertNoticeListResponse(soap, NULL, NULL, "ns1:GetAlertNoticeListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeList:
		return soap_in_PointerTo_ns1__GetAlertNoticeList(soap, NULL, NULL, "ns1:GetAlertNoticeList");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItemResponse:
		return soap_in_PointerTo_ns1__GetNoticeItemResponse(soap, NULL, NULL, "ns1:GetNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItem:
		return soap_in_PointerTo_ns1__GetNoticeItem(soap, NULL, NULL, "ns1:GetNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByConditionResponse:
		return soap_in_PointerTo_ns1__GetNoticeListByConditionResponse(soap, NULL, NULL, "ns1:GetNoticeListByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByCondition:
		return soap_in_PointerTo_ns1__GetNoticeListByCondition(soap, NULL, NULL, "ns1:GetNoticeListByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListResponse:
		return soap_in_PointerTo_ns1__GetNoticeListResponse(soap, NULL, NULL, "ns1:GetNoticeListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeList:
		return soap_in_PointerTo_ns1__GetNoticeList(soap, NULL, NULL, "ns1:GetNoticeList");
	case SOAP_TYPE_PointerTo_ns1__GetTableStatisticsResponse:
		return soap_in_PointerTo_ns1__GetTableStatisticsResponse(soap, NULL, NULL, "ns1:GetTableStatisticsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTableStatistics:
		return soap_in_PointerTo_ns1__GetTableStatistics(soap, NULL, NULL, "ns1:GetTableStatistics");
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRightResponse:
		return soap_in_PointerTo_ns1__UpdateFunctionRightResponse(soap, NULL, NULL, "ns1:UpdateFunctionRightResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRight:
		return soap_in_PointerTo_ns1__UpdateFunctionRight(soap, NULL, NULL, "ns1:UpdateFunctionRight");
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionListResponse:
		return soap_in_PointerTo_ns1__UpdateUserFunctionListResponse(soap, NULL, NULL, "ns1:UpdateUserFunctionListResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionList:
		return soap_in_PointerTo_ns1__UpdateUserFunctionList(soap, NULL, NULL, "ns1:UpdateUserFunctionList");
	case SOAP_TYPE_PointerTo_ns1__GetFunctionListResponse:
		return soap_in_PointerTo_ns1__GetFunctionListResponse(soap, NULL, NULL, "ns1:GetFunctionListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetFunctionList:
		return soap_in_PointerTo_ns1__GetFunctionList(soap, NULL, NULL, "ns1:GetFunctionList");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategoryResponse:
		return soap_in_PointerTo_ns1__UpdateDicContentByCategoryResponse(soap, NULL, NULL, "ns1:UpdateDicContentByCategoryResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategory:
		return soap_in_PointerTo_ns1__UpdateDicContentByCategory(soap, NULL, NULL, "ns1:UpdateDicContentByCategory");
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContentResponse:
		return soap_in_PointerTo_ns1__DeleteDicContentResponse(soap, NULL, NULL, "ns1:DeleteDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContent:
		return soap_in_PointerTo_ns1__DeleteDicContent(soap, NULL, NULL, "ns1:DeleteDicContent");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentResponse:
		return soap_in_PointerTo_ns1__UpdateDicContentResponse(soap, NULL, NULL, "ns1:UpdateDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContent:
		return soap_in_PointerTo_ns1__UpdateDicContent(soap, NULL, NULL, "ns1:UpdateDicContent");
	case SOAP_TYPE_PointerTo_ns1__InsertDicContentResponse:
		return soap_in_PointerTo_ns1__InsertDicContentResponse(soap, NULL, NULL, "ns1:InsertDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__InsertDicContent:
		return soap_in_PointerTo_ns1__InsertDicContent(soap, NULL, NULL, "ns1:InsertDicContent");
	case SOAP_TYPE_PointerTo_ns1__GetAllCategoryResponse:
		return soap_in_PointerTo_ns1__GetAllCategoryResponse(soap, NULL, NULL, "ns1:GetAllCategoryResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCategory:
		return soap_in_PointerTo_ns1__GetAllCategory(soap, NULL, NULL, "ns1:GetAllCategory");
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByConditionResponse:
		return soap_in_PointerTo_ns1__GetDicContentByConditionResponse(soap, NULL, NULL, "ns1:GetDicContentByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByCondition:
		return soap_in_PointerTo_ns1__GetDicContentByCondition(soap, NULL, NULL, "ns1:GetDicContentByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecordResponse:
		return soap_in_PointerTo_ns1__GetAcountPaymentRecordResponse(soap, NULL, NULL, "ns1:GetAcountPaymentRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecord:
		return soap_in_PointerTo_ns1__GetAcountPaymentRecord(soap, NULL, NULL, "ns1:GetAcountPaymentRecord");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDealResponse:
		return soap_in_PointerTo_ns1__GetReturnRecordDealResponse(soap, NULL, NULL, "ns1:GetReturnRecordDealResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDeal:
		return soap_in_PointerTo_ns1__GetReturnRecordDeal(soap, NULL, NULL, "ns1:GetReturnRecordDeal");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordResponse:
		return soap_in_PointerTo_ns1__GetReturnRecordResponse(soap, NULL, NULL, "ns1:GetReturnRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecord:
		return soap_in_PointerTo_ns1__GetReturnRecord(soap, NULL, NULL, "ns1:GetReturnRecord");
	case SOAP_TYPE_PointerTo_ns1__GetUserFunctionResponse:
		return soap_in_PointerTo_ns1__GetUserFunctionResponse(soap, NULL, NULL, "ns1:GetUserFunctionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserFunction:
		return soap_in_PointerTo_ns1__GetUserFunction(soap, NULL, NULL, "ns1:GetUserFunction");
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameListResponse:
		return soap_in_PointerTo_ns1__GetWorkNameListResponse(soap, NULL, NULL, "ns1:GetWorkNameListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameList:
		return soap_in_PointerTo_ns1__GetWorkNameList(soap, NULL, NULL, "ns1:GetWorkNameList");
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoneyResponse:
		return soap_in_PointerTo_ns1__CharegeReturnedMoneyResponse(soap, NULL, NULL, "ns1:CharegeReturnedMoneyResponse");
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoney:
		return soap_in_PointerTo_ns1__CharegeReturnedMoney(soap, NULL, NULL, "ns1:CharegeReturnedMoney");
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfoResponse:
		return soap_in_PointerTo_ns1__GetReturnInfoResponse(soap, NULL, NULL, "ns1:GetReturnInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfo:
		return soap_in_PointerTo_ns1__GetReturnInfo(soap, NULL, NULL, "ns1:GetReturnInfo");
	case SOAP_TYPE_PointerTo_ns1__AddAcountPaymentResponse:
		return soap_in_PointerTo_ns1__AddAcountPaymentResponse(soap, NULL, NULL, "ns1:AddAcountPaymentResponse");
	case SOAP_TYPE_PointerTo_ns1__AddAcountPayment:
		return soap_in_PointerTo_ns1__AddAcountPayment(soap, NULL, NULL, "ns1:AddAcountPayment");
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfoResponse:
		return soap_in_PointerTo_ns1__AlterUserInfoResponse(soap, NULL, NULL, "ns1:AlterUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfo:
		return soap_in_PointerTo_ns1__AlterUserInfo(soap, NULL, NULL, "ns1:AlterUserInfo");
	case SOAP_TYPE_PointerTo_ns1__AlterPswResponse:
		return soap_in_PointerTo_ns1__AlterPswResponse(soap, NULL, NULL, "ns1:AlterPswResponse");
	case SOAP_TYPE_PointerTo_ns1__AlterPsw:
		return soap_in_PointerTo_ns1__AlterPsw(soap, NULL, NULL, "ns1:AlterPsw");
	case SOAP_TYPE_PointerTo_ns1__RegisterUserResponse:
		return soap_in_PointerTo_ns1__RegisterUserResponse(soap, NULL, NULL, "ns1:RegisterUserResponse");
	case SOAP_TYPE_PointerTo_ns1__RegisterUser:
		return soap_in_PointerTo_ns1__RegisterUser(soap, NULL, NULL, "ns1:RegisterUser");
	case SOAP_TYPE_PointerTo_ns1__GetUserInfoResponse:
		return soap_in_PointerTo_ns1__GetUserInfoResponse(soap, NULL, NULL, "ns1:GetUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserInfo:
		return soap_in_PointerTo_ns1__GetUserInfo(soap, NULL, NULL, "ns1:GetUserInfo");
	case SOAP_TYPE_PointerTo_ns1__TestLoginResponse:
		return soap_in_PointerTo_ns1__TestLoginResponse(soap, NULL, NULL, "ns1:TestLoginResponse");
	case SOAP_TYPE_PointerTo_ns1__TestLogin:
		return soap_in_PointerTo_ns1__TestLogin(soap, NULL, NULL, "ns1:TestLogin");
	case SOAP_TYPE_PointerTo_ns1__loggoutResponse:
		return soap_in_PointerTo_ns1__loggoutResponse(soap, NULL, NULL, "ns1:loggoutResponse");
	case SOAP_TYPE_PointerTo_ns1__loggout:
		return soap_in_PointerTo_ns1__loggout(soap, NULL, NULL, "ns1:loggout");
	case SOAP_TYPE_PointerTo_ns1__HelloWorldResponse:
		return soap_in_PointerTo_ns1__HelloWorldResponse(soap, NULL, NULL, "ns1:HelloWorldResponse");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_in_PointerTo_ns1__HelloWorld(soap, NULL, NULL, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPayPublicTelHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, NULL, NULL, "ns1:GetPayPublicTelHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayPublicTelByConditionResponse(soap, NULL, NULL, "ns1:GetPayPublicTelByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByCondition:
		return soap_in_PointerTo_ns1__GetPayPublicTelByCondition(soap, NULL, NULL, "ns1:GetPayPublicTelByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayGameHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPayGameHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPayGameHistoryByCondition(soap, NULL, NULL, "ns1:GetPayGameHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayGameByConditionResponse(soap, NULL, NULL, "ns1:GetPayGameByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByCondition:
		return soap_in_PointerTo_ns1__GetPayGameByCondition(soap, NULL, NULL, "ns1:GetPayGameByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPayInternetHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, NULL, NULL, "ns1:GetPayInternetHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayInternetByConditionResponse(soap, NULL, NULL, "ns1:GetPayInternetByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByCondition:
		return soap_in_PointerTo_ns1__GetPayInternetByCondition(soap, NULL, NULL, "ns1:GetPayInternetByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPaymentOrPaymentHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, NULL, NULL, "ns1:GetPaymentOrPaymentHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByConditionResponse:
		return soap_in_PointerTo_ns1__GetTransactionStaticsByConditionResponse(soap, NULL, NULL, "ns1:GetTransactionStaticsByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByCondition:
		return soap_in_PointerTo_ns1__GetTransactionStaticsByCondition(soap, NULL, NULL, "ns1:GetTransactionStaticsByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByConditionResponse:
		return soap_in_PointerTo_ns1__GetTransactionByConditionResponse(soap, NULL, NULL, "ns1:GetTransactionByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByCondition:
		return soap_in_PointerTo_ns1__GetTransactionByCondition(soap, NULL, NULL, "ns1:GetTransactionByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItemResponse:
		return soap_in_PointerTo_ns1__GetPaymentItemResponse(soap, NULL, NULL, "ns1:GetPaymentItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItem:
		return soap_in_PointerTo_ns1__GetPaymentItem(soap, NULL, NULL, "ns1:GetPaymentItem");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecordResponse:
		return soap_in_PointerTo_ns1__GetPaymentRecordResponse(soap, NULL, NULL, "ns1:GetPaymentRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecord:
		return soap_in_PointerTo_ns1__GetPaymentRecord(soap, NULL, NULL, "ns1:GetPaymentRecord");
	case SOAP_TYPE_PointerTo_ns1__PayPublicTelResponse:
		return soap_in_PointerTo_ns1__PayPublicTelResponse(soap, NULL, NULL, "ns1:PayPublicTelResponse");
	case SOAP_TYPE_PointerTo_ns1__PayPublicTel:
		return soap_in_PointerTo_ns1__PayPublicTel(soap, NULL, NULL, "ns1:PayPublicTel");
	case SOAP_TYPE_PointerTo_ns1__PayGameResponse:
		return soap_in_PointerTo_ns1__PayGameResponse(soap, NULL, NULL, "ns1:PayGameResponse");
	case SOAP_TYPE_PointerTo_ns1__PayGame:
		return soap_in_PointerTo_ns1__PayGame(soap, NULL, NULL, "ns1:PayGame");
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollbackResponse:
		return soap_in_PointerTo_ns1__RequstInternetRollbackResponse(soap, NULL, NULL, "ns1:RequstInternetRollbackResponse");
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollback:
		return soap_in_PointerTo_ns1__RequstInternetRollback(soap, NULL, NULL, "ns1:RequstInternetRollback");
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithListResponse:
		return soap_in_PointerTo_ns1__PayInternetWithListResponse(soap, NULL, NULL, "ns1:PayInternetWithListResponse");
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithList:
		return soap_in_PointerTo_ns1__PayInternetWithList(soap, NULL, NULL, "ns1:PayInternetWithList");
	case SOAP_TYPE_PointerTo_ns1__PayInternetResponse:
		return soap_in_PointerTo_ns1__PayInternetResponse(soap, NULL, NULL, "ns1:PayInternetResponse");
	case SOAP_TYPE_PointerTo_ns1__PayInternet:
		return soap_in_PointerTo_ns1__PayInternet(soap, NULL, NULL, "ns1:PayInternet");
	case SOAP_TYPE_PointerTo_ns1__RequstRollbackResponse:
		return soap_in_PointerTo_ns1__RequstRollbackResponse(soap, NULL, NULL, "ns1:RequstRollbackResponse");
	case SOAP_TYPE_PointerTo_ns1__RequstRollback:
		return soap_in_PointerTo_ns1__RequstRollback(soap, NULL, NULL, "ns1:RequstRollback");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithListResponse:
		return soap_in_PointerTo_ns1__PayMoneyWithListResponse(soap, NULL, NULL, "ns1:PayMoneyWithListResponse");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithList:
		return soap_in_PointerTo_ns1__PayMoneyWithList(soap, NULL, NULL, "ns1:PayMoneyWithList");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyResponse:
		return soap_in_PointerTo_ns1__PayMoneyResponse(soap, NULL, NULL, "ns1:PayMoneyResponse");
	case SOAP_TYPE_PointerTo_ns1__PayMoney:
		return soap_in_PointerTo_ns1__PayMoney(soap, NULL, NULL, "ns1:PayMoney");
	case SOAP_TYPE_PointerTo_ns1__GetLocationResponse:
		return soap_in_PointerTo_ns1__GetLocationResponse(soap, NULL, NULL, "ns1:GetLocationResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLocation:
		return soap_in_PointerTo_ns1__GetLocation(soap, NULL, NULL, "ns1:GetLocation");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetStockCardItemAndHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByCondition:
		return soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, NULL, NULL, "ns1:GetStockCardItemAndHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByConditionResponse:
		return soap_in_PointerTo_ns1__GetStockCardItemByConditionResponse(soap, NULL, NULL, "ns1:GetStockCardItemByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByCondition:
		return soap_in_PointerTo_ns1__GetStockCardItemByCondition(soap, NULL, NULL, "ns1:GetStockCardItemByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardListResponse:
		return soap_in_PointerTo_ns1__GetOtherCardListResponse(soap, NULL, NULL, "ns1:GetOtherCardListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardList:
		return soap_in_PointerTo_ns1__GetOtherCardList(soap, NULL, NULL, "ns1:GetOtherCardList");
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, NULL, NULL, "ns1:GettSellOtherCardRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition:
		return soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, NULL, NULL, "ns1:GettSellOtherCardRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse:
		return soap_in_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(soap, NULL, NULL, "ns1:GetSellOtherCardRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByCondition:
		return soap_in_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, NULL, NULL, "ns1:GetSellOtherCardRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(soap, NULL, NULL, "ns1:GettBusinessRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByCondition:
		return soap_in_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, NULL, NULL, "ns1:GettBusinessRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByConditionResponse:
		return soap_in_PointerTo_ns1__GetBusinessRecordByConditionResponse(soap, NULL, NULL, "ns1:GetBusinessRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByCondition:
		return soap_in_PointerTo_ns1__GetBusinessRecordByCondition(soap, NULL, NULL, "ns1:GetBusinessRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetSellCardRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByCondition:
		return soap_in_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, NULL, NULL, "ns1:GetSellCardRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByConditionResponse:
		return soap_in_PointerTo_ns1__GetSellCardRecordByConditionResponse(soap, NULL, NULL, "ns1:GetSellCardRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByCondition:
		return soap_in_PointerTo_ns1__GetSellCardRecordByCondition(soap, NULL, NULL, "ns1:GetSellCardRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetCardServiceResponse:
		return soap_in_PointerTo_ns1__GetCardServiceResponse(soap, NULL, NULL, "ns1:GetCardServiceResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCardService:
		return soap_in_PointerTo_ns1__GetCardService(soap, NULL, NULL, "ns1:GetCardService");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPhoneNoItemAndHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, NULL, NULL, "ns1:GetPhoneNoItemAndHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByConditionResponse:
		return soap_in_PointerTo_ns1__GetPhoneNoItemByConditionResponse(soap, NULL, NULL, "ns1:GetPhoneNoItemByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByCondition:
		return soap_in_PointerTo_ns1__GetPhoneNoItemByCondition(soap, NULL, NULL, "ns1:GetPhoneNoItemByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(soap, NULL, NULL, "ns1:GetPayMiniCardHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByCondition:
		return soap_in_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, NULL, NULL, "ns1:GetPayMiniCardHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByConditionResponse:
		return soap_in_PointerTo_ns1__GetPayMiniCardByConditionResponse(soap, NULL, NULL, "ns1:GetPayMiniCardByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByCondition:
		return soap_in_PointerTo_ns1__GetPayMiniCardByCondition(soap, NULL, NULL, "ns1:GetPayMiniCardByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecordResponse:
		return soap_in_PointerTo_ns1__GetMiniCardRecordResponse(soap, NULL, NULL, "ns1:GetMiniCardRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecord:
		return soap_in_PointerTo_ns1__GetMiniCardRecord(soap, NULL, NULL, "ns1:GetMiniCardRecord");
	case SOAP_TYPE_PointerTo_ns1__SellOhterCardResponse:
		return soap_in_PointerTo_ns1__SellOhterCardResponse(soap, NULL, NULL, "ns1:SellOhterCardResponse");
	case SOAP_TYPE_PointerTo_ns1__SellOhterCard:
		return soap_in_PointerTo_ns1__SellOhterCard(soap, NULL, NULL, "ns1:SellOhterCard");
	case SOAP_TYPE_PointerTo_ns1__SellNoResponse:
		return soap_in_PointerTo_ns1__SellNoResponse(soap, NULL, NULL, "ns1:SellNoResponse");
	case SOAP_TYPE_PointerTo_ns1__SellNo:
		return soap_in_PointerTo_ns1__SellNo(soap, NULL, NULL, "ns1:SellNo");
	case SOAP_TYPE_PointerTo_ns1__SubmitBusinessResponse:
		return soap_in_PointerTo_ns1__SubmitBusinessResponse(soap, NULL, NULL, "ns1:SubmitBusinessResponse");
	case SOAP_TYPE_PointerTo_ns1__SubmitBusiness:
		return soap_in_PointerTo_ns1__SubmitBusiness(soap, NULL, NULL, "ns1:SubmitBusiness");
	case SOAP_TYPE_PointerTo_ns1__UnlockNoResponse:
		return soap_in_PointerTo_ns1__UnlockNoResponse(soap, NULL, NULL, "ns1:UnlockNoResponse");
	case SOAP_TYPE_PointerTo_ns1__UnlockNo:
		return soap_in_PointerTo_ns1__UnlockNo(soap, NULL, NULL, "ns1:UnlockNo");
	case SOAP_TYPE_PointerTo_ns1__LockNoResponse:
		return soap_in_PointerTo_ns1__LockNoResponse(soap, NULL, NULL, "ns1:LockNoResponse");
	case SOAP_TYPE_PointerTo_ns1__LockNo:
		return soap_in_PointerTo_ns1__LockNo(soap, NULL, NULL, "ns1:LockNo");
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSectionResponse:
		return soap_in_PointerTo_ns1__GetMyNoSectionResponse(soap, NULL, NULL, "ns1:GetMyNoSectionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSection:
		return soap_in_PointerTo_ns1__GetMyNoSection(soap, NULL, NULL, "ns1:GetMyNoSection");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByConditionResponse:
		return soap_in_PointerTo_ns1__GetPhoneNoByConditionResponse(soap, NULL, NULL, "ns1:GetPhoneNoByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByCondition:
		return soap_in_PointerTo_ns1__GetPhoneNoByCondition(soap, NULL, NULL, "ns1:GetPhoneNoByCondition");
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCardResponse:
		return soap_in_PointerTo_ns1__BuyMiniCardResponse(soap, NULL, NULL, "ns1:BuyMiniCardResponse");
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCard:
		return soap_in_PointerTo_ns1__BuyMiniCard(soap, NULL, NULL, "ns1:BuyMiniCard");
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfoResponse:
		return soap_in_PointerTo_ns1__queryPhoneNOInfoResponse(soap, NULL, NULL, "ns1:queryPhoneNOInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfo:
		return soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, NULL, NULL, "ns1:queryPhoneNOInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfStockCardItem:
		return soap_in_PointerTons1__ArrayOfStockCardItem(soap, NULL, NULL, "ns1:ArrayOfStockCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfOtherCardItem:
		return soap_in_PointerTons1__ArrayOfOtherCardItem(soap, NULL, NULL, "ns1:ArrayOfOtherCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSellOtherCardItem:
		return soap_in_PointerTons1__ArrayOfSellOtherCardItem(soap, NULL, NULL, "ns1:ArrayOfSellOtherCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfBusinessItem:
		return soap_in_PointerTons1__ArrayOfBusinessItem(soap, NULL, NULL, "ns1:ArrayOfBusinessItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSellCardItem:
		return soap_in_PointerTons1__ArrayOfSellCardItem(soap, NULL, NULL, "ns1:ArrayOfSellCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfCardService:
		return soap_in_PointerTons1__ArrayOfCardService(soap, NULL, NULL, "ns1:ArrayOfCardService");
	case SOAP_TYPE_PointerTons1__ArrayOfPayMiniCardItem:
		return soap_in_PointerTons1__ArrayOfPayMiniCardItem(soap, NULL, NULL, "ns1:ArrayOfPayMiniCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfMiniCardItem:
		return soap_in_PointerTons1__ArrayOfMiniCardItem(soap, NULL, NULL, "ns1:ArrayOfMiniCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__PhoneNoList:
		return soap_in_PointerTons1__PhoneNoList(soap, NULL, NULL, "ns1:PhoneNoList");
	case SOAP_TYPE_PointerTons1__Result:
		return soap_in_PointerTons1__Result(soap, NULL, NULL, "ns1:Result");
	case SOAP_TYPE_PointerTons1__ArrayOfCompanyAccount:
		return soap_in_PointerTons1__ArrayOfCompanyAccount(soap, NULL, NULL, "ns1:ArrayOfCompanyAccount");
	case SOAP_TYPE_PointerTons1__CompanyInfo:
		return soap_in_PointerTons1__CompanyInfo(soap, NULL, NULL, "ns1:CompanyInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNumberBelong:
		return soap_in_PointerTons1__ArrayOfPhoneNumberBelong(soap, NULL, NULL, "ns1:ArrayOfPhoneNumberBelong");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnProportion:
		return soap_in_PointerTons1__ArrayOfReturnProportion(soap, NULL, NULL, "ns1:ArrayOfReturnProportion");
	case SOAP_TYPE_PointerTons1__Notice:
		return soap_in_PointerTons1__Notice(soap, NULL, NULL, "ns1:Notice");
	case SOAP_TYPE_PointerTons1__TableStatistics:
		return soap_in_PointerTons1__TableStatistics(soap, NULL, NULL, "ns1:TableStatistics");
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCORECategory:
		return soap_in_PointerTons1__ArrayOfDIC_USCORECategory(soap, NULL, NULL, "ns1:ArrayOfDIC_Category");
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCOREContent:
		return soap_in_PointerTons1__ArrayOfDIC_USCOREContent(soap, NULL, NULL, "ns1:ArrayOfDIC_Content");
	case SOAP_TYPE_PointerTons1__ArrayOfAcountPaymentItem:
		return soap_in_PointerTons1__ArrayOfAcountPaymentItem(soap, NULL, NULL, "ns1:ArrayOfAcountPaymentItem");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnedItem:
		return soap_in_PointerTons1__ArrayOfReturnedItem(soap, NULL, NULL, "ns1:ArrayOfReturnedItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSystemFunction:
		return soap_in_PointerTons1__ArrayOfSystemFunction(soap, NULL, NULL, "ns1:ArrayOfSystemFunction");
	case SOAP_TYPE_PointerTons1__ArrayOfWorker:
		return soap_in_PointerTons1__ArrayOfWorker(soap, NULL, NULL, "ns1:ArrayOfWorker");
	case SOAP_TYPE_PointerTons1__ReturnInfo:
		return soap_in_PointerTons1__ReturnInfo(soap, NULL, NULL, "ns1:ReturnInfo");
	case SOAP_TYPE_PointerTons1__User:
		return soap_in_PointerTons1__User(soap, NULL, NULL, "ns1:User");
	case SOAP_TYPE_PointerTons1__ArrayOfPayPublicTelItem:
		return soap_in_PointerTons1__ArrayOfPayPublicTelItem(soap, NULL, NULL, "ns1:ArrayOfPayPublicTelItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayGameItem:
		return soap_in_PointerTons1__ArrayOfPayGameItem(soap, NULL, NULL, "ns1:ArrayOfPayGameItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayInternetItem:
		return soap_in_PointerTons1__ArrayOfPayInternetItem(soap, NULL, NULL, "ns1:ArrayOfPayInternetItem");
	case SOAP_TYPE_PointerTons1__ArrayOfTransStaticsItem:
		return soap_in_PointerTons1__ArrayOfTransStaticsItem(soap, NULL, NULL, "ns1:ArrayOfTransStaticsItem");
	case SOAP_TYPE_PointerTons1__ArrayOfTransaction:
		return soap_in_PointerTons1__ArrayOfTransaction(soap, NULL, NULL, "ns1:ArrayOfTransaction");
	case SOAP_TYPE_PointerTons1__ArrayOfPaymentItem:
		return soap_in_PointerTons1__ArrayOfPaymentItem(soap, NULL, NULL, "ns1:ArrayOfPaymentItem");
	case SOAP_TYPE_PointerTons1__PayWithListResult:
		return soap_in_PointerTons1__PayWithListResult(soap, NULL, NULL, "ns1:PayWithListResult");
	case SOAP_TYPE_PointerToPointerTons1__StockCardItem:
		return soap_in_PointerToPointerTons1__StockCardItem(soap, NULL, NULL, "ns1:StockCardItem");
	case SOAP_TYPE_PointerTons1__StockCardItem:
		return soap_in_PointerTons1__StockCardItem(soap, NULL, NULL, "ns1:StockCardItem");
	case SOAP_TYPE_PointerToPointerTons1__OtherCardItem:
		return soap_in_PointerToPointerTons1__OtherCardItem(soap, NULL, NULL, "ns1:OtherCardItem");
	case SOAP_TYPE_PointerTons1__OtherCardItem:
		return soap_in_PointerTons1__OtherCardItem(soap, NULL, NULL, "ns1:OtherCardItem");
	case SOAP_TYPE_PointerToPointerTons1__SellOtherCardItem:
		return soap_in_PointerToPointerTons1__SellOtherCardItem(soap, NULL, NULL, "ns1:SellOtherCardItem");
	case SOAP_TYPE_PointerTons1__SellOtherCardItem:
		return soap_in_PointerTons1__SellOtherCardItem(soap, NULL, NULL, "ns1:SellOtherCardItem");
	case SOAP_TYPE_PointerToPointerTons1__BusinessItem:
		return soap_in_PointerToPointerTons1__BusinessItem(soap, NULL, NULL, "ns1:BusinessItem");
	case SOAP_TYPE_PointerTons1__BusinessItem:
		return soap_in_PointerTons1__BusinessItem(soap, NULL, NULL, "ns1:BusinessItem");
	case SOAP_TYPE_PointerToPointerTons1__SellCardItem:
		return soap_in_PointerToPointerTons1__SellCardItem(soap, NULL, NULL, "ns1:SellCardItem");
	case SOAP_TYPE_PointerTons1__SellCardItem:
		return soap_in_PointerTons1__SellCardItem(soap, NULL, NULL, "ns1:SellCardItem");
	case SOAP_TYPE_PointerToPointerTons1__CardService:
		return soap_in_PointerToPointerTons1__CardService(soap, NULL, NULL, "ns1:CardService");
	case SOAP_TYPE_PointerTons1__CardService:
		return soap_in_PointerTons1__CardService(soap, NULL, NULL, "ns1:CardService");
	case SOAP_TYPE_PointerToPointerTons1__PayMiniCardItem:
		return soap_in_PointerToPointerTons1__PayMiniCardItem(soap, NULL, NULL, "ns1:PayMiniCardItem");
	case SOAP_TYPE_PointerTons1__PayMiniCardItem:
		return soap_in_PointerTons1__PayMiniCardItem(soap, NULL, NULL, "ns1:PayMiniCardItem");
	case SOAP_TYPE_PointerToPointerTons1__MiniCardItem:
		return soap_in_PointerToPointerTons1__MiniCardItem(soap, NULL, NULL, "ns1:MiniCardItem");
	case SOAP_TYPE_PointerTons1__MiniCardItem:
		return soap_in_PointerTons1__MiniCardItem(soap, NULL, NULL, "ns1:MiniCardItem");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__PhoneNoItem:
		return soap_in_PointerToPointerTons1__PhoneNoItem(soap, NULL, NULL, "ns1:PhoneNoItem");
	case SOAP_TYPE_PointerTons1__PhoneNoItem:
		return soap_in_PointerTons1__PhoneNoItem(soap, NULL, NULL, "ns1:PhoneNoItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNoItem:
		return soap_in_PointerTons1__ArrayOfPhoneNoItem(soap, NULL, NULL, "ns1:ArrayOfPhoneNoItem");
	case SOAP_TYPE_PointerToPointerTons1__CompanyAccount:
		return soap_in_PointerToPointerTons1__CompanyAccount(soap, NULL, NULL, "ns1:CompanyAccount");
	case SOAP_TYPE_PointerTons1__CompanyAccount:
		return soap_in_PointerTons1__CompanyAccount(soap, NULL, NULL, "ns1:CompanyAccount");
	case SOAP_TYPE_PointerToPointerTons1__PhoneNumberBelong:
		return soap_in_PointerToPointerTons1__PhoneNumberBelong(soap, NULL, NULL, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_PointerTons1__PhoneNumberBelong:
		return soap_in_PointerTons1__PhoneNumberBelong(soap, NULL, NULL, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_PointerToPointerTons1__ReturnProportion:
		return soap_in_PointerToPointerTons1__ReturnProportion(soap, NULL, NULL, "ns1:ReturnProportion");
	case SOAP_TYPE_PointerTons1__ReturnProportion:
		return soap_in_PointerTons1__ReturnProportion(soap, NULL, NULL, "ns1:ReturnProportion");
	case SOAP_TYPE_PointerToPointerTons1__NoticeItem:
		return soap_in_PointerToPointerTons1__NoticeItem(soap, NULL, NULL, "ns1:NoticeItem");
	case SOAP_TYPE_PointerTons1__NoticeItem:
		return soap_in_PointerTons1__NoticeItem(soap, NULL, NULL, "ns1:NoticeItem");
	case SOAP_TYPE_PointerTons1__ArrayOfNoticeItem:
		return soap_in_PointerTons1__ArrayOfNoticeItem(soap, NULL, NULL, "ns1:ArrayOfNoticeItem");
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCORECategory:
		return soap_in_PointerToPointerTons1__DIC_USCORECategory(soap, NULL, NULL, "ns1:DIC_Category");
	case SOAP_TYPE_PointerTons1__DIC_USCORECategory:
		return soap_in_PointerTons1__DIC_USCORECategory(soap, NULL, NULL, "ns1:DIC_Category");
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCOREContent:
		return soap_in_PointerToPointerTons1__DIC_USCOREContent(soap, NULL, NULL, "ns1:DIC_Content");
	case SOAP_TYPE_PointerTons1__DIC_USCOREContent:
		return soap_in_PointerTons1__DIC_USCOREContent(soap, NULL, NULL, "ns1:DIC_Content");
	case SOAP_TYPE_PointerToPointerTons1__AcountPaymentItem:
		return soap_in_PointerToPointerTons1__AcountPaymentItem(soap, NULL, NULL, "ns1:AcountPaymentItem");
	case SOAP_TYPE_PointerTons1__AcountPaymentItem:
		return soap_in_PointerTons1__AcountPaymentItem(soap, NULL, NULL, "ns1:AcountPaymentItem");
	case SOAP_TYPE_PointerToPointerTons1__ReturnedItem:
		return soap_in_PointerToPointerTons1__ReturnedItem(soap, NULL, NULL, "ns1:ReturnedItem");
	case SOAP_TYPE_PointerTons1__ReturnedItem:
		return soap_in_PointerTons1__ReturnedItem(soap, NULL, NULL, "ns1:ReturnedItem");
	case SOAP_TYPE_PointerToPointerTons1__SystemFunction:
		return soap_in_PointerToPointerTons1__SystemFunction(soap, NULL, NULL, "ns1:SystemFunction");
	case SOAP_TYPE_PointerTons1__SystemFunction:
		return soap_in_PointerTons1__SystemFunction(soap, NULL, NULL, "ns1:SystemFunction");
	case SOAP_TYPE_PointerToPointerTons1__Worker:
		return soap_in_PointerToPointerTons1__Worker(soap, NULL, NULL, "ns1:Worker");
	case SOAP_TYPE_PointerTons1__Worker:
		return soap_in_PointerTons1__Worker(soap, NULL, NULL, "ns1:Worker");
	case SOAP_TYPE_PointerToPointerTons1__ReturnInfoItem:
		return soap_in_PointerToPointerTons1__ReturnInfoItem(soap, NULL, NULL, "ns1:ReturnInfoItem");
	case SOAP_TYPE_PointerTons1__ReturnInfoItem:
		return soap_in_PointerTons1__ReturnInfoItem(soap, NULL, NULL, "ns1:ReturnInfoItem");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnInfoItem:
		return soap_in_PointerTons1__ArrayOfReturnInfoItem(soap, NULL, NULL, "ns1:ArrayOfReturnInfoItem");
	case SOAP_TYPE_PointerToPointerTons1__PayPublicTelItem:
		return soap_in_PointerToPointerTons1__PayPublicTelItem(soap, NULL, NULL, "ns1:PayPublicTelItem");
	case SOAP_TYPE_PointerTons1__PayPublicTelItem:
		return soap_in_PointerTons1__PayPublicTelItem(soap, NULL, NULL, "ns1:PayPublicTelItem");
	case SOAP_TYPE_PointerToPointerTons1__PayGameItem:
		return soap_in_PointerToPointerTons1__PayGameItem(soap, NULL, NULL, "ns1:PayGameItem");
	case SOAP_TYPE_PointerTons1__PayGameItem:
		return soap_in_PointerTons1__PayGameItem(soap, NULL, NULL, "ns1:PayGameItem");
	case SOAP_TYPE_PointerToPointerTons1__PayInternetItem:
		return soap_in_PointerToPointerTons1__PayInternetItem(soap, NULL, NULL, "ns1:PayInternetItem");
	case SOAP_TYPE_PointerTons1__PayInternetItem:
		return soap_in_PointerTons1__PayInternetItem(soap, NULL, NULL, "ns1:PayInternetItem");
	case SOAP_TYPE_PointerToPointerTons1__TransStaticsItem:
		return soap_in_PointerToPointerTons1__TransStaticsItem(soap, NULL, NULL, "ns1:TransStaticsItem");
	case SOAP_TYPE_PointerTons1__TransStaticsItem:
		return soap_in_PointerTons1__TransStaticsItem(soap, NULL, NULL, "ns1:TransStaticsItem");
	case SOAP_TYPE_PointerToPointerTons1__Transaction:
		return soap_in_PointerToPointerTons1__Transaction(soap, NULL, NULL, "ns1:Transaction");
	case SOAP_TYPE_PointerTons1__Transaction:
		return soap_in_PointerTons1__Transaction(soap, NULL, NULL, "ns1:Transaction");
	case SOAP_TYPE_PointerToPointerTons1__PaymentItem:
		return soap_in_PointerToPointerTons1__PaymentItem(soap, NULL, NULL, "ns1:PaymentItem");
	case SOAP_TYPE_PointerTons1__PaymentItem:
		return soap_in_PointerTons1__PaymentItem(soap, NULL, NULL, "ns1:PaymentItem");
	case SOAP_TYPE_PointerToPointerTons1__PayWithListItem:
		return soap_in_PointerToPointerTons1__PayWithListItem(soap, NULL, NULL, "ns1:PayWithListItem");
	case SOAP_TYPE_PointerTons1__PayWithListItem:
		return soap_in_PointerTons1__PayWithListItem(soap, NULL, NULL, "ns1:PayWithListItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayWithListItem:
		return soap_in_PointerTons1__ArrayOfPayWithListItem(soap, NULL, NULL, "ns1:ArrayOfPayWithListItem");
	case SOAP_TYPE_ns2__guid:
	{	char **s;
		s = soap_in_ns2__guid(soap, NULL, NULL, "ns2:guid");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:StockCardItem"))
		{	*type = SOAP_TYPE_ns1__StockCardItem;
			return soap_in_ns1__StockCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfStockCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfStockCardItem;
			return soap_in_ns1__ArrayOfStockCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtherCardItem"))
		{	*type = SOAP_TYPE_ns1__OtherCardItem;
			return soap_in_ns1__OtherCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfOtherCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfOtherCardItem;
			return soap_in_ns1__ArrayOfOtherCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellOtherCardItem"))
		{	*type = SOAP_TYPE_ns1__SellOtherCardItem;
			return soap_in_ns1__SellOtherCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSellOtherCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSellOtherCardItem;
			return soap_in_ns1__ArrayOfSellOtherCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BusinessItem"))
		{	*type = SOAP_TYPE_ns1__BusinessItem;
			return soap_in_ns1__BusinessItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfBusinessItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfBusinessItem;
			return soap_in_ns1__ArrayOfBusinessItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellCardItem"))
		{	*type = SOAP_TYPE_ns1__SellCardItem;
			return soap_in_ns1__SellCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSellCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSellCardItem;
			return soap_in_ns1__ArrayOfSellCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CardService"))
		{	*type = SOAP_TYPE_ns1__CardService;
			return soap_in_ns1__CardService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCardService"))
		{	*type = SOAP_TYPE_ns1__ArrayOfCardService;
			return soap_in_ns1__ArrayOfCardService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayMiniCardItem"))
		{	*type = SOAP_TYPE_ns1__PayMiniCardItem;
			return soap_in_ns1__PayMiniCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPayMiniCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPayMiniCardItem;
			return soap_in_ns1__ArrayOfPayMiniCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MiniCardItem"))
		{	*type = SOAP_TYPE_ns1__MiniCardItem;
			return soap_in_ns1__MiniCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfMiniCardItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfMiniCardItem;
			return soap_in_ns1__ArrayOfMiniCardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneNoItem"))
		{	*type = SOAP_TYPE_ns1__PhoneNoItem;
			return soap_in_ns1__PhoneNoItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPhoneNoItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPhoneNoItem;
			return soap_in_ns1__ArrayOfPhoneNoItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneNoList"))
		{	*type = SOAP_TYPE_ns1__PhoneNoList;
			return soap_in_ns1__PhoneNoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Result"))
		{	*type = SOAP_TYPE_ns1__Result;
			return soap_in_ns1__Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CompanyAccount"))
		{	*type = SOAP_TYPE_ns1__CompanyAccount;
			return soap_in_ns1__CompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCompanyAccount"))
		{	*type = SOAP_TYPE_ns1__ArrayOfCompanyAccount;
			return soap_in_ns1__ArrayOfCompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CompanyInfo"))
		{	*type = SOAP_TYPE_ns1__CompanyInfo;
			return soap_in_ns1__CompanyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneNumberBelong"))
		{	*type = SOAP_TYPE_ns1__PhoneNumberBelong;
			return soap_in_ns1__PhoneNumberBelong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPhoneNumberBelong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong;
			return soap_in_ns1__ArrayOfPhoneNumberBelong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnProportion"))
		{	*type = SOAP_TYPE_ns1__ReturnProportion;
			return soap_in_ns1__ReturnProportion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfReturnProportion"))
		{	*type = SOAP_TYPE_ns1__ArrayOfReturnProportion;
			return soap_in_ns1__ArrayOfReturnProportion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoticeItem"))
		{	*type = SOAP_TYPE_ns1__NoticeItem;
			return soap_in_ns1__NoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNoticeItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfNoticeItem;
			return soap_in_ns1__ArrayOfNoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Notice"))
		{	*type = SOAP_TYPE_ns1__Notice;
			return soap_in_ns1__Notice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TableStatistics"))
		{	*type = SOAP_TYPE_ns1__TableStatistics;
			return soap_in_ns1__TableStatistics(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DIC_Category"))
		{	*type = SOAP_TYPE_ns1__DIC_USCORECategory;
			return soap_in_ns1__DIC_USCORECategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDIC_Category"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory;
			return soap_in_ns1__ArrayOfDIC_USCORECategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DIC_Content"))
		{	*type = SOAP_TYPE_ns1__DIC_USCOREContent;
			return soap_in_ns1__DIC_USCOREContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDIC_Content"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent;
			return soap_in_ns1__ArrayOfDIC_USCOREContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcountPaymentItem"))
		{	*type = SOAP_TYPE_ns1__AcountPaymentItem;
			return soap_in_ns1__AcountPaymentItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAcountPaymentItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAcountPaymentItem;
			return soap_in_ns1__ArrayOfAcountPaymentItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnedItem"))
		{	*type = SOAP_TYPE_ns1__ReturnedItem;
			return soap_in_ns1__ReturnedItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfReturnedItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfReturnedItem;
			return soap_in_ns1__ArrayOfReturnedItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SystemFunction"))
		{	*type = SOAP_TYPE_ns1__SystemFunction;
			return soap_in_ns1__SystemFunction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSystemFunction"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSystemFunction;
			return soap_in_ns1__ArrayOfSystemFunction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Worker"))
		{	*type = SOAP_TYPE_ns1__Worker;
			return soap_in_ns1__Worker(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfWorker"))
		{	*type = SOAP_TYPE_ns1__ArrayOfWorker;
			return soap_in_ns1__ArrayOfWorker(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnInfoItem"))
		{	*type = SOAP_TYPE_ns1__ReturnInfoItem;
			return soap_in_ns1__ReturnInfoItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfReturnInfoItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfReturnInfoItem;
			return soap_in_ns1__ArrayOfReturnInfoItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnInfo"))
		{	*type = SOAP_TYPE_ns1__ReturnInfo;
			return soap_in_ns1__ReturnInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:User"))
		{	*type = SOAP_TYPE_ns1__User;
			return soap_in_ns1__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayPublicTelItem"))
		{	*type = SOAP_TYPE_ns1__PayPublicTelItem;
			return soap_in_ns1__PayPublicTelItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPayPublicTelItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPayPublicTelItem;
			return soap_in_ns1__ArrayOfPayPublicTelItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayGameItem"))
		{	*type = SOAP_TYPE_ns1__PayGameItem;
			return soap_in_ns1__PayGameItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPayGameItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPayGameItem;
			return soap_in_ns1__ArrayOfPayGameItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayInternetItem"))
		{	*type = SOAP_TYPE_ns1__PayInternetItem;
			return soap_in_ns1__PayInternetItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPayInternetItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPayInternetItem;
			return soap_in_ns1__ArrayOfPayInternetItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TransStaticsItem"))
		{	*type = SOAP_TYPE_ns1__TransStaticsItem;
			return soap_in_ns1__TransStaticsItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTransStaticsItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTransStaticsItem;
			return soap_in_ns1__ArrayOfTransStaticsItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Transaction"))
		{	*type = SOAP_TYPE_ns1__Transaction;
			return soap_in_ns1__Transaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTransaction"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTransaction;
			return soap_in_ns1__ArrayOfTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PaymentItem"))
		{	*type = SOAP_TYPE_ns1__PaymentItem;
			return soap_in_ns1__PaymentItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPaymentItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPaymentItem;
			return soap_in_ns1__ArrayOfPaymentItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayWithListItem"))
		{	*type = SOAP_TYPE_ns1__PayWithListItem;
			return soap_in_ns1__PayWithListItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPayWithListItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPayWithListItem;
			return soap_in_ns1__ArrayOfPayWithListItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayWithListResult"))
		{	*type = SOAP_TYPE_ns1__PayWithListResult;
			return soap_in_ns1__PayWithListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:guid"))
		{	char **s;
			*type = SOAP_TYPE_ns2__guid;
			s = soap_in_ns2__guid(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetStockCardItemAndHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse;
			return soap_in__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStockCardItemAndHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition;
			return soap_in__ns1__GetStockCardItemAndHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStockCardItemByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetStockCardItemByConditionResponse;
			return soap_in__ns1__GetStockCardItemByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStockCardItemByCondition"))
		{	*type = SOAP_TYPE__ns1__GetStockCardItemByCondition;
			return soap_in__ns1__GetStockCardItemByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherCardListResponse"))
		{	*type = SOAP_TYPE__ns1__GetOtherCardListResponse;
			return soap_in__ns1__GetOtherCardListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherCardList"))
		{	*type = SOAP_TYPE__ns1__GetOtherCardList;
			return soap_in__ns1__GetOtherCardList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GettSellOtherCardRecordHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse;
			return soap_in__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GettSellOtherCardRecordHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition;
			return soap_in__ns1__GettSellOtherCardRecordHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellOtherCardRecordByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse;
			return soap_in__ns1__GetSellOtherCardRecordByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellOtherCardRecordByCondition"))
		{	*type = SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition;
			return soap_in__ns1__GetSellOtherCardRecordByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GettBusinessRecordHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse;
			return soap_in__ns1__GettBusinessRecordHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GettBusinessRecordHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition;
			return soap_in__ns1__GettBusinessRecordHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBusinessRecordByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse;
			return soap_in__ns1__GetBusinessRecordByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBusinessRecordByCondition"))
		{	*type = SOAP_TYPE__ns1__GetBusinessRecordByCondition;
			return soap_in__ns1__GetBusinessRecordByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellCardRecordHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse;
			return soap_in__ns1__GetSellCardRecordHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellCardRecordHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition;
			return soap_in__ns1__GetSellCardRecordHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellCardRecordByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse;
			return soap_in__ns1__GetSellCardRecordByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSellCardRecordByCondition"))
		{	*type = SOAP_TYPE__ns1__GetSellCardRecordByCondition;
			return soap_in__ns1__GetSellCardRecordByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCardServiceResponse"))
		{	*type = SOAP_TYPE__ns1__GetCardServiceResponse;
			return soap_in__ns1__GetCardServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCardService"))
		{	*type = SOAP_TYPE__ns1__GetCardService;
			return soap_in__ns1__GetCardService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoItemAndHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse;
			return soap_in__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoItemAndHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition;
			return soap_in__ns1__GetPhoneNoItemAndHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoItemByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse;
			return soap_in__ns1__GetPhoneNoItemByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoItemByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoItemByCondition;
			return soap_in__ns1__GetPhoneNoItemByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayMiniCardHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse;
			return soap_in__ns1__GetPayMiniCardHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayMiniCardHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition;
			return soap_in__ns1__GetPayMiniCardHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayMiniCardByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse;
			return soap_in__ns1__GetPayMiniCardByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayMiniCardByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayMiniCardByCondition;
			return soap_in__ns1__GetPayMiniCardByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMiniCardRecordResponse"))
		{	*type = SOAP_TYPE__ns1__GetMiniCardRecordResponse;
			return soap_in__ns1__GetMiniCardRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMiniCardRecord"))
		{	*type = SOAP_TYPE__ns1__GetMiniCardRecord;
			return soap_in__ns1__GetMiniCardRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellOhterCardResponse"))
		{	*type = SOAP_TYPE__ns1__SellOhterCardResponse;
			return soap_in__ns1__SellOhterCardResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellOhterCard"))
		{	*type = SOAP_TYPE__ns1__SellOhterCard;
			return soap_in__ns1__SellOhterCard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellNoResponse"))
		{	*type = SOAP_TYPE__ns1__SellNoResponse;
			return soap_in__ns1__SellNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SellNo"))
		{	*type = SOAP_TYPE__ns1__SellNo;
			return soap_in__ns1__SellNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitBusinessResponse"))
		{	*type = SOAP_TYPE__ns1__SubmitBusinessResponse;
			return soap_in__ns1__SubmitBusinessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitBusiness"))
		{	*type = SOAP_TYPE__ns1__SubmitBusiness;
			return soap_in__ns1__SubmitBusiness(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnlockNoResponse"))
		{	*type = SOAP_TYPE__ns1__UnlockNoResponse;
			return soap_in__ns1__UnlockNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnlockNo"))
		{	*type = SOAP_TYPE__ns1__UnlockNo;
			return soap_in__ns1__UnlockNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LockNoResponse"))
		{	*type = SOAP_TYPE__ns1__LockNoResponse;
			return soap_in__ns1__LockNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LockNo"))
		{	*type = SOAP_TYPE__ns1__LockNo;
			return soap_in__ns1__LockNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMyNoSectionResponse"))
		{	*type = SOAP_TYPE__ns1__GetMyNoSectionResponse;
			return soap_in__ns1__GetMyNoSectionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMyNoSection"))
		{	*type = SOAP_TYPE__ns1__GetMyNoSection;
			return soap_in__ns1__GetMyNoSection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoByConditionResponse;
			return soap_in__ns1__GetPhoneNoByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNoByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNoByCondition;
			return soap_in__ns1__GetPhoneNoByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BuyMiniCardResponse"))
		{	*type = SOAP_TYPE__ns1__BuyMiniCardResponse;
			return soap_in__ns1__BuyMiniCardResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BuyMiniCard"))
		{	*type = SOAP_TYPE__ns1__BuyMiniCard;
			return soap_in__ns1__BuyMiniCard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPhoneNOInfoResponse"))
		{	*type = SOAP_TYPE__ns1__queryPhoneNOInfoResponse;
			return soap_in__ns1__queryPhoneNOInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPhoneNOInfo"))
		{	*type = SOAP_TYPE__ns1__queryPhoneNOInfo;
			return soap_in__ns1__queryPhoneNOInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClientVersionResponse"))
		{	*type = SOAP_TYPE__ns1__GetClientVersionResponse;
			return soap_in__ns1__GetClientVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClientVersion"))
		{	*type = SOAP_TYPE__ns1__GetClientVersion;
			return soap_in__ns1__GetClientVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteCompanyAccountResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteCompanyAccountResponse;
			return soap_in__ns1__DeleteCompanyAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteCompanyAccount"))
		{	*type = SOAP_TYPE__ns1__DeleteCompanyAccount;
			return soap_in__ns1__DeleteCompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateCompanyAccountResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateCompanyAccountResponse;
			return soap_in__ns1__UpdateCompanyAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateCompanyAccount"))
		{	*type = SOAP_TYPE__ns1__UpdateCompanyAccount;
			return soap_in__ns1__UpdateCompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddCompanyAccountResponse"))
		{	*type = SOAP_TYPE__ns1__AddCompanyAccountResponse;
			return soap_in__ns1__AddCompanyAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddCompanyAccount"))
		{	*type = SOAP_TYPE__ns1__AddCompanyAccount;
			return soap_in__ns1__AddCompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCompanyAccountResponse"))
		{	*type = SOAP_TYPE__ns1__GetCompanyAccountResponse;
			return soap_in__ns1__GetCompanyAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCompanyAccount"))
		{	*type = SOAP_TYPE__ns1__GetCompanyAccount;
			return soap_in__ns1__GetCompanyAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateCompanyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateCompanyInfoResponse;
			return soap_in__ns1__UpdateCompanyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateCompanyInfo"))
		{	*type = SOAP_TYPE__ns1__UpdateCompanyInfo;
			return soap_in__ns1__UpdateCompanyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCompanyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetCompanyInfoResponse;
			return soap_in__ns1__GetCompanyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCompanyInfo"))
		{	*type = SOAP_TYPE__ns1__GetCompanyInfo;
			return soap_in__ns1__GetCompanyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeletePhoneNumberBelongResponse"))
		{	*type = SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse;
			return soap_in__ns1__DeletePhoneNumberBelongResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeletePhoneNumberBelong"))
		{	*type = SOAP_TYPE__ns1__DeletePhoneNumberBelong;
			return soap_in__ns1__DeletePhoneNumberBelong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPhoneNumberBelongResponse"))
		{	*type = SOAP_TYPE__ns1__AddPhoneNumberBelongResponse;
			return soap_in__ns1__AddPhoneNumberBelongResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPhoneNumberBelong"))
		{	*type = SOAP_TYPE__ns1__AddPhoneNumberBelong;
			return soap_in__ns1__AddPhoneNumberBelong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePhoneNumberBelongResponse"))
		{	*type = SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse;
			return soap_in__ns1__UpdatePhoneNumberBelongResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePhoneNumberBelong"))
		{	*type = SOAP_TYPE__ns1__UpdatePhoneNumberBelong;
			return soap_in__ns1__UpdatePhoneNumberBelong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNumberBelongByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse;
			return soap_in__ns1__GetPhoneNumberBelongByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPhoneNumberBelongByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition;
			return soap_in__ns1__GetPhoneNumberBelongByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeletetReturnProportionResponse"))
		{	*type = SOAP_TYPE__ns1__DeletetReturnProportionResponse;
			return soap_in__ns1__DeletetReturnProportionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeletetReturnProportion"))
		{	*type = SOAP_TYPE__ns1__DeletetReturnProportion;
			return soap_in__ns1__DeletetReturnProportion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatetReturnProportionResponse"))
		{	*type = SOAP_TYPE__ns1__UpdatetReturnProportionResponse;
			return soap_in__ns1__UpdatetReturnProportionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatetReturnProportion"))
		{	*type = SOAP_TYPE__ns1__UpdatetReturnProportion;
			return soap_in__ns1__UpdatetReturnProportion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddtReturnProportionResponse"))
		{	*type = SOAP_TYPE__ns1__AddtReturnProportionResponse;
			return soap_in__ns1__AddtReturnProportionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddtReturnProportion"))
		{	*type = SOAP_TYPE__ns1__AddtReturnProportion;
			return soap_in__ns1__AddtReturnProportion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnProportionRecordResponse"))
		{	*type = SOAP_TYPE__ns1__GetReturnProportionRecordResponse;
			return soap_in__ns1__GetReturnProportionRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnProportionRecord"))
		{	*type = SOAP_TYPE__ns1__GetReturnProportionRecord;
			return soap_in__ns1__GetReturnProportionRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InserNoticeToSomeOneResponse"))
		{	*type = SOAP_TYPE__ns1__InserNoticeToSomeOneResponse;
			return soap_in__ns1__InserNoticeToSomeOneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InserNoticeToSomeOne"))
		{	*type = SOAP_TYPE__ns1__InserNoticeToSomeOne;
			return soap_in__ns1__InserNoticeToSomeOne(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteNoticeItemResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteNoticeItemResponse;
			return soap_in__ns1__DeleteNoticeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteNoticeItem"))
		{	*type = SOAP_TYPE__ns1__DeleteNoticeItem;
			return soap_in__ns1__DeleteNoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateNoticeItemResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateNoticeItemResponse;
			return soap_in__ns1__UpdateNoticeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateNoticeItem"))
		{	*type = SOAP_TYPE__ns1__UpdateNoticeItem;
			return soap_in__ns1__UpdateNoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddNoticeItemToSomeoneResponse"))
		{	*type = SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse;
			return soap_in__ns1__AddNoticeItemToSomeoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddNoticeItemToSomeone"))
		{	*type = SOAP_TYPE__ns1__AddNoticeItemToSomeone;
			return soap_in__ns1__AddNoticeItemToSomeone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddNoticeItemResponse"))
		{	*type = SOAP_TYPE__ns1__AddNoticeItemResponse;
			return soap_in__ns1__AddNoticeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddNoticeItem"))
		{	*type = SOAP_TYPE__ns1__AddNoticeItem;
			return soap_in__ns1__AddNoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertNoticeListResponse"))
		{	*type = SOAP_TYPE__ns1__GetAlertNoticeListResponse;
			return soap_in__ns1__GetAlertNoticeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertNoticeList"))
		{	*type = SOAP_TYPE__ns1__GetAlertNoticeList;
			return soap_in__ns1__GetAlertNoticeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeItemResponse"))
		{	*type = SOAP_TYPE__ns1__GetNoticeItemResponse;
			return soap_in__ns1__GetNoticeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeItem"))
		{	*type = SOAP_TYPE__ns1__GetNoticeItem;
			return soap_in__ns1__GetNoticeItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeListByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetNoticeListByConditionResponse;
			return soap_in__ns1__GetNoticeListByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeListByCondition"))
		{	*type = SOAP_TYPE__ns1__GetNoticeListByCondition;
			return soap_in__ns1__GetNoticeListByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeListResponse"))
		{	*type = SOAP_TYPE__ns1__GetNoticeListResponse;
			return soap_in__ns1__GetNoticeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetNoticeList"))
		{	*type = SOAP_TYPE__ns1__GetNoticeList;
			return soap_in__ns1__GetNoticeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTableStatisticsResponse"))
		{	*type = SOAP_TYPE__ns1__GetTableStatisticsResponse;
			return soap_in__ns1__GetTableStatisticsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTableStatistics"))
		{	*type = SOAP_TYPE__ns1__GetTableStatistics;
			return soap_in__ns1__GetTableStatistics(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateFunctionRightResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateFunctionRightResponse;
			return soap_in__ns1__UpdateFunctionRightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateFunctionRight"))
		{	*type = SOAP_TYPE__ns1__UpdateFunctionRight;
			return soap_in__ns1__UpdateFunctionRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateUserFunctionListResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateUserFunctionListResponse;
			return soap_in__ns1__UpdateUserFunctionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateUserFunctionList"))
		{	*type = SOAP_TYPE__ns1__UpdateUserFunctionList;
			return soap_in__ns1__UpdateUserFunctionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFunctionListResponse"))
		{	*type = SOAP_TYPE__ns1__GetFunctionListResponse;
			return soap_in__ns1__GetFunctionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFunctionList"))
		{	*type = SOAP_TYPE__ns1__GetFunctionList;
			return soap_in__ns1__GetFunctionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDicContentByCategoryResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse;
			return soap_in__ns1__UpdateDicContentByCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDicContentByCategory"))
		{	*type = SOAP_TYPE__ns1__UpdateDicContentByCategory;
			return soap_in__ns1__UpdateDicContentByCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteDicContentResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteDicContentResponse;
			return soap_in__ns1__DeleteDicContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteDicContent"))
		{	*type = SOAP_TYPE__ns1__DeleteDicContent;
			return soap_in__ns1__DeleteDicContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDicContentResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateDicContentResponse;
			return soap_in__ns1__UpdateDicContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDicContent"))
		{	*type = SOAP_TYPE__ns1__UpdateDicContent;
			return soap_in__ns1__UpdateDicContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertDicContentResponse"))
		{	*type = SOAP_TYPE__ns1__InsertDicContentResponse;
			return soap_in__ns1__InsertDicContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertDicContent"))
		{	*type = SOAP_TYPE__ns1__InsertDicContent;
			return soap_in__ns1__InsertDicContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCategoryResponse"))
		{	*type = SOAP_TYPE__ns1__GetAllCategoryResponse;
			return soap_in__ns1__GetAllCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCategory"))
		{	*type = SOAP_TYPE__ns1__GetAllCategory;
			return soap_in__ns1__GetAllCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDicContentByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetDicContentByConditionResponse;
			return soap_in__ns1__GetDicContentByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDicContentByCondition"))
		{	*type = SOAP_TYPE__ns1__GetDicContentByCondition;
			return soap_in__ns1__GetDicContentByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAcountPaymentRecordResponse"))
		{	*type = SOAP_TYPE__ns1__GetAcountPaymentRecordResponse;
			return soap_in__ns1__GetAcountPaymentRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAcountPaymentRecord"))
		{	*type = SOAP_TYPE__ns1__GetAcountPaymentRecord;
			return soap_in__ns1__GetAcountPaymentRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnRecordDealResponse"))
		{	*type = SOAP_TYPE__ns1__GetReturnRecordDealResponse;
			return soap_in__ns1__GetReturnRecordDealResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnRecordDeal"))
		{	*type = SOAP_TYPE__ns1__GetReturnRecordDeal;
			return soap_in__ns1__GetReturnRecordDeal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnRecordResponse"))
		{	*type = SOAP_TYPE__ns1__GetReturnRecordResponse;
			return soap_in__ns1__GetReturnRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnRecord"))
		{	*type = SOAP_TYPE__ns1__GetReturnRecord;
			return soap_in__ns1__GetReturnRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserFunctionResponse"))
		{	*type = SOAP_TYPE__ns1__GetUserFunctionResponse;
			return soap_in__ns1__GetUserFunctionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserFunction"))
		{	*type = SOAP_TYPE__ns1__GetUserFunction;
			return soap_in__ns1__GetUserFunction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWorkNameListResponse"))
		{	*type = SOAP_TYPE__ns1__GetWorkNameListResponse;
			return soap_in__ns1__GetWorkNameListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWorkNameList"))
		{	*type = SOAP_TYPE__ns1__GetWorkNameList;
			return soap_in__ns1__GetWorkNameList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CharegeReturnedMoneyResponse"))
		{	*type = SOAP_TYPE__ns1__CharegeReturnedMoneyResponse;
			return soap_in__ns1__CharegeReturnedMoneyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CharegeReturnedMoney"))
		{	*type = SOAP_TYPE__ns1__CharegeReturnedMoney;
			return soap_in__ns1__CharegeReturnedMoney(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetReturnInfoResponse;
			return soap_in__ns1__GetReturnInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReturnInfo"))
		{	*type = SOAP_TYPE__ns1__GetReturnInfo;
			return soap_in__ns1__GetReturnInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddAcountPaymentResponse"))
		{	*type = SOAP_TYPE__ns1__AddAcountPaymentResponse;
			return soap_in__ns1__AddAcountPaymentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddAcountPayment"))
		{	*type = SOAP_TYPE__ns1__AddAcountPayment;
			return soap_in__ns1__AddAcountPayment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterUserInfoResponse"))
		{	*type = SOAP_TYPE__ns1__AlterUserInfoResponse;
			return soap_in__ns1__AlterUserInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterUserInfo"))
		{	*type = SOAP_TYPE__ns1__AlterUserInfo;
			return soap_in__ns1__AlterUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterPswResponse"))
		{	*type = SOAP_TYPE__ns1__AlterPswResponse;
			return soap_in__ns1__AlterPswResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterPsw"))
		{	*type = SOAP_TYPE__ns1__AlterPsw;
			return soap_in__ns1__AlterPsw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegisterUserResponse"))
		{	*type = SOAP_TYPE__ns1__RegisterUserResponse;
			return soap_in__ns1__RegisterUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegisterUser"))
		{	*type = SOAP_TYPE__ns1__RegisterUser;
			return soap_in__ns1__RegisterUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetUserInfoResponse;
			return soap_in__ns1__GetUserInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserInfo"))
		{	*type = SOAP_TYPE__ns1__GetUserInfo;
			return soap_in__ns1__GetUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TestLoginResponse"))
		{	*type = SOAP_TYPE__ns1__TestLoginResponse;
			return soap_in__ns1__TestLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TestLogin"))
		{	*type = SOAP_TYPE__ns1__TestLogin;
			return soap_in__ns1__TestLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loggoutResponse"))
		{	*type = SOAP_TYPE__ns1__loggoutResponse;
			return soap_in__ns1__loggoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loggout"))
		{	*type = SOAP_TYPE__ns1__loggout;
			return soap_in__ns1__loggout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorldResponse"))
		{	*type = SOAP_TYPE__ns1__HelloWorldResponse;
			return soap_in__ns1__HelloWorldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorld"))
		{	*type = SOAP_TYPE__ns1__HelloWorld;
			return soap_in__ns1__HelloWorld(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayPublicTelHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse;
			return soap_in__ns1__GetPayPublicTelHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayPublicTelHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition;
			return soap_in__ns1__GetPayPublicTelHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayPublicTelByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse;
			return soap_in__ns1__GetPayPublicTelByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayPublicTelByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayPublicTelByCondition;
			return soap_in__ns1__GetPayPublicTelByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayGameHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse;
			return soap_in__ns1__GetPayGameHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayGameHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayGameHistoryByCondition;
			return soap_in__ns1__GetPayGameHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayGameByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayGameByConditionResponse;
			return soap_in__ns1__GetPayGameByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayGameByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayGameByCondition;
			return soap_in__ns1__GetPayGameByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayInternetHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse;
			return soap_in__ns1__GetPayInternetHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayInternetHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayInternetHistoryByCondition;
			return soap_in__ns1__GetPayInternetHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayInternetByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPayInternetByConditionResponse;
			return soap_in__ns1__GetPayInternetByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPayInternetByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPayInternetByCondition;
			return soap_in__ns1__GetPayInternetByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentOrPaymentHistoryByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse;
			return soap_in__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentOrPaymentHistoryByCondition"))
		{	*type = SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition;
			return soap_in__ns1__GetPaymentOrPaymentHistoryByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTransactionStaticsByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse;
			return soap_in__ns1__GetTransactionStaticsByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTransactionStaticsByCondition"))
		{	*type = SOAP_TYPE__ns1__GetTransactionStaticsByCondition;
			return soap_in__ns1__GetTransactionStaticsByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTransactionByConditionResponse"))
		{	*type = SOAP_TYPE__ns1__GetTransactionByConditionResponse;
			return soap_in__ns1__GetTransactionByConditionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTransactionByCondition"))
		{	*type = SOAP_TYPE__ns1__GetTransactionByCondition;
			return soap_in__ns1__GetTransactionByCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentItemResponse"))
		{	*type = SOAP_TYPE__ns1__GetPaymentItemResponse;
			return soap_in__ns1__GetPaymentItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentItem"))
		{	*type = SOAP_TYPE__ns1__GetPaymentItem;
			return soap_in__ns1__GetPaymentItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentRecordResponse"))
		{	*type = SOAP_TYPE__ns1__GetPaymentRecordResponse;
			return soap_in__ns1__GetPaymentRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPaymentRecord"))
		{	*type = SOAP_TYPE__ns1__GetPaymentRecord;
			return soap_in__ns1__GetPaymentRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayPublicTelResponse"))
		{	*type = SOAP_TYPE__ns1__PayPublicTelResponse;
			return soap_in__ns1__PayPublicTelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayPublicTel"))
		{	*type = SOAP_TYPE__ns1__PayPublicTel;
			return soap_in__ns1__PayPublicTel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayGameResponse"))
		{	*type = SOAP_TYPE__ns1__PayGameResponse;
			return soap_in__ns1__PayGameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayGame"))
		{	*type = SOAP_TYPE__ns1__PayGame;
			return soap_in__ns1__PayGame(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequstInternetRollbackResponse"))
		{	*type = SOAP_TYPE__ns1__RequstInternetRollbackResponse;
			return soap_in__ns1__RequstInternetRollbackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequstInternetRollback"))
		{	*type = SOAP_TYPE__ns1__RequstInternetRollback;
			return soap_in__ns1__RequstInternetRollback(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayInternetWithListResponse"))
		{	*type = SOAP_TYPE__ns1__PayInternetWithListResponse;
			return soap_in__ns1__PayInternetWithListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayInternetWithList"))
		{	*type = SOAP_TYPE__ns1__PayInternetWithList;
			return soap_in__ns1__PayInternetWithList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayInternetResponse"))
		{	*type = SOAP_TYPE__ns1__PayInternetResponse;
			return soap_in__ns1__PayInternetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayInternet"))
		{	*type = SOAP_TYPE__ns1__PayInternet;
			return soap_in__ns1__PayInternet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequstRollbackResponse"))
		{	*type = SOAP_TYPE__ns1__RequstRollbackResponse;
			return soap_in__ns1__RequstRollbackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequstRollback"))
		{	*type = SOAP_TYPE__ns1__RequstRollback;
			return soap_in__ns1__RequstRollback(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayMoneyWithListResponse"))
		{	*type = SOAP_TYPE__ns1__PayMoneyWithListResponse;
			return soap_in__ns1__PayMoneyWithListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayMoneyWithList"))
		{	*type = SOAP_TYPE__ns1__PayMoneyWithList;
			return soap_in__ns1__PayMoneyWithList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayMoneyResponse"))
		{	*type = SOAP_TYPE__ns1__PayMoneyResponse;
			return soap_in__ns1__PayMoneyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PayMoney"))
		{	*type = SOAP_TYPE__ns1__PayMoney;
			return soap_in__ns1__PayMoney(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLocationResponse"))
		{	*type = SOAP_TYPE__ns1__GetLocationResponse;
			return soap_in__ns1__GetLocationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLocation"))
		{	*type = SOAP_TYPE__ns1__GetLocation;
			return soap_in__ns1__GetLocation(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse:
		return ((_ns1__GetStockCardItemAndHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetStockCardItemAndHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition:
		return ((_ns1__GetStockCardItemAndHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetStockCardItemAndHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetStockCardItemByConditionResponse:
		return ((_ns1__GetStockCardItemByConditionResponse *)ptr)->soap_out(soap, "ns1:GetStockCardItemByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetStockCardItemByCondition:
		return ((_ns1__GetStockCardItemByCondition *)ptr)->soap_out(soap, "ns1:GetStockCardItemByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetOtherCardListResponse:
		return ((_ns1__GetOtherCardListResponse *)ptr)->soap_out(soap, "ns1:GetOtherCardListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetOtherCardList:
		return ((_ns1__GetOtherCardList *)ptr)->soap_out(soap, "ns1:GetOtherCardList", id, NULL);
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		return ((_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GettSellOtherCardRecordHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition:
		return ((_ns1__GettSellOtherCardRecordHistoryByCondition *)ptr)->soap_out(soap, "ns1:GettSellOtherCardRecordHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse:
		return ((_ns1__GetSellOtherCardRecordByConditionResponse *)ptr)->soap_out(soap, "ns1:GetSellOtherCardRecordByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition:
		return ((_ns1__GetSellOtherCardRecordByCondition *)ptr)->soap_out(soap, "ns1:GetSellOtherCardRecordByCondition", id, NULL);
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse:
		return ((_ns1__GettBusinessRecordHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GettBusinessRecordHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition:
		return ((_ns1__GettBusinessRecordHistoryByCondition *)ptr)->soap_out(soap, "ns1:GettBusinessRecordHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse:
		return ((_ns1__GetBusinessRecordByConditionResponse *)ptr)->soap_out(soap, "ns1:GetBusinessRecordByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetBusinessRecordByCondition:
		return ((_ns1__GetBusinessRecordByCondition *)ptr)->soap_out(soap, "ns1:GetBusinessRecordByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse:
		return ((_ns1__GetSellCardRecordHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetSellCardRecordHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition:
		return ((_ns1__GetSellCardRecordHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetSellCardRecordHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse:
		return ((_ns1__GetSellCardRecordByConditionResponse *)ptr)->soap_out(soap, "ns1:GetSellCardRecordByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSellCardRecordByCondition:
		return ((_ns1__GetSellCardRecordByCondition *)ptr)->soap_out(soap, "ns1:GetSellCardRecordByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetCardServiceResponse:
		return ((_ns1__GetCardServiceResponse *)ptr)->soap_out(soap, "ns1:GetCardServiceResponse", id, NULL);
	case SOAP_TYPE__ns1__GetCardService:
		return ((_ns1__GetCardService *)ptr)->soap_out(soap, "ns1:GetCardService", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		return ((_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPhoneNoItemAndHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition:
		return ((_ns1__GetPhoneNoItemAndHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPhoneNoItemAndHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse:
		return ((_ns1__GetPhoneNoItemByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPhoneNoItemByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoItemByCondition:
		return ((_ns1__GetPhoneNoItemByCondition *)ptr)->soap_out(soap, "ns1:GetPhoneNoItemByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse:
		return ((_ns1__GetPayMiniCardHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayMiniCardHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition:
		return ((_ns1__GetPayMiniCardHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPayMiniCardHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse:
		return ((_ns1__GetPayMiniCardByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayMiniCardByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayMiniCardByCondition:
		return ((_ns1__GetPayMiniCardByCondition *)ptr)->soap_out(soap, "ns1:GetPayMiniCardByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetMiniCardRecordResponse:
		return ((_ns1__GetMiniCardRecordResponse *)ptr)->soap_out(soap, "ns1:GetMiniCardRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetMiniCardRecord:
		return ((_ns1__GetMiniCardRecord *)ptr)->soap_out(soap, "ns1:GetMiniCardRecord", id, NULL);
	case SOAP_TYPE__ns1__SellOhterCardResponse:
		return ((_ns1__SellOhterCardResponse *)ptr)->soap_out(soap, "ns1:SellOhterCardResponse", id, NULL);
	case SOAP_TYPE__ns1__SellOhterCard:
		return ((_ns1__SellOhterCard *)ptr)->soap_out(soap, "ns1:SellOhterCard", id, NULL);
	case SOAP_TYPE__ns1__SellNoResponse:
		return ((_ns1__SellNoResponse *)ptr)->soap_out(soap, "ns1:SellNoResponse", id, NULL);
	case SOAP_TYPE__ns1__SellNo:
		return ((_ns1__SellNo *)ptr)->soap_out(soap, "ns1:SellNo", id, NULL);
	case SOAP_TYPE__ns1__SubmitBusinessResponse:
		return ((_ns1__SubmitBusinessResponse *)ptr)->soap_out(soap, "ns1:SubmitBusinessResponse", id, NULL);
	case SOAP_TYPE__ns1__SubmitBusiness:
		return ((_ns1__SubmitBusiness *)ptr)->soap_out(soap, "ns1:SubmitBusiness", id, NULL);
	case SOAP_TYPE__ns1__UnlockNoResponse:
		return ((_ns1__UnlockNoResponse *)ptr)->soap_out(soap, "ns1:UnlockNoResponse", id, NULL);
	case SOAP_TYPE__ns1__UnlockNo:
		return ((_ns1__UnlockNo *)ptr)->soap_out(soap, "ns1:UnlockNo", id, NULL);
	case SOAP_TYPE__ns1__LockNoResponse:
		return ((_ns1__LockNoResponse *)ptr)->soap_out(soap, "ns1:LockNoResponse", id, NULL);
	case SOAP_TYPE__ns1__LockNo:
		return ((_ns1__LockNo *)ptr)->soap_out(soap, "ns1:LockNo", id, NULL);
	case SOAP_TYPE__ns1__GetMyNoSectionResponse:
		return ((_ns1__GetMyNoSectionResponse *)ptr)->soap_out(soap, "ns1:GetMyNoSectionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetMyNoSection:
		return ((_ns1__GetMyNoSection *)ptr)->soap_out(soap, "ns1:GetMyNoSection", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoByConditionResponse:
		return ((_ns1__GetPhoneNoByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPhoneNoByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNoByCondition:
		return ((_ns1__GetPhoneNoByCondition *)ptr)->soap_out(soap, "ns1:GetPhoneNoByCondition", id, NULL);
	case SOAP_TYPE__ns1__BuyMiniCardResponse:
		return ((_ns1__BuyMiniCardResponse *)ptr)->soap_out(soap, "ns1:BuyMiniCardResponse", id, NULL);
	case SOAP_TYPE__ns1__BuyMiniCard:
		return ((_ns1__BuyMiniCard *)ptr)->soap_out(soap, "ns1:BuyMiniCard", id, NULL);
	case SOAP_TYPE__ns1__queryPhoneNOInfoResponse:
		return ((_ns1__queryPhoneNOInfoResponse *)ptr)->soap_out(soap, "ns1:queryPhoneNOInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__queryPhoneNOInfo:
		return ((_ns1__queryPhoneNOInfo *)ptr)->soap_out(soap, "ns1:queryPhoneNOInfo", id, NULL);
	case SOAP_TYPE__ns1__GetClientVersionResponse:
		return ((_ns1__GetClientVersionResponse *)ptr)->soap_out(soap, "ns1:GetClientVersionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetClientVersion:
		return ((_ns1__GetClientVersion *)ptr)->soap_out(soap, "ns1:GetClientVersion", id, NULL);
	case SOAP_TYPE__ns1__DeleteCompanyAccountResponse:
		return ((_ns1__DeleteCompanyAccountResponse *)ptr)->soap_out(soap, "ns1:DeleteCompanyAccountResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteCompanyAccount:
		return ((_ns1__DeleteCompanyAccount *)ptr)->soap_out(soap, "ns1:DeleteCompanyAccount", id, NULL);
	case SOAP_TYPE__ns1__UpdateCompanyAccountResponse:
		return ((_ns1__UpdateCompanyAccountResponse *)ptr)->soap_out(soap, "ns1:UpdateCompanyAccountResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateCompanyAccount:
		return ((_ns1__UpdateCompanyAccount *)ptr)->soap_out(soap, "ns1:UpdateCompanyAccount", id, NULL);
	case SOAP_TYPE__ns1__AddCompanyAccountResponse:
		return ((_ns1__AddCompanyAccountResponse *)ptr)->soap_out(soap, "ns1:AddCompanyAccountResponse", id, NULL);
	case SOAP_TYPE__ns1__AddCompanyAccount:
		return ((_ns1__AddCompanyAccount *)ptr)->soap_out(soap, "ns1:AddCompanyAccount", id, NULL);
	case SOAP_TYPE__ns1__GetCompanyAccountResponse:
		return ((_ns1__GetCompanyAccountResponse *)ptr)->soap_out(soap, "ns1:GetCompanyAccountResponse", id, NULL);
	case SOAP_TYPE__ns1__GetCompanyAccount:
		return ((_ns1__GetCompanyAccount *)ptr)->soap_out(soap, "ns1:GetCompanyAccount", id, NULL);
	case SOAP_TYPE__ns1__UpdateCompanyInfoResponse:
		return ((_ns1__UpdateCompanyInfoResponse *)ptr)->soap_out(soap, "ns1:UpdateCompanyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateCompanyInfo:
		return ((_ns1__UpdateCompanyInfo *)ptr)->soap_out(soap, "ns1:UpdateCompanyInfo", id, NULL);
	case SOAP_TYPE__ns1__GetCompanyInfoResponse:
		return ((_ns1__GetCompanyInfoResponse *)ptr)->soap_out(soap, "ns1:GetCompanyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetCompanyInfo:
		return ((_ns1__GetCompanyInfo *)ptr)->soap_out(soap, "ns1:GetCompanyInfo", id, NULL);
	case SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse:
		return ((_ns1__DeletePhoneNumberBelongResponse *)ptr)->soap_out(soap, "ns1:DeletePhoneNumberBelongResponse", id, NULL);
	case SOAP_TYPE__ns1__DeletePhoneNumberBelong:
		return ((_ns1__DeletePhoneNumberBelong *)ptr)->soap_out(soap, "ns1:DeletePhoneNumberBelong", id, NULL);
	case SOAP_TYPE__ns1__AddPhoneNumberBelongResponse:
		return ((_ns1__AddPhoneNumberBelongResponse *)ptr)->soap_out(soap, "ns1:AddPhoneNumberBelongResponse", id, NULL);
	case SOAP_TYPE__ns1__AddPhoneNumberBelong:
		return ((_ns1__AddPhoneNumberBelong *)ptr)->soap_out(soap, "ns1:AddPhoneNumberBelong", id, NULL);
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse:
		return ((_ns1__UpdatePhoneNumberBelongResponse *)ptr)->soap_out(soap, "ns1:UpdatePhoneNumberBelongResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelong:
		return ((_ns1__UpdatePhoneNumberBelong *)ptr)->soap_out(soap, "ns1:UpdatePhoneNumberBelong", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse:
		return ((_ns1__GetPhoneNumberBelongByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPhoneNumberBelongByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition:
		return ((_ns1__GetPhoneNumberBelongByCondition *)ptr)->soap_out(soap, "ns1:GetPhoneNumberBelongByCondition", id, NULL);
	case SOAP_TYPE__ns1__DeletetReturnProportionResponse:
		return ((_ns1__DeletetReturnProportionResponse *)ptr)->soap_out(soap, "ns1:DeletetReturnProportionResponse", id, NULL);
	case SOAP_TYPE__ns1__DeletetReturnProportion:
		return ((_ns1__DeletetReturnProportion *)ptr)->soap_out(soap, "ns1:DeletetReturnProportion", id, NULL);
	case SOAP_TYPE__ns1__UpdatetReturnProportionResponse:
		return ((_ns1__UpdatetReturnProportionResponse *)ptr)->soap_out(soap, "ns1:UpdatetReturnProportionResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdatetReturnProportion:
		return ((_ns1__UpdatetReturnProportion *)ptr)->soap_out(soap, "ns1:UpdatetReturnProportion", id, NULL);
	case SOAP_TYPE__ns1__AddtReturnProportionResponse:
		return ((_ns1__AddtReturnProportionResponse *)ptr)->soap_out(soap, "ns1:AddtReturnProportionResponse", id, NULL);
	case SOAP_TYPE__ns1__AddtReturnProportion:
		return ((_ns1__AddtReturnProportion *)ptr)->soap_out(soap, "ns1:AddtReturnProportion", id, NULL);
	case SOAP_TYPE__ns1__GetReturnProportionRecordResponse:
		return ((_ns1__GetReturnProportionRecordResponse *)ptr)->soap_out(soap, "ns1:GetReturnProportionRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetReturnProportionRecord:
		return ((_ns1__GetReturnProportionRecord *)ptr)->soap_out(soap, "ns1:GetReturnProportionRecord", id, NULL);
	case SOAP_TYPE__ns1__InserNoticeToSomeOneResponse:
		return ((_ns1__InserNoticeToSomeOneResponse *)ptr)->soap_out(soap, "ns1:InserNoticeToSomeOneResponse", id, NULL);
	case SOAP_TYPE__ns1__InserNoticeToSomeOne:
		return ((_ns1__InserNoticeToSomeOne *)ptr)->soap_out(soap, "ns1:InserNoticeToSomeOne", id, NULL);
	case SOAP_TYPE__ns1__DeleteNoticeItemResponse:
		return ((_ns1__DeleteNoticeItemResponse *)ptr)->soap_out(soap, "ns1:DeleteNoticeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteNoticeItem:
		return ((_ns1__DeleteNoticeItem *)ptr)->soap_out(soap, "ns1:DeleteNoticeItem", id, NULL);
	case SOAP_TYPE__ns1__UpdateNoticeItemResponse:
		return ((_ns1__UpdateNoticeItemResponse *)ptr)->soap_out(soap, "ns1:UpdateNoticeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateNoticeItem:
		return ((_ns1__UpdateNoticeItem *)ptr)->soap_out(soap, "ns1:UpdateNoticeItem", id, NULL);
	case SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse:
		return ((_ns1__AddNoticeItemToSomeoneResponse *)ptr)->soap_out(soap, "ns1:AddNoticeItemToSomeoneResponse", id, NULL);
	case SOAP_TYPE__ns1__AddNoticeItemToSomeone:
		return ((_ns1__AddNoticeItemToSomeone *)ptr)->soap_out(soap, "ns1:AddNoticeItemToSomeone", id, NULL);
	case SOAP_TYPE__ns1__AddNoticeItemResponse:
		return ((_ns1__AddNoticeItemResponse *)ptr)->soap_out(soap, "ns1:AddNoticeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__AddNoticeItem:
		return ((_ns1__AddNoticeItem *)ptr)->soap_out(soap, "ns1:AddNoticeItem", id, NULL);
	case SOAP_TYPE__ns1__GetAlertNoticeListResponse:
		return ((_ns1__GetAlertNoticeListResponse *)ptr)->soap_out(soap, "ns1:GetAlertNoticeListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAlertNoticeList:
		return ((_ns1__GetAlertNoticeList *)ptr)->soap_out(soap, "ns1:GetAlertNoticeList", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeItemResponse:
		return ((_ns1__GetNoticeItemResponse *)ptr)->soap_out(soap, "ns1:GetNoticeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeItem:
		return ((_ns1__GetNoticeItem *)ptr)->soap_out(soap, "ns1:GetNoticeItem", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeListByConditionResponse:
		return ((_ns1__GetNoticeListByConditionResponse *)ptr)->soap_out(soap, "ns1:GetNoticeListByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeListByCondition:
		return ((_ns1__GetNoticeListByCondition *)ptr)->soap_out(soap, "ns1:GetNoticeListByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeListResponse:
		return ((_ns1__GetNoticeListResponse *)ptr)->soap_out(soap, "ns1:GetNoticeListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetNoticeList:
		return ((_ns1__GetNoticeList *)ptr)->soap_out(soap, "ns1:GetNoticeList", id, NULL);
	case SOAP_TYPE__ns1__GetTableStatisticsResponse:
		return ((_ns1__GetTableStatisticsResponse *)ptr)->soap_out(soap, "ns1:GetTableStatisticsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetTableStatistics:
		return ((_ns1__GetTableStatistics *)ptr)->soap_out(soap, "ns1:GetTableStatistics", id, NULL);
	case SOAP_TYPE__ns1__UpdateFunctionRightResponse:
		return ((_ns1__UpdateFunctionRightResponse *)ptr)->soap_out(soap, "ns1:UpdateFunctionRightResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateFunctionRight:
		return ((_ns1__UpdateFunctionRight *)ptr)->soap_out(soap, "ns1:UpdateFunctionRight", id, NULL);
	case SOAP_TYPE__ns1__UpdateUserFunctionListResponse:
		return ((_ns1__UpdateUserFunctionListResponse *)ptr)->soap_out(soap, "ns1:UpdateUserFunctionListResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateUserFunctionList:
		return ((_ns1__UpdateUserFunctionList *)ptr)->soap_out(soap, "ns1:UpdateUserFunctionList", id, NULL);
	case SOAP_TYPE__ns1__GetFunctionListResponse:
		return ((_ns1__GetFunctionListResponse *)ptr)->soap_out(soap, "ns1:GetFunctionListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetFunctionList:
		return ((_ns1__GetFunctionList *)ptr)->soap_out(soap, "ns1:GetFunctionList", id, NULL);
	case SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse:
		return ((_ns1__UpdateDicContentByCategoryResponse *)ptr)->soap_out(soap, "ns1:UpdateDicContentByCategoryResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateDicContentByCategory:
		return ((_ns1__UpdateDicContentByCategory *)ptr)->soap_out(soap, "ns1:UpdateDicContentByCategory", id, NULL);
	case SOAP_TYPE__ns1__DeleteDicContentResponse:
		return ((_ns1__DeleteDicContentResponse *)ptr)->soap_out(soap, "ns1:DeleteDicContentResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteDicContent:
		return ((_ns1__DeleteDicContent *)ptr)->soap_out(soap, "ns1:DeleteDicContent", id, NULL);
	case SOAP_TYPE__ns1__UpdateDicContentResponse:
		return ((_ns1__UpdateDicContentResponse *)ptr)->soap_out(soap, "ns1:UpdateDicContentResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateDicContent:
		return ((_ns1__UpdateDicContent *)ptr)->soap_out(soap, "ns1:UpdateDicContent", id, NULL);
	case SOAP_TYPE__ns1__InsertDicContentResponse:
		return ((_ns1__InsertDicContentResponse *)ptr)->soap_out(soap, "ns1:InsertDicContentResponse", id, NULL);
	case SOAP_TYPE__ns1__InsertDicContent:
		return ((_ns1__InsertDicContent *)ptr)->soap_out(soap, "ns1:InsertDicContent", id, NULL);
	case SOAP_TYPE__ns1__GetAllCategoryResponse:
		return ((_ns1__GetAllCategoryResponse *)ptr)->soap_out(soap, "ns1:GetAllCategoryResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAllCategory:
		return ((_ns1__GetAllCategory *)ptr)->soap_out(soap, "ns1:GetAllCategory", id, NULL);
	case SOAP_TYPE__ns1__GetDicContentByConditionResponse:
		return ((_ns1__GetDicContentByConditionResponse *)ptr)->soap_out(soap, "ns1:GetDicContentByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetDicContentByCondition:
		return ((_ns1__GetDicContentByCondition *)ptr)->soap_out(soap, "ns1:GetDicContentByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetAcountPaymentRecordResponse:
		return ((_ns1__GetAcountPaymentRecordResponse *)ptr)->soap_out(soap, "ns1:GetAcountPaymentRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAcountPaymentRecord:
		return ((_ns1__GetAcountPaymentRecord *)ptr)->soap_out(soap, "ns1:GetAcountPaymentRecord", id, NULL);
	case SOAP_TYPE__ns1__GetReturnRecordDealResponse:
		return ((_ns1__GetReturnRecordDealResponse *)ptr)->soap_out(soap, "ns1:GetReturnRecordDealResponse", id, NULL);
	case SOAP_TYPE__ns1__GetReturnRecordDeal:
		return ((_ns1__GetReturnRecordDeal *)ptr)->soap_out(soap, "ns1:GetReturnRecordDeal", id, NULL);
	case SOAP_TYPE__ns1__GetReturnRecordResponse:
		return ((_ns1__GetReturnRecordResponse *)ptr)->soap_out(soap, "ns1:GetReturnRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetReturnRecord:
		return ((_ns1__GetReturnRecord *)ptr)->soap_out(soap, "ns1:GetReturnRecord", id, NULL);
	case SOAP_TYPE__ns1__GetUserFunctionResponse:
		return ((_ns1__GetUserFunctionResponse *)ptr)->soap_out(soap, "ns1:GetUserFunctionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetUserFunction:
		return ((_ns1__GetUserFunction *)ptr)->soap_out(soap, "ns1:GetUserFunction", id, NULL);
	case SOAP_TYPE__ns1__GetWorkNameListResponse:
		return ((_ns1__GetWorkNameListResponse *)ptr)->soap_out(soap, "ns1:GetWorkNameListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetWorkNameList:
		return ((_ns1__GetWorkNameList *)ptr)->soap_out(soap, "ns1:GetWorkNameList", id, NULL);
	case SOAP_TYPE__ns1__CharegeReturnedMoneyResponse:
		return ((_ns1__CharegeReturnedMoneyResponse *)ptr)->soap_out(soap, "ns1:CharegeReturnedMoneyResponse", id, NULL);
	case SOAP_TYPE__ns1__CharegeReturnedMoney:
		return ((_ns1__CharegeReturnedMoney *)ptr)->soap_out(soap, "ns1:CharegeReturnedMoney", id, NULL);
	case SOAP_TYPE__ns1__GetReturnInfoResponse:
		return ((_ns1__GetReturnInfoResponse *)ptr)->soap_out(soap, "ns1:GetReturnInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetReturnInfo:
		return ((_ns1__GetReturnInfo *)ptr)->soap_out(soap, "ns1:GetReturnInfo", id, NULL);
	case SOAP_TYPE__ns1__AddAcountPaymentResponse:
		return ((_ns1__AddAcountPaymentResponse *)ptr)->soap_out(soap, "ns1:AddAcountPaymentResponse", id, NULL);
	case SOAP_TYPE__ns1__AddAcountPayment:
		return ((_ns1__AddAcountPayment *)ptr)->soap_out(soap, "ns1:AddAcountPayment", id, NULL);
	case SOAP_TYPE__ns1__AlterUserInfoResponse:
		return ((_ns1__AlterUserInfoResponse *)ptr)->soap_out(soap, "ns1:AlterUserInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__AlterUserInfo:
		return ((_ns1__AlterUserInfo *)ptr)->soap_out(soap, "ns1:AlterUserInfo", id, NULL);
	case SOAP_TYPE__ns1__AlterPswResponse:
		return ((_ns1__AlterPswResponse *)ptr)->soap_out(soap, "ns1:AlterPswResponse", id, NULL);
	case SOAP_TYPE__ns1__AlterPsw:
		return ((_ns1__AlterPsw *)ptr)->soap_out(soap, "ns1:AlterPsw", id, NULL);
	case SOAP_TYPE__ns1__RegisterUserResponse:
		return ((_ns1__RegisterUserResponse *)ptr)->soap_out(soap, "ns1:RegisterUserResponse", id, NULL);
	case SOAP_TYPE__ns1__RegisterUser:
		return ((_ns1__RegisterUser *)ptr)->soap_out(soap, "ns1:RegisterUser", id, NULL);
	case SOAP_TYPE__ns1__GetUserInfoResponse:
		return ((_ns1__GetUserInfoResponse *)ptr)->soap_out(soap, "ns1:GetUserInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetUserInfo:
		return ((_ns1__GetUserInfo *)ptr)->soap_out(soap, "ns1:GetUserInfo", id, NULL);
	case SOAP_TYPE__ns1__TestLoginResponse:
		return ((_ns1__TestLoginResponse *)ptr)->soap_out(soap, "ns1:TestLoginResponse", id, NULL);
	case SOAP_TYPE__ns1__TestLogin:
		return ((_ns1__TestLogin *)ptr)->soap_out(soap, "ns1:TestLogin", id, NULL);
	case SOAP_TYPE__ns1__loggoutResponse:
		return ((_ns1__loggoutResponse *)ptr)->soap_out(soap, "ns1:loggoutResponse", id, NULL);
	case SOAP_TYPE__ns1__loggout:
		return ((_ns1__loggout *)ptr)->soap_out(soap, "ns1:loggout", id, NULL);
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return ((_ns1__HelloWorldResponse *)ptr)->soap_out(soap, "ns1:HelloWorldResponse", id, NULL);
	case SOAP_TYPE__ns1__HelloWorld:
		return ((_ns1__HelloWorld *)ptr)->soap_out(soap, "ns1:HelloWorld", id, NULL);
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse:
		return ((_ns1__GetPayPublicTelHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayPublicTelHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition:
		return ((_ns1__GetPayPublicTelHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPayPublicTelHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse:
		return ((_ns1__GetPayPublicTelByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayPublicTelByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayPublicTelByCondition:
		return ((_ns1__GetPayPublicTelByCondition *)ptr)->soap_out(soap, "ns1:GetPayPublicTelByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse:
		return ((_ns1__GetPayGameHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayGameHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayGameHistoryByCondition:
		return ((_ns1__GetPayGameHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPayGameHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayGameByConditionResponse:
		return ((_ns1__GetPayGameByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayGameByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayGameByCondition:
		return ((_ns1__GetPayGameByCondition *)ptr)->soap_out(soap, "ns1:GetPayGameByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse:
		return ((_ns1__GetPayInternetHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayInternetHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayInternetHistoryByCondition:
		return ((_ns1__GetPayInternetHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPayInternetHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPayInternetByConditionResponse:
		return ((_ns1__GetPayInternetByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPayInternetByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPayInternetByCondition:
		return ((_ns1__GetPayInternetByCondition *)ptr)->soap_out(soap, "ns1:GetPayInternetByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		return ((_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)ptr)->soap_out(soap, "ns1:GetPaymentOrPaymentHistoryByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition:
		return ((_ns1__GetPaymentOrPaymentHistoryByCondition *)ptr)->soap_out(soap, "ns1:GetPaymentOrPaymentHistoryByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse:
		return ((_ns1__GetTransactionStaticsByConditionResponse *)ptr)->soap_out(soap, "ns1:GetTransactionStaticsByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetTransactionStaticsByCondition:
		return ((_ns1__GetTransactionStaticsByCondition *)ptr)->soap_out(soap, "ns1:GetTransactionStaticsByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetTransactionByConditionResponse:
		return ((_ns1__GetTransactionByConditionResponse *)ptr)->soap_out(soap, "ns1:GetTransactionByConditionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetTransactionByCondition:
		return ((_ns1__GetTransactionByCondition *)ptr)->soap_out(soap, "ns1:GetTransactionByCondition", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentItemResponse:
		return ((_ns1__GetPaymentItemResponse *)ptr)->soap_out(soap, "ns1:GetPaymentItemResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentItem:
		return ((_ns1__GetPaymentItem *)ptr)->soap_out(soap, "ns1:GetPaymentItem", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentRecordResponse:
		return ((_ns1__GetPaymentRecordResponse *)ptr)->soap_out(soap, "ns1:GetPaymentRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPaymentRecord:
		return ((_ns1__GetPaymentRecord *)ptr)->soap_out(soap, "ns1:GetPaymentRecord", id, NULL);
	case SOAP_TYPE__ns1__PayPublicTelResponse:
		return ((_ns1__PayPublicTelResponse *)ptr)->soap_out(soap, "ns1:PayPublicTelResponse", id, NULL);
	case SOAP_TYPE__ns1__PayPublicTel:
		return ((_ns1__PayPublicTel *)ptr)->soap_out(soap, "ns1:PayPublicTel", id, NULL);
	case SOAP_TYPE__ns1__PayGameResponse:
		return ((_ns1__PayGameResponse *)ptr)->soap_out(soap, "ns1:PayGameResponse", id, NULL);
	case SOAP_TYPE__ns1__PayGame:
		return ((_ns1__PayGame *)ptr)->soap_out(soap, "ns1:PayGame", id, NULL);
	case SOAP_TYPE__ns1__RequstInternetRollbackResponse:
		return ((_ns1__RequstInternetRollbackResponse *)ptr)->soap_out(soap, "ns1:RequstInternetRollbackResponse", id, NULL);
	case SOAP_TYPE__ns1__RequstInternetRollback:
		return ((_ns1__RequstInternetRollback *)ptr)->soap_out(soap, "ns1:RequstInternetRollback", id, NULL);
	case SOAP_TYPE__ns1__PayInternetWithListResponse:
		return ((_ns1__PayInternetWithListResponse *)ptr)->soap_out(soap, "ns1:PayInternetWithListResponse", id, NULL);
	case SOAP_TYPE__ns1__PayInternetWithList:
		return ((_ns1__PayInternetWithList *)ptr)->soap_out(soap, "ns1:PayInternetWithList", id, NULL);
	case SOAP_TYPE__ns1__PayInternetResponse:
		return ((_ns1__PayInternetResponse *)ptr)->soap_out(soap, "ns1:PayInternetResponse", id, NULL);
	case SOAP_TYPE__ns1__PayInternet:
		return ((_ns1__PayInternet *)ptr)->soap_out(soap, "ns1:PayInternet", id, NULL);
	case SOAP_TYPE__ns1__RequstRollbackResponse:
		return ((_ns1__RequstRollbackResponse *)ptr)->soap_out(soap, "ns1:RequstRollbackResponse", id, NULL);
	case SOAP_TYPE__ns1__RequstRollback:
		return ((_ns1__RequstRollback *)ptr)->soap_out(soap, "ns1:RequstRollback", id, NULL);
	case SOAP_TYPE__ns1__PayMoneyWithListResponse:
		return ((_ns1__PayMoneyWithListResponse *)ptr)->soap_out(soap, "ns1:PayMoneyWithListResponse", id, NULL);
	case SOAP_TYPE__ns1__PayMoneyWithList:
		return ((_ns1__PayMoneyWithList *)ptr)->soap_out(soap, "ns1:PayMoneyWithList", id, NULL);
	case SOAP_TYPE__ns1__PayMoneyResponse:
		return ((_ns1__PayMoneyResponse *)ptr)->soap_out(soap, "ns1:PayMoneyResponse", id, NULL);
	case SOAP_TYPE__ns1__PayMoney:
		return ((_ns1__PayMoney *)ptr)->soap_out(soap, "ns1:PayMoney", id, NULL);
	case SOAP_TYPE__ns1__GetLocationResponse:
		return ((_ns1__GetLocationResponse *)ptr)->soap_out(soap, "ns1:GetLocationResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLocation:
		return ((_ns1__GetLocation *)ptr)->soap_out(soap, "ns1:GetLocation", id, NULL);
	case SOAP_TYPE_ns1__StockCardItem:
		return ((ns1__StockCardItem *)ptr)->soap_out(soap, tag, id, "ns1:StockCardItem");
	case SOAP_TYPE_ns1__ArrayOfStockCardItem:
		return ((ns1__ArrayOfStockCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfStockCardItem");
	case SOAP_TYPE_ns1__OtherCardItem:
		return ((ns1__OtherCardItem *)ptr)->soap_out(soap, tag, id, "ns1:OtherCardItem");
	case SOAP_TYPE_ns1__ArrayOfOtherCardItem:
		return ((ns1__ArrayOfOtherCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfOtherCardItem");
	case SOAP_TYPE_ns1__SellOtherCardItem:
		return ((ns1__SellOtherCardItem *)ptr)->soap_out(soap, tag, id, "ns1:SellOtherCardItem");
	case SOAP_TYPE_ns1__ArrayOfSellOtherCardItem:
		return ((ns1__ArrayOfSellOtherCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSellOtherCardItem");
	case SOAP_TYPE_ns1__BusinessItem:
		return ((ns1__BusinessItem *)ptr)->soap_out(soap, tag, id, "ns1:BusinessItem");
	case SOAP_TYPE_ns1__ArrayOfBusinessItem:
		return ((ns1__ArrayOfBusinessItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfBusinessItem");
	case SOAP_TYPE_ns1__SellCardItem:
		return ((ns1__SellCardItem *)ptr)->soap_out(soap, tag, id, "ns1:SellCardItem");
	case SOAP_TYPE_ns1__ArrayOfSellCardItem:
		return ((ns1__ArrayOfSellCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSellCardItem");
	case SOAP_TYPE_ns1__CardService:
		return ((ns1__CardService *)ptr)->soap_out(soap, tag, id, "ns1:CardService");
	case SOAP_TYPE_ns1__ArrayOfCardService:
		return ((ns1__ArrayOfCardService *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCardService");
	case SOAP_TYPE_ns1__PayMiniCardItem:
		return ((ns1__PayMiniCardItem *)ptr)->soap_out(soap, tag, id, "ns1:PayMiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfPayMiniCardItem:
		return ((ns1__ArrayOfPayMiniCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPayMiniCardItem");
	case SOAP_TYPE_ns1__MiniCardItem:
		return ((ns1__MiniCardItem *)ptr)->soap_out(soap, tag, id, "ns1:MiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfMiniCardItem:
		return ((ns1__ArrayOfMiniCardItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfMiniCardItem");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__PhoneNoItem:
		return ((ns1__PhoneNoItem *)ptr)->soap_out(soap, tag, id, "ns1:PhoneNoItem");
	case SOAP_TYPE_ns1__ArrayOfPhoneNoItem:
		return ((ns1__ArrayOfPhoneNoItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPhoneNoItem");
	case SOAP_TYPE_ns1__PhoneNoList:
		return ((ns1__PhoneNoList *)ptr)->soap_out(soap, tag, id, "ns1:PhoneNoList");
	case SOAP_TYPE_ns1__Result:
		return ((ns1__Result *)ptr)->soap_out(soap, tag, id, "ns1:Result");
	case SOAP_TYPE_ns1__CompanyAccount:
		return ((ns1__CompanyAccount *)ptr)->soap_out(soap, tag, id, "ns1:CompanyAccount");
	case SOAP_TYPE_ns1__ArrayOfCompanyAccount:
		return ((ns1__ArrayOfCompanyAccount *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCompanyAccount");
	case SOAP_TYPE_ns1__CompanyInfo:
		return ((ns1__CompanyInfo *)ptr)->soap_out(soap, tag, id, "ns1:CompanyInfo");
	case SOAP_TYPE_ns1__PhoneNumberBelong:
		return ((ns1__PhoneNumberBelong *)ptr)->soap_out(soap, tag, id, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong:
		return ((ns1__ArrayOfPhoneNumberBelong *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPhoneNumberBelong");
	case SOAP_TYPE_ns1__ReturnProportion:
		return ((ns1__ReturnProportion *)ptr)->soap_out(soap, tag, id, "ns1:ReturnProportion");
	case SOAP_TYPE_ns1__ArrayOfReturnProportion:
		return ((ns1__ArrayOfReturnProportion *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfReturnProportion");
	case SOAP_TYPE_ns1__NoticeItem:
		return ((ns1__NoticeItem *)ptr)->soap_out(soap, tag, id, "ns1:NoticeItem");
	case SOAP_TYPE_ns1__ArrayOfNoticeItem:
		return ((ns1__ArrayOfNoticeItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfNoticeItem");
	case SOAP_TYPE_ns1__Notice:
		return ((ns1__Notice *)ptr)->soap_out(soap, tag, id, "ns1:Notice");
	case SOAP_TYPE_ns1__TableStatistics:
		return ((ns1__TableStatistics *)ptr)->soap_out(soap, tag, id, "ns1:TableStatistics");
	case SOAP_TYPE_ns1__DIC_USCORECategory:
		return ((ns1__DIC_USCORECategory *)ptr)->soap_out(soap, tag, id, "ns1:DIC_Category");
	case SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory:
		return ((ns1__ArrayOfDIC_USCORECategory *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDIC_Category");
	case SOAP_TYPE_ns1__DIC_USCOREContent:
		return ((ns1__DIC_USCOREContent *)ptr)->soap_out(soap, tag, id, "ns1:DIC_Content");
	case SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent:
		return ((ns1__ArrayOfDIC_USCOREContent *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDIC_Content");
	case SOAP_TYPE_ns1__AcountPaymentItem:
		return ((ns1__AcountPaymentItem *)ptr)->soap_out(soap, tag, id, "ns1:AcountPaymentItem");
	case SOAP_TYPE_ns1__ArrayOfAcountPaymentItem:
		return ((ns1__ArrayOfAcountPaymentItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAcountPaymentItem");
	case SOAP_TYPE_ns1__ReturnedItem:
		return ((ns1__ReturnedItem *)ptr)->soap_out(soap, tag, id, "ns1:ReturnedItem");
	case SOAP_TYPE_ns1__ArrayOfReturnedItem:
		return ((ns1__ArrayOfReturnedItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfReturnedItem");
	case SOAP_TYPE_ns1__SystemFunction:
		return ((ns1__SystemFunction *)ptr)->soap_out(soap, tag, id, "ns1:SystemFunction");
	case SOAP_TYPE_ns1__ArrayOfSystemFunction:
		return ((ns1__ArrayOfSystemFunction *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSystemFunction");
	case SOAP_TYPE_ns1__Worker:
		return ((ns1__Worker *)ptr)->soap_out(soap, tag, id, "ns1:Worker");
	case SOAP_TYPE_ns1__ArrayOfWorker:
		return ((ns1__ArrayOfWorker *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfWorker");
	case SOAP_TYPE_ns1__ReturnInfoItem:
		return ((ns1__ReturnInfoItem *)ptr)->soap_out(soap, tag, id, "ns1:ReturnInfoItem");
	case SOAP_TYPE_ns1__ArrayOfReturnInfoItem:
		return ((ns1__ArrayOfReturnInfoItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfReturnInfoItem");
	case SOAP_TYPE_ns1__ReturnInfo:
		return ((ns1__ReturnInfo *)ptr)->soap_out(soap, tag, id, "ns1:ReturnInfo");
	case SOAP_TYPE_ns1__User:
		return ((ns1__User *)ptr)->soap_out(soap, tag, id, "ns1:User");
	case SOAP_TYPE_ns1__PayPublicTelItem:
		return ((ns1__PayPublicTelItem *)ptr)->soap_out(soap, tag, id, "ns1:PayPublicTelItem");
	case SOAP_TYPE_ns1__ArrayOfPayPublicTelItem:
		return ((ns1__ArrayOfPayPublicTelItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPayPublicTelItem");
	case SOAP_TYPE_ns1__PayGameItem:
		return ((ns1__PayGameItem *)ptr)->soap_out(soap, tag, id, "ns1:PayGameItem");
	case SOAP_TYPE_ns1__ArrayOfPayGameItem:
		return ((ns1__ArrayOfPayGameItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPayGameItem");
	case SOAP_TYPE_ns1__PayInternetItem:
		return ((ns1__PayInternetItem *)ptr)->soap_out(soap, tag, id, "ns1:PayInternetItem");
	case SOAP_TYPE_ns1__ArrayOfPayInternetItem:
		return ((ns1__ArrayOfPayInternetItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPayInternetItem");
	case SOAP_TYPE_ns1__TransStaticsItem:
		return ((ns1__TransStaticsItem *)ptr)->soap_out(soap, tag, id, "ns1:TransStaticsItem");
	case SOAP_TYPE_ns1__ArrayOfTransStaticsItem:
		return ((ns1__ArrayOfTransStaticsItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfTransStaticsItem");
	case SOAP_TYPE_ns1__Transaction:
		return ((ns1__Transaction *)ptr)->soap_out(soap, tag, id, "ns1:Transaction");
	case SOAP_TYPE_ns1__ArrayOfTransaction:
		return ((ns1__ArrayOfTransaction *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfTransaction");
	case SOAP_TYPE_ns1__PaymentItem:
		return ((ns1__PaymentItem *)ptr)->soap_out(soap, tag, id, "ns1:PaymentItem");
	case SOAP_TYPE_ns1__ArrayOfPaymentItem:
		return ((ns1__ArrayOfPaymentItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPaymentItem");
	case SOAP_TYPE_ns1__PayWithListItem:
		return ((ns1__PayWithListItem *)ptr)->soap_out(soap, tag, id, "ns1:PayWithListItem");
	case SOAP_TYPE_ns1__ArrayOfPayWithListItem:
		return ((ns1__ArrayOfPayWithListItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPayWithListItem");
	case SOAP_TYPE_ns1__PayWithListResult:
		return ((ns1__PayWithListResult *)ptr)->soap_out(soap, tag, id, "ns1:PayWithListResult");
	case SOAP_TYPE_PointerTo_ns1__GetClientVersionResponse:
		return soap_out_PointerTo_ns1__GetClientVersionResponse(soap, tag, id, (_ns1__GetClientVersionResponse *const*)ptr, "ns1:GetClientVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClientVersion:
		return soap_out_PointerTo_ns1__GetClientVersion(soap, tag, id, (_ns1__GetClientVersion *const*)ptr, "ns1:GetClientVersion");
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccountResponse:
		return soap_out_PointerTo_ns1__DeleteCompanyAccountResponse(soap, tag, id, (_ns1__DeleteCompanyAccountResponse *const*)ptr, "ns1:DeleteCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccount:
		return soap_out_PointerTo_ns1__DeleteCompanyAccount(soap, tag, id, (_ns1__DeleteCompanyAccount *const*)ptr, "ns1:DeleteCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccountResponse:
		return soap_out_PointerTo_ns1__UpdateCompanyAccountResponse(soap, tag, id, (_ns1__UpdateCompanyAccountResponse *const*)ptr, "ns1:UpdateCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccount:
		return soap_out_PointerTo_ns1__UpdateCompanyAccount(soap, tag, id, (_ns1__UpdateCompanyAccount *const*)ptr, "ns1:UpdateCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccountResponse:
		return soap_out_PointerTo_ns1__AddCompanyAccountResponse(soap, tag, id, (_ns1__AddCompanyAccountResponse *const*)ptr, "ns1:AddCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccount:
		return soap_out_PointerTo_ns1__AddCompanyAccount(soap, tag, id, (_ns1__AddCompanyAccount *const*)ptr, "ns1:AddCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccountResponse:
		return soap_out_PointerTo_ns1__GetCompanyAccountResponse(soap, tag, id, (_ns1__GetCompanyAccountResponse *const*)ptr, "ns1:GetCompanyAccountResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccount:
		return soap_out_PointerTo_ns1__GetCompanyAccount(soap, tag, id, (_ns1__GetCompanyAccount *const*)ptr, "ns1:GetCompanyAccount");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfoResponse:
		return soap_out_PointerTo_ns1__UpdateCompanyInfoResponse(soap, tag, id, (_ns1__UpdateCompanyInfoResponse *const*)ptr, "ns1:UpdateCompanyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfo:
		return soap_out_PointerTo_ns1__UpdateCompanyInfo(soap, tag, id, (_ns1__UpdateCompanyInfo *const*)ptr, "ns1:UpdateCompanyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfoResponse:
		return soap_out_PointerTo_ns1__GetCompanyInfoResponse(soap, tag, id, (_ns1__GetCompanyInfoResponse *const*)ptr, "ns1:GetCompanyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfo:
		return soap_out_PointerTo_ns1__GetCompanyInfo(soap, tag, id, (_ns1__GetCompanyInfo *const*)ptr, "ns1:GetCompanyInfo");
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelongResponse:
		return soap_out_PointerTo_ns1__DeletePhoneNumberBelongResponse(soap, tag, id, (_ns1__DeletePhoneNumberBelongResponse *const*)ptr, "ns1:DeletePhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelong:
		return soap_out_PointerTo_ns1__DeletePhoneNumberBelong(soap, tag, id, (_ns1__DeletePhoneNumberBelong *const*)ptr, "ns1:DeletePhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelongResponse:
		return soap_out_PointerTo_ns1__AddPhoneNumberBelongResponse(soap, tag, id, (_ns1__AddPhoneNumberBelongResponse *const*)ptr, "ns1:AddPhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelong:
		return soap_out_PointerTo_ns1__AddPhoneNumberBelong(soap, tag, id, (_ns1__AddPhoneNumberBelong *const*)ptr, "ns1:AddPhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelongResponse:
		return soap_out_PointerTo_ns1__UpdatePhoneNumberBelongResponse(soap, tag, id, (_ns1__UpdatePhoneNumberBelongResponse *const*)ptr, "ns1:UpdatePhoneNumberBelongResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelong:
		return soap_out_PointerTo_ns1__UpdatePhoneNumberBelong(soap, tag, id, (_ns1__UpdatePhoneNumberBelong *const*)ptr, "ns1:UpdatePhoneNumberBelong");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse:
		return soap_out_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(soap, tag, id, (_ns1__GetPhoneNumberBelongByConditionResponse *const*)ptr, "ns1:GetPhoneNumberBelongByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByCondition:
		return soap_out_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, tag, id, (_ns1__GetPhoneNumberBelongByCondition *const*)ptr, "ns1:GetPhoneNumberBelongByCondition");
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportionResponse:
		return soap_out_PointerTo_ns1__DeletetReturnProportionResponse(soap, tag, id, (_ns1__DeletetReturnProportionResponse *const*)ptr, "ns1:DeletetReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportion:
		return soap_out_PointerTo_ns1__DeletetReturnProportion(soap, tag, id, (_ns1__DeletetReturnProportion *const*)ptr, "ns1:DeletetReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportionResponse:
		return soap_out_PointerTo_ns1__UpdatetReturnProportionResponse(soap, tag, id, (_ns1__UpdatetReturnProportionResponse *const*)ptr, "ns1:UpdatetReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportion:
		return soap_out_PointerTo_ns1__UpdatetReturnProportion(soap, tag, id, (_ns1__UpdatetReturnProportion *const*)ptr, "ns1:UpdatetReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportionResponse:
		return soap_out_PointerTo_ns1__AddtReturnProportionResponse(soap, tag, id, (_ns1__AddtReturnProportionResponse *const*)ptr, "ns1:AddtReturnProportionResponse");
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportion:
		return soap_out_PointerTo_ns1__AddtReturnProportion(soap, tag, id, (_ns1__AddtReturnProportion *const*)ptr, "ns1:AddtReturnProportion");
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecordResponse:
		return soap_out_PointerTo_ns1__GetReturnProportionRecordResponse(soap, tag, id, (_ns1__GetReturnProportionRecordResponse *const*)ptr, "ns1:GetReturnProportionRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecord:
		return soap_out_PointerTo_ns1__GetReturnProportionRecord(soap, tag, id, (_ns1__GetReturnProportionRecord *const*)ptr, "ns1:GetReturnProportionRecord");
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOneResponse:
		return soap_out_PointerTo_ns1__InserNoticeToSomeOneResponse(soap, tag, id, (_ns1__InserNoticeToSomeOneResponse *const*)ptr, "ns1:InserNoticeToSomeOneResponse");
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOne:
		return soap_out_PointerTo_ns1__InserNoticeToSomeOne(soap, tag, id, (_ns1__InserNoticeToSomeOne *const*)ptr, "ns1:InserNoticeToSomeOne");
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItemResponse:
		return soap_out_PointerTo_ns1__DeleteNoticeItemResponse(soap, tag, id, (_ns1__DeleteNoticeItemResponse *const*)ptr, "ns1:DeleteNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItem:
		return soap_out_PointerTo_ns1__DeleteNoticeItem(soap, tag, id, (_ns1__DeleteNoticeItem *const*)ptr, "ns1:DeleteNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItemResponse:
		return soap_out_PointerTo_ns1__UpdateNoticeItemResponse(soap, tag, id, (_ns1__UpdateNoticeItemResponse *const*)ptr, "ns1:UpdateNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItem:
		return soap_out_PointerTo_ns1__UpdateNoticeItem(soap, tag, id, (_ns1__UpdateNoticeItem *const*)ptr, "ns1:UpdateNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeoneResponse:
		return soap_out_PointerTo_ns1__AddNoticeItemToSomeoneResponse(soap, tag, id, (_ns1__AddNoticeItemToSomeoneResponse *const*)ptr, "ns1:AddNoticeItemToSomeoneResponse");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeone:
		return soap_out_PointerTo_ns1__AddNoticeItemToSomeone(soap, tag, id, (_ns1__AddNoticeItemToSomeone *const*)ptr, "ns1:AddNoticeItemToSomeone");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemResponse:
		return soap_out_PointerTo_ns1__AddNoticeItemResponse(soap, tag, id, (_ns1__AddNoticeItemResponse *const*)ptr, "ns1:AddNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItem:
		return soap_out_PointerTo_ns1__AddNoticeItem(soap, tag, id, (_ns1__AddNoticeItem *const*)ptr, "ns1:AddNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeListResponse:
		return soap_out_PointerTo_ns1__GetAlertNoticeListResponse(soap, tag, id, (_ns1__GetAlertNoticeListResponse *const*)ptr, "ns1:GetAlertNoticeListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeList:
		return soap_out_PointerTo_ns1__GetAlertNoticeList(soap, tag, id, (_ns1__GetAlertNoticeList *const*)ptr, "ns1:GetAlertNoticeList");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItemResponse:
		return soap_out_PointerTo_ns1__GetNoticeItemResponse(soap, tag, id, (_ns1__GetNoticeItemResponse *const*)ptr, "ns1:GetNoticeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItem:
		return soap_out_PointerTo_ns1__GetNoticeItem(soap, tag, id, (_ns1__GetNoticeItem *const*)ptr, "ns1:GetNoticeItem");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByConditionResponse:
		return soap_out_PointerTo_ns1__GetNoticeListByConditionResponse(soap, tag, id, (_ns1__GetNoticeListByConditionResponse *const*)ptr, "ns1:GetNoticeListByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByCondition:
		return soap_out_PointerTo_ns1__GetNoticeListByCondition(soap, tag, id, (_ns1__GetNoticeListByCondition *const*)ptr, "ns1:GetNoticeListByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListResponse:
		return soap_out_PointerTo_ns1__GetNoticeListResponse(soap, tag, id, (_ns1__GetNoticeListResponse *const*)ptr, "ns1:GetNoticeListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetNoticeList:
		return soap_out_PointerTo_ns1__GetNoticeList(soap, tag, id, (_ns1__GetNoticeList *const*)ptr, "ns1:GetNoticeList");
	case SOAP_TYPE_PointerTo_ns1__GetTableStatisticsResponse:
		return soap_out_PointerTo_ns1__GetTableStatisticsResponse(soap, tag, id, (_ns1__GetTableStatisticsResponse *const*)ptr, "ns1:GetTableStatisticsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTableStatistics:
		return soap_out_PointerTo_ns1__GetTableStatistics(soap, tag, id, (_ns1__GetTableStatistics *const*)ptr, "ns1:GetTableStatistics");
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRightResponse:
		return soap_out_PointerTo_ns1__UpdateFunctionRightResponse(soap, tag, id, (_ns1__UpdateFunctionRightResponse *const*)ptr, "ns1:UpdateFunctionRightResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRight:
		return soap_out_PointerTo_ns1__UpdateFunctionRight(soap, tag, id, (_ns1__UpdateFunctionRight *const*)ptr, "ns1:UpdateFunctionRight");
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionListResponse:
		return soap_out_PointerTo_ns1__UpdateUserFunctionListResponse(soap, tag, id, (_ns1__UpdateUserFunctionListResponse *const*)ptr, "ns1:UpdateUserFunctionListResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionList:
		return soap_out_PointerTo_ns1__UpdateUserFunctionList(soap, tag, id, (_ns1__UpdateUserFunctionList *const*)ptr, "ns1:UpdateUserFunctionList");
	case SOAP_TYPE_PointerTo_ns1__GetFunctionListResponse:
		return soap_out_PointerTo_ns1__GetFunctionListResponse(soap, tag, id, (_ns1__GetFunctionListResponse *const*)ptr, "ns1:GetFunctionListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetFunctionList:
		return soap_out_PointerTo_ns1__GetFunctionList(soap, tag, id, (_ns1__GetFunctionList *const*)ptr, "ns1:GetFunctionList");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategoryResponse:
		return soap_out_PointerTo_ns1__UpdateDicContentByCategoryResponse(soap, tag, id, (_ns1__UpdateDicContentByCategoryResponse *const*)ptr, "ns1:UpdateDicContentByCategoryResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategory:
		return soap_out_PointerTo_ns1__UpdateDicContentByCategory(soap, tag, id, (_ns1__UpdateDicContentByCategory *const*)ptr, "ns1:UpdateDicContentByCategory");
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContentResponse:
		return soap_out_PointerTo_ns1__DeleteDicContentResponse(soap, tag, id, (_ns1__DeleteDicContentResponse *const*)ptr, "ns1:DeleteDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContent:
		return soap_out_PointerTo_ns1__DeleteDicContent(soap, tag, id, (_ns1__DeleteDicContent *const*)ptr, "ns1:DeleteDicContent");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentResponse:
		return soap_out_PointerTo_ns1__UpdateDicContentResponse(soap, tag, id, (_ns1__UpdateDicContentResponse *const*)ptr, "ns1:UpdateDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContent:
		return soap_out_PointerTo_ns1__UpdateDicContent(soap, tag, id, (_ns1__UpdateDicContent *const*)ptr, "ns1:UpdateDicContent");
	case SOAP_TYPE_PointerTo_ns1__InsertDicContentResponse:
		return soap_out_PointerTo_ns1__InsertDicContentResponse(soap, tag, id, (_ns1__InsertDicContentResponse *const*)ptr, "ns1:InsertDicContentResponse");
	case SOAP_TYPE_PointerTo_ns1__InsertDicContent:
		return soap_out_PointerTo_ns1__InsertDicContent(soap, tag, id, (_ns1__InsertDicContent *const*)ptr, "ns1:InsertDicContent");
	case SOAP_TYPE_PointerTo_ns1__GetAllCategoryResponse:
		return soap_out_PointerTo_ns1__GetAllCategoryResponse(soap, tag, id, (_ns1__GetAllCategoryResponse *const*)ptr, "ns1:GetAllCategoryResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCategory:
		return soap_out_PointerTo_ns1__GetAllCategory(soap, tag, id, (_ns1__GetAllCategory *const*)ptr, "ns1:GetAllCategory");
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByConditionResponse:
		return soap_out_PointerTo_ns1__GetDicContentByConditionResponse(soap, tag, id, (_ns1__GetDicContentByConditionResponse *const*)ptr, "ns1:GetDicContentByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByCondition:
		return soap_out_PointerTo_ns1__GetDicContentByCondition(soap, tag, id, (_ns1__GetDicContentByCondition *const*)ptr, "ns1:GetDicContentByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecordResponse:
		return soap_out_PointerTo_ns1__GetAcountPaymentRecordResponse(soap, tag, id, (_ns1__GetAcountPaymentRecordResponse *const*)ptr, "ns1:GetAcountPaymentRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecord:
		return soap_out_PointerTo_ns1__GetAcountPaymentRecord(soap, tag, id, (_ns1__GetAcountPaymentRecord *const*)ptr, "ns1:GetAcountPaymentRecord");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDealResponse:
		return soap_out_PointerTo_ns1__GetReturnRecordDealResponse(soap, tag, id, (_ns1__GetReturnRecordDealResponse *const*)ptr, "ns1:GetReturnRecordDealResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDeal:
		return soap_out_PointerTo_ns1__GetReturnRecordDeal(soap, tag, id, (_ns1__GetReturnRecordDeal *const*)ptr, "ns1:GetReturnRecordDeal");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordResponse:
		return soap_out_PointerTo_ns1__GetReturnRecordResponse(soap, tag, id, (_ns1__GetReturnRecordResponse *const*)ptr, "ns1:GetReturnRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecord:
		return soap_out_PointerTo_ns1__GetReturnRecord(soap, tag, id, (_ns1__GetReturnRecord *const*)ptr, "ns1:GetReturnRecord");
	case SOAP_TYPE_PointerTo_ns1__GetUserFunctionResponse:
		return soap_out_PointerTo_ns1__GetUserFunctionResponse(soap, tag, id, (_ns1__GetUserFunctionResponse *const*)ptr, "ns1:GetUserFunctionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserFunction:
		return soap_out_PointerTo_ns1__GetUserFunction(soap, tag, id, (_ns1__GetUserFunction *const*)ptr, "ns1:GetUserFunction");
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameListResponse:
		return soap_out_PointerTo_ns1__GetWorkNameListResponse(soap, tag, id, (_ns1__GetWorkNameListResponse *const*)ptr, "ns1:GetWorkNameListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameList:
		return soap_out_PointerTo_ns1__GetWorkNameList(soap, tag, id, (_ns1__GetWorkNameList *const*)ptr, "ns1:GetWorkNameList");
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoneyResponse:
		return soap_out_PointerTo_ns1__CharegeReturnedMoneyResponse(soap, tag, id, (_ns1__CharegeReturnedMoneyResponse *const*)ptr, "ns1:CharegeReturnedMoneyResponse");
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoney:
		return soap_out_PointerTo_ns1__CharegeReturnedMoney(soap, tag, id, (_ns1__CharegeReturnedMoney *const*)ptr, "ns1:CharegeReturnedMoney");
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfoResponse:
		return soap_out_PointerTo_ns1__GetReturnInfoResponse(soap, tag, id, (_ns1__GetReturnInfoResponse *const*)ptr, "ns1:GetReturnInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfo:
		return soap_out_PointerTo_ns1__GetReturnInfo(soap, tag, id, (_ns1__GetReturnInfo *const*)ptr, "ns1:GetReturnInfo");
	case SOAP_TYPE_PointerTo_ns1__AddAcountPaymentResponse:
		return soap_out_PointerTo_ns1__AddAcountPaymentResponse(soap, tag, id, (_ns1__AddAcountPaymentResponse *const*)ptr, "ns1:AddAcountPaymentResponse");
	case SOAP_TYPE_PointerTo_ns1__AddAcountPayment:
		return soap_out_PointerTo_ns1__AddAcountPayment(soap, tag, id, (_ns1__AddAcountPayment *const*)ptr, "ns1:AddAcountPayment");
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfoResponse:
		return soap_out_PointerTo_ns1__AlterUserInfoResponse(soap, tag, id, (_ns1__AlterUserInfoResponse *const*)ptr, "ns1:AlterUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfo:
		return soap_out_PointerTo_ns1__AlterUserInfo(soap, tag, id, (_ns1__AlterUserInfo *const*)ptr, "ns1:AlterUserInfo");
	case SOAP_TYPE_PointerTo_ns1__AlterPswResponse:
		return soap_out_PointerTo_ns1__AlterPswResponse(soap, tag, id, (_ns1__AlterPswResponse *const*)ptr, "ns1:AlterPswResponse");
	case SOAP_TYPE_PointerTo_ns1__AlterPsw:
		return soap_out_PointerTo_ns1__AlterPsw(soap, tag, id, (_ns1__AlterPsw *const*)ptr, "ns1:AlterPsw");
	case SOAP_TYPE_PointerTo_ns1__RegisterUserResponse:
		return soap_out_PointerTo_ns1__RegisterUserResponse(soap, tag, id, (_ns1__RegisterUserResponse *const*)ptr, "ns1:RegisterUserResponse");
	case SOAP_TYPE_PointerTo_ns1__RegisterUser:
		return soap_out_PointerTo_ns1__RegisterUser(soap, tag, id, (_ns1__RegisterUser *const*)ptr, "ns1:RegisterUser");
	case SOAP_TYPE_PointerTo_ns1__GetUserInfoResponse:
		return soap_out_PointerTo_ns1__GetUserInfoResponse(soap, tag, id, (_ns1__GetUserInfoResponse *const*)ptr, "ns1:GetUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserInfo:
		return soap_out_PointerTo_ns1__GetUserInfo(soap, tag, id, (_ns1__GetUserInfo *const*)ptr, "ns1:GetUserInfo");
	case SOAP_TYPE_PointerTo_ns1__TestLoginResponse:
		return soap_out_PointerTo_ns1__TestLoginResponse(soap, tag, id, (_ns1__TestLoginResponse *const*)ptr, "ns1:TestLoginResponse");
	case SOAP_TYPE_PointerTo_ns1__TestLogin:
		return soap_out_PointerTo_ns1__TestLogin(soap, tag, id, (_ns1__TestLogin *const*)ptr, "ns1:TestLogin");
	case SOAP_TYPE_PointerTo_ns1__loggoutResponse:
		return soap_out_PointerTo_ns1__loggoutResponse(soap, tag, id, (_ns1__loggoutResponse *const*)ptr, "ns1:loggoutResponse");
	case SOAP_TYPE_PointerTo_ns1__loggout:
		return soap_out_PointerTo_ns1__loggout(soap, tag, id, (_ns1__loggout *const*)ptr, "ns1:loggout");
	case SOAP_TYPE_PointerTo_ns1__HelloWorldResponse:
		return soap_out_PointerTo_ns1__HelloWorldResponse(soap, tag, id, (_ns1__HelloWorldResponse *const*)ptr, "ns1:HelloWorldResponse");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_out_PointerTo_ns1__HelloWorld(soap, tag, id, (_ns1__HelloWorld *const*)ptr, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag, id, (_ns1__GetPayPublicTelHistoryByConditionResponse *const*)ptr, "ns1:GetPayPublicTelHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, tag, id, (_ns1__GetPayPublicTelHistoryByCondition *const*)ptr, "ns1:GetPayPublicTelHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayPublicTelByConditionResponse(soap, tag, id, (_ns1__GetPayPublicTelByConditionResponse *const*)ptr, "ns1:GetPayPublicTelByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByCondition:
		return soap_out_PointerTo_ns1__GetPayPublicTelByCondition(soap, tag, id, (_ns1__GetPayPublicTelByCondition *const*)ptr, "ns1:GetPayPublicTelByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayGameHistoryByConditionResponse(soap, tag, id, (_ns1__GetPayGameHistoryByConditionResponse *const*)ptr, "ns1:GetPayGameHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPayGameHistoryByCondition(soap, tag, id, (_ns1__GetPayGameHistoryByCondition *const*)ptr, "ns1:GetPayGameHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayGameByConditionResponse(soap, tag, id, (_ns1__GetPayGameByConditionResponse *const*)ptr, "ns1:GetPayGameByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByCondition:
		return soap_out_PointerTo_ns1__GetPayGameByCondition(soap, tag, id, (_ns1__GetPayGameByCondition *const*)ptr, "ns1:GetPayGameByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(soap, tag, id, (_ns1__GetPayInternetHistoryByConditionResponse *const*)ptr, "ns1:GetPayInternetHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, tag, id, (_ns1__GetPayInternetHistoryByCondition *const*)ptr, "ns1:GetPayInternetHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayInternetByConditionResponse(soap, tag, id, (_ns1__GetPayInternetByConditionResponse *const*)ptr, "ns1:GetPayInternetByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByCondition:
		return soap_out_PointerTo_ns1__GetPayInternetByCondition(soap, tag, id, (_ns1__GetPayInternetByCondition *const*)ptr, "ns1:GetPayInternetByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag, id, (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *const*)ptr, "ns1:GetPaymentOrPaymentHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag, id, (_ns1__GetPaymentOrPaymentHistoryByCondition *const*)ptr, "ns1:GetPaymentOrPaymentHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByConditionResponse:
		return soap_out_PointerTo_ns1__GetTransactionStaticsByConditionResponse(soap, tag, id, (_ns1__GetTransactionStaticsByConditionResponse *const*)ptr, "ns1:GetTransactionStaticsByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByCondition:
		return soap_out_PointerTo_ns1__GetTransactionStaticsByCondition(soap, tag, id, (_ns1__GetTransactionStaticsByCondition *const*)ptr, "ns1:GetTransactionStaticsByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByConditionResponse:
		return soap_out_PointerTo_ns1__GetTransactionByConditionResponse(soap, tag, id, (_ns1__GetTransactionByConditionResponse *const*)ptr, "ns1:GetTransactionByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByCondition:
		return soap_out_PointerTo_ns1__GetTransactionByCondition(soap, tag, id, (_ns1__GetTransactionByCondition *const*)ptr, "ns1:GetTransactionByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItemResponse:
		return soap_out_PointerTo_ns1__GetPaymentItemResponse(soap, tag, id, (_ns1__GetPaymentItemResponse *const*)ptr, "ns1:GetPaymentItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItem:
		return soap_out_PointerTo_ns1__GetPaymentItem(soap, tag, id, (_ns1__GetPaymentItem *const*)ptr, "ns1:GetPaymentItem");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecordResponse:
		return soap_out_PointerTo_ns1__GetPaymentRecordResponse(soap, tag, id, (_ns1__GetPaymentRecordResponse *const*)ptr, "ns1:GetPaymentRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecord:
		return soap_out_PointerTo_ns1__GetPaymentRecord(soap, tag, id, (_ns1__GetPaymentRecord *const*)ptr, "ns1:GetPaymentRecord");
	case SOAP_TYPE_PointerTo_ns1__PayPublicTelResponse:
		return soap_out_PointerTo_ns1__PayPublicTelResponse(soap, tag, id, (_ns1__PayPublicTelResponse *const*)ptr, "ns1:PayPublicTelResponse");
	case SOAP_TYPE_PointerTo_ns1__PayPublicTel:
		return soap_out_PointerTo_ns1__PayPublicTel(soap, tag, id, (_ns1__PayPublicTel *const*)ptr, "ns1:PayPublicTel");
	case SOAP_TYPE_PointerTo_ns1__PayGameResponse:
		return soap_out_PointerTo_ns1__PayGameResponse(soap, tag, id, (_ns1__PayGameResponse *const*)ptr, "ns1:PayGameResponse");
	case SOAP_TYPE_PointerTo_ns1__PayGame:
		return soap_out_PointerTo_ns1__PayGame(soap, tag, id, (_ns1__PayGame *const*)ptr, "ns1:PayGame");
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollbackResponse:
		return soap_out_PointerTo_ns1__RequstInternetRollbackResponse(soap, tag, id, (_ns1__RequstInternetRollbackResponse *const*)ptr, "ns1:RequstInternetRollbackResponse");
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollback:
		return soap_out_PointerTo_ns1__RequstInternetRollback(soap, tag, id, (_ns1__RequstInternetRollback *const*)ptr, "ns1:RequstInternetRollback");
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithListResponse:
		return soap_out_PointerTo_ns1__PayInternetWithListResponse(soap, tag, id, (_ns1__PayInternetWithListResponse *const*)ptr, "ns1:PayInternetWithListResponse");
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithList:
		return soap_out_PointerTo_ns1__PayInternetWithList(soap, tag, id, (_ns1__PayInternetWithList *const*)ptr, "ns1:PayInternetWithList");
	case SOAP_TYPE_PointerTo_ns1__PayInternetResponse:
		return soap_out_PointerTo_ns1__PayInternetResponse(soap, tag, id, (_ns1__PayInternetResponse *const*)ptr, "ns1:PayInternetResponse");
	case SOAP_TYPE_PointerTo_ns1__PayInternet:
		return soap_out_PointerTo_ns1__PayInternet(soap, tag, id, (_ns1__PayInternet *const*)ptr, "ns1:PayInternet");
	case SOAP_TYPE_PointerTo_ns1__RequstRollbackResponse:
		return soap_out_PointerTo_ns1__RequstRollbackResponse(soap, tag, id, (_ns1__RequstRollbackResponse *const*)ptr, "ns1:RequstRollbackResponse");
	case SOAP_TYPE_PointerTo_ns1__RequstRollback:
		return soap_out_PointerTo_ns1__RequstRollback(soap, tag, id, (_ns1__RequstRollback *const*)ptr, "ns1:RequstRollback");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithListResponse:
		return soap_out_PointerTo_ns1__PayMoneyWithListResponse(soap, tag, id, (_ns1__PayMoneyWithListResponse *const*)ptr, "ns1:PayMoneyWithListResponse");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithList:
		return soap_out_PointerTo_ns1__PayMoneyWithList(soap, tag, id, (_ns1__PayMoneyWithList *const*)ptr, "ns1:PayMoneyWithList");
	case SOAP_TYPE_PointerTo_ns1__PayMoneyResponse:
		return soap_out_PointerTo_ns1__PayMoneyResponse(soap, tag, id, (_ns1__PayMoneyResponse *const*)ptr, "ns1:PayMoneyResponse");
	case SOAP_TYPE_PointerTo_ns1__PayMoney:
		return soap_out_PointerTo_ns1__PayMoney(soap, tag, id, (_ns1__PayMoney *const*)ptr, "ns1:PayMoney");
	case SOAP_TYPE_PointerTo_ns1__GetLocationResponse:
		return soap_out_PointerTo_ns1__GetLocationResponse(soap, tag, id, (_ns1__GetLocationResponse *const*)ptr, "ns1:GetLocationResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLocation:
		return soap_out_PointerTo_ns1__GetLocation(soap, tag, id, (_ns1__GetLocation *const*)ptr, "ns1:GetLocation");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag, id, (_ns1__GetStockCardItemAndHistoryByConditionResponse *const*)ptr, "ns1:GetStockCardItemAndHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByCondition:
		return soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, tag, id, (_ns1__GetStockCardItemAndHistoryByCondition *const*)ptr, "ns1:GetStockCardItemAndHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByConditionResponse:
		return soap_out_PointerTo_ns1__GetStockCardItemByConditionResponse(soap, tag, id, (_ns1__GetStockCardItemByConditionResponse *const*)ptr, "ns1:GetStockCardItemByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByCondition:
		return soap_out_PointerTo_ns1__GetStockCardItemByCondition(soap, tag, id, (_ns1__GetStockCardItemByCondition *const*)ptr, "ns1:GetStockCardItemByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardListResponse:
		return soap_out_PointerTo_ns1__GetOtherCardListResponse(soap, tag, id, (_ns1__GetOtherCardListResponse *const*)ptr, "ns1:GetOtherCardListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardList:
		return soap_out_PointerTo_ns1__GetOtherCardList(soap, tag, id, (_ns1__GetOtherCardList *const*)ptr, "ns1:GetOtherCardList");
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag, id, (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *const*)ptr, "ns1:GettSellOtherCardRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition:
		return soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag, id, (_ns1__GettSellOtherCardRecordHistoryByCondition *const*)ptr, "ns1:GettSellOtherCardRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse:
		return soap_out_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(soap, tag, id, (_ns1__GetSellOtherCardRecordByConditionResponse *const*)ptr, "ns1:GetSellOtherCardRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByCondition:
		return soap_out_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, tag, id, (_ns1__GetSellOtherCardRecordByCondition *const*)ptr, "ns1:GetSellOtherCardRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag, id, (_ns1__GettBusinessRecordHistoryByConditionResponse *const*)ptr, "ns1:GettBusinessRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByCondition:
		return soap_out_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, tag, id, (_ns1__GettBusinessRecordHistoryByCondition *const*)ptr, "ns1:GettBusinessRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByConditionResponse:
		return soap_out_PointerTo_ns1__GetBusinessRecordByConditionResponse(soap, tag, id, (_ns1__GetBusinessRecordByConditionResponse *const*)ptr, "ns1:GetBusinessRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByCondition:
		return soap_out_PointerTo_ns1__GetBusinessRecordByCondition(soap, tag, id, (_ns1__GetBusinessRecordByCondition *const*)ptr, "ns1:GetBusinessRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag, id, (_ns1__GetSellCardRecordHistoryByConditionResponse *const*)ptr, "ns1:GetSellCardRecordHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByCondition:
		return soap_out_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, tag, id, (_ns1__GetSellCardRecordHistoryByCondition *const*)ptr, "ns1:GetSellCardRecordHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByConditionResponse:
		return soap_out_PointerTo_ns1__GetSellCardRecordByConditionResponse(soap, tag, id, (_ns1__GetSellCardRecordByConditionResponse *const*)ptr, "ns1:GetSellCardRecordByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByCondition:
		return soap_out_PointerTo_ns1__GetSellCardRecordByCondition(soap, tag, id, (_ns1__GetSellCardRecordByCondition *const*)ptr, "ns1:GetSellCardRecordByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetCardServiceResponse:
		return soap_out_PointerTo_ns1__GetCardServiceResponse(soap, tag, id, (_ns1__GetCardServiceResponse *const*)ptr, "ns1:GetCardServiceResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCardService:
		return soap_out_PointerTo_ns1__GetCardService(soap, tag, id, (_ns1__GetCardService *const*)ptr, "ns1:GetCardService");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag, id, (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *const*)ptr, "ns1:GetPhoneNoItemAndHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag, id, (_ns1__GetPhoneNoItemAndHistoryByCondition *const*)ptr, "ns1:GetPhoneNoItemAndHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByConditionResponse:
		return soap_out_PointerTo_ns1__GetPhoneNoItemByConditionResponse(soap, tag, id, (_ns1__GetPhoneNoItemByConditionResponse *const*)ptr, "ns1:GetPhoneNoItemByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByCondition:
		return soap_out_PointerTo_ns1__GetPhoneNoItemByCondition(soap, tag, id, (_ns1__GetPhoneNoItemByCondition *const*)ptr, "ns1:GetPhoneNoItemByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag, id, (_ns1__GetPayMiniCardHistoryByConditionResponse *const*)ptr, "ns1:GetPayMiniCardHistoryByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByCondition:
		return soap_out_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, tag, id, (_ns1__GetPayMiniCardHistoryByCondition *const*)ptr, "ns1:GetPayMiniCardHistoryByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByConditionResponse:
		return soap_out_PointerTo_ns1__GetPayMiniCardByConditionResponse(soap, tag, id, (_ns1__GetPayMiniCardByConditionResponse *const*)ptr, "ns1:GetPayMiniCardByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByCondition:
		return soap_out_PointerTo_ns1__GetPayMiniCardByCondition(soap, tag, id, (_ns1__GetPayMiniCardByCondition *const*)ptr, "ns1:GetPayMiniCardByCondition");
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecordResponse:
		return soap_out_PointerTo_ns1__GetMiniCardRecordResponse(soap, tag, id, (_ns1__GetMiniCardRecordResponse *const*)ptr, "ns1:GetMiniCardRecordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecord:
		return soap_out_PointerTo_ns1__GetMiniCardRecord(soap, tag, id, (_ns1__GetMiniCardRecord *const*)ptr, "ns1:GetMiniCardRecord");
	case SOAP_TYPE_PointerTo_ns1__SellOhterCardResponse:
		return soap_out_PointerTo_ns1__SellOhterCardResponse(soap, tag, id, (_ns1__SellOhterCardResponse *const*)ptr, "ns1:SellOhterCardResponse");
	case SOAP_TYPE_PointerTo_ns1__SellOhterCard:
		return soap_out_PointerTo_ns1__SellOhterCard(soap, tag, id, (_ns1__SellOhterCard *const*)ptr, "ns1:SellOhterCard");
	case SOAP_TYPE_PointerTo_ns1__SellNoResponse:
		return soap_out_PointerTo_ns1__SellNoResponse(soap, tag, id, (_ns1__SellNoResponse *const*)ptr, "ns1:SellNoResponse");
	case SOAP_TYPE_PointerTo_ns1__SellNo:
		return soap_out_PointerTo_ns1__SellNo(soap, tag, id, (_ns1__SellNo *const*)ptr, "ns1:SellNo");
	case SOAP_TYPE_PointerTo_ns1__SubmitBusinessResponse:
		return soap_out_PointerTo_ns1__SubmitBusinessResponse(soap, tag, id, (_ns1__SubmitBusinessResponse *const*)ptr, "ns1:SubmitBusinessResponse");
	case SOAP_TYPE_PointerTo_ns1__SubmitBusiness:
		return soap_out_PointerTo_ns1__SubmitBusiness(soap, tag, id, (_ns1__SubmitBusiness *const*)ptr, "ns1:SubmitBusiness");
	case SOAP_TYPE_PointerTo_ns1__UnlockNoResponse:
		return soap_out_PointerTo_ns1__UnlockNoResponse(soap, tag, id, (_ns1__UnlockNoResponse *const*)ptr, "ns1:UnlockNoResponse");
	case SOAP_TYPE_PointerTo_ns1__UnlockNo:
		return soap_out_PointerTo_ns1__UnlockNo(soap, tag, id, (_ns1__UnlockNo *const*)ptr, "ns1:UnlockNo");
	case SOAP_TYPE_PointerTo_ns1__LockNoResponse:
		return soap_out_PointerTo_ns1__LockNoResponse(soap, tag, id, (_ns1__LockNoResponse *const*)ptr, "ns1:LockNoResponse");
	case SOAP_TYPE_PointerTo_ns1__LockNo:
		return soap_out_PointerTo_ns1__LockNo(soap, tag, id, (_ns1__LockNo *const*)ptr, "ns1:LockNo");
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSectionResponse:
		return soap_out_PointerTo_ns1__GetMyNoSectionResponse(soap, tag, id, (_ns1__GetMyNoSectionResponse *const*)ptr, "ns1:GetMyNoSectionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSection:
		return soap_out_PointerTo_ns1__GetMyNoSection(soap, tag, id, (_ns1__GetMyNoSection *const*)ptr, "ns1:GetMyNoSection");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByConditionResponse:
		return soap_out_PointerTo_ns1__GetPhoneNoByConditionResponse(soap, tag, id, (_ns1__GetPhoneNoByConditionResponse *const*)ptr, "ns1:GetPhoneNoByConditionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByCondition:
		return soap_out_PointerTo_ns1__GetPhoneNoByCondition(soap, tag, id, (_ns1__GetPhoneNoByCondition *const*)ptr, "ns1:GetPhoneNoByCondition");
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCardResponse:
		return soap_out_PointerTo_ns1__BuyMiniCardResponse(soap, tag, id, (_ns1__BuyMiniCardResponse *const*)ptr, "ns1:BuyMiniCardResponse");
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCard:
		return soap_out_PointerTo_ns1__BuyMiniCard(soap, tag, id, (_ns1__BuyMiniCard *const*)ptr, "ns1:BuyMiniCard");
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfoResponse:
		return soap_out_PointerTo_ns1__queryPhoneNOInfoResponse(soap, tag, id, (_ns1__queryPhoneNOInfoResponse *const*)ptr, "ns1:queryPhoneNOInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfo:
		return soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, tag, id, (_ns1__queryPhoneNOInfo *const*)ptr, "ns1:queryPhoneNOInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfStockCardItem:
		return soap_out_PointerTons1__ArrayOfStockCardItem(soap, tag, id, (ns1__ArrayOfStockCardItem *const*)ptr, "ns1:ArrayOfStockCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfOtherCardItem:
		return soap_out_PointerTons1__ArrayOfOtherCardItem(soap, tag, id, (ns1__ArrayOfOtherCardItem *const*)ptr, "ns1:ArrayOfOtherCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSellOtherCardItem:
		return soap_out_PointerTons1__ArrayOfSellOtherCardItem(soap, tag, id, (ns1__ArrayOfSellOtherCardItem *const*)ptr, "ns1:ArrayOfSellOtherCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfBusinessItem:
		return soap_out_PointerTons1__ArrayOfBusinessItem(soap, tag, id, (ns1__ArrayOfBusinessItem *const*)ptr, "ns1:ArrayOfBusinessItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSellCardItem:
		return soap_out_PointerTons1__ArrayOfSellCardItem(soap, tag, id, (ns1__ArrayOfSellCardItem *const*)ptr, "ns1:ArrayOfSellCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfCardService:
		return soap_out_PointerTons1__ArrayOfCardService(soap, tag, id, (ns1__ArrayOfCardService *const*)ptr, "ns1:ArrayOfCardService");
	case SOAP_TYPE_PointerTons1__ArrayOfPayMiniCardItem:
		return soap_out_PointerTons1__ArrayOfPayMiniCardItem(soap, tag, id, (ns1__ArrayOfPayMiniCardItem *const*)ptr, "ns1:ArrayOfPayMiniCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfMiniCardItem:
		return soap_out_PointerTons1__ArrayOfMiniCardItem(soap, tag, id, (ns1__ArrayOfMiniCardItem *const*)ptr, "ns1:ArrayOfMiniCardItem");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__PhoneNoList:
		return soap_out_PointerTons1__PhoneNoList(soap, tag, id, (ns1__PhoneNoList *const*)ptr, "ns1:PhoneNoList");
	case SOAP_TYPE_PointerTons1__Result:
		return soap_out_PointerTons1__Result(soap, tag, id, (ns1__Result *const*)ptr, "ns1:Result");
	case SOAP_TYPE_PointerTons1__ArrayOfCompanyAccount:
		return soap_out_PointerTons1__ArrayOfCompanyAccount(soap, tag, id, (ns1__ArrayOfCompanyAccount *const*)ptr, "ns1:ArrayOfCompanyAccount");
	case SOAP_TYPE_PointerTons1__CompanyInfo:
		return soap_out_PointerTons1__CompanyInfo(soap, tag, id, (ns1__CompanyInfo *const*)ptr, "ns1:CompanyInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNumberBelong:
		return soap_out_PointerTons1__ArrayOfPhoneNumberBelong(soap, tag, id, (ns1__ArrayOfPhoneNumberBelong *const*)ptr, "ns1:ArrayOfPhoneNumberBelong");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnProportion:
		return soap_out_PointerTons1__ArrayOfReturnProportion(soap, tag, id, (ns1__ArrayOfReturnProportion *const*)ptr, "ns1:ArrayOfReturnProportion");
	case SOAP_TYPE_PointerTons1__Notice:
		return soap_out_PointerTons1__Notice(soap, tag, id, (ns1__Notice *const*)ptr, "ns1:Notice");
	case SOAP_TYPE_PointerTons1__TableStatistics:
		return soap_out_PointerTons1__TableStatistics(soap, tag, id, (ns1__TableStatistics *const*)ptr, "ns1:TableStatistics");
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCORECategory:
		return soap_out_PointerTons1__ArrayOfDIC_USCORECategory(soap, tag, id, (ns1__ArrayOfDIC_USCORECategory *const*)ptr, "ns1:ArrayOfDIC_Category");
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCOREContent:
		return soap_out_PointerTons1__ArrayOfDIC_USCOREContent(soap, tag, id, (ns1__ArrayOfDIC_USCOREContent *const*)ptr, "ns1:ArrayOfDIC_Content");
	case SOAP_TYPE_PointerTons1__ArrayOfAcountPaymentItem:
		return soap_out_PointerTons1__ArrayOfAcountPaymentItem(soap, tag, id, (ns1__ArrayOfAcountPaymentItem *const*)ptr, "ns1:ArrayOfAcountPaymentItem");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnedItem:
		return soap_out_PointerTons1__ArrayOfReturnedItem(soap, tag, id, (ns1__ArrayOfReturnedItem *const*)ptr, "ns1:ArrayOfReturnedItem");
	case SOAP_TYPE_PointerTons1__ArrayOfSystemFunction:
		return soap_out_PointerTons1__ArrayOfSystemFunction(soap, tag, id, (ns1__ArrayOfSystemFunction *const*)ptr, "ns1:ArrayOfSystemFunction");
	case SOAP_TYPE_PointerTons1__ArrayOfWorker:
		return soap_out_PointerTons1__ArrayOfWorker(soap, tag, id, (ns1__ArrayOfWorker *const*)ptr, "ns1:ArrayOfWorker");
	case SOAP_TYPE_PointerTons1__ReturnInfo:
		return soap_out_PointerTons1__ReturnInfo(soap, tag, id, (ns1__ReturnInfo *const*)ptr, "ns1:ReturnInfo");
	case SOAP_TYPE_PointerTons1__User:
		return soap_out_PointerTons1__User(soap, tag, id, (ns1__User *const*)ptr, "ns1:User");
	case SOAP_TYPE_PointerTons1__ArrayOfPayPublicTelItem:
		return soap_out_PointerTons1__ArrayOfPayPublicTelItem(soap, tag, id, (ns1__ArrayOfPayPublicTelItem *const*)ptr, "ns1:ArrayOfPayPublicTelItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayGameItem:
		return soap_out_PointerTons1__ArrayOfPayGameItem(soap, tag, id, (ns1__ArrayOfPayGameItem *const*)ptr, "ns1:ArrayOfPayGameItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayInternetItem:
		return soap_out_PointerTons1__ArrayOfPayInternetItem(soap, tag, id, (ns1__ArrayOfPayInternetItem *const*)ptr, "ns1:ArrayOfPayInternetItem");
	case SOAP_TYPE_PointerTons1__ArrayOfTransStaticsItem:
		return soap_out_PointerTons1__ArrayOfTransStaticsItem(soap, tag, id, (ns1__ArrayOfTransStaticsItem *const*)ptr, "ns1:ArrayOfTransStaticsItem");
	case SOAP_TYPE_PointerTons1__ArrayOfTransaction:
		return soap_out_PointerTons1__ArrayOfTransaction(soap, tag, id, (ns1__ArrayOfTransaction *const*)ptr, "ns1:ArrayOfTransaction");
	case SOAP_TYPE_PointerTons1__ArrayOfPaymentItem:
		return soap_out_PointerTons1__ArrayOfPaymentItem(soap, tag, id, (ns1__ArrayOfPaymentItem *const*)ptr, "ns1:ArrayOfPaymentItem");
	case SOAP_TYPE_PointerTons1__PayWithListResult:
		return soap_out_PointerTons1__PayWithListResult(soap, tag, id, (ns1__PayWithListResult *const*)ptr, "ns1:PayWithListResult");
	case SOAP_TYPE_PointerToPointerTons1__StockCardItem:
		return soap_out_PointerToPointerTons1__StockCardItem(soap, tag, id, (ns1__StockCardItem **const*)ptr, "ns1:StockCardItem");
	case SOAP_TYPE_PointerTons1__StockCardItem:
		return soap_out_PointerTons1__StockCardItem(soap, tag, id, (ns1__StockCardItem *const*)ptr, "ns1:StockCardItem");
	case SOAP_TYPE_PointerToPointerTons1__OtherCardItem:
		return soap_out_PointerToPointerTons1__OtherCardItem(soap, tag, id, (ns1__OtherCardItem **const*)ptr, "ns1:OtherCardItem");
	case SOAP_TYPE_PointerTons1__OtherCardItem:
		return soap_out_PointerTons1__OtherCardItem(soap, tag, id, (ns1__OtherCardItem *const*)ptr, "ns1:OtherCardItem");
	case SOAP_TYPE_PointerToPointerTons1__SellOtherCardItem:
		return soap_out_PointerToPointerTons1__SellOtherCardItem(soap, tag, id, (ns1__SellOtherCardItem **const*)ptr, "ns1:SellOtherCardItem");
	case SOAP_TYPE_PointerTons1__SellOtherCardItem:
		return soap_out_PointerTons1__SellOtherCardItem(soap, tag, id, (ns1__SellOtherCardItem *const*)ptr, "ns1:SellOtherCardItem");
	case SOAP_TYPE_PointerToPointerTons1__BusinessItem:
		return soap_out_PointerToPointerTons1__BusinessItem(soap, tag, id, (ns1__BusinessItem **const*)ptr, "ns1:BusinessItem");
	case SOAP_TYPE_PointerTons1__BusinessItem:
		return soap_out_PointerTons1__BusinessItem(soap, tag, id, (ns1__BusinessItem *const*)ptr, "ns1:BusinessItem");
	case SOAP_TYPE_PointerToPointerTons1__SellCardItem:
		return soap_out_PointerToPointerTons1__SellCardItem(soap, tag, id, (ns1__SellCardItem **const*)ptr, "ns1:SellCardItem");
	case SOAP_TYPE_PointerTons1__SellCardItem:
		return soap_out_PointerTons1__SellCardItem(soap, tag, id, (ns1__SellCardItem *const*)ptr, "ns1:SellCardItem");
	case SOAP_TYPE_PointerToPointerTons1__CardService:
		return soap_out_PointerToPointerTons1__CardService(soap, tag, id, (ns1__CardService **const*)ptr, "ns1:CardService");
	case SOAP_TYPE_PointerTons1__CardService:
		return soap_out_PointerTons1__CardService(soap, tag, id, (ns1__CardService *const*)ptr, "ns1:CardService");
	case SOAP_TYPE_PointerToPointerTons1__PayMiniCardItem:
		return soap_out_PointerToPointerTons1__PayMiniCardItem(soap, tag, id, (ns1__PayMiniCardItem **const*)ptr, "ns1:PayMiniCardItem");
	case SOAP_TYPE_PointerTons1__PayMiniCardItem:
		return soap_out_PointerTons1__PayMiniCardItem(soap, tag, id, (ns1__PayMiniCardItem *const*)ptr, "ns1:PayMiniCardItem");
	case SOAP_TYPE_PointerToPointerTons1__MiniCardItem:
		return soap_out_PointerToPointerTons1__MiniCardItem(soap, tag, id, (ns1__MiniCardItem **const*)ptr, "ns1:MiniCardItem");
	case SOAP_TYPE_PointerTons1__MiniCardItem:
		return soap_out_PointerTons1__MiniCardItem(soap, tag, id, (ns1__MiniCardItem *const*)ptr, "ns1:MiniCardItem");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__PhoneNoItem:
		return soap_out_PointerToPointerTons1__PhoneNoItem(soap, tag, id, (ns1__PhoneNoItem **const*)ptr, "ns1:PhoneNoItem");
	case SOAP_TYPE_PointerTons1__PhoneNoItem:
		return soap_out_PointerTons1__PhoneNoItem(soap, tag, id, (ns1__PhoneNoItem *const*)ptr, "ns1:PhoneNoItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNoItem:
		return soap_out_PointerTons1__ArrayOfPhoneNoItem(soap, tag, id, (ns1__ArrayOfPhoneNoItem *const*)ptr, "ns1:ArrayOfPhoneNoItem");
	case SOAP_TYPE_PointerToPointerTons1__CompanyAccount:
		return soap_out_PointerToPointerTons1__CompanyAccount(soap, tag, id, (ns1__CompanyAccount **const*)ptr, "ns1:CompanyAccount");
	case SOAP_TYPE_PointerTons1__CompanyAccount:
		return soap_out_PointerTons1__CompanyAccount(soap, tag, id, (ns1__CompanyAccount *const*)ptr, "ns1:CompanyAccount");
	case SOAP_TYPE_PointerToPointerTons1__PhoneNumberBelong:
		return soap_out_PointerToPointerTons1__PhoneNumberBelong(soap, tag, id, (ns1__PhoneNumberBelong **const*)ptr, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_PointerTons1__PhoneNumberBelong:
		return soap_out_PointerTons1__PhoneNumberBelong(soap, tag, id, (ns1__PhoneNumberBelong *const*)ptr, "ns1:PhoneNumberBelong");
	case SOAP_TYPE_PointerToPointerTons1__ReturnProportion:
		return soap_out_PointerToPointerTons1__ReturnProportion(soap, tag, id, (ns1__ReturnProportion **const*)ptr, "ns1:ReturnProportion");
	case SOAP_TYPE_PointerTons1__ReturnProportion:
		return soap_out_PointerTons1__ReturnProportion(soap, tag, id, (ns1__ReturnProportion *const*)ptr, "ns1:ReturnProportion");
	case SOAP_TYPE_PointerToPointerTons1__NoticeItem:
		return soap_out_PointerToPointerTons1__NoticeItem(soap, tag, id, (ns1__NoticeItem **const*)ptr, "ns1:NoticeItem");
	case SOAP_TYPE_PointerTons1__NoticeItem:
		return soap_out_PointerTons1__NoticeItem(soap, tag, id, (ns1__NoticeItem *const*)ptr, "ns1:NoticeItem");
	case SOAP_TYPE_PointerTons1__ArrayOfNoticeItem:
		return soap_out_PointerTons1__ArrayOfNoticeItem(soap, tag, id, (ns1__ArrayOfNoticeItem *const*)ptr, "ns1:ArrayOfNoticeItem");
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCORECategory:
		return soap_out_PointerToPointerTons1__DIC_USCORECategory(soap, tag, id, (ns1__DIC_USCORECategory **const*)ptr, "ns1:DIC_Category");
	case SOAP_TYPE_PointerTons1__DIC_USCORECategory:
		return soap_out_PointerTons1__DIC_USCORECategory(soap, tag, id, (ns1__DIC_USCORECategory *const*)ptr, "ns1:DIC_Category");
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCOREContent:
		return soap_out_PointerToPointerTons1__DIC_USCOREContent(soap, tag, id, (ns1__DIC_USCOREContent **const*)ptr, "ns1:DIC_Content");
	case SOAP_TYPE_PointerTons1__DIC_USCOREContent:
		return soap_out_PointerTons1__DIC_USCOREContent(soap, tag, id, (ns1__DIC_USCOREContent *const*)ptr, "ns1:DIC_Content");
	case SOAP_TYPE_PointerToPointerTons1__AcountPaymentItem:
		return soap_out_PointerToPointerTons1__AcountPaymentItem(soap, tag, id, (ns1__AcountPaymentItem **const*)ptr, "ns1:AcountPaymentItem");
	case SOAP_TYPE_PointerTons1__AcountPaymentItem:
		return soap_out_PointerTons1__AcountPaymentItem(soap, tag, id, (ns1__AcountPaymentItem *const*)ptr, "ns1:AcountPaymentItem");
	case SOAP_TYPE_PointerToPointerTons1__ReturnedItem:
		return soap_out_PointerToPointerTons1__ReturnedItem(soap, tag, id, (ns1__ReturnedItem **const*)ptr, "ns1:ReturnedItem");
	case SOAP_TYPE_PointerTons1__ReturnedItem:
		return soap_out_PointerTons1__ReturnedItem(soap, tag, id, (ns1__ReturnedItem *const*)ptr, "ns1:ReturnedItem");
	case SOAP_TYPE_PointerToPointerTons1__SystemFunction:
		return soap_out_PointerToPointerTons1__SystemFunction(soap, tag, id, (ns1__SystemFunction **const*)ptr, "ns1:SystemFunction");
	case SOAP_TYPE_PointerTons1__SystemFunction:
		return soap_out_PointerTons1__SystemFunction(soap, tag, id, (ns1__SystemFunction *const*)ptr, "ns1:SystemFunction");
	case SOAP_TYPE_PointerToPointerTons1__Worker:
		return soap_out_PointerToPointerTons1__Worker(soap, tag, id, (ns1__Worker **const*)ptr, "ns1:Worker");
	case SOAP_TYPE_PointerTons1__Worker:
		return soap_out_PointerTons1__Worker(soap, tag, id, (ns1__Worker *const*)ptr, "ns1:Worker");
	case SOAP_TYPE_PointerToPointerTons1__ReturnInfoItem:
		return soap_out_PointerToPointerTons1__ReturnInfoItem(soap, tag, id, (ns1__ReturnInfoItem **const*)ptr, "ns1:ReturnInfoItem");
	case SOAP_TYPE_PointerTons1__ReturnInfoItem:
		return soap_out_PointerTons1__ReturnInfoItem(soap, tag, id, (ns1__ReturnInfoItem *const*)ptr, "ns1:ReturnInfoItem");
	case SOAP_TYPE_PointerTons1__ArrayOfReturnInfoItem:
		return soap_out_PointerTons1__ArrayOfReturnInfoItem(soap, tag, id, (ns1__ArrayOfReturnInfoItem *const*)ptr, "ns1:ArrayOfReturnInfoItem");
	case SOAP_TYPE_PointerToPointerTons1__PayPublicTelItem:
		return soap_out_PointerToPointerTons1__PayPublicTelItem(soap, tag, id, (ns1__PayPublicTelItem **const*)ptr, "ns1:PayPublicTelItem");
	case SOAP_TYPE_PointerTons1__PayPublicTelItem:
		return soap_out_PointerTons1__PayPublicTelItem(soap, tag, id, (ns1__PayPublicTelItem *const*)ptr, "ns1:PayPublicTelItem");
	case SOAP_TYPE_PointerToPointerTons1__PayGameItem:
		return soap_out_PointerToPointerTons1__PayGameItem(soap, tag, id, (ns1__PayGameItem **const*)ptr, "ns1:PayGameItem");
	case SOAP_TYPE_PointerTons1__PayGameItem:
		return soap_out_PointerTons1__PayGameItem(soap, tag, id, (ns1__PayGameItem *const*)ptr, "ns1:PayGameItem");
	case SOAP_TYPE_PointerToPointerTons1__PayInternetItem:
		return soap_out_PointerToPointerTons1__PayInternetItem(soap, tag, id, (ns1__PayInternetItem **const*)ptr, "ns1:PayInternetItem");
	case SOAP_TYPE_PointerTons1__PayInternetItem:
		return soap_out_PointerTons1__PayInternetItem(soap, tag, id, (ns1__PayInternetItem *const*)ptr, "ns1:PayInternetItem");
	case SOAP_TYPE_PointerToPointerTons1__TransStaticsItem:
		return soap_out_PointerToPointerTons1__TransStaticsItem(soap, tag, id, (ns1__TransStaticsItem **const*)ptr, "ns1:TransStaticsItem");
	case SOAP_TYPE_PointerTons1__TransStaticsItem:
		return soap_out_PointerTons1__TransStaticsItem(soap, tag, id, (ns1__TransStaticsItem *const*)ptr, "ns1:TransStaticsItem");
	case SOAP_TYPE_PointerToPointerTons1__Transaction:
		return soap_out_PointerToPointerTons1__Transaction(soap, tag, id, (ns1__Transaction **const*)ptr, "ns1:Transaction");
	case SOAP_TYPE_PointerTons1__Transaction:
		return soap_out_PointerTons1__Transaction(soap, tag, id, (ns1__Transaction *const*)ptr, "ns1:Transaction");
	case SOAP_TYPE_PointerToPointerTons1__PaymentItem:
		return soap_out_PointerToPointerTons1__PaymentItem(soap, tag, id, (ns1__PaymentItem **const*)ptr, "ns1:PaymentItem");
	case SOAP_TYPE_PointerTons1__PaymentItem:
		return soap_out_PointerTons1__PaymentItem(soap, tag, id, (ns1__PaymentItem *const*)ptr, "ns1:PaymentItem");
	case SOAP_TYPE_PointerToPointerTons1__PayWithListItem:
		return soap_out_PointerToPointerTons1__PayWithListItem(soap, tag, id, (ns1__PayWithListItem **const*)ptr, "ns1:PayWithListItem");
	case SOAP_TYPE_PointerTons1__PayWithListItem:
		return soap_out_PointerTons1__PayWithListItem(soap, tag, id, (ns1__PayWithListItem *const*)ptr, "ns1:PayWithListItem");
	case SOAP_TYPE_PointerTons1__ArrayOfPayWithListItem:
		return soap_out_PointerTons1__ArrayOfPayWithListItem(soap, tag, id, (ns1__ArrayOfPayWithListItem *const*)ptr, "ns1:ArrayOfPayWithListItem");
	case SOAP_TYPE_ns2__guid:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:guid");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse:
		((_ns1__GetStockCardItemAndHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition:
		((_ns1__GetStockCardItemAndHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemByConditionResponse:
		((_ns1__GetStockCardItemByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemByCondition:
		((_ns1__GetStockCardItemByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherCardListResponse:
		((_ns1__GetOtherCardListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherCardList:
		((_ns1__GetOtherCardList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		((_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition:
		((_ns1__GettSellOtherCardRecordHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse:
		((_ns1__GetSellOtherCardRecordByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition:
		((_ns1__GetSellOtherCardRecordByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse:
		((_ns1__GettBusinessRecordHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition:
		((_ns1__GettBusinessRecordHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse:
		((_ns1__GetBusinessRecordByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBusinessRecordByCondition:
		((_ns1__GetBusinessRecordByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse:
		((_ns1__GetSellCardRecordHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition:
		((_ns1__GetSellCardRecordHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse:
		((_ns1__GetSellCardRecordByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordByCondition:
		((_ns1__GetSellCardRecordByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCardServiceResponse:
		((_ns1__GetCardServiceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCardService:
		((_ns1__GetCardService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		((_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition:
		((_ns1__GetPhoneNoItemAndHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse:
		((_ns1__GetPhoneNoItemByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemByCondition:
		((_ns1__GetPhoneNoItemByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse:
		((_ns1__GetPayMiniCardHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition:
		((_ns1__GetPayMiniCardHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse:
		((_ns1__GetPayMiniCardByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardByCondition:
		((_ns1__GetPayMiniCardByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMiniCardRecordResponse:
		((_ns1__GetMiniCardRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMiniCardRecord:
		((_ns1__GetMiniCardRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SellOhterCardResponse:
		((_ns1__SellOhterCardResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SellOhterCard:
		((_ns1__SellOhterCard *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SellNoResponse:
		((_ns1__SellNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SellNo:
		((_ns1__SellNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubmitBusinessResponse:
		((_ns1__SubmitBusinessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubmitBusiness:
		((_ns1__SubmitBusiness *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnlockNoResponse:
		((_ns1__UnlockNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnlockNo:
		((_ns1__UnlockNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LockNoResponse:
		((_ns1__LockNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LockNo:
		((_ns1__LockNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMyNoSectionResponse:
		((_ns1__GetMyNoSectionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMyNoSection:
		((_ns1__GetMyNoSection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoByConditionResponse:
		((_ns1__GetPhoneNoByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoByCondition:
		((_ns1__GetPhoneNoByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BuyMiniCardResponse:
		((_ns1__BuyMiniCardResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BuyMiniCard:
		((_ns1__BuyMiniCard *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__queryPhoneNOInfoResponse:
		((_ns1__queryPhoneNOInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__queryPhoneNOInfo:
		((_ns1__queryPhoneNOInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClientVersionResponse:
		((_ns1__GetClientVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClientVersion:
		((_ns1__GetClientVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteCompanyAccountResponse:
		((_ns1__DeleteCompanyAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteCompanyAccount:
		((_ns1__DeleteCompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyAccountResponse:
		((_ns1__UpdateCompanyAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyAccount:
		((_ns1__UpdateCompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddCompanyAccountResponse:
		((_ns1__AddCompanyAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddCompanyAccount:
		((_ns1__AddCompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCompanyAccountResponse:
		((_ns1__GetCompanyAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCompanyAccount:
		((_ns1__GetCompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyInfoResponse:
		((_ns1__UpdateCompanyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyInfo:
		((_ns1__UpdateCompanyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCompanyInfoResponse:
		((_ns1__GetCompanyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCompanyInfo:
		((_ns1__GetCompanyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse:
		((_ns1__DeletePhoneNumberBelongResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeletePhoneNumberBelong:
		((_ns1__DeletePhoneNumberBelong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPhoneNumberBelongResponse:
		((_ns1__AddPhoneNumberBelongResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPhoneNumberBelong:
		((_ns1__AddPhoneNumberBelong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse:
		((_ns1__UpdatePhoneNumberBelongResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelong:
		((_ns1__UpdatePhoneNumberBelong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse:
		((_ns1__GetPhoneNumberBelongByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition:
		((_ns1__GetPhoneNumberBelongByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeletetReturnProportionResponse:
		((_ns1__DeletetReturnProportionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeletetReturnProportion:
		((_ns1__DeletetReturnProportion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatetReturnProportionResponse:
		((_ns1__UpdatetReturnProportionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatetReturnProportion:
		((_ns1__UpdatetReturnProportion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddtReturnProportionResponse:
		((_ns1__AddtReturnProportionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddtReturnProportion:
		((_ns1__AddtReturnProportion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnProportionRecordResponse:
		((_ns1__GetReturnProportionRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnProportionRecord:
		((_ns1__GetReturnProportionRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InserNoticeToSomeOneResponse:
		((_ns1__InserNoticeToSomeOneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InserNoticeToSomeOne:
		((_ns1__InserNoticeToSomeOne *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteNoticeItemResponse:
		((_ns1__DeleteNoticeItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteNoticeItem:
		((_ns1__DeleteNoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateNoticeItemResponse:
		((_ns1__UpdateNoticeItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateNoticeItem:
		((_ns1__UpdateNoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse:
		((_ns1__AddNoticeItemToSomeoneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemToSomeone:
		((_ns1__AddNoticeItemToSomeone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemResponse:
		((_ns1__AddNoticeItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddNoticeItem:
		((_ns1__AddNoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlertNoticeListResponse:
		((_ns1__GetAlertNoticeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlertNoticeList:
		((_ns1__GetAlertNoticeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeItemResponse:
		((_ns1__GetNoticeItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeItem:
		((_ns1__GetNoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeListByConditionResponse:
		((_ns1__GetNoticeListByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeListByCondition:
		((_ns1__GetNoticeListByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeListResponse:
		((_ns1__GetNoticeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetNoticeList:
		((_ns1__GetNoticeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTableStatisticsResponse:
		((_ns1__GetTableStatisticsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTableStatistics:
		((_ns1__GetTableStatistics *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateFunctionRightResponse:
		((_ns1__UpdateFunctionRightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateFunctionRight:
		((_ns1__UpdateFunctionRight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateUserFunctionListResponse:
		((_ns1__UpdateUserFunctionListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateUserFunctionList:
		((_ns1__UpdateUserFunctionList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFunctionListResponse:
		((_ns1__GetFunctionListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFunctionList:
		((_ns1__GetFunctionList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse:
		((_ns1__UpdateDicContentByCategoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentByCategory:
		((_ns1__UpdateDicContentByCategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteDicContentResponse:
		((_ns1__DeleteDicContentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteDicContent:
		((_ns1__DeleteDicContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentResponse:
		((_ns1__UpdateDicContentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDicContent:
		((_ns1__UpdateDicContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertDicContentResponse:
		((_ns1__InsertDicContentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertDicContent:
		((_ns1__InsertDicContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCategoryResponse:
		((_ns1__GetAllCategoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCategory:
		((_ns1__GetAllCategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDicContentByConditionResponse:
		((_ns1__GetDicContentByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDicContentByCondition:
		((_ns1__GetDicContentByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAcountPaymentRecordResponse:
		((_ns1__GetAcountPaymentRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAcountPaymentRecord:
		((_ns1__GetAcountPaymentRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordDealResponse:
		((_ns1__GetReturnRecordDealResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordDeal:
		((_ns1__GetReturnRecordDeal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordResponse:
		((_ns1__GetReturnRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnRecord:
		((_ns1__GetReturnRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserFunctionResponse:
		((_ns1__GetUserFunctionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserFunction:
		((_ns1__GetUserFunction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWorkNameListResponse:
		((_ns1__GetWorkNameListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWorkNameList:
		((_ns1__GetWorkNameList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CharegeReturnedMoneyResponse:
		((_ns1__CharegeReturnedMoneyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CharegeReturnedMoney:
		((_ns1__CharegeReturnedMoney *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnInfoResponse:
		((_ns1__GetReturnInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReturnInfo:
		((_ns1__GetReturnInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddAcountPaymentResponse:
		((_ns1__AddAcountPaymentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddAcountPayment:
		((_ns1__AddAcountPayment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterUserInfoResponse:
		((_ns1__AlterUserInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterUserInfo:
		((_ns1__AlterUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterPswResponse:
		((_ns1__AlterPswResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterPsw:
		((_ns1__AlterPsw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RegisterUserResponse:
		((_ns1__RegisterUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RegisterUser:
		((_ns1__RegisterUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserInfoResponse:
		((_ns1__GetUserInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserInfo:
		((_ns1__GetUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TestLoginResponse:
		((_ns1__TestLoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TestLogin:
		((_ns1__TestLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loggoutResponse:
		((_ns1__loggoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loggout:
		((_ns1__loggout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		((_ns1__HelloWorldResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		((_ns1__HelloWorld *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse:
		((_ns1__GetPayPublicTelHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition:
		((_ns1__GetPayPublicTelHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse:
		((_ns1__GetPayPublicTelByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelByCondition:
		((_ns1__GetPayPublicTelByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse:
		((_ns1__GetPayGameHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayGameHistoryByCondition:
		((_ns1__GetPayGameHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayGameByConditionResponse:
		((_ns1__GetPayGameByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayGameByCondition:
		((_ns1__GetPayGameByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse:
		((_ns1__GetPayInternetHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayInternetHistoryByCondition:
		((_ns1__GetPayInternetHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayInternetByConditionResponse:
		((_ns1__GetPayInternetByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPayInternetByCondition:
		((_ns1__GetPayInternetByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		((_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition:
		((_ns1__GetPaymentOrPaymentHistoryByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse:
		((_ns1__GetTransactionStaticsByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTransactionStaticsByCondition:
		((_ns1__GetTransactionStaticsByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTransactionByConditionResponse:
		((_ns1__GetTransactionByConditionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTransactionByCondition:
		((_ns1__GetTransactionByCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentItemResponse:
		((_ns1__GetPaymentItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentItem:
		((_ns1__GetPaymentItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentRecordResponse:
		((_ns1__GetPaymentRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPaymentRecord:
		((_ns1__GetPaymentRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayPublicTelResponse:
		((_ns1__PayPublicTelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayPublicTel:
		((_ns1__PayPublicTel *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayGameResponse:
		((_ns1__PayGameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayGame:
		((_ns1__PayGame *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RequstInternetRollbackResponse:
		((_ns1__RequstInternetRollbackResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RequstInternetRollback:
		((_ns1__RequstInternetRollback *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayInternetWithListResponse:
		((_ns1__PayInternetWithListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayInternetWithList:
		((_ns1__PayInternetWithList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayInternetResponse:
		((_ns1__PayInternetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayInternet:
		((_ns1__PayInternet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RequstRollbackResponse:
		((_ns1__RequstRollbackResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RequstRollback:
		((_ns1__RequstRollback *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayMoneyWithListResponse:
		((_ns1__PayMoneyWithListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayMoneyWithList:
		((_ns1__PayMoneyWithList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayMoneyResponse:
		((_ns1__PayMoneyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PayMoney:
		((_ns1__PayMoney *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLocationResponse:
		((_ns1__GetLocationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLocation:
		((_ns1__GetLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StockCardItem:
		((ns1__StockCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfStockCardItem:
		((ns1__ArrayOfStockCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OtherCardItem:
		((ns1__OtherCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfOtherCardItem:
		((ns1__ArrayOfOtherCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellOtherCardItem:
		((ns1__SellOtherCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSellOtherCardItem:
		((ns1__ArrayOfSellOtherCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BusinessItem:
		((ns1__BusinessItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfBusinessItem:
		((ns1__ArrayOfBusinessItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SellCardItem:
		((ns1__SellCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSellCardItem:
		((ns1__ArrayOfSellCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CardService:
		((ns1__CardService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfCardService:
		((ns1__ArrayOfCardService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayMiniCardItem:
		((ns1__PayMiniCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayMiniCardItem:
		((ns1__ArrayOfPayMiniCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MiniCardItem:
		((ns1__MiniCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfMiniCardItem:
		((ns1__ArrayOfMiniCardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PhoneNoItem:
		((ns1__PhoneNoItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPhoneNoItem:
		((ns1__ArrayOfPhoneNoItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PhoneNoList:
		((ns1__PhoneNoList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Result:
		((ns1__Result *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CompanyAccount:
		((ns1__CompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfCompanyAccount:
		((ns1__ArrayOfCompanyAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CompanyInfo:
		((ns1__CompanyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PhoneNumberBelong:
		((ns1__PhoneNumberBelong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong:
		((ns1__ArrayOfPhoneNumberBelong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnProportion:
		((ns1__ReturnProportion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnProportion:
		((ns1__ArrayOfReturnProportion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NoticeItem:
		((ns1__NoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfNoticeItem:
		((ns1__ArrayOfNoticeItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Notice:
		((ns1__Notice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TableStatistics:
		((ns1__TableStatistics *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DIC_USCORECategory:
		((ns1__DIC_USCORECategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory:
		((ns1__ArrayOfDIC_USCORECategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DIC_USCOREContent:
		((ns1__DIC_USCOREContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent:
		((ns1__ArrayOfDIC_USCOREContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AcountPaymentItem:
		((ns1__AcountPaymentItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAcountPaymentItem:
		((ns1__ArrayOfAcountPaymentItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnedItem:
		((ns1__ReturnedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnedItem:
		((ns1__ArrayOfReturnedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SystemFunction:
		((ns1__SystemFunction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSystemFunction:
		((ns1__ArrayOfSystemFunction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Worker:
		((ns1__Worker *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfWorker:
		((ns1__ArrayOfWorker *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnInfoItem:
		((ns1__ReturnInfoItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnInfoItem:
		((ns1__ArrayOfReturnInfoItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnInfo:
		((ns1__ReturnInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__User:
		((ns1__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayPublicTelItem:
		((ns1__PayPublicTelItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayPublicTelItem:
		((ns1__ArrayOfPayPublicTelItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayGameItem:
		((ns1__PayGameItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayGameItem:
		((ns1__ArrayOfPayGameItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayInternetItem:
		((ns1__PayInternetItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayInternetItem:
		((ns1__ArrayOfPayInternetItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TransStaticsItem:
		((ns1__TransStaticsItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfTransStaticsItem:
		((ns1__ArrayOfTransStaticsItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Transaction:
		((ns1__Transaction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfTransaction:
		((ns1__ArrayOfTransaction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PaymentItem:
		((ns1__PaymentItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPaymentItem:
		((ns1__ArrayOfPaymentItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayWithListItem:
		((ns1__PayWithListItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayWithListItem:
		((ns1__ArrayOfPayWithListItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PayWithListResult:
		((ns1__PayWithListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns9__queryPhoneNOInfo:
		soap_serialize___ns9__queryPhoneNOInfo(soap, (const struct __ns9__queryPhoneNOInfo *)ptr);
		break;
	case SOAP_TYPE___ns8__GetClientVersion:
		soap_serialize___ns8__GetClientVersion(soap, (const struct __ns8__GetClientVersion *)ptr);
		break;
	case SOAP_TYPE___ns8__DeleteCompanyAccount:
		soap_serialize___ns8__DeleteCompanyAccount(soap, (const struct __ns8__DeleteCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateCompanyAccount:
		soap_serialize___ns8__UpdateCompanyAccount(soap, (const struct __ns8__UpdateCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns8__AddCompanyAccount:
		soap_serialize___ns8__AddCompanyAccount(soap, (const struct __ns8__AddCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns8__GetCompanyAccount:
		soap_serialize___ns8__GetCompanyAccount(soap, (const struct __ns8__GetCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateCompanyInfo:
		soap_serialize___ns8__UpdateCompanyInfo(soap, (const struct __ns8__UpdateCompanyInfo *)ptr);
		break;
	case SOAP_TYPE___ns8__GetCompanyInfo:
		soap_serialize___ns8__GetCompanyInfo(soap, (const struct __ns8__GetCompanyInfo *)ptr);
		break;
	case SOAP_TYPE___ns8__DeletePhoneNumberBelong:
		soap_serialize___ns8__DeletePhoneNumberBelong(soap, (const struct __ns8__DeletePhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns8__AddPhoneNumberBelong:
		soap_serialize___ns8__AddPhoneNumberBelong(soap, (const struct __ns8__AddPhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdatePhoneNumberBelong:
		soap_serialize___ns8__UpdatePhoneNumberBelong(soap, (const struct __ns8__UpdatePhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns8__GetPhoneNumberBelongByCondition:
		soap_serialize___ns8__GetPhoneNumberBelongByCondition(soap, (const struct __ns8__GetPhoneNumberBelongByCondition *)ptr);
		break;
	case SOAP_TYPE___ns8__DeletetReturnProportion:
		soap_serialize___ns8__DeletetReturnProportion(soap, (const struct __ns8__DeletetReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdatetReturnProportion:
		soap_serialize___ns8__UpdatetReturnProportion(soap, (const struct __ns8__UpdatetReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns8__AddtReturnProportion:
		soap_serialize___ns8__AddtReturnProportion(soap, (const struct __ns8__AddtReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns8__GetReturnProportionRecord:
		soap_serialize___ns8__GetReturnProportionRecord(soap, (const struct __ns8__GetReturnProportionRecord *)ptr);
		break;
	case SOAP_TYPE___ns8__InserNoticeToSomeOne:
		soap_serialize___ns8__InserNoticeToSomeOne(soap, (const struct __ns8__InserNoticeToSomeOne *)ptr);
		break;
	case SOAP_TYPE___ns8__DeleteNoticeItem:
		soap_serialize___ns8__DeleteNoticeItem(soap, (const struct __ns8__DeleteNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateNoticeItem:
		soap_serialize___ns8__UpdateNoticeItem(soap, (const struct __ns8__UpdateNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns8__AddNoticeItemToSomeone:
		soap_serialize___ns8__AddNoticeItemToSomeone(soap, (const struct __ns8__AddNoticeItemToSomeone *)ptr);
		break;
	case SOAP_TYPE___ns8__AddNoticeItem:
		soap_serialize___ns8__AddNoticeItem(soap, (const struct __ns8__AddNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns8__GetAlertNoticeList:
		soap_serialize___ns8__GetAlertNoticeList(soap, (const struct __ns8__GetAlertNoticeList *)ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeItem:
		soap_serialize___ns8__GetNoticeItem(soap, (const struct __ns8__GetNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeListByCondition:
		soap_serialize___ns8__GetNoticeListByCondition(soap, (const struct __ns8__GetNoticeListByCondition *)ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeList:
		soap_serialize___ns8__GetNoticeList(soap, (const struct __ns8__GetNoticeList *)ptr);
		break;
	case SOAP_TYPE___ns8__GetTableStatistics:
		soap_serialize___ns8__GetTableStatistics(soap, (const struct __ns8__GetTableStatistics *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateFunctionRight:
		soap_serialize___ns8__UpdateFunctionRight(soap, (const struct __ns8__UpdateFunctionRight *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateUserFunctionList:
		soap_serialize___ns8__UpdateUserFunctionList(soap, (const struct __ns8__UpdateUserFunctionList *)ptr);
		break;
	case SOAP_TYPE___ns8__GetFunctionList:
		soap_serialize___ns8__GetFunctionList(soap, (const struct __ns8__GetFunctionList *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateDicContentByCategory:
		soap_serialize___ns8__UpdateDicContentByCategory(soap, (const struct __ns8__UpdateDicContentByCategory *)ptr);
		break;
	case SOAP_TYPE___ns8__DeleteDicContent:
		soap_serialize___ns8__DeleteDicContent(soap, (const struct __ns8__DeleteDicContent *)ptr);
		break;
	case SOAP_TYPE___ns8__UpdateDicContent:
		soap_serialize___ns8__UpdateDicContent(soap, (const struct __ns8__UpdateDicContent *)ptr);
		break;
	case SOAP_TYPE___ns8__InsertDicContent:
		soap_serialize___ns8__InsertDicContent(soap, (const struct __ns8__InsertDicContent *)ptr);
		break;
	case SOAP_TYPE___ns8__GetAllCategory:
		soap_serialize___ns8__GetAllCategory(soap, (const struct __ns8__GetAllCategory *)ptr);
		break;
	case SOAP_TYPE___ns8__GetDicContentByCondition:
		soap_serialize___ns8__GetDicContentByCondition(soap, (const struct __ns8__GetDicContentByCondition *)ptr);
		break;
	case SOAP_TYPE___ns7__GetClientVersion:
		soap_serialize___ns7__GetClientVersion(soap, (const struct __ns7__GetClientVersion *)ptr);
		break;
	case SOAP_TYPE___ns7__DeleteCompanyAccount:
		soap_serialize___ns7__DeleteCompanyAccount(soap, (const struct __ns7__DeleteCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateCompanyAccount:
		soap_serialize___ns7__UpdateCompanyAccount(soap, (const struct __ns7__UpdateCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__AddCompanyAccount:
		soap_serialize___ns7__AddCompanyAccount(soap, (const struct __ns7__AddCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__GetCompanyAccount:
		soap_serialize___ns7__GetCompanyAccount(soap, (const struct __ns7__GetCompanyAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateCompanyInfo:
		soap_serialize___ns7__UpdateCompanyInfo(soap, (const struct __ns7__UpdateCompanyInfo *)ptr);
		break;
	case SOAP_TYPE___ns7__GetCompanyInfo:
		soap_serialize___ns7__GetCompanyInfo(soap, (const struct __ns7__GetCompanyInfo *)ptr);
		break;
	case SOAP_TYPE___ns7__DeletePhoneNumberBelong:
		soap_serialize___ns7__DeletePhoneNumberBelong(soap, (const struct __ns7__DeletePhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns7__AddPhoneNumberBelong:
		soap_serialize___ns7__AddPhoneNumberBelong(soap, (const struct __ns7__AddPhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdatePhoneNumberBelong:
		soap_serialize___ns7__UpdatePhoneNumberBelong(soap, (const struct __ns7__UpdatePhoneNumberBelong *)ptr);
		break;
	case SOAP_TYPE___ns7__GetPhoneNumberBelongByCondition:
		soap_serialize___ns7__GetPhoneNumberBelongByCondition(soap, (const struct __ns7__GetPhoneNumberBelongByCondition *)ptr);
		break;
	case SOAP_TYPE___ns7__DeletetReturnProportion:
		soap_serialize___ns7__DeletetReturnProportion(soap, (const struct __ns7__DeletetReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdatetReturnProportion:
		soap_serialize___ns7__UpdatetReturnProportion(soap, (const struct __ns7__UpdatetReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns7__AddtReturnProportion:
		soap_serialize___ns7__AddtReturnProportion(soap, (const struct __ns7__AddtReturnProportion *)ptr);
		break;
	case SOAP_TYPE___ns7__GetReturnProportionRecord:
		soap_serialize___ns7__GetReturnProportionRecord(soap, (const struct __ns7__GetReturnProportionRecord *)ptr);
		break;
	case SOAP_TYPE___ns7__InserNoticeToSomeOne:
		soap_serialize___ns7__InserNoticeToSomeOne(soap, (const struct __ns7__InserNoticeToSomeOne *)ptr);
		break;
	case SOAP_TYPE___ns7__DeleteNoticeItem:
		soap_serialize___ns7__DeleteNoticeItem(soap, (const struct __ns7__DeleteNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateNoticeItem:
		soap_serialize___ns7__UpdateNoticeItem(soap, (const struct __ns7__UpdateNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns7__AddNoticeItemToSomeone:
		soap_serialize___ns7__AddNoticeItemToSomeone(soap, (const struct __ns7__AddNoticeItemToSomeone *)ptr);
		break;
	case SOAP_TYPE___ns7__AddNoticeItem:
		soap_serialize___ns7__AddNoticeItem(soap, (const struct __ns7__AddNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns7__GetAlertNoticeList:
		soap_serialize___ns7__GetAlertNoticeList(soap, (const struct __ns7__GetAlertNoticeList *)ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeItem:
		soap_serialize___ns7__GetNoticeItem(soap, (const struct __ns7__GetNoticeItem *)ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeListByCondition:
		soap_serialize___ns7__GetNoticeListByCondition(soap, (const struct __ns7__GetNoticeListByCondition *)ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeList:
		soap_serialize___ns7__GetNoticeList(soap, (const struct __ns7__GetNoticeList *)ptr);
		break;
	case SOAP_TYPE___ns7__GetTableStatistics:
		soap_serialize___ns7__GetTableStatistics(soap, (const struct __ns7__GetTableStatistics *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateFunctionRight:
		soap_serialize___ns7__UpdateFunctionRight(soap, (const struct __ns7__UpdateFunctionRight *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateUserFunctionList:
		soap_serialize___ns7__UpdateUserFunctionList(soap, (const struct __ns7__UpdateUserFunctionList *)ptr);
		break;
	case SOAP_TYPE___ns7__GetFunctionList:
		soap_serialize___ns7__GetFunctionList(soap, (const struct __ns7__GetFunctionList *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateDicContentByCategory:
		soap_serialize___ns7__UpdateDicContentByCategory(soap, (const struct __ns7__UpdateDicContentByCategory *)ptr);
		break;
	case SOAP_TYPE___ns7__DeleteDicContent:
		soap_serialize___ns7__DeleteDicContent(soap, (const struct __ns7__DeleteDicContent *)ptr);
		break;
	case SOAP_TYPE___ns7__UpdateDicContent:
		soap_serialize___ns7__UpdateDicContent(soap, (const struct __ns7__UpdateDicContent *)ptr);
		break;
	case SOAP_TYPE___ns7__InsertDicContent:
		soap_serialize___ns7__InsertDicContent(soap, (const struct __ns7__InsertDicContent *)ptr);
		break;
	case SOAP_TYPE___ns7__GetAllCategory:
		soap_serialize___ns7__GetAllCategory(soap, (const struct __ns7__GetAllCategory *)ptr);
		break;
	case SOAP_TYPE___ns7__GetDicContentByCondition:
		soap_serialize___ns7__GetDicContentByCondition(soap, (const struct __ns7__GetDicContentByCondition *)ptr);
		break;
	case SOAP_TYPE___ns6__GetAcountPaymentRecord:
		soap_serialize___ns6__GetAcountPaymentRecord(soap, (const struct __ns6__GetAcountPaymentRecord *)ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnRecordDeal:
		soap_serialize___ns6__GetReturnRecordDeal(soap, (const struct __ns6__GetReturnRecordDeal *)ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnRecord:
		soap_serialize___ns6__GetReturnRecord(soap, (const struct __ns6__GetReturnRecord *)ptr);
		break;
	case SOAP_TYPE___ns6__GetUserFunction:
		soap_serialize___ns6__GetUserFunction(soap, (const struct __ns6__GetUserFunction *)ptr);
		break;
	case SOAP_TYPE___ns6__GetWorkNameList:
		soap_serialize___ns6__GetWorkNameList(soap, (const struct __ns6__GetWorkNameList *)ptr);
		break;
	case SOAP_TYPE___ns6__CharegeReturnedMoney:
		soap_serialize___ns6__CharegeReturnedMoney(soap, (const struct __ns6__CharegeReturnedMoney *)ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnInfo:
		soap_serialize___ns6__GetReturnInfo(soap, (const struct __ns6__GetReturnInfo *)ptr);
		break;
	case SOAP_TYPE___ns6__AddAcountPayment:
		soap_serialize___ns6__AddAcountPayment(soap, (const struct __ns6__AddAcountPayment *)ptr);
		break;
	case SOAP_TYPE___ns6__AlterUserInfo:
		soap_serialize___ns6__AlterUserInfo(soap, (const struct __ns6__AlterUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns6__AlterPsw:
		soap_serialize___ns6__AlterPsw(soap, (const struct __ns6__AlterPsw *)ptr);
		break;
	case SOAP_TYPE___ns6__RegisterUser:
		soap_serialize___ns6__RegisterUser(soap, (const struct __ns6__RegisterUser *)ptr);
		break;
	case SOAP_TYPE___ns6__GetUserInfo:
		soap_serialize___ns6__GetUserInfo(soap, (const struct __ns6__GetUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns6__TestLogin:
		soap_serialize___ns6__TestLogin(soap, (const struct __ns6__TestLogin *)ptr);
		break;
	case SOAP_TYPE___ns6__loggout:
		soap_serialize___ns6__loggout(soap, (const struct __ns6__loggout *)ptr);
		break;
	case SOAP_TYPE___ns6__HelloWorld:
		soap_serialize___ns6__HelloWorld(soap, (const struct __ns6__HelloWorld *)ptr);
		break;
	case SOAP_TYPE___ns5__GetAcountPaymentRecord:
		soap_serialize___ns5__GetAcountPaymentRecord(soap, (const struct __ns5__GetAcountPaymentRecord *)ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnRecordDeal:
		soap_serialize___ns5__GetReturnRecordDeal(soap, (const struct __ns5__GetReturnRecordDeal *)ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnRecord:
		soap_serialize___ns5__GetReturnRecord(soap, (const struct __ns5__GetReturnRecord *)ptr);
		break;
	case SOAP_TYPE___ns5__GetUserFunction:
		soap_serialize___ns5__GetUserFunction(soap, (const struct __ns5__GetUserFunction *)ptr);
		break;
	case SOAP_TYPE___ns5__GetWorkNameList:
		soap_serialize___ns5__GetWorkNameList(soap, (const struct __ns5__GetWorkNameList *)ptr);
		break;
	case SOAP_TYPE___ns5__CharegeReturnedMoney:
		soap_serialize___ns5__CharegeReturnedMoney(soap, (const struct __ns5__CharegeReturnedMoney *)ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnInfo:
		soap_serialize___ns5__GetReturnInfo(soap, (const struct __ns5__GetReturnInfo *)ptr);
		break;
	case SOAP_TYPE___ns5__AddAcountPayment:
		soap_serialize___ns5__AddAcountPayment(soap, (const struct __ns5__AddAcountPayment *)ptr);
		break;
	case SOAP_TYPE___ns5__AlterUserInfo:
		soap_serialize___ns5__AlterUserInfo(soap, (const struct __ns5__AlterUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns5__AlterPsw:
		soap_serialize___ns5__AlterPsw(soap, (const struct __ns5__AlterPsw *)ptr);
		break;
	case SOAP_TYPE___ns5__RegisterUser:
		soap_serialize___ns5__RegisterUser(soap, (const struct __ns5__RegisterUser *)ptr);
		break;
	case SOAP_TYPE___ns5__GetUserInfo:
		soap_serialize___ns5__GetUserInfo(soap, (const struct __ns5__GetUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns5__TestLogin:
		soap_serialize___ns5__TestLogin(soap, (const struct __ns5__TestLogin *)ptr);
		break;
	case SOAP_TYPE___ns5__loggout:
		soap_serialize___ns5__loggout(soap, (const struct __ns5__loggout *)ptr);
		break;
	case SOAP_TYPE___ns5__HelloWorld:
		soap_serialize___ns5__HelloWorld(soap, (const struct __ns5__HelloWorld *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayPublicTelHistoryByCondition:
		soap_serialize___ns4__GetPayPublicTelHistoryByCondition(soap, (const struct __ns4__GetPayPublicTelHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayPublicTelByCondition:
		soap_serialize___ns4__GetPayPublicTelByCondition(soap, (const struct __ns4__GetPayPublicTelByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayGameHistoryByCondition:
		soap_serialize___ns4__GetPayGameHistoryByCondition(soap, (const struct __ns4__GetPayGameHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayGameByCondition:
		soap_serialize___ns4__GetPayGameByCondition(soap, (const struct __ns4__GetPayGameByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayInternetHistoryByCondition:
		soap_serialize___ns4__GetPayInternetHistoryByCondition(soap, (const struct __ns4__GetPayInternetHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPayInternetByCondition:
		soap_serialize___ns4__GetPayInternetByCondition(soap, (const struct __ns4__GetPayInternetByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentOrPaymentHistoryByCondition:
		soap_serialize___ns4__GetPaymentOrPaymentHistoryByCondition(soap, (const struct __ns4__GetPaymentOrPaymentHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetTransactionStaticsByCondition:
		soap_serialize___ns4__GetTransactionStaticsByCondition(soap, (const struct __ns4__GetTransactionStaticsByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetTransactionByCondition:
		soap_serialize___ns4__GetTransactionByCondition(soap, (const struct __ns4__GetTransactionByCondition *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentItem:
		soap_serialize___ns4__GetPaymentItem(soap, (const struct __ns4__GetPaymentItem *)ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentRecord:
		soap_serialize___ns4__GetPaymentRecord(soap, (const struct __ns4__GetPaymentRecord *)ptr);
		break;
	case SOAP_TYPE___ns4__PayPublicTel:
		soap_serialize___ns4__PayPublicTel(soap, (const struct __ns4__PayPublicTel *)ptr);
		break;
	case SOAP_TYPE___ns4__PayGame:
		soap_serialize___ns4__PayGame(soap, (const struct __ns4__PayGame *)ptr);
		break;
	case SOAP_TYPE___ns4__RequstInternetRollback:
		soap_serialize___ns4__RequstInternetRollback(soap, (const struct __ns4__RequstInternetRollback *)ptr);
		break;
	case SOAP_TYPE___ns4__PayInternetWithList:
		soap_serialize___ns4__PayInternetWithList(soap, (const struct __ns4__PayInternetWithList *)ptr);
		break;
	case SOAP_TYPE___ns4__PayInternet:
		soap_serialize___ns4__PayInternet(soap, (const struct __ns4__PayInternet *)ptr);
		break;
	case SOAP_TYPE___ns4__RequstRollback:
		soap_serialize___ns4__RequstRollback(soap, (const struct __ns4__RequstRollback *)ptr);
		break;
	case SOAP_TYPE___ns4__PayMoneyWithList:
		soap_serialize___ns4__PayMoneyWithList(soap, (const struct __ns4__PayMoneyWithList *)ptr);
		break;
	case SOAP_TYPE___ns4__PayMoney:
		soap_serialize___ns4__PayMoney(soap, (const struct __ns4__PayMoney *)ptr);
		break;
	case SOAP_TYPE___ns4__GetLocation:
		soap_serialize___ns4__GetLocation(soap, (const struct __ns4__GetLocation *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayPublicTelHistoryByCondition:
		soap_serialize___ns3__GetPayPublicTelHistoryByCondition(soap, (const struct __ns3__GetPayPublicTelHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayPublicTelByCondition:
		soap_serialize___ns3__GetPayPublicTelByCondition(soap, (const struct __ns3__GetPayPublicTelByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayGameHistoryByCondition:
		soap_serialize___ns3__GetPayGameHistoryByCondition(soap, (const struct __ns3__GetPayGameHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayGameByCondition:
		soap_serialize___ns3__GetPayGameByCondition(soap, (const struct __ns3__GetPayGameByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayInternetHistoryByCondition:
		soap_serialize___ns3__GetPayInternetHistoryByCondition(soap, (const struct __ns3__GetPayInternetHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPayInternetByCondition:
		soap_serialize___ns3__GetPayInternetByCondition(soap, (const struct __ns3__GetPayInternetByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentOrPaymentHistoryByCondition:
		soap_serialize___ns3__GetPaymentOrPaymentHistoryByCondition(soap, (const struct __ns3__GetPaymentOrPaymentHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetTransactionStaticsByCondition:
		soap_serialize___ns3__GetTransactionStaticsByCondition(soap, (const struct __ns3__GetTransactionStaticsByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetTransactionByCondition:
		soap_serialize___ns3__GetTransactionByCondition(soap, (const struct __ns3__GetTransactionByCondition *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentItem:
		soap_serialize___ns3__GetPaymentItem(soap, (const struct __ns3__GetPaymentItem *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentRecord:
		soap_serialize___ns3__GetPaymentRecord(soap, (const struct __ns3__GetPaymentRecord *)ptr);
		break;
	case SOAP_TYPE___ns3__PayPublicTel:
		soap_serialize___ns3__PayPublicTel(soap, (const struct __ns3__PayPublicTel *)ptr);
		break;
	case SOAP_TYPE___ns3__PayGame:
		soap_serialize___ns3__PayGame(soap, (const struct __ns3__PayGame *)ptr);
		break;
	case SOAP_TYPE___ns3__RequstInternetRollback:
		soap_serialize___ns3__RequstInternetRollback(soap, (const struct __ns3__RequstInternetRollback *)ptr);
		break;
	case SOAP_TYPE___ns3__PayInternetWithList:
		soap_serialize___ns3__PayInternetWithList(soap, (const struct __ns3__PayInternetWithList *)ptr);
		break;
	case SOAP_TYPE___ns3__PayInternet:
		soap_serialize___ns3__PayInternet(soap, (const struct __ns3__PayInternet *)ptr);
		break;
	case SOAP_TYPE___ns3__RequstRollback:
		soap_serialize___ns3__RequstRollback(soap, (const struct __ns3__RequstRollback *)ptr);
		break;
	case SOAP_TYPE___ns3__PayMoneyWithList:
		soap_serialize___ns3__PayMoneyWithList(soap, (const struct __ns3__PayMoneyWithList *)ptr);
		break;
	case SOAP_TYPE___ns3__PayMoney:
		soap_serialize___ns3__PayMoney(soap, (const struct __ns3__PayMoney *)ptr);
		break;
	case SOAP_TYPE___ns3__GetLocation:
		soap_serialize___ns3__GetLocation(soap, (const struct __ns3__GetLocation *)ptr);
		break;
	case SOAP_TYPE___ns14__GetStockCardItemAndHistoryByCondition:
		soap_serialize___ns14__GetStockCardItemAndHistoryByCondition(soap, (const struct __ns14__GetStockCardItemAndHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetStockCardItemByCondition:
		soap_serialize___ns14__GetStockCardItemByCondition(soap, (const struct __ns14__GetStockCardItemByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetOtherCardList:
		soap_serialize___ns14__GetOtherCardList(soap, (const struct __ns14__GetOtherCardList *)ptr);
		break;
	case SOAP_TYPE___ns14__GettSellOtherCardRecordHistoryByCondition:
		soap_serialize___ns14__GettSellOtherCardRecordHistoryByCondition(soap, (const struct __ns14__GettSellOtherCardRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetSellOtherCardRecordByCondition:
		soap_serialize___ns14__GetSellOtherCardRecordByCondition(soap, (const struct __ns14__GetSellOtherCardRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GettBusinessRecordHistoryByCondition:
		soap_serialize___ns14__GettBusinessRecordHistoryByCondition(soap, (const struct __ns14__GettBusinessRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetBusinessRecordByCondition:
		soap_serialize___ns14__GetBusinessRecordByCondition(soap, (const struct __ns14__GetBusinessRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetSellCardRecordHistoryByCondition:
		soap_serialize___ns14__GetSellCardRecordHistoryByCondition(soap, (const struct __ns14__GetSellCardRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetSellCardRecordByCondition:
		soap_serialize___ns14__GetSellCardRecordByCondition(soap, (const struct __ns14__GetSellCardRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetCardService:
		soap_serialize___ns14__GetCardService(soap, (const struct __ns14__GetCardService *)ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoItemAndHistoryByCondition:
		soap_serialize___ns14__GetPhoneNoItemAndHistoryByCondition(soap, (const struct __ns14__GetPhoneNoItemAndHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoItemByCondition:
		soap_serialize___ns14__GetPhoneNoItemByCondition(soap, (const struct __ns14__GetPhoneNoItemByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetPayMiniCardHistoryByCondition:
		soap_serialize___ns14__GetPayMiniCardHistoryByCondition(soap, (const struct __ns14__GetPayMiniCardHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetPayMiniCardByCondition:
		soap_serialize___ns14__GetPayMiniCardByCondition(soap, (const struct __ns14__GetPayMiniCardByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__GetMiniCardRecord:
		soap_serialize___ns14__GetMiniCardRecord(soap, (const struct __ns14__GetMiniCardRecord *)ptr);
		break;
	case SOAP_TYPE___ns14__SellOhterCard:
		soap_serialize___ns14__SellOhterCard(soap, (const struct __ns14__SellOhterCard *)ptr);
		break;
	case SOAP_TYPE___ns14__SellNo:
		soap_serialize___ns14__SellNo(soap, (const struct __ns14__SellNo *)ptr);
		break;
	case SOAP_TYPE___ns14__SubmitBusiness:
		soap_serialize___ns14__SubmitBusiness(soap, (const struct __ns14__SubmitBusiness *)ptr);
		break;
	case SOAP_TYPE___ns14__UnlockNo:
		soap_serialize___ns14__UnlockNo(soap, (const struct __ns14__UnlockNo *)ptr);
		break;
	case SOAP_TYPE___ns14__LockNo:
		soap_serialize___ns14__LockNo(soap, (const struct __ns14__LockNo *)ptr);
		break;
	case SOAP_TYPE___ns14__GetMyNoSection:
		soap_serialize___ns14__GetMyNoSection(soap, (const struct __ns14__GetMyNoSection *)ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoByCondition:
		soap_serialize___ns14__GetPhoneNoByCondition(soap, (const struct __ns14__GetPhoneNoByCondition *)ptr);
		break;
	case SOAP_TYPE___ns14__BuyMiniCard:
		soap_serialize___ns14__BuyMiniCard(soap, (const struct __ns14__BuyMiniCard *)ptr);
		break;
	case SOAP_TYPE___ns13__GetStockCardItemAndHistoryByCondition:
		soap_serialize___ns13__GetStockCardItemAndHistoryByCondition(soap, (const struct __ns13__GetStockCardItemAndHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetStockCardItemByCondition:
		soap_serialize___ns13__GetStockCardItemByCondition(soap, (const struct __ns13__GetStockCardItemByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetOtherCardList:
		soap_serialize___ns13__GetOtherCardList(soap, (const struct __ns13__GetOtherCardList *)ptr);
		break;
	case SOAP_TYPE___ns13__GettSellOtherCardRecordHistoryByCondition:
		soap_serialize___ns13__GettSellOtherCardRecordHistoryByCondition(soap, (const struct __ns13__GettSellOtherCardRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetSellOtherCardRecordByCondition:
		soap_serialize___ns13__GetSellOtherCardRecordByCondition(soap, (const struct __ns13__GetSellOtherCardRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GettBusinessRecordHistoryByCondition:
		soap_serialize___ns13__GettBusinessRecordHistoryByCondition(soap, (const struct __ns13__GettBusinessRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetBusinessRecordByCondition:
		soap_serialize___ns13__GetBusinessRecordByCondition(soap, (const struct __ns13__GetBusinessRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetSellCardRecordHistoryByCondition:
		soap_serialize___ns13__GetSellCardRecordHistoryByCondition(soap, (const struct __ns13__GetSellCardRecordHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetSellCardRecordByCondition:
		soap_serialize___ns13__GetSellCardRecordByCondition(soap, (const struct __ns13__GetSellCardRecordByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetCardService:
		soap_serialize___ns13__GetCardService(soap, (const struct __ns13__GetCardService *)ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoItemAndHistoryByCondition:
		soap_serialize___ns13__GetPhoneNoItemAndHistoryByCondition(soap, (const struct __ns13__GetPhoneNoItemAndHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoItemByCondition:
		soap_serialize___ns13__GetPhoneNoItemByCondition(soap, (const struct __ns13__GetPhoneNoItemByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetPayMiniCardHistoryByCondition:
		soap_serialize___ns13__GetPayMiniCardHistoryByCondition(soap, (const struct __ns13__GetPayMiniCardHistoryByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetPayMiniCardByCondition:
		soap_serialize___ns13__GetPayMiniCardByCondition(soap, (const struct __ns13__GetPayMiniCardByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__GetMiniCardRecord:
		soap_serialize___ns13__GetMiniCardRecord(soap, (const struct __ns13__GetMiniCardRecord *)ptr);
		break;
	case SOAP_TYPE___ns13__SellOhterCard:
		soap_serialize___ns13__SellOhterCard(soap, (const struct __ns13__SellOhterCard *)ptr);
		break;
	case SOAP_TYPE___ns13__SellNo:
		soap_serialize___ns13__SellNo(soap, (const struct __ns13__SellNo *)ptr);
		break;
	case SOAP_TYPE___ns13__SubmitBusiness:
		soap_serialize___ns13__SubmitBusiness(soap, (const struct __ns13__SubmitBusiness *)ptr);
		break;
	case SOAP_TYPE___ns13__UnlockNo:
		soap_serialize___ns13__UnlockNo(soap, (const struct __ns13__UnlockNo *)ptr);
		break;
	case SOAP_TYPE___ns13__LockNo:
		soap_serialize___ns13__LockNo(soap, (const struct __ns13__LockNo *)ptr);
		break;
	case SOAP_TYPE___ns13__GetMyNoSection:
		soap_serialize___ns13__GetMyNoSection(soap, (const struct __ns13__GetMyNoSection *)ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoByCondition:
		soap_serialize___ns13__GetPhoneNoByCondition(soap, (const struct __ns13__GetPhoneNoByCondition *)ptr);
		break;
	case SOAP_TYPE___ns13__BuyMiniCard:
		soap_serialize___ns13__BuyMiniCard(soap, (const struct __ns13__BuyMiniCard *)ptr);
		break;
	case SOAP_TYPE___ns12__queryPhoneNOInfo:
		soap_serialize___ns12__queryPhoneNOInfo(soap, (const struct __ns12__queryPhoneNOInfo *)ptr);
		break;
	case SOAP_TYPE___ns11__queryPhoneNOInfo:
		soap_serialize___ns11__queryPhoneNOInfo(soap, (const struct __ns11__queryPhoneNOInfo *)ptr);
		break;
	case SOAP_TYPE___ns10__queryPhoneNOInfo:
		soap_serialize___ns10__queryPhoneNOInfo(soap, (const struct __ns10__queryPhoneNOInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClientVersionResponse:
		soap_serialize_PointerTo_ns1__GetClientVersionResponse(soap, (_ns1__GetClientVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClientVersion:
		soap_serialize_PointerTo_ns1__GetClientVersion(soap, (_ns1__GetClientVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccountResponse:
		soap_serialize_PointerTo_ns1__DeleteCompanyAccountResponse(soap, (_ns1__DeleteCompanyAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccount:
		soap_serialize_PointerTo_ns1__DeleteCompanyAccount(soap, (_ns1__DeleteCompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccountResponse:
		soap_serialize_PointerTo_ns1__UpdateCompanyAccountResponse(soap, (_ns1__UpdateCompanyAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccount:
		soap_serialize_PointerTo_ns1__UpdateCompanyAccount(soap, (_ns1__UpdateCompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccountResponse:
		soap_serialize_PointerTo_ns1__AddCompanyAccountResponse(soap, (_ns1__AddCompanyAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddCompanyAccount:
		soap_serialize_PointerTo_ns1__AddCompanyAccount(soap, (_ns1__AddCompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccountResponse:
		soap_serialize_PointerTo_ns1__GetCompanyAccountResponse(soap, (_ns1__GetCompanyAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCompanyAccount:
		soap_serialize_PointerTo_ns1__GetCompanyAccount(soap, (_ns1__GetCompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfoResponse:
		soap_serialize_PointerTo_ns1__UpdateCompanyInfoResponse(soap, (_ns1__UpdateCompanyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfo:
		soap_serialize_PointerTo_ns1__UpdateCompanyInfo(soap, (_ns1__UpdateCompanyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfoResponse:
		soap_serialize_PointerTo_ns1__GetCompanyInfoResponse(soap, (_ns1__GetCompanyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCompanyInfo:
		soap_serialize_PointerTo_ns1__GetCompanyInfo(soap, (_ns1__GetCompanyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelongResponse:
		soap_serialize_PointerTo_ns1__DeletePhoneNumberBelongResponse(soap, (_ns1__DeletePhoneNumberBelongResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelong:
		soap_serialize_PointerTo_ns1__DeletePhoneNumberBelong(soap, (_ns1__DeletePhoneNumberBelong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelongResponse:
		soap_serialize_PointerTo_ns1__AddPhoneNumberBelongResponse(soap, (_ns1__AddPhoneNumberBelongResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelong:
		soap_serialize_PointerTo_ns1__AddPhoneNumberBelong(soap, (_ns1__AddPhoneNumberBelong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelongResponse:
		soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelongResponse(soap, (_ns1__UpdatePhoneNumberBelongResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelong:
		soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelong(soap, (_ns1__UpdatePhoneNumberBelong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(soap, (_ns1__GetPhoneNumberBelongByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByCondition:
		soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, (_ns1__GetPhoneNumberBelongByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportionResponse:
		soap_serialize_PointerTo_ns1__DeletetReturnProportionResponse(soap, (_ns1__DeletetReturnProportionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeletetReturnProportion:
		soap_serialize_PointerTo_ns1__DeletetReturnProportion(soap, (_ns1__DeletetReturnProportion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportionResponse:
		soap_serialize_PointerTo_ns1__UpdatetReturnProportionResponse(soap, (_ns1__UpdatetReturnProportionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportion:
		soap_serialize_PointerTo_ns1__UpdatetReturnProportion(soap, (_ns1__UpdatetReturnProportion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportionResponse:
		soap_serialize_PointerTo_ns1__AddtReturnProportionResponse(soap, (_ns1__AddtReturnProportionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddtReturnProportion:
		soap_serialize_PointerTo_ns1__AddtReturnProportion(soap, (_ns1__AddtReturnProportion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecordResponse:
		soap_serialize_PointerTo_ns1__GetReturnProportionRecordResponse(soap, (_ns1__GetReturnProportionRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecord:
		soap_serialize_PointerTo_ns1__GetReturnProportionRecord(soap, (_ns1__GetReturnProportionRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOneResponse:
		soap_serialize_PointerTo_ns1__InserNoticeToSomeOneResponse(soap, (_ns1__InserNoticeToSomeOneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOne:
		soap_serialize_PointerTo_ns1__InserNoticeToSomeOne(soap, (_ns1__InserNoticeToSomeOne *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItemResponse:
		soap_serialize_PointerTo_ns1__DeleteNoticeItemResponse(soap, (_ns1__DeleteNoticeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteNoticeItem:
		soap_serialize_PointerTo_ns1__DeleteNoticeItem(soap, (_ns1__DeleteNoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItemResponse:
		soap_serialize_PointerTo_ns1__UpdateNoticeItemResponse(soap, (_ns1__UpdateNoticeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateNoticeItem:
		soap_serialize_PointerTo_ns1__UpdateNoticeItem(soap, (_ns1__UpdateNoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeoneResponse:
		soap_serialize_PointerTo_ns1__AddNoticeItemToSomeoneResponse(soap, (_ns1__AddNoticeItemToSomeoneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeone:
		soap_serialize_PointerTo_ns1__AddNoticeItemToSomeone(soap, (_ns1__AddNoticeItemToSomeone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItemResponse:
		soap_serialize_PointerTo_ns1__AddNoticeItemResponse(soap, (_ns1__AddNoticeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddNoticeItem:
		soap_serialize_PointerTo_ns1__AddNoticeItem(soap, (_ns1__AddNoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeListResponse:
		soap_serialize_PointerTo_ns1__GetAlertNoticeListResponse(soap, (_ns1__GetAlertNoticeListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlertNoticeList:
		soap_serialize_PointerTo_ns1__GetAlertNoticeList(soap, (_ns1__GetAlertNoticeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItemResponse:
		soap_serialize_PointerTo_ns1__GetNoticeItemResponse(soap, (_ns1__GetNoticeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeItem:
		soap_serialize_PointerTo_ns1__GetNoticeItem(soap, (_ns1__GetNoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByConditionResponse:
		soap_serialize_PointerTo_ns1__GetNoticeListByConditionResponse(soap, (_ns1__GetNoticeListByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListByCondition:
		soap_serialize_PointerTo_ns1__GetNoticeListByCondition(soap, (_ns1__GetNoticeListByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeListResponse:
		soap_serialize_PointerTo_ns1__GetNoticeListResponse(soap, (_ns1__GetNoticeListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetNoticeList:
		soap_serialize_PointerTo_ns1__GetNoticeList(soap, (_ns1__GetNoticeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTableStatisticsResponse:
		soap_serialize_PointerTo_ns1__GetTableStatisticsResponse(soap, (_ns1__GetTableStatisticsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTableStatistics:
		soap_serialize_PointerTo_ns1__GetTableStatistics(soap, (_ns1__GetTableStatistics *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRightResponse:
		soap_serialize_PointerTo_ns1__UpdateFunctionRightResponse(soap, (_ns1__UpdateFunctionRightResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateFunctionRight:
		soap_serialize_PointerTo_ns1__UpdateFunctionRight(soap, (_ns1__UpdateFunctionRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionListResponse:
		soap_serialize_PointerTo_ns1__UpdateUserFunctionListResponse(soap, (_ns1__UpdateUserFunctionListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionList:
		soap_serialize_PointerTo_ns1__UpdateUserFunctionList(soap, (_ns1__UpdateUserFunctionList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFunctionListResponse:
		soap_serialize_PointerTo_ns1__GetFunctionListResponse(soap, (_ns1__GetFunctionListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFunctionList:
		soap_serialize_PointerTo_ns1__GetFunctionList(soap, (_ns1__GetFunctionList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategoryResponse:
		soap_serialize_PointerTo_ns1__UpdateDicContentByCategoryResponse(soap, (_ns1__UpdateDicContentByCategoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategory:
		soap_serialize_PointerTo_ns1__UpdateDicContentByCategory(soap, (_ns1__UpdateDicContentByCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContentResponse:
		soap_serialize_PointerTo_ns1__DeleteDicContentResponse(soap, (_ns1__DeleteDicContentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteDicContent:
		soap_serialize_PointerTo_ns1__DeleteDicContent(soap, (_ns1__DeleteDicContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContentResponse:
		soap_serialize_PointerTo_ns1__UpdateDicContentResponse(soap, (_ns1__UpdateDicContentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateDicContent:
		soap_serialize_PointerTo_ns1__UpdateDicContent(soap, (_ns1__UpdateDicContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsertDicContentResponse:
		soap_serialize_PointerTo_ns1__InsertDicContentResponse(soap, (_ns1__InsertDicContentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsertDicContent:
		soap_serialize_PointerTo_ns1__InsertDicContent(soap, (_ns1__InsertDicContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCategoryResponse:
		soap_serialize_PointerTo_ns1__GetAllCategoryResponse(soap, (_ns1__GetAllCategoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCategory:
		soap_serialize_PointerTo_ns1__GetAllCategory(soap, (_ns1__GetAllCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByConditionResponse:
		soap_serialize_PointerTo_ns1__GetDicContentByConditionResponse(soap, (_ns1__GetDicContentByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDicContentByCondition:
		soap_serialize_PointerTo_ns1__GetDicContentByCondition(soap, (_ns1__GetDicContentByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecordResponse:
		soap_serialize_PointerTo_ns1__GetAcountPaymentRecordResponse(soap, (_ns1__GetAcountPaymentRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecord:
		soap_serialize_PointerTo_ns1__GetAcountPaymentRecord(soap, (_ns1__GetAcountPaymentRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDealResponse:
		soap_serialize_PointerTo_ns1__GetReturnRecordDealResponse(soap, (_ns1__GetReturnRecordDealResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordDeal:
		soap_serialize_PointerTo_ns1__GetReturnRecordDeal(soap, (_ns1__GetReturnRecordDeal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecordResponse:
		soap_serialize_PointerTo_ns1__GetReturnRecordResponse(soap, (_ns1__GetReturnRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnRecord:
		soap_serialize_PointerTo_ns1__GetReturnRecord(soap, (_ns1__GetReturnRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserFunctionResponse:
		soap_serialize_PointerTo_ns1__GetUserFunctionResponse(soap, (_ns1__GetUserFunctionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserFunction:
		soap_serialize_PointerTo_ns1__GetUserFunction(soap, (_ns1__GetUserFunction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameListResponse:
		soap_serialize_PointerTo_ns1__GetWorkNameListResponse(soap, (_ns1__GetWorkNameListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetWorkNameList:
		soap_serialize_PointerTo_ns1__GetWorkNameList(soap, (_ns1__GetWorkNameList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoneyResponse:
		soap_serialize_PointerTo_ns1__CharegeReturnedMoneyResponse(soap, (_ns1__CharegeReturnedMoneyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoney:
		soap_serialize_PointerTo_ns1__CharegeReturnedMoney(soap, (_ns1__CharegeReturnedMoney *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfoResponse:
		soap_serialize_PointerTo_ns1__GetReturnInfoResponse(soap, (_ns1__GetReturnInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReturnInfo:
		soap_serialize_PointerTo_ns1__GetReturnInfo(soap, (_ns1__GetReturnInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddAcountPaymentResponse:
		soap_serialize_PointerTo_ns1__AddAcountPaymentResponse(soap, (_ns1__AddAcountPaymentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddAcountPayment:
		soap_serialize_PointerTo_ns1__AddAcountPayment(soap, (_ns1__AddAcountPayment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfoResponse:
		soap_serialize_PointerTo_ns1__AlterUserInfoResponse(soap, (_ns1__AlterUserInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AlterUserInfo:
		soap_serialize_PointerTo_ns1__AlterUserInfo(soap, (_ns1__AlterUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AlterPswResponse:
		soap_serialize_PointerTo_ns1__AlterPswResponse(soap, (_ns1__AlterPswResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AlterPsw:
		soap_serialize_PointerTo_ns1__AlterPsw(soap, (_ns1__AlterPsw *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RegisterUserResponse:
		soap_serialize_PointerTo_ns1__RegisterUserResponse(soap, (_ns1__RegisterUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RegisterUser:
		soap_serialize_PointerTo_ns1__RegisterUser(soap, (_ns1__RegisterUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserInfoResponse:
		soap_serialize_PointerTo_ns1__GetUserInfoResponse(soap, (_ns1__GetUserInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserInfo:
		soap_serialize_PointerTo_ns1__GetUserInfo(soap, (_ns1__GetUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TestLoginResponse:
		soap_serialize_PointerTo_ns1__TestLoginResponse(soap, (_ns1__TestLoginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TestLogin:
		soap_serialize_PointerTo_ns1__TestLogin(soap, (_ns1__TestLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loggoutResponse:
		soap_serialize_PointerTo_ns1__loggoutResponse(soap, (_ns1__loggoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loggout:
		soap_serialize_PointerTo_ns1__loggout(soap, (_ns1__loggout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__HelloWorldResponse:
		soap_serialize_PointerTo_ns1__HelloWorldResponse(soap, (_ns1__HelloWorldResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		soap_serialize_PointerTo_ns1__HelloWorld(soap, (_ns1__HelloWorld *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(soap, (_ns1__GetPayPublicTelHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, (_ns1__GetPayPublicTelHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayPublicTelByConditionResponse(soap, (_ns1__GetPayPublicTelByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByCondition:
		soap_serialize_PointerTo_ns1__GetPayPublicTelByCondition(soap, (_ns1__GetPayPublicTelByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayGameHistoryByConditionResponse(soap, (_ns1__GetPayGameHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPayGameHistoryByCondition(soap, (_ns1__GetPayGameHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayGameByConditionResponse(soap, (_ns1__GetPayGameByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayGameByCondition:
		soap_serialize_PointerTo_ns1__GetPayGameByCondition(soap, (_ns1__GetPayGameByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(soap, (_ns1__GetPayInternetHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, (_ns1__GetPayInternetHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayInternetByConditionResponse(soap, (_ns1__GetPayInternetByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayInternetByCondition:
		soap_serialize_PointerTo_ns1__GetPayInternetByCondition(soap, (_ns1__GetPayInternetByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, (_ns1__GetPaymentOrPaymentHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByConditionResponse:
		soap_serialize_PointerTo_ns1__GetTransactionStaticsByConditionResponse(soap, (_ns1__GetTransactionStaticsByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByCondition:
		soap_serialize_PointerTo_ns1__GetTransactionStaticsByCondition(soap, (_ns1__GetTransactionStaticsByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByConditionResponse:
		soap_serialize_PointerTo_ns1__GetTransactionByConditionResponse(soap, (_ns1__GetTransactionByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTransactionByCondition:
		soap_serialize_PointerTo_ns1__GetTransactionByCondition(soap, (_ns1__GetTransactionByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItemResponse:
		soap_serialize_PointerTo_ns1__GetPaymentItemResponse(soap, (_ns1__GetPaymentItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentItem:
		soap_serialize_PointerTo_ns1__GetPaymentItem(soap, (_ns1__GetPaymentItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecordResponse:
		soap_serialize_PointerTo_ns1__GetPaymentRecordResponse(soap, (_ns1__GetPaymentRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPaymentRecord:
		soap_serialize_PointerTo_ns1__GetPaymentRecord(soap, (_ns1__GetPaymentRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayPublicTelResponse:
		soap_serialize_PointerTo_ns1__PayPublicTelResponse(soap, (_ns1__PayPublicTelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayPublicTel:
		soap_serialize_PointerTo_ns1__PayPublicTel(soap, (_ns1__PayPublicTel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayGameResponse:
		soap_serialize_PointerTo_ns1__PayGameResponse(soap, (_ns1__PayGameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayGame:
		soap_serialize_PointerTo_ns1__PayGame(soap, (_ns1__PayGame *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollbackResponse:
		soap_serialize_PointerTo_ns1__RequstInternetRollbackResponse(soap, (_ns1__RequstInternetRollbackResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RequstInternetRollback:
		soap_serialize_PointerTo_ns1__RequstInternetRollback(soap, (_ns1__RequstInternetRollback *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithListResponse:
		soap_serialize_PointerTo_ns1__PayInternetWithListResponse(soap, (_ns1__PayInternetWithListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayInternetWithList:
		soap_serialize_PointerTo_ns1__PayInternetWithList(soap, (_ns1__PayInternetWithList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayInternetResponse:
		soap_serialize_PointerTo_ns1__PayInternetResponse(soap, (_ns1__PayInternetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayInternet:
		soap_serialize_PointerTo_ns1__PayInternet(soap, (_ns1__PayInternet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RequstRollbackResponse:
		soap_serialize_PointerTo_ns1__RequstRollbackResponse(soap, (_ns1__RequstRollbackResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RequstRollback:
		soap_serialize_PointerTo_ns1__RequstRollback(soap, (_ns1__RequstRollback *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithListResponse:
		soap_serialize_PointerTo_ns1__PayMoneyWithListResponse(soap, (_ns1__PayMoneyWithListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayMoneyWithList:
		soap_serialize_PointerTo_ns1__PayMoneyWithList(soap, (_ns1__PayMoneyWithList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayMoneyResponse:
		soap_serialize_PointerTo_ns1__PayMoneyResponse(soap, (_ns1__PayMoneyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PayMoney:
		soap_serialize_PointerTo_ns1__PayMoney(soap, (_ns1__PayMoney *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLocationResponse:
		soap_serialize_PointerTo_ns1__GetLocationResponse(soap, (_ns1__GetLocationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLocation:
		soap_serialize_PointerTo_ns1__GetLocation(soap, (_ns1__GetLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(soap, (_ns1__GetStockCardItemAndHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, (_ns1__GetStockCardItemAndHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByConditionResponse:
		soap_serialize_PointerTo_ns1__GetStockCardItemByConditionResponse(soap, (_ns1__GetStockCardItemByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStockCardItemByCondition:
		soap_serialize_PointerTo_ns1__GetStockCardItemByCondition(soap, (_ns1__GetStockCardItemByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardListResponse:
		soap_serialize_PointerTo_ns1__GetOtherCardListResponse(soap, (_ns1__GetOtherCardListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOtherCardList:
		soap_serialize_PointerTo_ns1__GetOtherCardList(soap, (_ns1__GetOtherCardList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition:
		soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, (_ns1__GettSellOtherCardRecordHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse:
		soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(soap, (_ns1__GetSellOtherCardRecordByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByCondition:
		soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, (_ns1__GetSellOtherCardRecordByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(soap, (_ns1__GettBusinessRecordHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByCondition:
		soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, (_ns1__GettBusinessRecordHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByConditionResponse:
		soap_serialize_PointerTo_ns1__GetBusinessRecordByConditionResponse(soap, (_ns1__GetBusinessRecordByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByCondition:
		soap_serialize_PointerTo_ns1__GetBusinessRecordByCondition(soap, (_ns1__GetBusinessRecordByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(soap, (_ns1__GetSellCardRecordHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, (_ns1__GetSellCardRecordHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByConditionResponse:
		soap_serialize_PointerTo_ns1__GetSellCardRecordByConditionResponse(soap, (_ns1__GetSellCardRecordByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByCondition:
		soap_serialize_PointerTo_ns1__GetSellCardRecordByCondition(soap, (_ns1__GetSellCardRecordByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCardServiceResponse:
		soap_serialize_PointerTo_ns1__GetCardServiceResponse(soap, (_ns1__GetCardServiceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCardService:
		soap_serialize_PointerTo_ns1__GetCardService(soap, (_ns1__GetCardService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, (_ns1__GetPhoneNoItemAndHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPhoneNoItemByConditionResponse(soap, (_ns1__GetPhoneNoItemByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByCondition:
		soap_serialize_PointerTo_ns1__GetPhoneNoItemByCondition(soap, (_ns1__GetPhoneNoItemByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(soap, (_ns1__GetPayMiniCardHistoryByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByCondition:
		soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, (_ns1__GetPayMiniCardHistoryByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPayMiniCardByConditionResponse(soap, (_ns1__GetPayMiniCardByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByCondition:
		soap_serialize_PointerTo_ns1__GetPayMiniCardByCondition(soap, (_ns1__GetPayMiniCardByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecordResponse:
		soap_serialize_PointerTo_ns1__GetMiniCardRecordResponse(soap, (_ns1__GetMiniCardRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMiniCardRecord:
		soap_serialize_PointerTo_ns1__GetMiniCardRecord(soap, (_ns1__GetMiniCardRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SellOhterCardResponse:
		soap_serialize_PointerTo_ns1__SellOhterCardResponse(soap, (_ns1__SellOhterCardResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SellOhterCard:
		soap_serialize_PointerTo_ns1__SellOhterCard(soap, (_ns1__SellOhterCard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SellNoResponse:
		soap_serialize_PointerTo_ns1__SellNoResponse(soap, (_ns1__SellNoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SellNo:
		soap_serialize_PointerTo_ns1__SellNo(soap, (_ns1__SellNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubmitBusinessResponse:
		soap_serialize_PointerTo_ns1__SubmitBusinessResponse(soap, (_ns1__SubmitBusinessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubmitBusiness:
		soap_serialize_PointerTo_ns1__SubmitBusiness(soap, (_ns1__SubmitBusiness *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UnlockNoResponse:
		soap_serialize_PointerTo_ns1__UnlockNoResponse(soap, (_ns1__UnlockNoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UnlockNo:
		soap_serialize_PointerTo_ns1__UnlockNo(soap, (_ns1__UnlockNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LockNoResponse:
		soap_serialize_PointerTo_ns1__LockNoResponse(soap, (_ns1__LockNoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LockNo:
		soap_serialize_PointerTo_ns1__LockNo(soap, (_ns1__LockNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSectionResponse:
		soap_serialize_PointerTo_ns1__GetMyNoSectionResponse(soap, (_ns1__GetMyNoSectionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMyNoSection:
		soap_serialize_PointerTo_ns1__GetMyNoSection(soap, (_ns1__GetMyNoSection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByConditionResponse:
		soap_serialize_PointerTo_ns1__GetPhoneNoByConditionResponse(soap, (_ns1__GetPhoneNoByConditionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPhoneNoByCondition:
		soap_serialize_PointerTo_ns1__GetPhoneNoByCondition(soap, (_ns1__GetPhoneNoByCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCardResponse:
		soap_serialize_PointerTo_ns1__BuyMiniCardResponse(soap, (_ns1__BuyMiniCardResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BuyMiniCard:
		soap_serialize_PointerTo_ns1__BuyMiniCard(soap, (_ns1__BuyMiniCard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfoResponse:
		soap_serialize_PointerTo_ns1__queryPhoneNOInfoResponse(soap, (_ns1__queryPhoneNOInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfo:
		soap_serialize_PointerTo_ns1__queryPhoneNOInfo(soap, (_ns1__queryPhoneNOInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfStockCardItem:
		soap_serialize_PointerTons1__ArrayOfStockCardItem(soap, (ns1__ArrayOfStockCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfOtherCardItem:
		soap_serialize_PointerTons1__ArrayOfOtherCardItem(soap, (ns1__ArrayOfOtherCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSellOtherCardItem:
		soap_serialize_PointerTons1__ArrayOfSellOtherCardItem(soap, (ns1__ArrayOfSellOtherCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfBusinessItem:
		soap_serialize_PointerTons1__ArrayOfBusinessItem(soap, (ns1__ArrayOfBusinessItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSellCardItem:
		soap_serialize_PointerTons1__ArrayOfSellCardItem(soap, (ns1__ArrayOfSellCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfCardService:
		soap_serialize_PointerTons1__ArrayOfCardService(soap, (ns1__ArrayOfCardService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPayMiniCardItem:
		soap_serialize_PointerTons1__ArrayOfPayMiniCardItem(soap, (ns1__ArrayOfPayMiniCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfMiniCardItem:
		soap_serialize_PointerTons1__ArrayOfMiniCardItem(soap, (ns1__ArrayOfMiniCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneNoList:
		soap_serialize_PointerTons1__PhoneNoList(soap, (ns1__PhoneNoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Result:
		soap_serialize_PointerTons1__Result(soap, (ns1__Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfCompanyAccount:
		soap_serialize_PointerTons1__ArrayOfCompanyAccount(soap, (ns1__ArrayOfCompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CompanyInfo:
		soap_serialize_PointerTons1__CompanyInfo(soap, (ns1__CompanyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNumberBelong:
		soap_serialize_PointerTons1__ArrayOfPhoneNumberBelong(soap, (ns1__ArrayOfPhoneNumberBelong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfReturnProportion:
		soap_serialize_PointerTons1__ArrayOfReturnProportion(soap, (ns1__ArrayOfReturnProportion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Notice:
		soap_serialize_PointerTons1__Notice(soap, (ns1__Notice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TableStatistics:
		soap_serialize_PointerTons1__TableStatistics(soap, (ns1__TableStatistics *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCORECategory:
		soap_serialize_PointerTons1__ArrayOfDIC_USCORECategory(soap, (ns1__ArrayOfDIC_USCORECategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDIC_USCOREContent:
		soap_serialize_PointerTons1__ArrayOfDIC_USCOREContent(soap, (ns1__ArrayOfDIC_USCOREContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAcountPaymentItem:
		soap_serialize_PointerTons1__ArrayOfAcountPaymentItem(soap, (ns1__ArrayOfAcountPaymentItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfReturnedItem:
		soap_serialize_PointerTons1__ArrayOfReturnedItem(soap, (ns1__ArrayOfReturnedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSystemFunction:
		soap_serialize_PointerTons1__ArrayOfSystemFunction(soap, (ns1__ArrayOfSystemFunction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfWorker:
		soap_serialize_PointerTons1__ArrayOfWorker(soap, (ns1__ArrayOfWorker *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnInfo:
		soap_serialize_PointerTons1__ReturnInfo(soap, (ns1__ReturnInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__User:
		soap_serialize_PointerTons1__User(soap, (ns1__User *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPayPublicTelItem:
		soap_serialize_PointerTons1__ArrayOfPayPublicTelItem(soap, (ns1__ArrayOfPayPublicTelItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPayGameItem:
		soap_serialize_PointerTons1__ArrayOfPayGameItem(soap, (ns1__ArrayOfPayGameItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPayInternetItem:
		soap_serialize_PointerTons1__ArrayOfPayInternetItem(soap, (ns1__ArrayOfPayInternetItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTransStaticsItem:
		soap_serialize_PointerTons1__ArrayOfTransStaticsItem(soap, (ns1__ArrayOfTransStaticsItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTransaction:
		soap_serialize_PointerTons1__ArrayOfTransaction(soap, (ns1__ArrayOfTransaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPaymentItem:
		soap_serialize_PointerTons1__ArrayOfPaymentItem(soap, (ns1__ArrayOfPaymentItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayWithListResult:
		soap_serialize_PointerTons1__PayWithListResult(soap, (ns1__PayWithListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__StockCardItem:
		soap_serialize_PointerToPointerTons1__StockCardItem(soap, (ns1__StockCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StockCardItem:
		soap_serialize_PointerTons1__StockCardItem(soap, (ns1__StockCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__OtherCardItem:
		soap_serialize_PointerToPointerTons1__OtherCardItem(soap, (ns1__OtherCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtherCardItem:
		soap_serialize_PointerTons1__OtherCardItem(soap, (ns1__OtherCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SellOtherCardItem:
		soap_serialize_PointerToPointerTons1__SellOtherCardItem(soap, (ns1__SellOtherCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellOtherCardItem:
		soap_serialize_PointerTons1__SellOtherCardItem(soap, (ns1__SellOtherCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__BusinessItem:
		soap_serialize_PointerToPointerTons1__BusinessItem(soap, (ns1__BusinessItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BusinessItem:
		soap_serialize_PointerTons1__BusinessItem(soap, (ns1__BusinessItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SellCardItem:
		soap_serialize_PointerToPointerTons1__SellCardItem(soap, (ns1__SellCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SellCardItem:
		soap_serialize_PointerTons1__SellCardItem(soap, (ns1__SellCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CardService:
		soap_serialize_PointerToPointerTons1__CardService(soap, (ns1__CardService **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CardService:
		soap_serialize_PointerTons1__CardService(soap, (ns1__CardService *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PayMiniCardItem:
		soap_serialize_PointerToPointerTons1__PayMiniCardItem(soap, (ns1__PayMiniCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayMiniCardItem:
		soap_serialize_PointerTons1__PayMiniCardItem(soap, (ns1__PayMiniCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MiniCardItem:
		soap_serialize_PointerToPointerTons1__MiniCardItem(soap, (ns1__MiniCardItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MiniCardItem:
		soap_serialize_PointerTons1__MiniCardItem(soap, (ns1__MiniCardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PhoneNoItem:
		soap_serialize_PointerToPointerTons1__PhoneNoItem(soap, (ns1__PhoneNoItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneNoItem:
		soap_serialize_PointerTons1__PhoneNoItem(soap, (ns1__PhoneNoItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPhoneNoItem:
		soap_serialize_PointerTons1__ArrayOfPhoneNoItem(soap, (ns1__ArrayOfPhoneNoItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CompanyAccount:
		soap_serialize_PointerToPointerTons1__CompanyAccount(soap, (ns1__CompanyAccount **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CompanyAccount:
		soap_serialize_PointerTons1__CompanyAccount(soap, (ns1__CompanyAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PhoneNumberBelong:
		soap_serialize_PointerToPointerTons1__PhoneNumberBelong(soap, (ns1__PhoneNumberBelong **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneNumberBelong:
		soap_serialize_PointerTons1__PhoneNumberBelong(soap, (ns1__PhoneNumberBelong *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ReturnProportion:
		soap_serialize_PointerToPointerTons1__ReturnProportion(soap, (ns1__ReturnProportion **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnProportion:
		soap_serialize_PointerTons1__ReturnProportion(soap, (ns1__ReturnProportion *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__NoticeItem:
		soap_serialize_PointerToPointerTons1__NoticeItem(soap, (ns1__NoticeItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoticeItem:
		soap_serialize_PointerTons1__NoticeItem(soap, (ns1__NoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfNoticeItem:
		soap_serialize_PointerTons1__ArrayOfNoticeItem(soap, (ns1__ArrayOfNoticeItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCORECategory:
		soap_serialize_PointerToPointerTons1__DIC_USCORECategory(soap, (ns1__DIC_USCORECategory **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DIC_USCORECategory:
		soap_serialize_PointerTons1__DIC_USCORECategory(soap, (ns1__DIC_USCORECategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DIC_USCOREContent:
		soap_serialize_PointerToPointerTons1__DIC_USCOREContent(soap, (ns1__DIC_USCOREContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DIC_USCOREContent:
		soap_serialize_PointerTons1__DIC_USCOREContent(soap, (ns1__DIC_USCOREContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AcountPaymentItem:
		soap_serialize_PointerToPointerTons1__AcountPaymentItem(soap, (ns1__AcountPaymentItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AcountPaymentItem:
		soap_serialize_PointerTons1__AcountPaymentItem(soap, (ns1__AcountPaymentItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ReturnedItem:
		soap_serialize_PointerToPointerTons1__ReturnedItem(soap, (ns1__ReturnedItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnedItem:
		soap_serialize_PointerTons1__ReturnedItem(soap, (ns1__ReturnedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SystemFunction:
		soap_serialize_PointerToPointerTons1__SystemFunction(soap, (ns1__SystemFunction **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SystemFunction:
		soap_serialize_PointerTons1__SystemFunction(soap, (ns1__SystemFunction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Worker:
		soap_serialize_PointerToPointerTons1__Worker(soap, (ns1__Worker **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Worker:
		soap_serialize_PointerTons1__Worker(soap, (ns1__Worker *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ReturnInfoItem:
		soap_serialize_PointerToPointerTons1__ReturnInfoItem(soap, (ns1__ReturnInfoItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnInfoItem:
		soap_serialize_PointerTons1__ReturnInfoItem(soap, (ns1__ReturnInfoItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfReturnInfoItem:
		soap_serialize_PointerTons1__ArrayOfReturnInfoItem(soap, (ns1__ArrayOfReturnInfoItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PayPublicTelItem:
		soap_serialize_PointerToPointerTons1__PayPublicTelItem(soap, (ns1__PayPublicTelItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayPublicTelItem:
		soap_serialize_PointerTons1__PayPublicTelItem(soap, (ns1__PayPublicTelItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PayGameItem:
		soap_serialize_PointerToPointerTons1__PayGameItem(soap, (ns1__PayGameItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayGameItem:
		soap_serialize_PointerTons1__PayGameItem(soap, (ns1__PayGameItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PayInternetItem:
		soap_serialize_PointerToPointerTons1__PayInternetItem(soap, (ns1__PayInternetItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayInternetItem:
		soap_serialize_PointerTons1__PayInternetItem(soap, (ns1__PayInternetItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TransStaticsItem:
		soap_serialize_PointerToPointerTons1__TransStaticsItem(soap, (ns1__TransStaticsItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TransStaticsItem:
		soap_serialize_PointerTons1__TransStaticsItem(soap, (ns1__TransStaticsItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Transaction:
		soap_serialize_PointerToPointerTons1__Transaction(soap, (ns1__Transaction **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Transaction:
		soap_serialize_PointerTons1__Transaction(soap, (ns1__Transaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PaymentItem:
		soap_serialize_PointerToPointerTons1__PaymentItem(soap, (ns1__PaymentItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PaymentItem:
		soap_serialize_PointerTons1__PaymentItem(soap, (ns1__PaymentItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PayWithListItem:
		soap_serialize_PointerToPointerTons1__PayWithListItem(soap, (ns1__PayWithListItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PayWithListItem:
		soap_serialize_PointerTons1__PayWithListItem(soap, (ns1__PayWithListItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPayWithListItem:
		soap_serialize_PointerTons1__ArrayOfPayWithListItem(soap, (ns1__ArrayOfPayWithListItem *const*)ptr);
		break;
	case SOAP_TYPE_ns2__guid:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__PayWithListResult:
		return (void*)soap_instantiate_ns1__PayWithListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPayWithListItem:
		return (void*)soap_instantiate_ns1__ArrayOfPayWithListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PayWithListItem:
		return (void*)soap_instantiate_ns1__PayWithListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPaymentItem:
		return (void*)soap_instantiate_ns1__ArrayOfPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PaymentItem:
		return (void*)soap_instantiate_ns1__PaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfTransaction:
		return (void*)soap_instantiate_ns1__ArrayOfTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Transaction:
		return (void*)soap_instantiate_ns1__Transaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfTransStaticsItem:
		return (void*)soap_instantiate_ns1__ArrayOfTransStaticsItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TransStaticsItem:
		return (void*)soap_instantiate_ns1__TransStaticsItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPayInternetItem:
		return (void*)soap_instantiate_ns1__ArrayOfPayInternetItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PayInternetItem:
		return (void*)soap_instantiate_ns1__PayInternetItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPayGameItem:
		return (void*)soap_instantiate_ns1__ArrayOfPayGameItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PayGameItem:
		return (void*)soap_instantiate_ns1__PayGameItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPayPublicTelItem:
		return (void*)soap_instantiate_ns1__ArrayOfPayPublicTelItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PayPublicTelItem:
		return (void*)soap_instantiate_ns1__PayPublicTelItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__User:
		return (void*)soap_instantiate_ns1__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnInfo:
		return (void*)soap_instantiate_ns1__ReturnInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfReturnInfoItem:
		return (void*)soap_instantiate_ns1__ArrayOfReturnInfoItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnInfoItem:
		return (void*)soap_instantiate_ns1__ReturnInfoItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfWorker:
		return (void*)soap_instantiate_ns1__ArrayOfWorker(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Worker:
		return (void*)soap_instantiate_ns1__Worker(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSystemFunction:
		return (void*)soap_instantiate_ns1__ArrayOfSystemFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SystemFunction:
		return (void*)soap_instantiate_ns1__SystemFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfReturnedItem:
		return (void*)soap_instantiate_ns1__ArrayOfReturnedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnedItem:
		return (void*)soap_instantiate_ns1__ReturnedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAcountPaymentItem:
		return (void*)soap_instantiate_ns1__ArrayOfAcountPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AcountPaymentItem:
		return (void*)soap_instantiate_ns1__AcountPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent:
		return (void*)soap_instantiate_ns1__ArrayOfDIC_USCOREContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DIC_USCOREContent:
		return (void*)soap_instantiate_ns1__DIC_USCOREContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory:
		return (void*)soap_instantiate_ns1__ArrayOfDIC_USCORECategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DIC_USCORECategory:
		return (void*)soap_instantiate_ns1__DIC_USCORECategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TableStatistics:
		return (void*)soap_instantiate_ns1__TableStatistics(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Notice:
		return (void*)soap_instantiate_ns1__Notice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfNoticeItem:
		return (void*)soap_instantiate_ns1__ArrayOfNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoticeItem:
		return (void*)soap_instantiate_ns1__NoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfReturnProportion:
		return (void*)soap_instantiate_ns1__ArrayOfReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnProportion:
		return (void*)soap_instantiate_ns1__ReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong:
		return (void*)soap_instantiate_ns1__ArrayOfPhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneNumberBelong:
		return (void*)soap_instantiate_ns1__PhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CompanyInfo:
		return (void*)soap_instantiate_ns1__CompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfCompanyAccount:
		return (void*)soap_instantiate_ns1__ArrayOfCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CompanyAccount:
		return (void*)soap_instantiate_ns1__CompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Result:
		return (void*)soap_instantiate_ns1__Result(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneNoList:
		return (void*)soap_instantiate_ns1__PhoneNoList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPhoneNoItem:
		return (void*)soap_instantiate_ns1__ArrayOfPhoneNoItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneNoItem:
		return (void*)soap_instantiate_ns1__PhoneNoItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfMiniCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfMiniCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MiniCardItem:
		return (void*)soap_instantiate_ns1__MiniCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPayMiniCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfPayMiniCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PayMiniCardItem:
		return (void*)soap_instantiate_ns1__PayMiniCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfCardService:
		return (void*)soap_instantiate_ns1__ArrayOfCardService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CardService:
		return (void*)soap_instantiate_ns1__CardService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSellCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfSellCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellCardItem:
		return (void*)soap_instantiate_ns1__SellCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfBusinessItem:
		return (void*)soap_instantiate_ns1__ArrayOfBusinessItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BusinessItem:
		return (void*)soap_instantiate_ns1__BusinessItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSellOtherCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfSellOtherCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SellOtherCardItem:
		return (void*)soap_instantiate_ns1__SellOtherCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfOtherCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfOtherCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OtherCardItem:
		return (void*)soap_instantiate_ns1__OtherCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfStockCardItem:
		return (void*)soap_instantiate_ns1__ArrayOfStockCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StockCardItem:
		return (void*)soap_instantiate_ns1__StockCardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLocation:
		return (void*)soap_instantiate__ns1__GetLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLocationResponse:
		return (void*)soap_instantiate__ns1__GetLocationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayMoney:
		return (void*)soap_instantiate__ns1__PayMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayMoneyResponse:
		return (void*)soap_instantiate__ns1__PayMoneyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayMoneyWithList:
		return (void*)soap_instantiate__ns1__PayMoneyWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayMoneyWithListResponse:
		return (void*)soap_instantiate__ns1__PayMoneyWithListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RequstRollback:
		return (void*)soap_instantiate__ns1__RequstRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RequstRollbackResponse:
		return (void*)soap_instantiate__ns1__RequstRollbackResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayInternet:
		return (void*)soap_instantiate__ns1__PayInternet(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayInternetResponse:
		return (void*)soap_instantiate__ns1__PayInternetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayInternetWithList:
		return (void*)soap_instantiate__ns1__PayInternetWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayInternetWithListResponse:
		return (void*)soap_instantiate__ns1__PayInternetWithListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RequstInternetRollback:
		return (void*)soap_instantiate__ns1__RequstInternetRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RequstInternetRollbackResponse:
		return (void*)soap_instantiate__ns1__RequstInternetRollbackResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayGame:
		return (void*)soap_instantiate__ns1__PayGame(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayGameResponse:
		return (void*)soap_instantiate__ns1__PayGameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayPublicTel:
		return (void*)soap_instantiate__ns1__PayPublicTel(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PayPublicTelResponse:
		return (void*)soap_instantiate__ns1__PayPublicTelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentRecord:
		return (void*)soap_instantiate__ns1__GetPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentRecordResponse:
		return (void*)soap_instantiate__ns1__GetPaymentRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentItem:
		return (void*)soap_instantiate__ns1__GetPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentItemResponse:
		return (void*)soap_instantiate__ns1__GetPaymentItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTransactionByCondition:
		return (void*)soap_instantiate__ns1__GetTransactionByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTransactionByConditionResponse:
		return (void*)soap_instantiate__ns1__GetTransactionByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTransactionStaticsByCondition:
		return (void*)soap_instantiate__ns1__GetTransactionStaticsByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse:
		return (void*)soap_instantiate__ns1__GetTransactionStaticsByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPaymentOrPaymentHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayInternetByCondition:
		return (void*)soap_instantiate__ns1__GetPayInternetByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayInternetByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayInternetByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayInternetHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPayInternetHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayInternetHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayGameByCondition:
		return (void*)soap_instantiate__ns1__GetPayGameByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayGameByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayGameByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayGameHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPayGameHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayGameHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayPublicTelByCondition:
		return (void*)soap_instantiate__ns1__GetPayPublicTelByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayPublicTelByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPayPublicTelHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayPublicTelHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorld:
		return (void*)soap_instantiate__ns1__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return (void*)soap_instantiate__ns1__HelloWorldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loggout:
		return (void*)soap_instantiate__ns1__loggout(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loggoutResponse:
		return (void*)soap_instantiate__ns1__loggoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TestLogin:
		return (void*)soap_instantiate__ns1__TestLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TestLoginResponse:
		return (void*)soap_instantiate__ns1__TestLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserInfo:
		return (void*)soap_instantiate__ns1__GetUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserInfoResponse:
		return (void*)soap_instantiate__ns1__GetUserInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RegisterUser:
		return (void*)soap_instantiate__ns1__RegisterUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RegisterUserResponse:
		return (void*)soap_instantiate__ns1__RegisterUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterPsw:
		return (void*)soap_instantiate__ns1__AlterPsw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterPswResponse:
		return (void*)soap_instantiate__ns1__AlterPswResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterUserInfo:
		return (void*)soap_instantiate__ns1__AlterUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterUserInfoResponse:
		return (void*)soap_instantiate__ns1__AlterUserInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddAcountPayment:
		return (void*)soap_instantiate__ns1__AddAcountPayment(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddAcountPaymentResponse:
		return (void*)soap_instantiate__ns1__AddAcountPaymentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnInfo:
		return (void*)soap_instantiate__ns1__GetReturnInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnInfoResponse:
		return (void*)soap_instantiate__ns1__GetReturnInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CharegeReturnedMoney:
		return (void*)soap_instantiate__ns1__CharegeReturnedMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CharegeReturnedMoneyResponse:
		return (void*)soap_instantiate__ns1__CharegeReturnedMoneyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWorkNameList:
		return (void*)soap_instantiate__ns1__GetWorkNameList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWorkNameListResponse:
		return (void*)soap_instantiate__ns1__GetWorkNameListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserFunction:
		return (void*)soap_instantiate__ns1__GetUserFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserFunctionResponse:
		return (void*)soap_instantiate__ns1__GetUserFunctionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnRecord:
		return (void*)soap_instantiate__ns1__GetReturnRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnRecordResponse:
		return (void*)soap_instantiate__ns1__GetReturnRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnRecordDeal:
		return (void*)soap_instantiate__ns1__GetReturnRecordDeal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnRecordDealResponse:
		return (void*)soap_instantiate__ns1__GetReturnRecordDealResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAcountPaymentRecord:
		return (void*)soap_instantiate__ns1__GetAcountPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAcountPaymentRecordResponse:
		return (void*)soap_instantiate__ns1__GetAcountPaymentRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDicContentByCondition:
		return (void*)soap_instantiate__ns1__GetDicContentByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDicContentByConditionResponse:
		return (void*)soap_instantiate__ns1__GetDicContentByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCategory:
		return (void*)soap_instantiate__ns1__GetAllCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCategoryResponse:
		return (void*)soap_instantiate__ns1__GetAllCategoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertDicContent:
		return (void*)soap_instantiate__ns1__InsertDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertDicContentResponse:
		return (void*)soap_instantiate__ns1__InsertDicContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDicContent:
		return (void*)soap_instantiate__ns1__UpdateDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDicContentResponse:
		return (void*)soap_instantiate__ns1__UpdateDicContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteDicContent:
		return (void*)soap_instantiate__ns1__DeleteDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteDicContentResponse:
		return (void*)soap_instantiate__ns1__DeleteDicContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDicContentByCategory:
		return (void*)soap_instantiate__ns1__UpdateDicContentByCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse:
		return (void*)soap_instantiate__ns1__UpdateDicContentByCategoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFunctionList:
		return (void*)soap_instantiate__ns1__GetFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFunctionListResponse:
		return (void*)soap_instantiate__ns1__GetFunctionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateUserFunctionList:
		return (void*)soap_instantiate__ns1__UpdateUserFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateUserFunctionListResponse:
		return (void*)soap_instantiate__ns1__UpdateUserFunctionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateFunctionRight:
		return (void*)soap_instantiate__ns1__UpdateFunctionRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateFunctionRightResponse:
		return (void*)soap_instantiate__ns1__UpdateFunctionRightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTableStatistics:
		return (void*)soap_instantiate__ns1__GetTableStatistics(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTableStatisticsResponse:
		return (void*)soap_instantiate__ns1__GetTableStatisticsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeList:
		return (void*)soap_instantiate__ns1__GetNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeListResponse:
		return (void*)soap_instantiate__ns1__GetNoticeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeListByCondition:
		return (void*)soap_instantiate__ns1__GetNoticeListByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeListByConditionResponse:
		return (void*)soap_instantiate__ns1__GetNoticeListByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeItem:
		return (void*)soap_instantiate__ns1__GetNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetNoticeItemResponse:
		return (void*)soap_instantiate__ns1__GetNoticeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlertNoticeList:
		return (void*)soap_instantiate__ns1__GetAlertNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlertNoticeListResponse:
		return (void*)soap_instantiate__ns1__GetAlertNoticeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddNoticeItem:
		return (void*)soap_instantiate__ns1__AddNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddNoticeItemResponse:
		return (void*)soap_instantiate__ns1__AddNoticeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddNoticeItemToSomeone:
		return (void*)soap_instantiate__ns1__AddNoticeItemToSomeone(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse:
		return (void*)soap_instantiate__ns1__AddNoticeItemToSomeoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateNoticeItem:
		return (void*)soap_instantiate__ns1__UpdateNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateNoticeItemResponse:
		return (void*)soap_instantiate__ns1__UpdateNoticeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteNoticeItem:
		return (void*)soap_instantiate__ns1__DeleteNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteNoticeItemResponse:
		return (void*)soap_instantiate__ns1__DeleteNoticeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InserNoticeToSomeOne:
		return (void*)soap_instantiate__ns1__InserNoticeToSomeOne(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InserNoticeToSomeOneResponse:
		return (void*)soap_instantiate__ns1__InserNoticeToSomeOneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnProportionRecord:
		return (void*)soap_instantiate__ns1__GetReturnProportionRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReturnProportionRecordResponse:
		return (void*)soap_instantiate__ns1__GetReturnProportionRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddtReturnProportion:
		return (void*)soap_instantiate__ns1__AddtReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddtReturnProportionResponse:
		return (void*)soap_instantiate__ns1__AddtReturnProportionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatetReturnProportion:
		return (void*)soap_instantiate__ns1__UpdatetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatetReturnProportionResponse:
		return (void*)soap_instantiate__ns1__UpdatetReturnProportionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeletetReturnProportion:
		return (void*)soap_instantiate__ns1__DeletetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeletetReturnProportionResponse:
		return (void*)soap_instantiate__ns1__DeletetReturnProportionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition:
		return (void*)soap_instantiate__ns1__GetPhoneNumberBelongByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPhoneNumberBelongByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelong:
		return (void*)soap_instantiate__ns1__UpdatePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse:
		return (void*)soap_instantiate__ns1__UpdatePhoneNumberBelongResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPhoneNumberBelong:
		return (void*)soap_instantiate__ns1__AddPhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPhoneNumberBelongResponse:
		return (void*)soap_instantiate__ns1__AddPhoneNumberBelongResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeletePhoneNumberBelong:
		return (void*)soap_instantiate__ns1__DeletePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse:
		return (void*)soap_instantiate__ns1__DeletePhoneNumberBelongResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCompanyInfo:
		return (void*)soap_instantiate__ns1__GetCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCompanyInfoResponse:
		return (void*)soap_instantiate__ns1__GetCompanyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateCompanyInfo:
		return (void*)soap_instantiate__ns1__UpdateCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateCompanyInfoResponse:
		return (void*)soap_instantiate__ns1__UpdateCompanyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCompanyAccount:
		return (void*)soap_instantiate__ns1__GetCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCompanyAccountResponse:
		return (void*)soap_instantiate__ns1__GetCompanyAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddCompanyAccount:
		return (void*)soap_instantiate__ns1__AddCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddCompanyAccountResponse:
		return (void*)soap_instantiate__ns1__AddCompanyAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateCompanyAccount:
		return (void*)soap_instantiate__ns1__UpdateCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateCompanyAccountResponse:
		return (void*)soap_instantiate__ns1__UpdateCompanyAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteCompanyAccount:
		return (void*)soap_instantiate__ns1__DeleteCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteCompanyAccountResponse:
		return (void*)soap_instantiate__ns1__DeleteCompanyAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClientVersion:
		return (void*)soap_instantiate__ns1__GetClientVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClientVersionResponse:
		return (void*)soap_instantiate__ns1__GetClientVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__queryPhoneNOInfo:
		return (void*)soap_instantiate__ns1__queryPhoneNOInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__queryPhoneNOInfoResponse:
		return (void*)soap_instantiate__ns1__queryPhoneNOInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BuyMiniCard:
		return (void*)soap_instantiate__ns1__BuyMiniCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BuyMiniCardResponse:
		return (void*)soap_instantiate__ns1__BuyMiniCardResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoByCondition:
		return (void*)soap_instantiate__ns1__GetPhoneNoByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPhoneNoByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMyNoSection:
		return (void*)soap_instantiate__ns1__GetMyNoSection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMyNoSectionResponse:
		return (void*)soap_instantiate__ns1__GetMyNoSectionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LockNo:
		return (void*)soap_instantiate__ns1__LockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LockNoResponse:
		return (void*)soap_instantiate__ns1__LockNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnlockNo:
		return (void*)soap_instantiate__ns1__UnlockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnlockNoResponse:
		return (void*)soap_instantiate__ns1__UnlockNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubmitBusiness:
		return (void*)soap_instantiate__ns1__SubmitBusiness(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubmitBusinessResponse:
		return (void*)soap_instantiate__ns1__SubmitBusinessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SellNo:
		return (void*)soap_instantiate__ns1__SellNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SellNoResponse:
		return (void*)soap_instantiate__ns1__SellNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SellOhterCard:
		return (void*)soap_instantiate__ns1__SellOhterCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SellOhterCardResponse:
		return (void*)soap_instantiate__ns1__SellOhterCardResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMiniCardRecord:
		return (void*)soap_instantiate__ns1__GetMiniCardRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMiniCardRecordResponse:
		return (void*)soap_instantiate__ns1__GetMiniCardRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayMiniCardByCondition:
		return (void*)soap_instantiate__ns1__GetPayMiniCardByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayMiniCardByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPayMiniCardHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPayMiniCardHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoItemByCondition:
		return (void*)soap_instantiate__ns1__GetPhoneNoItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPhoneNoItemByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetPhoneNoItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCardService:
		return (void*)soap_instantiate__ns1__GetCardService(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCardServiceResponse:
		return (void*)soap_instantiate__ns1__GetCardServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellCardRecordByCondition:
		return (void*)soap_instantiate__ns1__GetSellCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse:
		return (void*)soap_instantiate__ns1__GetSellCardRecordByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetSellCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetSellCardRecordHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBusinessRecordByCondition:
		return (void*)soap_instantiate__ns1__GetBusinessRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse:
		return (void*)soap_instantiate__ns1__GetBusinessRecordByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition:
		return (void*)soap_instantiate__ns1__GettBusinessRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GettBusinessRecordHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition:
		return (void*)soap_instantiate__ns1__GetSellOtherCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse:
		return (void*)soap_instantiate__ns1__GetSellOtherCardRecordByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition:
		return (void*)soap_instantiate__ns1__GettSellOtherCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherCardList:
		return (void*)soap_instantiate__ns1__GetOtherCardList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherCardListResponse:
		return (void*)soap_instantiate__ns1__GetOtherCardListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStockCardItemByCondition:
		return (void*)soap_instantiate__ns1__GetStockCardItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStockCardItemByConditionResponse:
		return (void*)soap_instantiate__ns1__GetStockCardItemByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition:
		return (void*)soap_instantiate__ns1__GetStockCardItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse:
		return (void*)soap_instantiate__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns10__queryPhoneNOInfo:
		return (void*)soap_instantiate___ns10__queryPhoneNOInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__queryPhoneNOInfo:
		return (void*)soap_instantiate___ns11__queryPhoneNOInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns12__queryPhoneNOInfo:
		return (void*)soap_instantiate___ns12__queryPhoneNOInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__BuyMiniCard:
		return (void*)soap_instantiate___ns13__BuyMiniCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetPhoneNoByCondition:
		return (void*)soap_instantiate___ns13__GetPhoneNoByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetMyNoSection:
		return (void*)soap_instantiate___ns13__GetMyNoSection(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__LockNo:
		return (void*)soap_instantiate___ns13__LockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__UnlockNo:
		return (void*)soap_instantiate___ns13__UnlockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__SubmitBusiness:
		return (void*)soap_instantiate___ns13__SubmitBusiness(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__SellNo:
		return (void*)soap_instantiate___ns13__SellNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__SellOhterCard:
		return (void*)soap_instantiate___ns13__SellOhterCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetMiniCardRecord:
		return (void*)soap_instantiate___ns13__GetMiniCardRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetPayMiniCardByCondition:
		return (void*)soap_instantiate___ns13__GetPayMiniCardByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetPayMiniCardHistoryByCondition:
		return (void*)soap_instantiate___ns13__GetPayMiniCardHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetPhoneNoItemByCondition:
		return (void*)soap_instantiate___ns13__GetPhoneNoItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetPhoneNoItemAndHistoryByCondition:
		return (void*)soap_instantiate___ns13__GetPhoneNoItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetCardService:
		return (void*)soap_instantiate___ns13__GetCardService(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetSellCardRecordByCondition:
		return (void*)soap_instantiate___ns13__GetSellCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetSellCardRecordHistoryByCondition:
		return (void*)soap_instantiate___ns13__GetSellCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetBusinessRecordByCondition:
		return (void*)soap_instantiate___ns13__GetBusinessRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GettBusinessRecordHistoryByCondition:
		return (void*)soap_instantiate___ns13__GettBusinessRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetSellOtherCardRecordByCondition:
		return (void*)soap_instantiate___ns13__GetSellOtherCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GettSellOtherCardRecordHistoryByCondition:
		return (void*)soap_instantiate___ns13__GettSellOtherCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetOtherCardList:
		return (void*)soap_instantiate___ns13__GetOtherCardList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetStockCardItemByCondition:
		return (void*)soap_instantiate___ns13__GetStockCardItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetStockCardItemAndHistoryByCondition:
		return (void*)soap_instantiate___ns13__GetStockCardItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__BuyMiniCard:
		return (void*)soap_instantiate___ns14__BuyMiniCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetPhoneNoByCondition:
		return (void*)soap_instantiate___ns14__GetPhoneNoByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetMyNoSection:
		return (void*)soap_instantiate___ns14__GetMyNoSection(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__LockNo:
		return (void*)soap_instantiate___ns14__LockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__UnlockNo:
		return (void*)soap_instantiate___ns14__UnlockNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__SubmitBusiness:
		return (void*)soap_instantiate___ns14__SubmitBusiness(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__SellNo:
		return (void*)soap_instantiate___ns14__SellNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__SellOhterCard:
		return (void*)soap_instantiate___ns14__SellOhterCard(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetMiniCardRecord:
		return (void*)soap_instantiate___ns14__GetMiniCardRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetPayMiniCardByCondition:
		return (void*)soap_instantiate___ns14__GetPayMiniCardByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetPayMiniCardHistoryByCondition:
		return (void*)soap_instantiate___ns14__GetPayMiniCardHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetPhoneNoItemByCondition:
		return (void*)soap_instantiate___ns14__GetPhoneNoItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetPhoneNoItemAndHistoryByCondition:
		return (void*)soap_instantiate___ns14__GetPhoneNoItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetCardService:
		return (void*)soap_instantiate___ns14__GetCardService(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetSellCardRecordByCondition:
		return (void*)soap_instantiate___ns14__GetSellCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetSellCardRecordHistoryByCondition:
		return (void*)soap_instantiate___ns14__GetSellCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetBusinessRecordByCondition:
		return (void*)soap_instantiate___ns14__GetBusinessRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GettBusinessRecordHistoryByCondition:
		return (void*)soap_instantiate___ns14__GettBusinessRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetSellOtherCardRecordByCondition:
		return (void*)soap_instantiate___ns14__GetSellOtherCardRecordByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GettSellOtherCardRecordHistoryByCondition:
		return (void*)soap_instantiate___ns14__GettSellOtherCardRecordHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetOtherCardList:
		return (void*)soap_instantiate___ns14__GetOtherCardList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetStockCardItemByCondition:
		return (void*)soap_instantiate___ns14__GetStockCardItemByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns14__GetStockCardItemAndHistoryByCondition:
		return (void*)soap_instantiate___ns14__GetStockCardItemAndHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetLocation:
		return (void*)soap_instantiate___ns3__GetLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayMoney:
		return (void*)soap_instantiate___ns3__PayMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayMoneyWithList:
		return (void*)soap_instantiate___ns3__PayMoneyWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__RequstRollback:
		return (void*)soap_instantiate___ns3__RequstRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayInternet:
		return (void*)soap_instantiate___ns3__PayInternet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayInternetWithList:
		return (void*)soap_instantiate___ns3__PayInternetWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__RequstInternetRollback:
		return (void*)soap_instantiate___ns3__RequstInternetRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayGame:
		return (void*)soap_instantiate___ns3__PayGame(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PayPublicTel:
		return (void*)soap_instantiate___ns3__PayPublicTel(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPaymentRecord:
		return (void*)soap_instantiate___ns3__GetPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPaymentItem:
		return (void*)soap_instantiate___ns3__GetPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetTransactionByCondition:
		return (void*)soap_instantiate___ns3__GetTransactionByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetTransactionStaticsByCondition:
		return (void*)soap_instantiate___ns3__GetTransactionStaticsByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPaymentOrPaymentHistoryByCondition:
		return (void*)soap_instantiate___ns3__GetPaymentOrPaymentHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayInternetByCondition:
		return (void*)soap_instantiate___ns3__GetPayInternetByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayInternetHistoryByCondition:
		return (void*)soap_instantiate___ns3__GetPayInternetHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayGameByCondition:
		return (void*)soap_instantiate___ns3__GetPayGameByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayGameHistoryByCondition:
		return (void*)soap_instantiate___ns3__GetPayGameHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayPublicTelByCondition:
		return (void*)soap_instantiate___ns3__GetPayPublicTelByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPayPublicTelHistoryByCondition:
		return (void*)soap_instantiate___ns3__GetPayPublicTelHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetLocation:
		return (void*)soap_instantiate___ns4__GetLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayMoney:
		return (void*)soap_instantiate___ns4__PayMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayMoneyWithList:
		return (void*)soap_instantiate___ns4__PayMoneyWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__RequstRollback:
		return (void*)soap_instantiate___ns4__RequstRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayInternet:
		return (void*)soap_instantiate___ns4__PayInternet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayInternetWithList:
		return (void*)soap_instantiate___ns4__PayInternetWithList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__RequstInternetRollback:
		return (void*)soap_instantiate___ns4__RequstInternetRollback(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayGame:
		return (void*)soap_instantiate___ns4__PayGame(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__PayPublicTel:
		return (void*)soap_instantiate___ns4__PayPublicTel(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPaymentRecord:
		return (void*)soap_instantiate___ns4__GetPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPaymentItem:
		return (void*)soap_instantiate___ns4__GetPaymentItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetTransactionByCondition:
		return (void*)soap_instantiate___ns4__GetTransactionByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetTransactionStaticsByCondition:
		return (void*)soap_instantiate___ns4__GetTransactionStaticsByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPaymentOrPaymentHistoryByCondition:
		return (void*)soap_instantiate___ns4__GetPaymentOrPaymentHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayInternetByCondition:
		return (void*)soap_instantiate___ns4__GetPayInternetByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayInternetHistoryByCondition:
		return (void*)soap_instantiate___ns4__GetPayInternetHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayGameByCondition:
		return (void*)soap_instantiate___ns4__GetPayGameByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayGameHistoryByCondition:
		return (void*)soap_instantiate___ns4__GetPayGameHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayPublicTelByCondition:
		return (void*)soap_instantiate___ns4__GetPayPublicTelByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetPayPublicTelHistoryByCondition:
		return (void*)soap_instantiate___ns4__GetPayPublicTelHistoryByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__HelloWorld:
		return (void*)soap_instantiate___ns5__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__loggout:
		return (void*)soap_instantiate___ns5__loggout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__TestLogin:
		return (void*)soap_instantiate___ns5__TestLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetUserInfo:
		return (void*)soap_instantiate___ns5__GetUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__RegisterUser:
		return (void*)soap_instantiate___ns5__RegisterUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AlterPsw:
		return (void*)soap_instantiate___ns5__AlterPsw(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AlterUserInfo:
		return (void*)soap_instantiate___ns5__AlterUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AddAcountPayment:
		return (void*)soap_instantiate___ns5__AddAcountPayment(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetReturnInfo:
		return (void*)soap_instantiate___ns5__GetReturnInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__CharegeReturnedMoney:
		return (void*)soap_instantiate___ns5__CharegeReturnedMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetWorkNameList:
		return (void*)soap_instantiate___ns5__GetWorkNameList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetUserFunction:
		return (void*)soap_instantiate___ns5__GetUserFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetReturnRecord:
		return (void*)soap_instantiate___ns5__GetReturnRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetReturnRecordDeal:
		return (void*)soap_instantiate___ns5__GetReturnRecordDeal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetAcountPaymentRecord:
		return (void*)soap_instantiate___ns5__GetAcountPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__HelloWorld:
		return (void*)soap_instantiate___ns6__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__loggout:
		return (void*)soap_instantiate___ns6__loggout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__TestLogin:
		return (void*)soap_instantiate___ns6__TestLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetUserInfo:
		return (void*)soap_instantiate___ns6__GetUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__RegisterUser:
		return (void*)soap_instantiate___ns6__RegisterUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__AlterPsw:
		return (void*)soap_instantiate___ns6__AlterPsw(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__AlterUserInfo:
		return (void*)soap_instantiate___ns6__AlterUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__AddAcountPayment:
		return (void*)soap_instantiate___ns6__AddAcountPayment(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetReturnInfo:
		return (void*)soap_instantiate___ns6__GetReturnInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__CharegeReturnedMoney:
		return (void*)soap_instantiate___ns6__CharegeReturnedMoney(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetWorkNameList:
		return (void*)soap_instantiate___ns6__GetWorkNameList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetUserFunction:
		return (void*)soap_instantiate___ns6__GetUserFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetReturnRecord:
		return (void*)soap_instantiate___ns6__GetReturnRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetReturnRecordDeal:
		return (void*)soap_instantiate___ns6__GetReturnRecordDeal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__GetAcountPaymentRecord:
		return (void*)soap_instantiate___ns6__GetAcountPaymentRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetDicContentByCondition:
		return (void*)soap_instantiate___ns7__GetDicContentByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetAllCategory:
		return (void*)soap_instantiate___ns7__GetAllCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__InsertDicContent:
		return (void*)soap_instantiate___ns7__InsertDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateDicContent:
		return (void*)soap_instantiate___ns7__UpdateDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__DeleteDicContent:
		return (void*)soap_instantiate___ns7__DeleteDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateDicContentByCategory:
		return (void*)soap_instantiate___ns7__UpdateDicContentByCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetFunctionList:
		return (void*)soap_instantiate___ns7__GetFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateUserFunctionList:
		return (void*)soap_instantiate___ns7__UpdateUserFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateFunctionRight:
		return (void*)soap_instantiate___ns7__UpdateFunctionRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetTableStatistics:
		return (void*)soap_instantiate___ns7__GetTableStatistics(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetNoticeList:
		return (void*)soap_instantiate___ns7__GetNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetNoticeListByCondition:
		return (void*)soap_instantiate___ns7__GetNoticeListByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetNoticeItem:
		return (void*)soap_instantiate___ns7__GetNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetAlertNoticeList:
		return (void*)soap_instantiate___ns7__GetAlertNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AddNoticeItem:
		return (void*)soap_instantiate___ns7__AddNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AddNoticeItemToSomeone:
		return (void*)soap_instantiate___ns7__AddNoticeItemToSomeone(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateNoticeItem:
		return (void*)soap_instantiate___ns7__UpdateNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__DeleteNoticeItem:
		return (void*)soap_instantiate___ns7__DeleteNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__InserNoticeToSomeOne:
		return (void*)soap_instantiate___ns7__InserNoticeToSomeOne(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetReturnProportionRecord:
		return (void*)soap_instantiate___ns7__GetReturnProportionRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AddtReturnProportion:
		return (void*)soap_instantiate___ns7__AddtReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdatetReturnProportion:
		return (void*)soap_instantiate___ns7__UpdatetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__DeletetReturnProportion:
		return (void*)soap_instantiate___ns7__DeletetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetPhoneNumberBelongByCondition:
		return (void*)soap_instantiate___ns7__GetPhoneNumberBelongByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdatePhoneNumberBelong:
		return (void*)soap_instantiate___ns7__UpdatePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AddPhoneNumberBelong:
		return (void*)soap_instantiate___ns7__AddPhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__DeletePhoneNumberBelong:
		return (void*)soap_instantiate___ns7__DeletePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetCompanyInfo:
		return (void*)soap_instantiate___ns7__GetCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateCompanyInfo:
		return (void*)soap_instantiate___ns7__UpdateCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetCompanyAccount:
		return (void*)soap_instantiate___ns7__GetCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AddCompanyAccount:
		return (void*)soap_instantiate___ns7__AddCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UpdateCompanyAccount:
		return (void*)soap_instantiate___ns7__UpdateCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__DeleteCompanyAccount:
		return (void*)soap_instantiate___ns7__DeleteCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__GetClientVersion:
		return (void*)soap_instantiate___ns7__GetClientVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetDicContentByCondition:
		return (void*)soap_instantiate___ns8__GetDicContentByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetAllCategory:
		return (void*)soap_instantiate___ns8__GetAllCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__InsertDicContent:
		return (void*)soap_instantiate___ns8__InsertDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateDicContent:
		return (void*)soap_instantiate___ns8__UpdateDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__DeleteDicContent:
		return (void*)soap_instantiate___ns8__DeleteDicContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateDicContentByCategory:
		return (void*)soap_instantiate___ns8__UpdateDicContentByCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetFunctionList:
		return (void*)soap_instantiate___ns8__GetFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateUserFunctionList:
		return (void*)soap_instantiate___ns8__UpdateUserFunctionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateFunctionRight:
		return (void*)soap_instantiate___ns8__UpdateFunctionRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetTableStatistics:
		return (void*)soap_instantiate___ns8__GetTableStatistics(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetNoticeList:
		return (void*)soap_instantiate___ns8__GetNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetNoticeListByCondition:
		return (void*)soap_instantiate___ns8__GetNoticeListByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetNoticeItem:
		return (void*)soap_instantiate___ns8__GetNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetAlertNoticeList:
		return (void*)soap_instantiate___ns8__GetAlertNoticeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AddNoticeItem:
		return (void*)soap_instantiate___ns8__AddNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AddNoticeItemToSomeone:
		return (void*)soap_instantiate___ns8__AddNoticeItemToSomeone(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateNoticeItem:
		return (void*)soap_instantiate___ns8__UpdateNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__DeleteNoticeItem:
		return (void*)soap_instantiate___ns8__DeleteNoticeItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__InserNoticeToSomeOne:
		return (void*)soap_instantiate___ns8__InserNoticeToSomeOne(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetReturnProportionRecord:
		return (void*)soap_instantiate___ns8__GetReturnProportionRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AddtReturnProportion:
		return (void*)soap_instantiate___ns8__AddtReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdatetReturnProportion:
		return (void*)soap_instantiate___ns8__UpdatetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__DeletetReturnProportion:
		return (void*)soap_instantiate___ns8__DeletetReturnProportion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetPhoneNumberBelongByCondition:
		return (void*)soap_instantiate___ns8__GetPhoneNumberBelongByCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdatePhoneNumberBelong:
		return (void*)soap_instantiate___ns8__UpdatePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AddPhoneNumberBelong:
		return (void*)soap_instantiate___ns8__AddPhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__DeletePhoneNumberBelong:
		return (void*)soap_instantiate___ns8__DeletePhoneNumberBelong(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetCompanyInfo:
		return (void*)soap_instantiate___ns8__GetCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateCompanyInfo:
		return (void*)soap_instantiate___ns8__UpdateCompanyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetCompanyAccount:
		return (void*)soap_instantiate___ns8__GetCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AddCompanyAccount:
		return (void*)soap_instantiate___ns8__AddCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__UpdateCompanyAccount:
		return (void*)soap_instantiate___ns8__UpdateCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__DeleteCompanyAccount:
		return (void*)soap_instantiate___ns8__DeleteCompanyAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__GetClientVersion:
		return (void*)soap_instantiate___ns8__GetClientVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__queryPhoneNOInfo:
		return (void*)soap_instantiate___ns9__queryPhoneNOInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__PayWithListResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayWithListResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayWithListResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayWithListItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPayWithListItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPayWithListItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PayWithListItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayWithListItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayWithListItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PaymentItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PaymentItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTransaction:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfTransaction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfTransaction*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Transaction:
		if (p->size < 0)
			SOAP_DELETE((ns1__Transaction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Transaction*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTransStaticsItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfTransStaticsItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfTransStaticsItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TransStaticsItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__TransStaticsItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TransStaticsItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayInternetItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPayInternetItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPayInternetItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PayInternetItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayInternetItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayInternetItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayGameItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPayGameItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPayGameItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PayGameItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayGameItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayGameItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayPublicTelItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPayPublicTelItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPayPublicTelItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PayPublicTelItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayPublicTelItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayPublicTelItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__User:
		if (p->size < 0)
			SOAP_DELETE((ns1__User*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__User*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ReturnInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__ReturnInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ReturnInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnInfoItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfReturnInfoItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfReturnInfoItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ReturnInfoItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ReturnInfoItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ReturnInfoItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfWorker:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfWorker*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfWorker*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Worker:
		if (p->size < 0)
			SOAP_DELETE((ns1__Worker*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Worker*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSystemFunction:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSystemFunction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSystemFunction*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SystemFunction:
		if (p->size < 0)
			SOAP_DELETE((ns1__SystemFunction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SystemFunction*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnedItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfReturnedItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfReturnedItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ReturnedItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ReturnedItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ReturnedItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfAcountPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfAcountPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfAcountPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AcountPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__AcountPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AcountPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfDIC_USCOREContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfDIC_USCOREContent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DIC_USCOREContent:
		if (p->size < 0)
			SOAP_DELETE((ns1__DIC_USCOREContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DIC_USCOREContent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfDIC_USCORECategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfDIC_USCORECategory*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DIC_USCORECategory:
		if (p->size < 0)
			SOAP_DELETE((ns1__DIC_USCORECategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DIC_USCORECategory*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TableStatistics:
		if (p->size < 0)
			SOAP_DELETE((ns1__TableStatistics*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TableStatistics*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Notice:
		if (p->size < 0)
			SOAP_DELETE((ns1__Notice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Notice*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoticeItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoticeItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((ns1__ReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((ns1__PhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__CompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((ns1__CompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Result:
		if (p->size < 0)
			SOAP_DELETE((ns1__Result*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Result*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PhoneNoList:
		if (p->size < 0)
			SOAP_DELETE((ns1__PhoneNoList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PhoneNoList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPhoneNoItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPhoneNoItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPhoneNoItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PhoneNoItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PhoneNoItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PhoneNoItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfString*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfString*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfMiniCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfMiniCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfMiniCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__MiniCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__MiniCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__MiniCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPayMiniCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPayMiniCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPayMiniCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PayMiniCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__PayMiniCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PayMiniCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfCardService:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfCardService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfCardService*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CardService:
		if (p->size < 0)
			SOAP_DELETE((ns1__CardService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CardService*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSellCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSellCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSellCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SellCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__SellCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SellCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfBusinessItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfBusinessItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfBusinessItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__BusinessItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__BusinessItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__BusinessItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSellOtherCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSellOtherCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSellOtherCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SellOtherCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__SellOtherCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SellOtherCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfOtherCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfOtherCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfOtherCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OtherCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__OtherCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OtherCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfStockCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfStockCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfStockCardItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StockCardItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__StockCardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StockCardItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLocation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLocation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLocation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLocationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLocationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLocationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayMoney:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayMoney*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayMoneyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayMoneyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayMoneyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayMoneyWithList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayMoneyWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayMoneyWithList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayMoneyWithListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayMoneyWithListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayMoneyWithListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RequstRollback:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RequstRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RequstRollback*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RequstRollbackResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RequstRollbackResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RequstRollbackResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayInternet:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayInternet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayInternet*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayInternetResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayInternetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayInternetResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayInternetWithList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayInternetWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayInternetWithList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayInternetWithListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayInternetWithListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayInternetWithListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RequstInternetRollback:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RequstInternetRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RequstInternetRollback*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RequstInternetRollbackResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RequstInternetRollbackResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RequstInternetRollbackResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayGame:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayGame*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayGame*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayGameResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayGameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayGameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayPublicTel:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayPublicTel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayPublicTel*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PayPublicTelResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PayPublicTelResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PayPublicTelResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTransactionByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTransactionByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTransactionByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTransactionByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTransactionByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTransactionByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTransactionStaticsByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTransactionStaticsByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTransactionStaticsByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTransactionStaticsByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTransactionStaticsByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayInternetByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayInternetByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayInternetByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayInternetByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayInternetByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayInternetByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayInternetHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayInternetHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayInternetHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayInternetHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayInternetHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayGameByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayGameByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayGameByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayGameByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayGameByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayGameByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayGameHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayGameHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayGameHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayGameHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayGameHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayPublicTelByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayPublicTelByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayPublicTelByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayPublicTelByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayPublicTelHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayPublicTelHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayPublicTelHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayPublicTelHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE((_ns1__HelloWorld*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__HelloWorld*)p->ptr);
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__HelloWorldResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__HelloWorldResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__loggout:
		if (p->size < 0)
			SOAP_DELETE((_ns1__loggout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__loggout*)p->ptr);
		break;
	case SOAP_TYPE__ns1__loggoutResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__loggoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__loggoutResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TestLogin:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TestLogin*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TestLogin*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TestLoginResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TestLoginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TestLoginResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RegisterUser:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RegisterUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RegisterUser*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RegisterUserResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RegisterUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RegisterUserResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AlterPsw:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AlterPsw*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AlterPsw*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AlterPswResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AlterPswResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AlterPswResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AlterUserInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AlterUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AlterUserInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AlterUserInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AlterUserInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AlterUserInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddAcountPayment:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddAcountPayment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddAcountPayment*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddAcountPaymentResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddAcountPaymentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddAcountPaymentResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CharegeReturnedMoney:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CharegeReturnedMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CharegeReturnedMoney*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CharegeReturnedMoneyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CharegeReturnedMoneyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CharegeReturnedMoneyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetWorkNameList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetWorkNameList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetWorkNameList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetWorkNameListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetWorkNameListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetWorkNameListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserFunction:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserFunction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserFunction*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserFunctionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserFunctionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserFunctionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordDeal:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnRecordDeal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnRecordDeal*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnRecordDealResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnRecordDealResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnRecordDealResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAcountPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAcountPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAcountPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAcountPaymentRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAcountPaymentRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAcountPaymentRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDicContentByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDicContentByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDicContentByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDicContentByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDicContentByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDicContentByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCategory:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCategory*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCategoryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCategoryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCategoryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InsertDicContent:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InsertDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InsertDicContent*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InsertDicContentResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InsertDicContentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InsertDicContentResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateDicContent:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateDicContent*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateDicContentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateDicContentResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteDicContent:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteDicContent*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteDicContentResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteDicContentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteDicContentResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentByCategory:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateDicContentByCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateDicContentByCategory*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateDicContentByCategoryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateDicContentByCategoryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetFunctionList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetFunctionList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetFunctionListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetFunctionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetFunctionListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateUserFunctionList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateUserFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateUserFunctionList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateUserFunctionListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateUserFunctionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateUserFunctionListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateFunctionRight:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateFunctionRight*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateFunctionRight*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateFunctionRightResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateFunctionRightResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateFunctionRightResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTableStatistics:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTableStatistics*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTableStatistics*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetTableStatisticsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetTableStatisticsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetTableStatisticsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeListByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeListByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeListByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeListByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeListByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeListByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetNoticeItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetNoticeItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetNoticeItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlertNoticeList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlertNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlertNoticeList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlertNoticeListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlertNoticeListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlertNoticeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddNoticeItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddNoticeItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemToSomeone:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddNoticeItemToSomeone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddNoticeItemToSomeone*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddNoticeItemToSomeoneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddNoticeItemToSomeoneResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateNoticeItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateNoticeItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateNoticeItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteNoticeItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteNoticeItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteNoticeItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InserNoticeToSomeOne:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InserNoticeToSomeOne*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InserNoticeToSomeOne*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InserNoticeToSomeOneResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InserNoticeToSomeOneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InserNoticeToSomeOneResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnProportionRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnProportionRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnProportionRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetReturnProportionRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetReturnProportionRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetReturnProportionRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddtReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddtReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddtReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddtReturnProportionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddtReturnProportionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddtReturnProportionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatetReturnProportionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatetReturnProportionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatetReturnProportionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeletetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeletetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeletetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeletetReturnProportionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeletetReturnProportionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeletetReturnProportionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNumberBelongByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNumberBelongByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNumberBelongByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNumberBelongByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatePhoneNumberBelongResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatePhoneNumberBelongResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddPhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddPhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddPhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddPhoneNumberBelongResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddPhoneNumberBelongResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddPhoneNumberBelongResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeletePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeletePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeletePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeletePhoneNumberBelongResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeletePhoneNumberBelongResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCompanyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCompanyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCompanyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateCompanyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateCompanyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCompanyAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCompanyAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCompanyAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddCompanyAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddCompanyAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddCompanyAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateCompanyAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateCompanyAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateCompanyAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteCompanyAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteCompanyAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteCompanyAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetClientVersion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetClientVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetClientVersion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetClientVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetClientVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetClientVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__queryPhoneNOInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__queryPhoneNOInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__queryPhoneNOInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__queryPhoneNOInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__queryPhoneNOInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__queryPhoneNOInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BuyMiniCard:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BuyMiniCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BuyMiniCard*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BuyMiniCardResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BuyMiniCardResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BuyMiniCardResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetMyNoSection:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetMyNoSection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetMyNoSection*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetMyNoSectionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetMyNoSectionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetMyNoSectionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LockNo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LockNo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LockNoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LockNoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LockNoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UnlockNo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UnlockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UnlockNo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UnlockNoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UnlockNoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UnlockNoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SubmitBusiness:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SubmitBusiness*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SubmitBusiness*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SubmitBusinessResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SubmitBusinessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SubmitBusinessResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SellNo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SellNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SellNo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SellNoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SellNoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SellNoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SellOhterCard:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SellOhterCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SellOhterCard*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SellOhterCardResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SellOhterCardResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SellOhterCardResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetMiniCardRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetMiniCardRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetMiniCardRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetMiniCardRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetMiniCardRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetMiniCardRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayMiniCardByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayMiniCardByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayMiniCardByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayMiniCardByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayMiniCardHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayMiniCardHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPayMiniCardHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPayMiniCardHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoItemByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoItemByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCardService:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCardService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCardService*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCardServiceResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCardServiceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCardServiceResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellCardRecordByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellCardRecordByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellCardRecordHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellCardRecordHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBusinessRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBusinessRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBusinessRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBusinessRecordByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBusinessRecordByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GettBusinessRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GettBusinessRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GettBusinessRecordHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GettBusinessRecordHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellOtherCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellOtherCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSellOtherCardRecordByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSellOtherCardRecordByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherCardList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherCardList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherCardList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherCardListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherCardListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherCardListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStockCardItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStockCardItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStockCardItemByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStockCardItemByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStockCardItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStockCardItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStockCardItemAndHistoryByConditionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStockCardItemAndHistoryByConditionResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns10__queryPhoneNOInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns10__queryPhoneNOInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns10__queryPhoneNOInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns11__queryPhoneNOInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns11__queryPhoneNOInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns11__queryPhoneNOInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns12__queryPhoneNOInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns12__queryPhoneNOInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns12__queryPhoneNOInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns13__BuyMiniCard:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__BuyMiniCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__BuyMiniCard*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetPhoneNoByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetPhoneNoByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetMyNoSection:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetMyNoSection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetMyNoSection*)p->ptr);
		break;
	case SOAP_TYPE___ns13__LockNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__LockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__LockNo*)p->ptr);
		break;
	case SOAP_TYPE___ns13__UnlockNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__UnlockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__UnlockNo*)p->ptr);
		break;
	case SOAP_TYPE___ns13__SubmitBusiness:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__SubmitBusiness*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__SubmitBusiness*)p->ptr);
		break;
	case SOAP_TYPE___ns13__SellNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__SellNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__SellNo*)p->ptr);
		break;
	case SOAP_TYPE___ns13__SellOhterCard:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__SellOhterCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__SellOhterCard*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetMiniCardRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetMiniCardRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetMiniCardRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetPayMiniCardByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetPayMiniCardByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetPayMiniCardByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetPayMiniCardHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetPayMiniCardHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetPayMiniCardHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetPhoneNoItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetPhoneNoItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetPhoneNoItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetCardService:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetCardService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetCardService*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetSellCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetSellCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetSellCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetSellCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetSellCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetSellCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetBusinessRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetBusinessRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetBusinessRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GettBusinessRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GettBusinessRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GettBusinessRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetSellOtherCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetSellOtherCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetSellOtherCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GettSellOtherCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetOtherCardList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetOtherCardList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetOtherCardList*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetStockCardItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetStockCardItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetStockCardItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns13__GetStockCardItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns13__GetStockCardItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns13__GetStockCardItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__BuyMiniCard:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__BuyMiniCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__BuyMiniCard*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetPhoneNoByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetPhoneNoByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetMyNoSection:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetMyNoSection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetMyNoSection*)p->ptr);
		break;
	case SOAP_TYPE___ns14__LockNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__LockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__LockNo*)p->ptr);
		break;
	case SOAP_TYPE___ns14__UnlockNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__UnlockNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__UnlockNo*)p->ptr);
		break;
	case SOAP_TYPE___ns14__SubmitBusiness:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__SubmitBusiness*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__SubmitBusiness*)p->ptr);
		break;
	case SOAP_TYPE___ns14__SellNo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__SellNo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__SellNo*)p->ptr);
		break;
	case SOAP_TYPE___ns14__SellOhterCard:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__SellOhterCard*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__SellOhterCard*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetMiniCardRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetMiniCardRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetMiniCardRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetPayMiniCardByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetPayMiniCardByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetPayMiniCardByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetPayMiniCardHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetPayMiniCardHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetPayMiniCardHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetPhoneNoItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetPhoneNoItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetPhoneNoItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetPhoneNoItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetCardService:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetCardService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetCardService*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetSellCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetSellCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetSellCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetSellCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetSellCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetSellCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetBusinessRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetBusinessRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetBusinessRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GettBusinessRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GettBusinessRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GettBusinessRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetSellOtherCardRecordByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetSellOtherCardRecordByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetSellOtherCardRecordByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GettSellOtherCardRecordHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GettSellOtherCardRecordHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetOtherCardList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetOtherCardList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetOtherCardList*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetStockCardItemByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetStockCardItemByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetStockCardItemByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns14__GetStockCardItemAndHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns14__GetStockCardItemAndHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns14__GetStockCardItemAndHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetLocation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetLocation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetLocation*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayMoney:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayMoney*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayMoneyWithList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayMoneyWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayMoneyWithList*)p->ptr);
		break;
	case SOAP_TYPE___ns3__RequstRollback:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__RequstRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__RequstRollback*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayInternet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayInternet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayInternet*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayInternetWithList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayInternetWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayInternetWithList*)p->ptr);
		break;
	case SOAP_TYPE___ns3__RequstInternetRollback:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__RequstInternetRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__RequstInternetRollback*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayGame:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayGame*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayGame*)p->ptr);
		break;
	case SOAP_TYPE___ns3__PayPublicTel:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__PayPublicTel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__PayPublicTel*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetTransactionByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetTransactionByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetTransactionByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetTransactionStaticsByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetTransactionStaticsByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetTransactionStaticsByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPaymentOrPaymentHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayInternetByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayInternetByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayInternetByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayInternetHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayInternetHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayInternetHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayGameByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayGameByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayGameByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayGameHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayGameHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayGameHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayPublicTelByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayPublicTelByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayPublicTelByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns3__GetPayPublicTelHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__GetPayPublicTelHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__GetPayPublicTelHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetLocation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetLocation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetLocation*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayMoney:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayMoney*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayMoneyWithList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayMoneyWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayMoneyWithList*)p->ptr);
		break;
	case SOAP_TYPE___ns4__RequstRollback:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__RequstRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__RequstRollback*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayInternet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayInternet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayInternet*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayInternetWithList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayInternetWithList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayInternetWithList*)p->ptr);
		break;
	case SOAP_TYPE___ns4__RequstInternetRollback:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__RequstInternetRollback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__RequstInternetRollback*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayGame:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayGame*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayGame*)p->ptr);
		break;
	case SOAP_TYPE___ns4__PayPublicTel:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__PayPublicTel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__PayPublicTel*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPaymentItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPaymentItem*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetTransactionByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetTransactionByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetTransactionByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetTransactionStaticsByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetTransactionStaticsByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetTransactionStaticsByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPaymentOrPaymentHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPaymentOrPaymentHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayInternetByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayInternetByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayInternetByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayInternetHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayInternetHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayInternetHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayGameByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayGameByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayGameByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayGameHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayGameHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayGameHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayPublicTelByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayPublicTelByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayPublicTelByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetPayPublicTelHistoryByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetPayPublicTelHistoryByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetPayPublicTelHistoryByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns5__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__HelloWorld*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__HelloWorld*)p->ptr);
		break;
	case SOAP_TYPE___ns5__loggout:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__loggout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__loggout*)p->ptr);
		break;
	case SOAP_TYPE___ns5__TestLogin:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__TestLogin*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__TestLogin*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetUserInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns5__RegisterUser:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__RegisterUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__RegisterUser*)p->ptr);
		break;
	case SOAP_TYPE___ns5__AlterPsw:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__AlterPsw*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__AlterPsw*)p->ptr);
		break;
	case SOAP_TYPE___ns5__AlterUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__AlterUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__AlterUserInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns5__AddAcountPayment:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__AddAcountPayment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__AddAcountPayment*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetReturnInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetReturnInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns5__CharegeReturnedMoney:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__CharegeReturnedMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__CharegeReturnedMoney*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetWorkNameList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetWorkNameList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetWorkNameList*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetUserFunction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetUserFunction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetUserFunction*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetReturnRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetReturnRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetReturnRecordDeal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetReturnRecordDeal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetReturnRecordDeal*)p->ptr);
		break;
	case SOAP_TYPE___ns5__GetAcountPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__GetAcountPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__GetAcountPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns6__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__HelloWorld*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__HelloWorld*)p->ptr);
		break;
	case SOAP_TYPE___ns6__loggout:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__loggout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__loggout*)p->ptr);
		break;
	case SOAP_TYPE___ns6__TestLogin:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__TestLogin*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__TestLogin*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetUserInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns6__RegisterUser:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__RegisterUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__RegisterUser*)p->ptr);
		break;
	case SOAP_TYPE___ns6__AlterPsw:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__AlterPsw*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__AlterPsw*)p->ptr);
		break;
	case SOAP_TYPE___ns6__AlterUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__AlterUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__AlterUserInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns6__AddAcountPayment:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__AddAcountPayment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__AddAcountPayment*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetReturnInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetReturnInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns6__CharegeReturnedMoney:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__CharegeReturnedMoney*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__CharegeReturnedMoney*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetWorkNameList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetWorkNameList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetWorkNameList*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetUserFunction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetUserFunction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetUserFunction*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetReturnRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetReturnRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetReturnRecordDeal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetReturnRecordDeal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetReturnRecordDeal*)p->ptr);
		break;
	case SOAP_TYPE___ns6__GetAcountPaymentRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns6__GetAcountPaymentRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns6__GetAcountPaymentRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetDicContentByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetDicContentByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetDicContentByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetAllCategory:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetAllCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetAllCategory*)p->ptr);
		break;
	case SOAP_TYPE___ns7__InsertDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__InsertDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__InsertDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns7__DeleteDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__DeleteDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__DeleteDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateDicContentByCategory:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateDicContentByCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateDicContentByCategory*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetFunctionList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetFunctionList*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateUserFunctionList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateUserFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateUserFunctionList*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateFunctionRight:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateFunctionRight*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateFunctionRight*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetTableStatistics:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetTableStatistics*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetTableStatistics*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetNoticeList*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeListByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetNoticeListByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetNoticeListByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetAlertNoticeList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetAlertNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetAlertNoticeList*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AddNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AddNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AddNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AddNoticeItemToSomeone:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AddNoticeItemToSomeone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AddNoticeItemToSomeone*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns7__DeleteNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__DeleteNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__DeleteNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns7__InserNoticeToSomeOne:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__InserNoticeToSomeOne*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__InserNoticeToSomeOne*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetReturnProportionRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetReturnProportionRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetReturnProportionRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AddtReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AddtReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AddtReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdatetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdatetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdatetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns7__DeletetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__DeletetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__DeletetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetPhoneNumberBelongByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetPhoneNumberBelongByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetPhoneNumberBelongByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdatePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdatePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdatePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AddPhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AddPhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AddPhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns7__DeletePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__DeletePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__DeletePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AddCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AddCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AddCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UpdateCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UpdateCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UpdateCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns7__DeleteCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__DeleteCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__DeleteCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns7__GetClientVersion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__GetClientVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__GetClientVersion*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetDicContentByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetDicContentByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetDicContentByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetAllCategory:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetAllCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetAllCategory*)p->ptr);
		break;
	case SOAP_TYPE___ns8__InsertDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__InsertDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__InsertDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns8__DeleteDicContent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__DeleteDicContent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__DeleteDicContent*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateDicContentByCategory:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateDicContentByCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateDicContentByCategory*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetFunctionList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetFunctionList*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateUserFunctionList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateUserFunctionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateUserFunctionList*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateFunctionRight:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateFunctionRight*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateFunctionRight*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetTableStatistics:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetTableStatistics*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetTableStatistics*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetNoticeList*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeListByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetNoticeListByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetNoticeListByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetAlertNoticeList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetAlertNoticeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetAlertNoticeList*)p->ptr);
		break;
	case SOAP_TYPE___ns8__AddNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__AddNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__AddNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns8__AddNoticeItemToSomeone:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__AddNoticeItemToSomeone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__AddNoticeItemToSomeone*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns8__DeleteNoticeItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__DeleteNoticeItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__DeleteNoticeItem*)p->ptr);
		break;
	case SOAP_TYPE___ns8__InserNoticeToSomeOne:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__InserNoticeToSomeOne*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__InserNoticeToSomeOne*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetReturnProportionRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetReturnProportionRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetReturnProportionRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns8__AddtReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__AddtReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__AddtReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdatetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdatetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdatetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns8__DeletetReturnProportion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__DeletetReturnProportion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__DeletetReturnProportion*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetPhoneNumberBelongByCondition:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetPhoneNumberBelongByCondition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetPhoneNumberBelongByCondition*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdatePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdatePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdatePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns8__AddPhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__AddPhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__AddPhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns8__DeletePhoneNumberBelong:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__DeletePhoneNumberBelong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__DeletePhoneNumberBelong*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateCompanyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateCompanyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateCompanyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns8__AddCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__AddCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__AddCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns8__UpdateCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__UpdateCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__UpdateCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns8__DeleteCompanyAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__DeleteCompanyAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__DeleteCompanyAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns8__GetClientVersion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns8__GetClientVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns8__GetClientVersion*)p->ptr);
		break;
	case SOAP_TYPE___ns9__queryPhoneNOInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns9__queryPhoneNOInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns9__queryPhoneNOInfo*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStockCardItemAndHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStockCardItemAndHistoryByConditionResponse::GetStockCardItemAndHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetStockCardItemAndHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfStockCardItem(soap, &this->_ns1__GetStockCardItemAndHistoryByConditionResponse::GetStockCardItemAndHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetStockCardItemAndHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStockCardItemAndHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetStockCardItemAndHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetStockCardItemAndHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfStockCardItem(soap, "ns1:GetStockCardItemAndHistoryByConditionResult", -1, &(a->_ns1__GetStockCardItemAndHistoryByConditionResponse::GetStockCardItemAndHistoryByConditionResult), "ns1:ArrayOfStockCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStockCardItemAndHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetStockCardItemAndHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStockCardItemAndHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse, sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStockCardItemAndHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetStockCardItemAndHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStockCardItemAndHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfStockCardItem(soap, "ns1:GetStockCardItemAndHistoryByConditionResult", &(a->_ns1__GetStockCardItemAndHistoryByConditionResponse::GetStockCardItemAndHistoryByConditionResult), "ns1:ArrayOfStockCardItem"))
				{	soap_flag_GetStockCardItemAndHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetStockCardItemAndHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStockCardItemAndHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse, 0, sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse), 0, soap_copy__ns1__GetStockCardItemAndHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetStockCardItemAndHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetStockCardItemAndHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStockCardItemAndHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetStockCardItemAndHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStockCardItemAndHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStockCardItemAndHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemAndHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse);
		((_ns1__GetStockCardItemAndHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemAndHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetStockCardItemAndHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStockCardItemAndHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStockCardItemAndHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetStockCardItemAndHistoryByConditionResponse*)p = *(_ns1__GetStockCardItemAndHistoryByConditionResponse*)q;
}

void _ns1__GetStockCardItemAndHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetStockCardItemAndHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetStockCardItemAndHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetStockCardItemAndHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetStockCardItemAndHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetStockCardItemAndHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetStockCardItemAndHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStockCardItemAndHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetStockCardItemAndHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetStockCardItemAndHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStockCardItemAndHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStockCardItemAndHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStockCardItemAndHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition, sizeof(_ns1__GetStockCardItemAndHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStockCardItemAndHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetStockCardItemAndHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetStockCardItemAndHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStockCardItemAndHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition, 0, sizeof(_ns1__GetStockCardItemAndHistoryByCondition), 0, soap_copy__ns1__GetStockCardItemAndHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetStockCardItemAndHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetStockCardItemAndHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStockCardItemAndHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStockCardItemAndHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, _ns1__GetStockCardItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStockCardItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStockCardItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStockCardItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemAndHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetStockCardItemAndHistoryByCondition);
		((_ns1__GetStockCardItemAndHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStockCardItemAndHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetStockCardItemAndHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStockCardItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStockCardItemAndHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetStockCardItemAndHistoryByCondition*)p = *(_ns1__GetStockCardItemAndHistoryByCondition*)q;
}

void _ns1__GetStockCardItemByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStockCardItemByConditionResponse::GetStockCardItemByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetStockCardItemByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfStockCardItem(soap, &this->_ns1__GetStockCardItemByConditionResponse::GetStockCardItemByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetStockCardItemByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStockCardItemByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStockCardItemByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStockCardItemByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse), type))
		return soap->error;
	if (a->GetStockCardItemByConditionResult)
		soap_element_result(soap, "ns1:GetStockCardItemByConditionResult");
	if (soap_out_PointerTons1__ArrayOfStockCardItem(soap, "ns1:GetStockCardItemByConditionResult", -1, &(a->_ns1__GetStockCardItemByConditionResponse::GetStockCardItemByConditionResult), "ns1:ArrayOfStockCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStockCardItemByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStockCardItemByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetStockCardItemByConditionResponse(struct soap *soap, const char *tag, _ns1__GetStockCardItemByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStockCardItemByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse, sizeof(_ns1__GetStockCardItemByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStockCardItemByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStockCardItemByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetStockCardItemByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStockCardItemByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfStockCardItem(soap, "ns1:GetStockCardItemByConditionResult", &(a->_ns1__GetStockCardItemByConditionResponse::GetStockCardItemByConditionResult), "ns1:ArrayOfStockCardItem"))
				{	soap_flag_GetStockCardItemByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetStockCardItemByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStockCardItemByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse, 0, sizeof(_ns1__GetStockCardItemByConditionResponse), 0, soap_copy__ns1__GetStockCardItemByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetStockCardItemByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetStockCardItemByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStockCardItemByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStockCardItemByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetStockCardItemByConditionResponse(struct soap *soap, _ns1__GetStockCardItemByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStockCardItemByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStockCardItemByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStockCardItemByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStockCardItemByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetStockCardItemByConditionResponse);
		((_ns1__GetStockCardItemByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStockCardItemByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetStockCardItemByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStockCardItemByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStockCardItemByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStockCardItemByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetStockCardItemByConditionResponse*)p = *(_ns1__GetStockCardItemByConditionResponse*)q;
}

void _ns1__GetStockCardItemByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetStockCardItemByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetStockCardItemByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetStockCardItemByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetStockCardItemByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetStockCardItemByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetStockCardItemByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStockCardItemByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStockCardItemByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetStockCardItemByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStockCardItemByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetStockCardItemByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetStockCardItemByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStockCardItemByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStockCardItemByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByCondition * SOAP_FMAC4 soap_in__ns1__GetStockCardItemByCondition(struct soap *soap, const char *tag, _ns1__GetStockCardItemByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStockCardItemByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStockCardItemByCondition, sizeof(_ns1__GetStockCardItemByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStockCardItemByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStockCardItemByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetStockCardItemByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetStockCardItemByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStockCardItemByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStockCardItemByCondition, 0, sizeof(_ns1__GetStockCardItemByCondition), 0, soap_copy__ns1__GetStockCardItemByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetStockCardItemByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStockCardItemByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetStockCardItemByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStockCardItemByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStockCardItemByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByCondition * SOAP_FMAC4 soap_get__ns1__GetStockCardItemByCondition(struct soap *soap, _ns1__GetStockCardItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStockCardItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStockCardItemByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetStockCardItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStockCardItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStockCardItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemByCondition);
		if (size)
			*size = sizeof(_ns1__GetStockCardItemByCondition);
		((_ns1__GetStockCardItemByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStockCardItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStockCardItemByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetStockCardItemByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStockCardItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStockCardItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStockCardItemByCondition %p -> %p\n", q, p));
	*(_ns1__GetStockCardItemByCondition*)p = *(_ns1__GetStockCardItemByCondition*)q;
}

void _ns1__GetOtherCardListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOtherCardListResponse::GetOtherCardListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetOtherCardListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfOtherCardItem(soap, &this->_ns1__GetOtherCardListResponse::GetOtherCardListResult);
	/* transient soap skipped */
}

int _ns1__GetOtherCardListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherCardListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherCardListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOtherCardListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherCardListResponse), type))
		return soap->error;
	if (a->GetOtherCardListResult)
		soap_element_result(soap, "ns1:GetOtherCardListResult");
	if (soap_out_PointerTons1__ArrayOfOtherCardItem(soap, "ns1:GetOtherCardListResult", -1, &(a->_ns1__GetOtherCardListResponse::GetOtherCardListResult), "ns1:ArrayOfOtherCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherCardListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherCardListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherCardListResponse * SOAP_FMAC4 soap_in__ns1__GetOtherCardListResponse(struct soap *soap, const char *tag, _ns1__GetOtherCardListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherCardListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherCardListResponse, sizeof(_ns1__GetOtherCardListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherCardListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherCardListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetOtherCardListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOtherCardListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfOtherCardItem(soap, "ns1:GetOtherCardListResult", &(a->_ns1__GetOtherCardListResponse::GetOtherCardListResult), "ns1:ArrayOfOtherCardItem"))
				{	soap_flag_GetOtherCardListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetOtherCardListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherCardListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherCardListResponse, 0, sizeof(_ns1__GetOtherCardListResponse), 0, soap_copy__ns1__GetOtherCardListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetOtherCardListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetOtherCardListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherCardListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherCardListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherCardListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherCardListResponse * SOAP_FMAC4 soap_get__ns1__GetOtherCardListResponse(struct soap *soap, _ns1__GetOtherCardListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherCardListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherCardListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOtherCardListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherCardListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherCardListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherCardListResponse);
		if (size)
			*size = sizeof(_ns1__GetOtherCardListResponse);
		((_ns1__GetOtherCardListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherCardListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetOtherCardListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetOtherCardListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetOtherCardListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherCardListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherCardListResponse %p -> %p\n", q, p));
	*(_ns1__GetOtherCardListResponse*)p = *(_ns1__GetOtherCardListResponse*)q;
}

void _ns1__GetOtherCardList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetOtherCardList::condition);
	soap_default_string(soap, &this->_ns1__GetOtherCardList::sessionId);
	/* transient soap skipped */
}

void _ns1__GetOtherCardList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetOtherCardList::condition);
	soap_serialize_string(soap, &this->_ns1__GetOtherCardList::sessionId);
	/* transient soap skipped */
}

int _ns1__GetOtherCardList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherCardList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherCardList(struct soap *soap, const char *tag, int id, const _ns1__GetOtherCardList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherCardList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetOtherCardList::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetOtherCardList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherCardList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherCardList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherCardList * SOAP_FMAC4 soap_in__ns1__GetOtherCardList(struct soap *soap, const char *tag, _ns1__GetOtherCardList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherCardList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherCardList, sizeof(_ns1__GetOtherCardList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherCardList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherCardList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetOtherCardList::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetOtherCardList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherCardList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherCardList, 0, sizeof(_ns1__GetOtherCardList), 0, soap_copy__ns1__GetOtherCardList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetOtherCardList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetOtherCardList);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherCardList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherCardList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherCardList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherCardList * SOAP_FMAC4 soap_get__ns1__GetOtherCardList(struct soap *soap, _ns1__GetOtherCardList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherCardList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherCardList * SOAP_FMAC2 soap_instantiate__ns1__GetOtherCardList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherCardList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherCardList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherCardList);
		if (size)
			*size = sizeof(_ns1__GetOtherCardList);
		((_ns1__GetOtherCardList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherCardList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetOtherCardList);
		for (int i = 0; i < n; i++)
			((_ns1__GetOtherCardList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetOtherCardList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherCardList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherCardList %p -> %p\n", q, p));
	*(_ns1__GetOtherCardList*)p = *(_ns1__GetOtherCardList*)q;
}

void _ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GettSellOtherCardRecordHistoryByConditionResponse::GettSellOtherCardRecordHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSellOtherCardItem(soap, &this->_ns1__GettSellOtherCardRecordHistoryByConditionResponse::GettSellOtherCardRecordHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GettSellOtherCardRecordHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse), type))
		return soap->error;
	if (a->GettSellOtherCardRecordHistoryByConditionResult)
		soap_element_result(soap, "ns1:GettSellOtherCardRecordHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfSellOtherCardItem(soap, "ns1:GettSellOtherCardRecordHistoryByConditionResult", -1, &(a->_ns1__GettSellOtherCardRecordHistoryByConditionResponse::GettSellOtherCardRecordHistoryByConditionResult), "ns1:ArrayOfSellOtherCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GettSellOtherCardRecordHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse, sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GettSellOtherCardRecordHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GettSellOtherCardRecordHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSellOtherCardItem(soap, "ns1:GettSellOtherCardRecordHistoryByConditionResult", &(a->_ns1__GettSellOtherCardRecordHistoryByConditionResponse::GettSellOtherCardRecordHistoryByConditionResult), "ns1:ArrayOfSellOtherCardItem"))
				{	soap_flag_GettSellOtherCardRecordHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GettSellOtherCardRecordHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse, 0, sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse), 0, soap_copy__ns1__GettSellOtherCardRecordHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GettSellOtherCardRecordHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GettSellOtherCardRecordHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GettSellOtherCardRecordHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GettSellOtherCardRecordHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettSellOtherCardRecordHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse);
		((_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettSellOtherCardRecordHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GettSellOtherCardRecordHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)p = *(_ns1__GettSellOtherCardRecordHistoryByConditionResponse*)q;
}

void _ns1__GettSellOtherCardRecordHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GettSellOtherCardRecordHistoryByCondition::top);
	soap_default_string(soap, &this->_ns1__GettSellOtherCardRecordHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GettSellOtherCardRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GettSellOtherCardRecordHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GettSellOtherCardRecordHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GettSellOtherCardRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GettSellOtherCardRecordHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GettSellOtherCardRecordHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GettSellOtherCardRecordHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition, sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GettSellOtherCardRecordHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GettSellOtherCardRecordHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GettSellOtherCardRecordHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition, 0, sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition), 0, soap_copy__ns1__GettSellOtherCardRecordHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GettSellOtherCardRecordHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GettSellOtherCardRecordHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GettSellOtherCardRecordHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GettSellOtherCardRecordHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GettSellOtherCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettSellOtherCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition);
		((_ns1__GettSellOtherCardRecordHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettSellOtherCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GettSellOtherCardRecordHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GettSellOtherCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GettSellOtherCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GettSellOtherCardRecordHistoryByCondition*)p = *(_ns1__GettSellOtherCardRecordHistoryByCondition*)q;
}

void _ns1__GetSellOtherCardRecordByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSellOtherCardRecordByConditionResponse::GetSellOtherCardRecordByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSellOtherCardRecordByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSellOtherCardItem(soap, &this->_ns1__GetSellOtherCardRecordByConditionResponse::GetSellOtherCardRecordByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetSellOtherCardRecordByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellOtherCardRecordByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSellOtherCardRecordByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse), type))
		return soap->error;
	if (a->GetSellOtherCardRecordByConditionResult)
		soap_element_result(soap, "ns1:GetSellOtherCardRecordByConditionResult");
	if (soap_out_PointerTons1__ArrayOfSellOtherCardItem(soap, "ns1:GetSellOtherCardRecordByConditionResult", -1, &(a->_ns1__GetSellOtherCardRecordByConditionResponse::GetSellOtherCardRecordByConditionResult), "ns1:ArrayOfSellOtherCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellOtherCardRecordByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellOtherCardRecordByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellOtherCardRecordByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellOtherCardRecordByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse, sizeof(_ns1__GetSellOtherCardRecordByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellOtherCardRecordByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSellOtherCardRecordByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSellOtherCardRecordByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSellOtherCardItem(soap, "ns1:GetSellOtherCardRecordByConditionResult", &(a->_ns1__GetSellOtherCardRecordByConditionResponse::GetSellOtherCardRecordByConditionResult), "ns1:ArrayOfSellOtherCardItem"))
				{	soap_flag_GetSellOtherCardRecordByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSellOtherCardRecordByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellOtherCardRecordByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse, 0, sizeof(_ns1__GetSellOtherCardRecordByConditionResponse), 0, soap_copy__ns1__GetSellOtherCardRecordByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSellOtherCardRecordByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellOtherCardRecordByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellOtherCardRecordByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellOtherCardRecordByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellOtherCardRecordByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellOtherCardRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellOtherCardRecordByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellOtherCardRecordByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellOtherCardRecordByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetSellOtherCardRecordByConditionResponse);
		((_ns1__GetSellOtherCardRecordByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellOtherCardRecordByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellOtherCardRecordByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellOtherCardRecordByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellOtherCardRecordByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellOtherCardRecordByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetSellOtherCardRecordByConditionResponse*)p = *(_ns1__GetSellOtherCardRecordByConditionResponse*)q;
}

void _ns1__GetSellOtherCardRecordByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetSellOtherCardRecordByCondition::top);
	soap_default_string(soap, &this->_ns1__GetSellOtherCardRecordByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetSellOtherCardRecordByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetSellOtherCardRecordByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetSellOtherCardRecordByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetSellOtherCardRecordByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetSellOtherCardRecordByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellOtherCardRecordByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetSellOtherCardRecordByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetSellOtherCardRecordByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetSellOtherCardRecordByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetSellOtherCardRecordByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellOtherCardRecordByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellOtherCardRecordByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_in__ns1__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, _ns1__GetSellOtherCardRecordByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellOtherCardRecordByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition, sizeof(_ns1__GetSellOtherCardRecordByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellOtherCardRecordByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetSellOtherCardRecordByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetSellOtherCardRecordByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetSellOtherCardRecordByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellOtherCardRecordByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition, 0, sizeof(_ns1__GetSellOtherCardRecordByCondition), 0, soap_copy__ns1__GetSellOtherCardRecordByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetSellOtherCardRecordByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellOtherCardRecordByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellOtherCardRecordByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellOtherCardRecordByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_get__ns1__GetSellOtherCardRecordByCondition(struct soap *soap, _ns1__GetSellOtherCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellOtherCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellOtherCardRecordByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetSellOtherCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellOtherCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellOtherCardRecordByCondition);
		if (size)
			*size = sizeof(_ns1__GetSellOtherCardRecordByCondition);
		((_ns1__GetSellOtherCardRecordByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellOtherCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellOtherCardRecordByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellOtherCardRecordByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellOtherCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellOtherCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellOtherCardRecordByCondition %p -> %p\n", q, p));
	*(_ns1__GetSellOtherCardRecordByCondition*)p = *(_ns1__GetSellOtherCardRecordByCondition*)q;
}

void _ns1__GettBusinessRecordHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GettBusinessRecordHistoryByConditionResponse::GettBusinessRecordHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GettBusinessRecordHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfBusinessItem(soap, &this->_ns1__GettBusinessRecordHistoryByConditionResponse::GettBusinessRecordHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GettBusinessRecordHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GettBusinessRecordHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse), type))
		return soap->error;
	if (a->GettBusinessRecordHistoryByConditionResult)
		soap_element_result(soap, "ns1:GettBusinessRecordHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfBusinessItem(soap, "ns1:GettBusinessRecordHistoryByConditionResult", -1, &(a->_ns1__GettBusinessRecordHistoryByConditionResponse::GettBusinessRecordHistoryByConditionResult), "ns1:ArrayOfBusinessItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GettBusinessRecordHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GettBusinessRecordHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GettBusinessRecordHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse, sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GettBusinessRecordHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GettBusinessRecordHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GettBusinessRecordHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfBusinessItem(soap, "ns1:GettBusinessRecordHistoryByConditionResult", &(a->_ns1__GettBusinessRecordHistoryByConditionResponse::GettBusinessRecordHistoryByConditionResult), "ns1:ArrayOfBusinessItem"))
				{	soap_flag_GettBusinessRecordHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GettBusinessRecordHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GettBusinessRecordHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse, 0, sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse), 0, soap_copy__ns1__GettBusinessRecordHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GettBusinessRecordHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GettBusinessRecordHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GettBusinessRecordHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GettBusinessRecordHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettBusinessRecordHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GettBusinessRecordHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GettBusinessRecordHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettBusinessRecordHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse);
		((_ns1__GettBusinessRecordHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettBusinessRecordHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GettBusinessRecordHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GettBusinessRecordHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GettBusinessRecordHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GettBusinessRecordHistoryByConditionResponse*)p = *(_ns1__GettBusinessRecordHistoryByConditionResponse*)q;
}

void _ns1__GettBusinessRecordHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GettBusinessRecordHistoryByCondition::top);
	soap_default_string(soap, &this->_ns1__GettBusinessRecordHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GettBusinessRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GettBusinessRecordHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GettBusinessRecordHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GettBusinessRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GettBusinessRecordHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GettBusinessRecordHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GettBusinessRecordHistoryByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GettBusinessRecordHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GettBusinessRecordHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GettBusinessRecordHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GettBusinessRecordHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GettBusinessRecordHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition, sizeof(_ns1__GettBusinessRecordHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GettBusinessRecordHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GettBusinessRecordHistoryByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GettBusinessRecordHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GettBusinessRecordHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GettBusinessRecordHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition, 0, sizeof(_ns1__GettBusinessRecordHistoryByCondition), 0, soap_copy__ns1__GettBusinessRecordHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GettBusinessRecordHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GettBusinessRecordHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GettBusinessRecordHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GettBusinessRecordHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, _ns1__GettBusinessRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GettBusinessRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GettBusinessRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GettBusinessRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettBusinessRecordHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GettBusinessRecordHistoryByCondition);
		((_ns1__GettBusinessRecordHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GettBusinessRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GettBusinessRecordHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GettBusinessRecordHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GettBusinessRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GettBusinessRecordHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GettBusinessRecordHistoryByCondition*)p = *(_ns1__GettBusinessRecordHistoryByCondition*)q;
}

void _ns1__GetBusinessRecordByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetBusinessRecordByConditionResponse::GetBusinessRecordByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetBusinessRecordByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfBusinessItem(soap, &this->_ns1__GetBusinessRecordByConditionResponse::GetBusinessRecordByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetBusinessRecordByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBusinessRecordByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBusinessRecordByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetBusinessRecordByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse), type))
		return soap->error;
	if (a->GetBusinessRecordByConditionResult)
		soap_element_result(soap, "ns1:GetBusinessRecordByConditionResult");
	if (soap_out_PointerTons1__ArrayOfBusinessItem(soap, "ns1:GetBusinessRecordByConditionResult", -1, &(a->_ns1__GetBusinessRecordByConditionResponse::GetBusinessRecordByConditionResult), "ns1:ArrayOfBusinessItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBusinessRecordByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBusinessRecordByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetBusinessRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetBusinessRecordByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBusinessRecordByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse, sizeof(_ns1__GetBusinessRecordByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBusinessRecordByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetBusinessRecordByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBusinessRecordByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfBusinessItem(soap, "ns1:GetBusinessRecordByConditionResult", &(a->_ns1__GetBusinessRecordByConditionResponse::GetBusinessRecordByConditionResult), "ns1:ArrayOfBusinessItem"))
				{	soap_flag_GetBusinessRecordByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetBusinessRecordByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBusinessRecordByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse, 0, sizeof(_ns1__GetBusinessRecordByConditionResponse), 0, soap_copy__ns1__GetBusinessRecordByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetBusinessRecordByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetBusinessRecordByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBusinessRecordByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBusinessRecordByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetBusinessRecordByConditionResponse(struct soap *soap, _ns1__GetBusinessRecordByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBusinessRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBusinessRecordByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetBusinessRecordByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBusinessRecordByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBusinessRecordByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetBusinessRecordByConditionResponse);
		((_ns1__GetBusinessRecordByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBusinessRecordByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBusinessRecordByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetBusinessRecordByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBusinessRecordByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBusinessRecordByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBusinessRecordByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetBusinessRecordByConditionResponse*)p = *(_ns1__GetBusinessRecordByConditionResponse*)q;
}

void _ns1__GetBusinessRecordByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetBusinessRecordByCondition::top);
	soap_default_string(soap, &this->_ns1__GetBusinessRecordByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetBusinessRecordByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetBusinessRecordByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetBusinessRecordByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetBusinessRecordByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetBusinessRecordByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBusinessRecordByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBusinessRecordByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetBusinessRecordByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBusinessRecordByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetBusinessRecordByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetBusinessRecordByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetBusinessRecordByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBusinessRecordByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBusinessRecordByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByCondition * SOAP_FMAC4 soap_in__ns1__GetBusinessRecordByCondition(struct soap *soap, const char *tag, _ns1__GetBusinessRecordByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBusinessRecordByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBusinessRecordByCondition, sizeof(_ns1__GetBusinessRecordByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBusinessRecordByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBusinessRecordByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetBusinessRecordByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetBusinessRecordByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetBusinessRecordByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBusinessRecordByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBusinessRecordByCondition, 0, sizeof(_ns1__GetBusinessRecordByCondition), 0, soap_copy__ns1__GetBusinessRecordByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetBusinessRecordByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBusinessRecordByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetBusinessRecordByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBusinessRecordByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBusinessRecordByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByCondition * SOAP_FMAC4 soap_get__ns1__GetBusinessRecordByCondition(struct soap *soap, _ns1__GetBusinessRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBusinessRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBusinessRecordByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetBusinessRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBusinessRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBusinessRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBusinessRecordByCondition);
		if (size)
			*size = sizeof(_ns1__GetBusinessRecordByCondition);
		((_ns1__GetBusinessRecordByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBusinessRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBusinessRecordByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetBusinessRecordByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBusinessRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBusinessRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBusinessRecordByCondition %p -> %p\n", q, p));
	*(_ns1__GetBusinessRecordByCondition*)p = *(_ns1__GetBusinessRecordByCondition*)q;
}

void _ns1__GetSellCardRecordHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSellCardRecordHistoryByConditionResponse::GetSellCardRecordHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSellCardRecordHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSellCardItem(soap, &this->_ns1__GetSellCardRecordHistoryByConditionResponse::GetSellCardRecordHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetSellCardRecordHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSellCardRecordHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetSellCardRecordHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetSellCardRecordHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfSellCardItem(soap, "ns1:GetSellCardRecordHistoryByConditionResult", -1, &(a->_ns1__GetSellCardRecordHistoryByConditionResponse::GetSellCardRecordHistoryByConditionResult), "ns1:ArrayOfSellCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellCardRecordHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellCardRecordHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellCardRecordHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse, sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellCardRecordHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSellCardRecordHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSellCardRecordHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSellCardItem(soap, "ns1:GetSellCardRecordHistoryByConditionResult", &(a->_ns1__GetSellCardRecordHistoryByConditionResponse::GetSellCardRecordHistoryByConditionResult), "ns1:ArrayOfSellCardItem"))
				{	soap_flag_GetSellCardRecordHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSellCardRecordHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellCardRecordHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse, 0, sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse), 0, soap_copy__ns1__GetSellCardRecordHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSellCardRecordHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellCardRecordHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellCardRecordHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellCardRecordHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellCardRecordHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellCardRecordHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse);
		((_ns1__GetSellCardRecordHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellCardRecordHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellCardRecordHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellCardRecordHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetSellCardRecordHistoryByConditionResponse*)p = *(_ns1__GetSellCardRecordHistoryByConditionResponse*)q;
}

void _ns1__GetSellCardRecordHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetSellCardRecordHistoryByCondition::top);
	soap_default_string(soap, &this->_ns1__GetSellCardRecordHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetSellCardRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetSellCardRecordHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetSellCardRecordHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetSellCardRecordHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetSellCardRecordHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellCardRecordHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetSellCardRecordHistoryByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetSellCardRecordHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetSellCardRecordHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellCardRecordHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellCardRecordHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellCardRecordHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition, sizeof(_ns1__GetSellCardRecordHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellCardRecordHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetSellCardRecordHistoryByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetSellCardRecordHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetSellCardRecordHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellCardRecordHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition, 0, sizeof(_ns1__GetSellCardRecordHistoryByCondition), 0, soap_copy__ns1__GetSellCardRecordHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetSellCardRecordHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellCardRecordHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellCardRecordHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellCardRecordHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, _ns1__GetSellCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetSellCardRecordHistoryByCondition);
		((_ns1__GetSellCardRecordHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellCardRecordHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellCardRecordHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetSellCardRecordHistoryByCondition*)p = *(_ns1__GetSellCardRecordHistoryByCondition*)q;
}

void _ns1__GetSellCardRecordByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSellCardRecordByConditionResponse::GetSellCardRecordByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSellCardRecordByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSellCardItem(soap, &this->_ns1__GetSellCardRecordByConditionResponse::GetSellCardRecordByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetSellCardRecordByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellCardRecordByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellCardRecordByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSellCardRecordByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse), type))
		return soap->error;
	if (a->GetSellCardRecordByConditionResult)
		soap_element_result(soap, "ns1:GetSellCardRecordByConditionResult");
	if (soap_out_PointerTons1__ArrayOfSellCardItem(soap, "ns1:GetSellCardRecordByConditionResult", -1, &(a->_ns1__GetSellCardRecordByConditionResponse::GetSellCardRecordByConditionResult), "ns1:ArrayOfSellCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellCardRecordByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellCardRecordByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetSellCardRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellCardRecordByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellCardRecordByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse, sizeof(_ns1__GetSellCardRecordByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellCardRecordByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSellCardRecordByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSellCardRecordByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSellCardItem(soap, "ns1:GetSellCardRecordByConditionResult", &(a->_ns1__GetSellCardRecordByConditionResponse::GetSellCardRecordByConditionResult), "ns1:ArrayOfSellCardItem"))
				{	soap_flag_GetSellCardRecordByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSellCardRecordByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellCardRecordByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse, 0, sizeof(_ns1__GetSellCardRecordByConditionResponse), 0, soap_copy__ns1__GetSellCardRecordByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSellCardRecordByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellCardRecordByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellCardRecordByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellCardRecordByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetSellCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellCardRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellCardRecordByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSellCardRecordByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellCardRecordByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetSellCardRecordByConditionResponse);
		((_ns1__GetSellCardRecordByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellCardRecordByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellCardRecordByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellCardRecordByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellCardRecordByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellCardRecordByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetSellCardRecordByConditionResponse*)p = *(_ns1__GetSellCardRecordByConditionResponse*)q;
}

void _ns1__GetSellCardRecordByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetSellCardRecordByCondition::top);
	soap_default_string(soap, &this->_ns1__GetSellCardRecordByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetSellCardRecordByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetSellCardRecordByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetSellCardRecordByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetSellCardRecordByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetSellCardRecordByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSellCardRecordByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSellCardRecordByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetSellCardRecordByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSellCardRecordByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetSellCardRecordByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetSellCardRecordByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetSellCardRecordByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSellCardRecordByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSellCardRecordByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByCondition * SOAP_FMAC4 soap_in__ns1__GetSellCardRecordByCondition(struct soap *soap, const char *tag, _ns1__GetSellCardRecordByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSellCardRecordByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSellCardRecordByCondition, sizeof(_ns1__GetSellCardRecordByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSellCardRecordByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSellCardRecordByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetSellCardRecordByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetSellCardRecordByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetSellCardRecordByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSellCardRecordByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSellCardRecordByCondition, 0, sizeof(_ns1__GetSellCardRecordByCondition), 0, soap_copy__ns1__GetSellCardRecordByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetSellCardRecordByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSellCardRecordByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetSellCardRecordByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSellCardRecordByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSellCardRecordByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByCondition * SOAP_FMAC4 soap_get__ns1__GetSellCardRecordByCondition(struct soap *soap, _ns1__GetSellCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSellCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSellCardRecordByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetSellCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSellCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSellCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordByCondition);
		if (size)
			*size = sizeof(_ns1__GetSellCardRecordByCondition);
		((_ns1__GetSellCardRecordByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSellCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetSellCardRecordByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetSellCardRecordByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetSellCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSellCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSellCardRecordByCondition %p -> %p\n", q, p));
	*(_ns1__GetSellCardRecordByCondition*)p = *(_ns1__GetSellCardRecordByCondition*)q;
}

void _ns1__GetCardServiceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCardServiceResponse::GetCardServiceResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetCardServiceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfCardService(soap, &this->_ns1__GetCardServiceResponse::GetCardServiceResult);
	/* transient soap skipped */
}

int _ns1__GetCardServiceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCardServiceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCardServiceResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCardServiceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCardServiceResponse), type))
		return soap->error;
	if (a->GetCardServiceResult)
		soap_element_result(soap, "ns1:GetCardServiceResult");
	if (soap_out_PointerTons1__ArrayOfCardService(soap, "ns1:GetCardServiceResult", -1, &(a->_ns1__GetCardServiceResponse::GetCardServiceResult), "ns1:ArrayOfCardService"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCardServiceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCardServiceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCardServiceResponse * SOAP_FMAC4 soap_in__ns1__GetCardServiceResponse(struct soap *soap, const char *tag, _ns1__GetCardServiceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCardServiceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCardServiceResponse, sizeof(_ns1__GetCardServiceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCardServiceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCardServiceResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCardServiceResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCardServiceResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfCardService(soap, "ns1:GetCardServiceResult", &(a->_ns1__GetCardServiceResponse::GetCardServiceResult), "ns1:ArrayOfCardService"))
				{	soap_flag_GetCardServiceResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetCardServiceResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCardServiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCardServiceResponse, 0, sizeof(_ns1__GetCardServiceResponse), 0, soap_copy__ns1__GetCardServiceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCardServiceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCardServiceResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetCardServiceResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCardServiceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCardServiceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCardServiceResponse * SOAP_FMAC4 soap_get__ns1__GetCardServiceResponse(struct soap *soap, _ns1__GetCardServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCardServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCardServiceResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCardServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCardServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCardServiceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCardServiceResponse);
		if (size)
			*size = sizeof(_ns1__GetCardServiceResponse);
		((_ns1__GetCardServiceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCardServiceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCardServiceResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetCardServiceResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCardServiceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCardServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCardServiceResponse %p -> %p\n", q, p));
	*(_ns1__GetCardServiceResponse*)p = *(_ns1__GetCardServiceResponse*)q;
}

void _ns1__GetCardService::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetCardService::top);
	soap_default_string(soap, &this->_ns1__GetCardService::condition);
	soap_default_string(soap, &this->_ns1__GetCardService::sessionId);
	/* transient soap skipped */
}

void _ns1__GetCardService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetCardService::condition);
	soap_serialize_string(soap, &this->_ns1__GetCardService::sessionId);
	/* transient soap skipped */
}

int _ns1__GetCardService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCardService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCardService(struct soap *soap, const char *tag, int id, const _ns1__GetCardService *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCardService), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetCardService::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetCardService::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetCardService::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCardService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCardService(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCardService * SOAP_FMAC4 soap_in__ns1__GetCardService(struct soap *soap, const char *tag, _ns1__GetCardService *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCardService *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCardService, sizeof(_ns1__GetCardService), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCardService)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCardService *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetCardService::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetCardService::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetCardService::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCardService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCardService, 0, sizeof(_ns1__GetCardService), 0, soap_copy__ns1__GetCardService);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetCardService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCardService);
	if (this->soap_out(soap, tag?tag:"ns1:GetCardService", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCardService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCardService(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCardService * SOAP_FMAC4 soap_get__ns1__GetCardService(struct soap *soap, _ns1__GetCardService *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCardService * SOAP_FMAC2 soap_instantiate__ns1__GetCardService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCardService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCardService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCardService);
		if (size)
			*size = sizeof(_ns1__GetCardService);
		((_ns1__GetCardService*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCardService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCardService);
		for (int i = 0; i < n; i++)
			((_ns1__GetCardService*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCardService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCardService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCardService %p -> %p\n", q, p));
	*(_ns1__GetCardService*)p = *(_ns1__GetCardService*)q;
}

void _ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPhoneNoItemAndHistoryByConditionResponse::GetPhoneNoItemAndHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPhoneNoItem(soap, &this->_ns1__GetPhoneNoItemAndHistoryByConditionResponse::GetPhoneNoItemAndHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoItemAndHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPhoneNoItemAndHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPhoneNoItemAndHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:GetPhoneNoItemAndHistoryByConditionResult", -1, &(a->_ns1__GetPhoneNoItemAndHistoryByConditionResponse::GetPhoneNoItemAndHistoryByConditionResult), "ns1:ArrayOfPhoneNoItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemAndHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse, sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPhoneNoItemAndHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPhoneNoItemAndHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:GetPhoneNoItemAndHistoryByConditionResult", &(a->_ns1__GetPhoneNoItemAndHistoryByConditionResponse::GetPhoneNoItemAndHistoryByConditionResult), "ns1:ArrayOfPhoneNoItem"))
				{	soap_flag_GetPhoneNoItemAndHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPhoneNoItemAndHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse, 0, sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse), 0, soap_copy__ns1__GetPhoneNoItemAndHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoItemAndHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoItemAndHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoItemAndHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoItemAndHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemAndHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse);
		((_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemAndHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoItemAndHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)p = *(_ns1__GetPhoneNoItemAndHistoryByConditionResponse*)q;
}

void _ns1__GetPhoneNoItemAndHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPhoneNoItemAndHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPhoneNoItemAndHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPhoneNoItemAndHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoItemAndHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoItemAndHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoItemAndHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPhoneNoItemAndHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPhoneNoItemAndHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoItemAndHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoItemAndHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition, sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoItemAndHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPhoneNoItemAndHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPhoneNoItemAndHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoItemAndHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition, 0, sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition), 0, soap_copy__ns1__GetPhoneNoItemAndHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoItemAndHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoItemAndHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoItemAndHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoItemAndHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemAndHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition);
		((_ns1__GetPhoneNoItemAndHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoItemAndHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoItemAndHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoItemAndHistoryByCondition*)p = *(_ns1__GetPhoneNoItemAndHistoryByCondition*)q;
}

void _ns1__GetPhoneNoItemByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPhoneNoItemByConditionResponse::GetPhoneNoItemByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPhoneNoItemByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPhoneNoItem(soap, &this->_ns1__GetPhoneNoItemByConditionResponse::GetPhoneNoItemByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoItemByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoItemByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoItemByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse), type))
		return soap->error;
	if (a->GetPhoneNoItemByConditionResult)
		soap_element_result(soap, "ns1:GetPhoneNoItemByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:GetPhoneNoItemByConditionResult", -1, &(a->_ns1__GetPhoneNoItemByConditionResponse::GetPhoneNoItemByConditionResult), "ns1:ArrayOfPhoneNoItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoItemByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoItemByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoItemByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse, sizeof(_ns1__GetPhoneNoItemByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoItemByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPhoneNoItemByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPhoneNoItemByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:GetPhoneNoItemByConditionResult", &(a->_ns1__GetPhoneNoItemByConditionResponse::GetPhoneNoItemByConditionResult), "ns1:ArrayOfPhoneNoItem"))
				{	soap_flag_GetPhoneNoItemByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPhoneNoItemByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoItemByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse, 0, sizeof(_ns1__GetPhoneNoItemByConditionResponse), 0, soap_copy__ns1__GetPhoneNoItemByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoItemByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoItemByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoItemByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoItemByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoItemByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoItemByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoItemByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoItemByConditionResponse);
		((_ns1__GetPhoneNoItemByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoItemByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoItemByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoItemByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoItemByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoItemByConditionResponse*)p = *(_ns1__GetPhoneNoItemByConditionResponse*)q;
}

void _ns1__GetPhoneNoItemByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPhoneNoItemByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPhoneNoItemByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPhoneNoItemByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoItemByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoItemByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoItemByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoItemByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoItemByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoItemByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPhoneNoItemByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPhoneNoItemByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoItemByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoItemByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_in__ns1__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoItemByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoItemByCondition, sizeof(_ns1__GetPhoneNoItemByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoItemByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoItemByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPhoneNoItemByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPhoneNoItemByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoItemByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoItemByCondition, 0, sizeof(_ns1__GetPhoneNoItemByCondition), 0, soap_copy__ns1__GetPhoneNoItemByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoItemByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoItemByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoItemByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoItemByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoItemByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_get__ns1__GetPhoneNoItemByCondition(struct soap *soap, _ns1__GetPhoneNoItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoItemByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemByCondition);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoItemByCondition);
		((_ns1__GetPhoneNoItemByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoItemByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoItemByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoItemByCondition %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoItemByCondition*)p = *(_ns1__GetPhoneNoItemByCondition*)q;
}

void _ns1__GetPayMiniCardHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayMiniCardHistoryByConditionResponse::GetPayMiniCardHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayMiniCardHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayMiniCardItem(soap, &this->_ns1__GetPayMiniCardHistoryByConditionResponse::GetPayMiniCardHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayMiniCardHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayMiniCardHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPayMiniCardHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPayMiniCardHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayMiniCardItem(soap, "ns1:GetPayMiniCardHistoryByConditionResult", -1, &(a->_ns1__GetPayMiniCardHistoryByConditionResponse::GetPayMiniCardHistoryByConditionResult), "ns1:ArrayOfPayMiniCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayMiniCardHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayMiniCardHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayMiniCardHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse, sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayMiniCardHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayMiniCardHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayMiniCardHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayMiniCardItem(soap, "ns1:GetPayMiniCardHistoryByConditionResult", &(a->_ns1__GetPayMiniCardHistoryByConditionResponse::GetPayMiniCardHistoryByConditionResult), "ns1:ArrayOfPayMiniCardItem"))
				{	soap_flag_GetPayMiniCardHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayMiniCardHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayMiniCardHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse, 0, sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse), 0, soap_copy__ns1__GetPayMiniCardHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayMiniCardHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayMiniCardHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayMiniCardHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayMiniCardHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayMiniCardHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayMiniCardHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse);
		((_ns1__GetPayMiniCardHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayMiniCardHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayMiniCardHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayMiniCardHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayMiniCardHistoryByConditionResponse*)p = *(_ns1__GetPayMiniCardHistoryByConditionResponse*)q;
}

void _ns1__GetPayMiniCardHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPayMiniCardHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayMiniCardHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayMiniCardHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayMiniCardHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayMiniCardHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayMiniCardHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayMiniCardHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayMiniCardHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayMiniCardHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayMiniCardHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayMiniCardHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayMiniCardHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition, sizeof(_ns1__GetPayMiniCardHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayMiniCardHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayMiniCardHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayMiniCardHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayMiniCardHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition, 0, sizeof(_ns1__GetPayMiniCardHistoryByCondition), 0, soap_copy__ns1__GetPayMiniCardHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayMiniCardHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayMiniCardHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayMiniCardHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayMiniCardHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, _ns1__GetPayMiniCardHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayMiniCardHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayMiniCardHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayMiniCardHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayMiniCardHistoryByCondition);
		((_ns1__GetPayMiniCardHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayMiniCardHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayMiniCardHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayMiniCardHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayMiniCardHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayMiniCardHistoryByCondition*)p = *(_ns1__GetPayMiniCardHistoryByCondition*)q;
}

void _ns1__GetPayMiniCardByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayMiniCardByConditionResponse::GetPayMiniCardByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayMiniCardByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayMiniCardItem(soap, &this->_ns1__GetPayMiniCardByConditionResponse::GetPayMiniCardByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayMiniCardByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayMiniCardByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayMiniCardByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayMiniCardByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse), type))
		return soap->error;
	if (a->GetPayMiniCardByConditionResult)
		soap_element_result(soap, "ns1:GetPayMiniCardByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayMiniCardItem(soap, "ns1:GetPayMiniCardByConditionResult", -1, &(a->_ns1__GetPayMiniCardByConditionResponse::GetPayMiniCardByConditionResult), "ns1:ArrayOfPayMiniCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayMiniCardByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayMiniCardByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayMiniCardByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayMiniCardByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayMiniCardByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse, sizeof(_ns1__GetPayMiniCardByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayMiniCardByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayMiniCardByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayMiniCardByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayMiniCardItem(soap, "ns1:GetPayMiniCardByConditionResult", &(a->_ns1__GetPayMiniCardByConditionResponse::GetPayMiniCardByConditionResult), "ns1:ArrayOfPayMiniCardItem"))
				{	soap_flag_GetPayMiniCardByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayMiniCardByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayMiniCardByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse, 0, sizeof(_ns1__GetPayMiniCardByConditionResponse), 0, soap_copy__ns1__GetPayMiniCardByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayMiniCardByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayMiniCardByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayMiniCardByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayMiniCardByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayMiniCardByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayMiniCardByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayMiniCardByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayMiniCardByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayMiniCardByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayMiniCardByConditionResponse);
		((_ns1__GetPayMiniCardByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayMiniCardByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayMiniCardByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayMiniCardByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayMiniCardByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayMiniCardByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayMiniCardByConditionResponse*)p = *(_ns1__GetPayMiniCardByConditionResponse*)q;
}

void _ns1__GetPayMiniCardByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPayMiniCardByCondition::top);
	soap_default_string(soap, &this->_ns1__GetPayMiniCardByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayMiniCardByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayMiniCardByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayMiniCardByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayMiniCardByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayMiniCardByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayMiniCardByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayMiniCardByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayMiniCardByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayMiniCardByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetPayMiniCardByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayMiniCardByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayMiniCardByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayMiniCardByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayMiniCardByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByCondition * SOAP_FMAC4 soap_in__ns1__GetPayMiniCardByCondition(struct soap *soap, const char *tag, _ns1__GetPayMiniCardByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayMiniCardByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayMiniCardByCondition, sizeof(_ns1__GetPayMiniCardByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayMiniCardByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayMiniCardByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetPayMiniCardByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayMiniCardByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayMiniCardByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayMiniCardByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayMiniCardByCondition, 0, sizeof(_ns1__GetPayMiniCardByCondition), 0, soap_copy__ns1__GetPayMiniCardByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPayMiniCardByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayMiniCardByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayMiniCardByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayMiniCardByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayMiniCardByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByCondition * SOAP_FMAC4 soap_get__ns1__GetPayMiniCardByCondition(struct soap *soap, _ns1__GetPayMiniCardByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayMiniCardByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayMiniCardByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayMiniCardByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayMiniCardByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayMiniCardByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayMiniCardByCondition);
		((_ns1__GetPayMiniCardByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayMiniCardByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayMiniCardByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayMiniCardByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayMiniCardByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayMiniCardByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayMiniCardByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayMiniCardByCondition*)p = *(_ns1__GetPayMiniCardByCondition*)q;
}

void _ns1__GetMiniCardRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMiniCardRecordResponse::GetMiniCardRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetMiniCardRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfMiniCardItem(soap, &this->_ns1__GetMiniCardRecordResponse::GetMiniCardRecordResult);
	/* transient soap skipped */
}

int _ns1__GetMiniCardRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMiniCardRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMiniCardRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMiniCardRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMiniCardRecordResponse), type))
		return soap->error;
	if (a->GetMiniCardRecordResult)
		soap_element_result(soap, "ns1:GetMiniCardRecordResult");
	if (soap_out_PointerTons1__ArrayOfMiniCardItem(soap, "ns1:GetMiniCardRecordResult", -1, &(a->_ns1__GetMiniCardRecordResponse::GetMiniCardRecordResult), "ns1:ArrayOfMiniCardItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMiniCardRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMiniCardRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecordResponse * SOAP_FMAC4 soap_in__ns1__GetMiniCardRecordResponse(struct soap *soap, const char *tag, _ns1__GetMiniCardRecordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMiniCardRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMiniCardRecordResponse, sizeof(_ns1__GetMiniCardRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetMiniCardRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetMiniCardRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetMiniCardRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMiniCardRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfMiniCardItem(soap, "ns1:GetMiniCardRecordResult", &(a->_ns1__GetMiniCardRecordResponse::GetMiniCardRecordResult), "ns1:ArrayOfMiniCardItem"))
				{	soap_flag_GetMiniCardRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetMiniCardRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMiniCardRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMiniCardRecordResponse, 0, sizeof(_ns1__GetMiniCardRecordResponse), 0, soap_copy__ns1__GetMiniCardRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetMiniCardRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetMiniCardRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetMiniCardRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMiniCardRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMiniCardRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecordResponse * SOAP_FMAC4 soap_get__ns1__GetMiniCardRecordResponse(struct soap *soap, _ns1__GetMiniCardRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMiniCardRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetMiniCardRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMiniCardRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMiniCardRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetMiniCardRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMiniCardRecordResponse);
		if (size)
			*size = sizeof(_ns1__GetMiniCardRecordResponse);
		((_ns1__GetMiniCardRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMiniCardRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetMiniCardRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetMiniCardRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetMiniCardRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetMiniCardRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetMiniCardRecordResponse %p -> %p\n", q, p));
	*(_ns1__GetMiniCardRecordResponse*)p = *(_ns1__GetMiniCardRecordResponse*)q;
}

void _ns1__GetMiniCardRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetMiniCardRecord::top);
	soap_default_string(soap, &this->_ns1__GetMiniCardRecord::condition);
	soap_default_string(soap, &this->_ns1__GetMiniCardRecord::sessionId);
	/* transient soap skipped */
}

void _ns1__GetMiniCardRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetMiniCardRecord::condition);
	soap_serialize_string(soap, &this->_ns1__GetMiniCardRecord::sessionId);
	/* transient soap skipped */
}

int _ns1__GetMiniCardRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMiniCardRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMiniCardRecord(struct soap *soap, const char *tag, int id, const _ns1__GetMiniCardRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMiniCardRecord), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetMiniCardRecord::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetMiniCardRecord::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetMiniCardRecord::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMiniCardRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMiniCardRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecord * SOAP_FMAC4 soap_in__ns1__GetMiniCardRecord(struct soap *soap, const char *tag, _ns1__GetMiniCardRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMiniCardRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMiniCardRecord, sizeof(_ns1__GetMiniCardRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetMiniCardRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetMiniCardRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetMiniCardRecord::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetMiniCardRecord::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetMiniCardRecord::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMiniCardRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMiniCardRecord, 0, sizeof(_ns1__GetMiniCardRecord), 0, soap_copy__ns1__GetMiniCardRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetMiniCardRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetMiniCardRecord);
	if (this->soap_out(soap, tag?tag:"ns1:GetMiniCardRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMiniCardRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMiniCardRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecord * SOAP_FMAC4 soap_get__ns1__GetMiniCardRecord(struct soap *soap, _ns1__GetMiniCardRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMiniCardRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetMiniCardRecord * SOAP_FMAC2 soap_instantiate__ns1__GetMiniCardRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMiniCardRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetMiniCardRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMiniCardRecord);
		if (size)
			*size = sizeof(_ns1__GetMiniCardRecord);
		((_ns1__GetMiniCardRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMiniCardRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetMiniCardRecord);
		for (int i = 0; i < n; i++)
			((_ns1__GetMiniCardRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetMiniCardRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetMiniCardRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetMiniCardRecord %p -> %p\n", q, p));
	*(_ns1__GetMiniCardRecord*)p = *(_ns1__GetMiniCardRecord*)q;
}

void _ns1__SellOhterCardResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SellOhterCardResponse::SellOhterCardResult);
	/* transient soap skipped */
}

void _ns1__SellOhterCardResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SellOhterCardResponse::SellOhterCardResult);
	/* transient soap skipped */
}

int _ns1__SellOhterCardResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SellOhterCardResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SellOhterCardResponse(struct soap *soap, const char *tag, int id, const _ns1__SellOhterCardResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SellOhterCardResponse), type))
		return soap->error;
	if (a->SellOhterCardResult)
		soap_element_result(soap, "ns1:SellOhterCardResult");
	if (soap_out_string(soap, "ns1:SellOhterCardResult", -1, &(a->_ns1__SellOhterCardResponse::SellOhterCardResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SellOhterCardResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SellOhterCardResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SellOhterCardResponse * SOAP_FMAC4 soap_in__ns1__SellOhterCardResponse(struct soap *soap, const char *tag, _ns1__SellOhterCardResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SellOhterCardResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SellOhterCardResponse, sizeof(_ns1__SellOhterCardResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SellOhterCardResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SellOhterCardResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellOhterCardResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellOhterCardResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SellOhterCardResult", &(a->_ns1__SellOhterCardResponse::SellOhterCardResult), "xsd:string"))
				{	soap_flag_SellOhterCardResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SellOhterCardResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SellOhterCardResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SellOhterCardResponse, 0, sizeof(_ns1__SellOhterCardResponse), 0, soap_copy__ns1__SellOhterCardResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SellOhterCardResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SellOhterCardResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SellOhterCardResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SellOhterCardResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SellOhterCardResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SellOhterCardResponse * SOAP_FMAC4 soap_get__ns1__SellOhterCardResponse(struct soap *soap, _ns1__SellOhterCardResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SellOhterCardResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SellOhterCardResponse * SOAP_FMAC2 soap_instantiate__ns1__SellOhterCardResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SellOhterCardResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SellOhterCardResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellOhterCardResponse);
		if (size)
			*size = sizeof(_ns1__SellOhterCardResponse);
		((_ns1__SellOhterCardResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellOhterCardResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SellOhterCardResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SellOhterCardResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SellOhterCardResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SellOhterCardResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SellOhterCardResponse %p -> %p\n", q, p));
	*(_ns1__SellOhterCardResponse*)p = *(_ns1__SellOhterCardResponse*)q;
}

void _ns1__SellOhterCard::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SellOhterCard::userId);
	soap_default_string(soap, &this->_ns1__SellOhterCard::cardType);
	soap_default_string(soap, &this->_ns1__SellOhterCard::cardName);
	soap_default_string(soap, &this->_ns1__SellOhterCard::sessionId);
	/* transient soap skipped */
}

void _ns1__SellOhterCard::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SellOhterCard::userId);
	soap_serialize_string(soap, &this->_ns1__SellOhterCard::cardType);
	soap_serialize_string(soap, &this->_ns1__SellOhterCard::cardName);
	soap_serialize_string(soap, &this->_ns1__SellOhterCard::sessionId);
	/* transient soap skipped */
}

int _ns1__SellOhterCard::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SellOhterCard(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SellOhterCard(struct soap *soap, const char *tag, int id, const _ns1__SellOhterCard *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SellOhterCard), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__SellOhterCard::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardType", -1, &(a->_ns1__SellOhterCard::cardType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardName", -1, &(a->_ns1__SellOhterCard::cardName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__SellOhterCard::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SellOhterCard::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SellOhterCard(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SellOhterCard * SOAP_FMAC4 soap_in__ns1__SellOhterCard(struct soap *soap, const char *tag, _ns1__SellOhterCard *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SellOhterCard *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SellOhterCard, sizeof(_ns1__SellOhterCard), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SellOhterCard)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SellOhterCard *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__SellOhterCard::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardType", &(a->_ns1__SellOhterCard::cardType), "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardName", &(a->_ns1__SellOhterCard::cardName), "xsd:string"))
				{	soap_flag_cardName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__SellOhterCard::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SellOhterCard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SellOhterCard, 0, sizeof(_ns1__SellOhterCard), 0, soap_copy__ns1__SellOhterCard);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SellOhterCard::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SellOhterCard);
	if (this->soap_out(soap, tag?tag:"ns1:SellOhterCard", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SellOhterCard::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SellOhterCard(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SellOhterCard * SOAP_FMAC4 soap_get__ns1__SellOhterCard(struct soap *soap, _ns1__SellOhterCard *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SellOhterCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SellOhterCard * SOAP_FMAC2 soap_instantiate__ns1__SellOhterCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SellOhterCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SellOhterCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellOhterCard);
		if (size)
			*size = sizeof(_ns1__SellOhterCard);
		((_ns1__SellOhterCard*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellOhterCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SellOhterCard);
		for (int i = 0; i < n; i++)
			((_ns1__SellOhterCard*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SellOhterCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SellOhterCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SellOhterCard %p -> %p\n", q, p));
	*(_ns1__SellOhterCard*)p = *(_ns1__SellOhterCard*)q;
}

void _ns1__SellNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SellNoResponse::SellNoResult);
	/* transient soap skipped */
}

void _ns1__SellNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SellNoResponse::SellNoResult);
	/* transient soap skipped */
}

int _ns1__SellNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SellNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SellNoResponse(struct soap *soap, const char *tag, int id, const _ns1__SellNoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SellNoResponse), type))
		return soap->error;
	if (a->SellNoResult)
		soap_element_result(soap, "ns1:SellNoResult");
	if (soap_out_string(soap, "ns1:SellNoResult", -1, &(a->_ns1__SellNoResponse::SellNoResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SellNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SellNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SellNoResponse * SOAP_FMAC4 soap_in__ns1__SellNoResponse(struct soap *soap, const char *tag, _ns1__SellNoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SellNoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SellNoResponse, sizeof(_ns1__SellNoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SellNoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SellNoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SellNoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SellNoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SellNoResult", &(a->_ns1__SellNoResponse::SellNoResult), "xsd:string"))
				{	soap_flag_SellNoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SellNoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SellNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SellNoResponse, 0, sizeof(_ns1__SellNoResponse), 0, soap_copy__ns1__SellNoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SellNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SellNoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SellNoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SellNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SellNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SellNoResponse * SOAP_FMAC4 soap_get__ns1__SellNoResponse(struct soap *soap, _ns1__SellNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SellNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SellNoResponse * SOAP_FMAC2 soap_instantiate__ns1__SellNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SellNoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SellNoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellNoResponse);
		if (size)
			*size = sizeof(_ns1__SellNoResponse);
		((_ns1__SellNoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellNoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SellNoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SellNoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SellNoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SellNoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SellNoResponse %p -> %p\n", q, p));
	*(_ns1__SellNoResponse*)p = *(_ns1__SellNoResponse*)q;
}

void _ns1__SellNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SellNo::userId);
	soap_default_string(soap, &this->_ns1__SellNo::No);
	soap_default_string(soap, &this->_ns1__SellNo::miniCard);
	soap_default_string(soap, &this->_ns1__SellNo::serviceName);
	soap_default_string(soap, &this->_ns1__SellNo::value);
	soap_default_string(soap, &this->_ns1__SellNo::sessionId);
	soap_default_string(soap, &this->_ns1__SellNo::business1);
	soap_default_string(soap, &this->_ns1__SellNo::business2);
	soap_default_string(soap, &this->_ns1__SellNo::business3);
	soap_default_string(soap, &this->_ns1__SellNo::clientType);
	/* transient soap skipped */
}

void _ns1__SellNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SellNo::userId);
	soap_serialize_string(soap, &this->_ns1__SellNo::No);
	soap_serialize_string(soap, &this->_ns1__SellNo::miniCard);
	soap_serialize_string(soap, &this->_ns1__SellNo::serviceName);
	soap_serialize_string(soap, &this->_ns1__SellNo::value);
	soap_serialize_string(soap, &this->_ns1__SellNo::sessionId);
	soap_serialize_string(soap, &this->_ns1__SellNo::business1);
	soap_serialize_string(soap, &this->_ns1__SellNo::business2);
	soap_serialize_string(soap, &this->_ns1__SellNo::business3);
	soap_serialize_string(soap, &this->_ns1__SellNo::clientType);
	/* transient soap skipped */
}

int _ns1__SellNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SellNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SellNo(struct soap *soap, const char *tag, int id, const _ns1__SellNo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SellNo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__SellNo::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:No", -1, &(a->_ns1__SellNo::No), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:miniCard", -1, &(a->_ns1__SellNo::miniCard), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:serviceName", -1, &(a->_ns1__SellNo::serviceName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:value", -1, &(a->_ns1__SellNo::value), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__SellNo::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:business1", -1, &(a->_ns1__SellNo::business1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:business2", -1, &(a->_ns1__SellNo::business2), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:business3", -1, &(a->_ns1__SellNo::business3), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__SellNo::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SellNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SellNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SellNo * SOAP_FMAC4 soap_in__ns1__SellNo(struct soap *soap, const char *tag, _ns1__SellNo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SellNo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SellNo, sizeof(_ns1__SellNo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SellNo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SellNo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_No1 = 1;
	size_t soap_flag_miniCard1 = 1;
	size_t soap_flag_serviceName1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_business11 = 1;
	size_t soap_flag_business21 = 1;
	size_t soap_flag_business31 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__SellNo::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_No1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:No", &(a->_ns1__SellNo::No), "xsd:string"))
				{	soap_flag_No1--;
					continue;
				}
			if (soap_flag_miniCard1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:miniCard", &(a->_ns1__SellNo::miniCard), "xsd:string"))
				{	soap_flag_miniCard1--;
					continue;
				}
			if (soap_flag_serviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:serviceName", &(a->_ns1__SellNo::serviceName), "xsd:string"))
				{	soap_flag_serviceName1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:value", &(a->_ns1__SellNo::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__SellNo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_business11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:business1", &(a->_ns1__SellNo::business1), "xsd:string"))
				{	soap_flag_business11--;
					continue;
				}
			if (soap_flag_business21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:business2", &(a->_ns1__SellNo::business2), "xsd:string"))
				{	soap_flag_business21--;
					continue;
				}
			if (soap_flag_business31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:business3", &(a->_ns1__SellNo::business3), "xsd:string"))
				{	soap_flag_business31--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__SellNo::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SellNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SellNo, 0, sizeof(_ns1__SellNo), 0, soap_copy__ns1__SellNo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SellNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SellNo);
	if (this->soap_out(soap, tag?tag:"ns1:SellNo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SellNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SellNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SellNo * SOAP_FMAC4 soap_get__ns1__SellNo(struct soap *soap, _ns1__SellNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SellNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SellNo * SOAP_FMAC2 soap_instantiate__ns1__SellNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SellNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SellNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellNo);
		if (size)
			*size = sizeof(_ns1__SellNo);
		((_ns1__SellNo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SellNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SellNo);
		for (int i = 0; i < n; i++)
			((_ns1__SellNo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SellNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SellNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SellNo %p -> %p\n", q, p));
	*(_ns1__SellNo*)p = *(_ns1__SellNo*)q;
}

void _ns1__SubmitBusinessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SubmitBusinessResponse::SubmitBusinessResult);
	/* transient soap skipped */
}

void _ns1__SubmitBusinessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SubmitBusinessResponse::SubmitBusinessResult);
	/* transient soap skipped */
}

int _ns1__SubmitBusinessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubmitBusinessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubmitBusinessResponse(struct soap *soap, const char *tag, int id, const _ns1__SubmitBusinessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubmitBusinessResponse), type))
		return soap->error;
	if (a->SubmitBusinessResult)
		soap_element_result(soap, "ns1:SubmitBusinessResult");
	if (soap_out_string(soap, "ns1:SubmitBusinessResult", -1, &(a->_ns1__SubmitBusinessResponse::SubmitBusinessResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SubmitBusinessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubmitBusinessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubmitBusinessResponse * SOAP_FMAC4 soap_in__ns1__SubmitBusinessResponse(struct soap *soap, const char *tag, _ns1__SubmitBusinessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubmitBusinessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubmitBusinessResponse, sizeof(_ns1__SubmitBusinessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubmitBusinessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubmitBusinessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SubmitBusinessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubmitBusinessResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SubmitBusinessResult", &(a->_ns1__SubmitBusinessResponse::SubmitBusinessResult), "xsd:string"))
				{	soap_flag_SubmitBusinessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SubmitBusinessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubmitBusinessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubmitBusinessResponse, 0, sizeof(_ns1__SubmitBusinessResponse), 0, soap_copy__ns1__SubmitBusinessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SubmitBusinessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubmitBusinessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SubmitBusinessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SubmitBusinessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubmitBusinessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubmitBusinessResponse * SOAP_FMAC4 soap_get__ns1__SubmitBusinessResponse(struct soap *soap, _ns1__SubmitBusinessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubmitBusinessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SubmitBusinessResponse * SOAP_FMAC2 soap_instantiate__ns1__SubmitBusinessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubmitBusinessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubmitBusinessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SubmitBusinessResponse);
		if (size)
			*size = sizeof(_ns1__SubmitBusinessResponse);
		((_ns1__SubmitBusinessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SubmitBusinessResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubmitBusinessResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SubmitBusinessResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubmitBusinessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubmitBusinessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubmitBusinessResponse %p -> %p\n", q, p));
	*(_ns1__SubmitBusinessResponse*)p = *(_ns1__SubmitBusinessResponse*)q;
}

void _ns1__SubmitBusiness::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SubmitBusiness::userId);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::userLevel);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::businessName);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::businessSpec);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::sp);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::No);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::passwd);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::content);
	soap_default_string(soap, &this->_ns1__SubmitBusiness::sessionId);
	/* transient soap skipped */
}

void _ns1__SubmitBusiness::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::userId);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::userLevel);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::businessName);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::businessSpec);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::sp);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::No);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::passwd);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::content);
	soap_serialize_string(soap, &this->_ns1__SubmitBusiness::sessionId);
	/* transient soap skipped */
}

int _ns1__SubmitBusiness::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubmitBusiness(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubmitBusiness(struct soap *soap, const char *tag, int id, const _ns1__SubmitBusiness *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubmitBusiness), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__SubmitBusiness::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userLevel", -1, &(a->_ns1__SubmitBusiness::userLevel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:businessName", -1, &(a->_ns1__SubmitBusiness::businessName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:businessSpec", -1, &(a->_ns1__SubmitBusiness::businessSpec), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sp", -1, &(a->_ns1__SubmitBusiness::sp), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:No", -1, &(a->_ns1__SubmitBusiness::No), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:passwd", -1, &(a->_ns1__SubmitBusiness::passwd), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__SubmitBusiness::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__SubmitBusiness::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SubmitBusiness::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubmitBusiness(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubmitBusiness * SOAP_FMAC4 soap_in__ns1__SubmitBusiness(struct soap *soap, const char *tag, _ns1__SubmitBusiness *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubmitBusiness *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubmitBusiness, sizeof(_ns1__SubmitBusiness), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubmitBusiness)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubmitBusiness *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userLevel1 = 1;
	size_t soap_flag_businessName1 = 1;
	size_t soap_flag_businessSpec1 = 1;
	size_t soap_flag_sp1 = 1;
	size_t soap_flag_No1 = 1;
	size_t soap_flag_passwd1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__SubmitBusiness::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userLevel", &(a->_ns1__SubmitBusiness::userLevel), "xsd:string"))
				{	soap_flag_userLevel1--;
					continue;
				}
			if (soap_flag_businessName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:businessName", &(a->_ns1__SubmitBusiness::businessName), "xsd:string"))
				{	soap_flag_businessName1--;
					continue;
				}
			if (soap_flag_businessSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:businessSpec", &(a->_ns1__SubmitBusiness::businessSpec), "xsd:string"))
				{	soap_flag_businessSpec1--;
					continue;
				}
			if (soap_flag_sp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sp", &(a->_ns1__SubmitBusiness::sp), "xsd:string"))
				{	soap_flag_sp1--;
					continue;
				}
			if (soap_flag_No1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:No", &(a->_ns1__SubmitBusiness::No), "xsd:string"))
				{	soap_flag_No1--;
					continue;
				}
			if (soap_flag_passwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:passwd", &(a->_ns1__SubmitBusiness::passwd), "xsd:string"))
				{	soap_flag_passwd1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__SubmitBusiness::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__SubmitBusiness::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubmitBusiness *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubmitBusiness, 0, sizeof(_ns1__SubmitBusiness), 0, soap_copy__ns1__SubmitBusiness);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SubmitBusiness::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubmitBusiness);
	if (this->soap_out(soap, tag?tag:"ns1:SubmitBusiness", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SubmitBusiness::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubmitBusiness(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubmitBusiness * SOAP_FMAC4 soap_get__ns1__SubmitBusiness(struct soap *soap, _ns1__SubmitBusiness *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubmitBusiness(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SubmitBusiness * SOAP_FMAC2 soap_instantiate__ns1__SubmitBusiness(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubmitBusiness(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubmitBusiness, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SubmitBusiness);
		if (size)
			*size = sizeof(_ns1__SubmitBusiness);
		((_ns1__SubmitBusiness*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SubmitBusiness[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubmitBusiness);
		for (int i = 0; i < n; i++)
			((_ns1__SubmitBusiness*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubmitBusiness*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubmitBusiness(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubmitBusiness %p -> %p\n", q, p));
	*(_ns1__SubmitBusiness*)p = *(_ns1__SubmitBusiness*)q;
}

void _ns1__UnlockNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UnlockNoResponse::UnlockNoResult);
	/* transient soap skipped */
}

void _ns1__UnlockNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UnlockNoResponse::UnlockNoResult);
	/* transient soap skipped */
}

int _ns1__UnlockNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnlockNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnlockNoResponse(struct soap *soap, const char *tag, int id, const _ns1__UnlockNoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnlockNoResponse), type))
		return soap->error;
	if (a->UnlockNoResult)
		soap_element_result(soap, "ns1:UnlockNoResult");
	if (soap_out_string(soap, "ns1:UnlockNoResult", -1, &(a->_ns1__UnlockNoResponse::UnlockNoResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnlockNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnlockNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnlockNoResponse * SOAP_FMAC4 soap_in__ns1__UnlockNoResponse(struct soap *soap, const char *tag, _ns1__UnlockNoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnlockNoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnlockNoResponse, sizeof(_ns1__UnlockNoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UnlockNoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UnlockNoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UnlockNoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UnlockNoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UnlockNoResult", &(a->_ns1__UnlockNoResponse::UnlockNoResult), "xsd:string"))
				{	soap_flag_UnlockNoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UnlockNoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UnlockNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnlockNoResponse, 0, sizeof(_ns1__UnlockNoResponse), 0, soap_copy__ns1__UnlockNoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UnlockNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UnlockNoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UnlockNoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnlockNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnlockNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnlockNoResponse * SOAP_FMAC4 soap_get__ns1__UnlockNoResponse(struct soap *soap, _ns1__UnlockNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnlockNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UnlockNoResponse * SOAP_FMAC2 soap_instantiate__ns1__UnlockNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnlockNoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UnlockNoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UnlockNoResponse);
		if (size)
			*size = sizeof(_ns1__UnlockNoResponse);
		((_ns1__UnlockNoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UnlockNoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UnlockNoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UnlockNoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UnlockNoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UnlockNoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UnlockNoResponse %p -> %p\n", q, p));
	*(_ns1__UnlockNoResponse*)p = *(_ns1__UnlockNoResponse*)q;
}

void _ns1__UnlockNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UnlockNo::No);
	soap_default_string(soap, &this->_ns1__UnlockNo::userId);
	soap_default_string(soap, &this->_ns1__UnlockNo::sessionId);
	/* transient soap skipped */
}

void _ns1__UnlockNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UnlockNo::No);
	soap_serialize_string(soap, &this->_ns1__UnlockNo::userId);
	soap_serialize_string(soap, &this->_ns1__UnlockNo::sessionId);
	/* transient soap skipped */
}

int _ns1__UnlockNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnlockNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnlockNo(struct soap *soap, const char *tag, int id, const _ns1__UnlockNo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnlockNo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:No", -1, &(a->_ns1__UnlockNo::No), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__UnlockNo::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UnlockNo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnlockNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnlockNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnlockNo * SOAP_FMAC4 soap_in__ns1__UnlockNo(struct soap *soap, const char *tag, _ns1__UnlockNo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnlockNo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnlockNo, sizeof(_ns1__UnlockNo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UnlockNo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UnlockNo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_No1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_No1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:No", &(a->_ns1__UnlockNo::No), "xsd:string"))
				{	soap_flag_No1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__UnlockNo::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UnlockNo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UnlockNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnlockNo, 0, sizeof(_ns1__UnlockNo), 0, soap_copy__ns1__UnlockNo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UnlockNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UnlockNo);
	if (this->soap_out(soap, tag?tag:"ns1:UnlockNo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnlockNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnlockNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnlockNo * SOAP_FMAC4 soap_get__ns1__UnlockNo(struct soap *soap, _ns1__UnlockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnlockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UnlockNo * SOAP_FMAC2 soap_instantiate__ns1__UnlockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnlockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UnlockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UnlockNo);
		if (size)
			*size = sizeof(_ns1__UnlockNo);
		((_ns1__UnlockNo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UnlockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UnlockNo);
		for (int i = 0; i < n; i++)
			((_ns1__UnlockNo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UnlockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UnlockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UnlockNo %p -> %p\n", q, p));
	*(_ns1__UnlockNo*)p = *(_ns1__UnlockNo*)q;
}

void _ns1__LockNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LockNoResponse::LockNoResult);
	/* transient soap skipped */
}

void _ns1__LockNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__LockNoResponse::LockNoResult);
	/* transient soap skipped */
}

int _ns1__LockNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LockNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LockNoResponse(struct soap *soap, const char *tag, int id, const _ns1__LockNoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LockNoResponse), type))
		return soap->error;
	if (a->LockNoResult)
		soap_element_result(soap, "ns1:LockNoResult");
	if (soap_out_string(soap, "ns1:LockNoResult", -1, &(a->_ns1__LockNoResponse::LockNoResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LockNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LockNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LockNoResponse * SOAP_FMAC4 soap_in__ns1__LockNoResponse(struct soap *soap, const char *tag, _ns1__LockNoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LockNoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LockNoResponse, sizeof(_ns1__LockNoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LockNoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LockNoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LockNoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LockNoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LockNoResult", &(a->_ns1__LockNoResponse::LockNoResult), "xsd:string"))
				{	soap_flag_LockNoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:LockNoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LockNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LockNoResponse, 0, sizeof(_ns1__LockNoResponse), 0, soap_copy__ns1__LockNoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__LockNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LockNoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LockNoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LockNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LockNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LockNoResponse * SOAP_FMAC4 soap_get__ns1__LockNoResponse(struct soap *soap, _ns1__LockNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LockNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LockNoResponse * SOAP_FMAC2 soap_instantiate__ns1__LockNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LockNoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LockNoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LockNoResponse);
		if (size)
			*size = sizeof(_ns1__LockNoResponse);
		((_ns1__LockNoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LockNoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LockNoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__LockNoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LockNoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LockNoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LockNoResponse %p -> %p\n", q, p));
	*(_ns1__LockNoResponse*)p = *(_ns1__LockNoResponse*)q;
}

void _ns1__LockNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LockNo::No);
	soap_default_string(soap, &this->_ns1__LockNo::userId);
	soap_default_string(soap, &this->_ns1__LockNo::sessionId);
	/* transient soap skipped */
}

void _ns1__LockNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__LockNo::No);
	soap_serialize_string(soap, &this->_ns1__LockNo::userId);
	soap_serialize_string(soap, &this->_ns1__LockNo::sessionId);
	/* transient soap skipped */
}

int _ns1__LockNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LockNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LockNo(struct soap *soap, const char *tag, int id, const _ns1__LockNo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LockNo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:No", -1, &(a->_ns1__LockNo::No), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__LockNo::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__LockNo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LockNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LockNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LockNo * SOAP_FMAC4 soap_in__ns1__LockNo(struct soap *soap, const char *tag, _ns1__LockNo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LockNo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LockNo, sizeof(_ns1__LockNo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LockNo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LockNo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_No1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_No1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:No", &(a->_ns1__LockNo::No), "xsd:string"))
				{	soap_flag_No1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__LockNo::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__LockNo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LockNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LockNo, 0, sizeof(_ns1__LockNo), 0, soap_copy__ns1__LockNo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__LockNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LockNo);
	if (this->soap_out(soap, tag?tag:"ns1:LockNo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LockNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LockNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LockNo * SOAP_FMAC4 soap_get__ns1__LockNo(struct soap *soap, _ns1__LockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LockNo * SOAP_FMAC2 soap_instantiate__ns1__LockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LockNo);
		if (size)
			*size = sizeof(_ns1__LockNo);
		((_ns1__LockNo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LockNo);
		for (int i = 0; i < n; i++)
			((_ns1__LockNo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LockNo %p -> %p\n", q, p));
	*(_ns1__LockNo*)p = *(_ns1__LockNo*)q;
}

void _ns1__GetMyNoSectionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMyNoSectionResponse::GetMyNoSectionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetMyNoSectionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__GetMyNoSectionResponse::GetMyNoSectionResult);
	/* transient soap skipped */
}

int _ns1__GetMyNoSectionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMyNoSectionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMyNoSectionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMyNoSectionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMyNoSectionResponse), type))
		return soap->error;
	if (a->GetMyNoSectionResult)
		soap_element_result(soap, "ns1:GetMyNoSectionResult");
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:GetMyNoSectionResult", -1, &(a->_ns1__GetMyNoSectionResponse::GetMyNoSectionResult), "ns1:ArrayOfString"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMyNoSectionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMyNoSectionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMyNoSectionResponse * SOAP_FMAC4 soap_in__ns1__GetMyNoSectionResponse(struct soap *soap, const char *tag, _ns1__GetMyNoSectionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMyNoSectionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMyNoSectionResponse, sizeof(_ns1__GetMyNoSectionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetMyNoSectionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetMyNoSectionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetMyNoSectionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMyNoSectionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:GetMyNoSectionResult", &(a->_ns1__GetMyNoSectionResponse::GetMyNoSectionResult), "ns1:ArrayOfString"))
				{	soap_flag_GetMyNoSectionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetMyNoSectionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMyNoSectionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMyNoSectionResponse, 0, sizeof(_ns1__GetMyNoSectionResponse), 0, soap_copy__ns1__GetMyNoSectionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetMyNoSectionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetMyNoSectionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetMyNoSectionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMyNoSectionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMyNoSectionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMyNoSectionResponse * SOAP_FMAC4 soap_get__ns1__GetMyNoSectionResponse(struct soap *soap, _ns1__GetMyNoSectionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMyNoSectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetMyNoSectionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMyNoSectionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMyNoSectionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetMyNoSectionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMyNoSectionResponse);
		if (size)
			*size = sizeof(_ns1__GetMyNoSectionResponse);
		((_ns1__GetMyNoSectionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMyNoSectionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetMyNoSectionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetMyNoSectionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetMyNoSectionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetMyNoSectionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetMyNoSectionResponse %p -> %p\n", q, p));
	*(_ns1__GetMyNoSectionResponse*)p = *(_ns1__GetMyNoSectionResponse*)q;
}

void _ns1__GetMyNoSection::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMyNoSection::userId);
	soap_default_string(soap, &this->_ns1__GetMyNoSection::sessionId);
	/* transient soap skipped */
}

void _ns1__GetMyNoSection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetMyNoSection::userId);
	soap_serialize_string(soap, &this->_ns1__GetMyNoSection::sessionId);
	/* transient soap skipped */
}

int _ns1__GetMyNoSection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMyNoSection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMyNoSection(struct soap *soap, const char *tag, int id, const _ns1__GetMyNoSection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMyNoSection), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__GetMyNoSection::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetMyNoSection::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMyNoSection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMyNoSection(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMyNoSection * SOAP_FMAC4 soap_in__ns1__GetMyNoSection(struct soap *soap, const char *tag, _ns1__GetMyNoSection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMyNoSection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMyNoSection, sizeof(_ns1__GetMyNoSection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetMyNoSection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetMyNoSection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__GetMyNoSection::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetMyNoSection::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMyNoSection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMyNoSection, 0, sizeof(_ns1__GetMyNoSection), 0, soap_copy__ns1__GetMyNoSection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetMyNoSection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetMyNoSection);
	if (this->soap_out(soap, tag?tag:"ns1:GetMyNoSection", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMyNoSection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMyNoSection(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMyNoSection * SOAP_FMAC4 soap_get__ns1__GetMyNoSection(struct soap *soap, _ns1__GetMyNoSection *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMyNoSection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetMyNoSection * SOAP_FMAC2 soap_instantiate__ns1__GetMyNoSection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMyNoSection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetMyNoSection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMyNoSection);
		if (size)
			*size = sizeof(_ns1__GetMyNoSection);
		((_ns1__GetMyNoSection*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetMyNoSection[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetMyNoSection);
		for (int i = 0; i < n; i++)
			((_ns1__GetMyNoSection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetMyNoSection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetMyNoSection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetMyNoSection %p -> %p\n", q, p));
	*(_ns1__GetMyNoSection*)p = *(_ns1__GetMyNoSection*)q;
}

void _ns1__GetPhoneNoByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPhoneNoByConditionResponse::GetPhoneNoByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPhoneNoByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PhoneNoList(soap, &this->_ns1__GetPhoneNoByConditionResponse::GetPhoneNoByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse), type))
		return soap->error;
	if (a->GetPhoneNoByConditionResult)
		soap_element_result(soap, "ns1:GetPhoneNoByConditionResult");
	if (soap_out_PointerTons1__PhoneNoList(soap, "ns1:GetPhoneNoByConditionResult", -1, &(a->_ns1__GetPhoneNoByConditionResponse::GetPhoneNoByConditionResult), "ns1:PhoneNoList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPhoneNoByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse, sizeof(_ns1__GetPhoneNoByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPhoneNoByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPhoneNoByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneNoList(soap, "ns1:GetPhoneNoByConditionResult", &(a->_ns1__GetPhoneNoByConditionResponse::GetPhoneNoByConditionResult), "ns1:PhoneNoList"))
				{	soap_flag_GetPhoneNoByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPhoneNoByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse, 0, sizeof(_ns1__GetPhoneNoByConditionResponse), 0, soap_copy__ns1__GetPhoneNoByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPhoneNoByConditionResponse(struct soap *soap, _ns1__GetPhoneNoByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoByConditionResponse);
		((_ns1__GetPhoneNoByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoByConditionResponse*)p = *(_ns1__GetPhoneNoByConditionResponse*)q;
}

void _ns1__GetPhoneNoByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPhoneNoByCondition::pageSize);
	soap_default_int(soap, &this->_ns1__GetPhoneNoByCondition::pageIndex);
	soap_default_string(soap, &this->_ns1__GetPhoneNoByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPhoneNoByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPhoneNoByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPhoneNoByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPhoneNoByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNoByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNoByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNoByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNoByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->_ns1__GetPhoneNoByCondition::pageSize), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageIndex", -1, &(a->_ns1__GetPhoneNoByCondition::pageIndex), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPhoneNoByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPhoneNoByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNoByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNoByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByCondition * SOAP_FMAC4 soap_in__ns1__GetPhoneNoByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNoByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNoByCondition, sizeof(_ns1__GetPhoneNoByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNoByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNoByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_pageIndex1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->_ns1__GetPhoneNoByCondition::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_pageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageIndex", &(a->_ns1__GetPhoneNoByCondition::pageIndex), "xsd:int"))
				{	soap_flag_pageIndex1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPhoneNoByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPhoneNoByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNoByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNoByCondition, 0, sizeof(_ns1__GetPhoneNoByCondition), 0, soap_copy__ns1__GetPhoneNoByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize1 > 0 || soap_flag_pageIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPhoneNoByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNoByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNoByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNoByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNoByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByCondition * SOAP_FMAC4 soap_get__ns1__GetPhoneNoByCondition(struct soap *soap, _ns1__GetPhoneNoByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNoByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNoByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNoByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNoByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNoByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoByCondition);
		if (size)
			*size = sizeof(_ns1__GetPhoneNoByCondition);
		((_ns1__GetPhoneNoByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNoByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNoByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNoByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNoByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNoByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNoByCondition %p -> %p\n", q, p));
	*(_ns1__GetPhoneNoByCondition*)p = *(_ns1__GetPhoneNoByCondition*)q;
}

void _ns1__BuyMiniCardResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__BuyMiniCardResponse::BuyMiniCardResult);
	/* transient soap skipped */
}

void _ns1__BuyMiniCardResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__BuyMiniCardResponse::BuyMiniCardResult);
	/* transient soap skipped */
}

int _ns1__BuyMiniCardResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BuyMiniCardResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BuyMiniCardResponse(struct soap *soap, const char *tag, int id, const _ns1__BuyMiniCardResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BuyMiniCardResponse), type))
		return soap->error;
	if (a->BuyMiniCardResult)
		soap_element_result(soap, "ns1:BuyMiniCardResult");
	if (soap_out_string(soap, "ns1:BuyMiniCardResult", -1, &(a->_ns1__BuyMiniCardResponse::BuyMiniCardResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BuyMiniCardResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BuyMiniCardResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BuyMiniCardResponse * SOAP_FMAC4 soap_in__ns1__BuyMiniCardResponse(struct soap *soap, const char *tag, _ns1__BuyMiniCardResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BuyMiniCardResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BuyMiniCardResponse, sizeof(_ns1__BuyMiniCardResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BuyMiniCardResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BuyMiniCardResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BuyMiniCardResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BuyMiniCardResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:BuyMiniCardResult", &(a->_ns1__BuyMiniCardResponse::BuyMiniCardResult), "xsd:string"))
				{	soap_flag_BuyMiniCardResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:BuyMiniCardResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BuyMiniCardResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BuyMiniCardResponse, 0, sizeof(_ns1__BuyMiniCardResponse), 0, soap_copy__ns1__BuyMiniCardResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__BuyMiniCardResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__BuyMiniCardResponse);
	if (this->soap_out(soap, tag?tag:"ns1:BuyMiniCardResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BuyMiniCardResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BuyMiniCardResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BuyMiniCardResponse * SOAP_FMAC4 soap_get__ns1__BuyMiniCardResponse(struct soap *soap, _ns1__BuyMiniCardResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BuyMiniCardResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BuyMiniCardResponse * SOAP_FMAC2 soap_instantiate__ns1__BuyMiniCardResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BuyMiniCardResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BuyMiniCardResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BuyMiniCardResponse);
		if (size)
			*size = sizeof(_ns1__BuyMiniCardResponse);
		((_ns1__BuyMiniCardResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BuyMiniCardResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__BuyMiniCardResponse);
		for (int i = 0; i < n; i++)
			((_ns1__BuyMiniCardResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__BuyMiniCardResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BuyMiniCardResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BuyMiniCardResponse %p -> %p\n", q, p));
	*(_ns1__BuyMiniCardResponse*)p = *(_ns1__BuyMiniCardResponse*)q;
}

void _ns1__BuyMiniCard::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__BuyMiniCard::data);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::userId);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::workerId);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::SP);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::count);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::money);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::content);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::clientType);
	soap_default_string(soap, &this->_ns1__BuyMiniCard::sessionId);
	/* transient soap skipped */
}

void _ns1__BuyMiniCard::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::data);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::userId);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::workerId);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::SP);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::count);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::money);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::content);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::clientType);
	soap_serialize_string(soap, &this->_ns1__BuyMiniCard::sessionId);
	/* transient soap skipped */
}

int _ns1__BuyMiniCard::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BuyMiniCard(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BuyMiniCard(struct soap *soap, const char *tag, int id, const _ns1__BuyMiniCard *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BuyMiniCard), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:data", -1, &(a->_ns1__BuyMiniCard::data), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__BuyMiniCard::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerId", -1, &(a->_ns1__BuyMiniCard::workerId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->_ns1__BuyMiniCard::SP), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:count", -1, &(a->_ns1__BuyMiniCard::count), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:money", -1, &(a->_ns1__BuyMiniCard::money), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__BuyMiniCard::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__BuyMiniCard::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__BuyMiniCard::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BuyMiniCard::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BuyMiniCard(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BuyMiniCard * SOAP_FMAC4 soap_in__ns1__BuyMiniCard(struct soap *soap, const char *tag, _ns1__BuyMiniCard *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BuyMiniCard *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BuyMiniCard, sizeof(_ns1__BuyMiniCard), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BuyMiniCard)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BuyMiniCard *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_data1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_SP1 = 1;
	size_t soap_flag_count1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:data", &(a->_ns1__BuyMiniCard::data), "xsd:string"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__BuyMiniCard::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerId", &(a->_ns1__BuyMiniCard::workerId), "xsd:string"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->_ns1__BuyMiniCard::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			if (soap_flag_count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:count", &(a->_ns1__BuyMiniCard::count), "xsd:string"))
				{	soap_flag_count1--;
					continue;
				}
			if (soap_flag_money1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:money", &(a->_ns1__BuyMiniCard::money), "xsd:string"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__BuyMiniCard::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__BuyMiniCard::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__BuyMiniCard::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BuyMiniCard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BuyMiniCard, 0, sizeof(_ns1__BuyMiniCard), 0, soap_copy__ns1__BuyMiniCard);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__BuyMiniCard::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__BuyMiniCard);
	if (this->soap_out(soap, tag?tag:"ns1:BuyMiniCard", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BuyMiniCard::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BuyMiniCard(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BuyMiniCard * SOAP_FMAC4 soap_get__ns1__BuyMiniCard(struct soap *soap, _ns1__BuyMiniCard *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BuyMiniCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BuyMiniCard * SOAP_FMAC2 soap_instantiate__ns1__BuyMiniCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BuyMiniCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BuyMiniCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BuyMiniCard);
		if (size)
			*size = sizeof(_ns1__BuyMiniCard);
		((_ns1__BuyMiniCard*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BuyMiniCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__BuyMiniCard);
		for (int i = 0; i < n; i++)
			((_ns1__BuyMiniCard*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__BuyMiniCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BuyMiniCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BuyMiniCard %p -> %p\n", q, p));
	*(_ns1__BuyMiniCard*)p = *(_ns1__BuyMiniCard*)q;
}

void _ns1__queryPhoneNOInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__queryPhoneNOInfoResponse::queryPhoneNOInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__queryPhoneNOInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Result(soap, &this->_ns1__queryPhoneNOInfoResponse::queryPhoneNOInfoResult);
	/* transient soap skipped */
}

int _ns1__queryPhoneNOInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__queryPhoneNOInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPhoneNOInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__queryPhoneNOInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPhoneNOInfoResponse), type))
		return soap->error;
	if (a->queryPhoneNOInfoResult)
		soap_element_result(soap, "ns1:queryPhoneNOInfoResult");
	if (soap_out_PointerTons1__Result(soap, "ns1:queryPhoneNOInfoResult", -1, &(a->_ns1__queryPhoneNOInfoResponse::queryPhoneNOInfoResult), "ns1:Result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__queryPhoneNOInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__queryPhoneNOInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfoResponse * SOAP_FMAC4 soap_in__ns1__queryPhoneNOInfoResponse(struct soap *soap, const char *tag, _ns1__queryPhoneNOInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__queryPhoneNOInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPhoneNOInfoResponse, sizeof(_ns1__queryPhoneNOInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__queryPhoneNOInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__queryPhoneNOInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queryPhoneNOInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryPhoneNOInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Result(soap, "ns1:queryPhoneNOInfoResult", &(a->_ns1__queryPhoneNOInfoResponse::queryPhoneNOInfoResult), "ns1:Result"))
				{	soap_flag_queryPhoneNOInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:queryPhoneNOInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__queryPhoneNOInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPhoneNOInfoResponse, 0, sizeof(_ns1__queryPhoneNOInfoResponse), 0, soap_copy__ns1__queryPhoneNOInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__queryPhoneNOInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__queryPhoneNOInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:queryPhoneNOInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__queryPhoneNOInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__queryPhoneNOInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfoResponse * SOAP_FMAC4 soap_get__ns1__queryPhoneNOInfoResponse(struct soap *soap, _ns1__queryPhoneNOInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPhoneNOInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__queryPhoneNOInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__queryPhoneNOInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__queryPhoneNOInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__queryPhoneNOInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__queryPhoneNOInfoResponse);
		if (size)
			*size = sizeof(_ns1__queryPhoneNOInfoResponse);
		((_ns1__queryPhoneNOInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__queryPhoneNOInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__queryPhoneNOInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__queryPhoneNOInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__queryPhoneNOInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__queryPhoneNOInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__queryPhoneNOInfoResponse %p -> %p\n", q, p));
	*(_ns1__queryPhoneNOInfoResponse*)p = *(_ns1__queryPhoneNOInfoResponse*)q;
}

void _ns1__queryPhoneNOInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__queryPhoneNOInfo::phoneNO);
	/* transient soap skipped */
}

void _ns1__queryPhoneNOInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__queryPhoneNOInfo::phoneNO);
	/* transient soap skipped */
}

int _ns1__queryPhoneNOInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__queryPhoneNOInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, const _ns1__queryPhoneNOInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPhoneNOInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:phoneNO", -1, &(a->_ns1__queryPhoneNOInfo::phoneNO), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__queryPhoneNOInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__queryPhoneNOInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfo * SOAP_FMAC4 soap_in__ns1__queryPhoneNOInfo(struct soap *soap, const char *tag, _ns1__queryPhoneNOInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__queryPhoneNOInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPhoneNOInfo, sizeof(_ns1__queryPhoneNOInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__queryPhoneNOInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__queryPhoneNOInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_phoneNO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_phoneNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:phoneNO", &(a->_ns1__queryPhoneNOInfo::phoneNO), "xsd:string"))
				{	soap_flag_phoneNO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__queryPhoneNOInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPhoneNOInfo, 0, sizeof(_ns1__queryPhoneNOInfo), 0, soap_copy__ns1__queryPhoneNOInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__queryPhoneNOInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__queryPhoneNOInfo);
	if (this->soap_out(soap, tag?tag:"ns1:queryPhoneNOInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__queryPhoneNOInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__queryPhoneNOInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfo * SOAP_FMAC4 soap_get__ns1__queryPhoneNOInfo(struct soap *soap, _ns1__queryPhoneNOInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__queryPhoneNOInfo * SOAP_FMAC2 soap_instantiate__ns1__queryPhoneNOInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__queryPhoneNOInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__queryPhoneNOInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__queryPhoneNOInfo);
		if (size)
			*size = sizeof(_ns1__queryPhoneNOInfo);
		((_ns1__queryPhoneNOInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__queryPhoneNOInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__queryPhoneNOInfo);
		for (int i = 0; i < n; i++)
			((_ns1__queryPhoneNOInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__queryPhoneNOInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__queryPhoneNOInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__queryPhoneNOInfo %p -> %p\n", q, p));
	*(_ns1__queryPhoneNOInfo*)p = *(_ns1__queryPhoneNOInfo*)q;
}

void _ns1__GetClientVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetClientVersionResponse::GetClientVersionResult);
	/* transient soap skipped */
}

void _ns1__GetClientVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetClientVersionResponse::GetClientVersionResult);
	/* transient soap skipped */
}

int _ns1__GetClientVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClientVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClientVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetClientVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClientVersionResponse), type))
		return soap->error;
	if (a->GetClientVersionResult)
		soap_element_result(soap, "ns1:GetClientVersionResult");
	if (soap_out_string(soap, "ns1:GetClientVersionResult", -1, &(a->_ns1__GetClientVersionResponse::GetClientVersionResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClientVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClientVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClientVersionResponse * SOAP_FMAC4 soap_in__ns1__GetClientVersionResponse(struct soap *soap, const char *tag, _ns1__GetClientVersionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClientVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClientVersionResponse, sizeof(_ns1__GetClientVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClientVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClientVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetClientVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetClientVersionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetClientVersionResult", &(a->_ns1__GetClientVersionResponse::GetClientVersionResult), "xsd:string"))
				{	soap_flag_GetClientVersionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetClientVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClientVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClientVersionResponse, 0, sizeof(_ns1__GetClientVersionResponse), 0, soap_copy__ns1__GetClientVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetClientVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClientVersionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetClientVersionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetClientVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClientVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClientVersionResponse * SOAP_FMAC4 soap_get__ns1__GetClientVersionResponse(struct soap *soap, _ns1__GetClientVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClientVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetClientVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetClientVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClientVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClientVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClientVersionResponse);
		if (size)
			*size = sizeof(_ns1__GetClientVersionResponse);
		((_ns1__GetClientVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClientVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetClientVersionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetClientVersionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetClientVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClientVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClientVersionResponse %p -> %p\n", q, p));
	*(_ns1__GetClientVersionResponse*)p = *(_ns1__GetClientVersionResponse*)q;
}

void _ns1__GetClientVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetClientVersion::clientType);
	/* transient soap skipped */
}

void _ns1__GetClientVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetClientVersion::clientType);
	/* transient soap skipped */
}

int _ns1__GetClientVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClientVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClientVersion(struct soap *soap, const char *tag, int id, const _ns1__GetClientVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClientVersion), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__GetClientVersion::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClientVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClientVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClientVersion * SOAP_FMAC4 soap_in__ns1__GetClientVersion(struct soap *soap, const char *tag, _ns1__GetClientVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClientVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClientVersion, sizeof(_ns1__GetClientVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClientVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClientVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__GetClientVersion::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClientVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClientVersion, 0, sizeof(_ns1__GetClientVersion), 0, soap_copy__ns1__GetClientVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetClientVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClientVersion);
	if (this->soap_out(soap, tag?tag:"ns1:GetClientVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetClientVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClientVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClientVersion * SOAP_FMAC4 soap_get__ns1__GetClientVersion(struct soap *soap, _ns1__GetClientVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClientVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetClientVersion * SOAP_FMAC2 soap_instantiate__ns1__GetClientVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClientVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClientVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClientVersion);
		if (size)
			*size = sizeof(_ns1__GetClientVersion);
		((_ns1__GetClientVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClientVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetClientVersion);
		for (int i = 0; i < n; i++)
			((_ns1__GetClientVersion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetClientVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClientVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClientVersion %p -> %p\n", q, p));
	*(_ns1__GetClientVersion*)p = *(_ns1__GetClientVersion*)q;
}

void _ns1__DeleteCompanyAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteCompanyAccountResponse::DeleteCompanyAccountResult);
	/* transient soap skipped */
}

void _ns1__DeleteCompanyAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteCompanyAccountResponse::DeleteCompanyAccountResult);
	/* transient soap skipped */
}

int _ns1__DeleteCompanyAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteCompanyAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteCompanyAccountResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteCompanyAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteCompanyAccountResponse), type))
		return soap->error;
	if (a->DeleteCompanyAccountResult)
		soap_element_result(soap, "ns1:DeleteCompanyAccountResult");
	if (soap_out_string(soap, "ns1:DeleteCompanyAccountResult", -1, &(a->_ns1__DeleteCompanyAccountResponse::DeleteCompanyAccountResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteCompanyAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteCompanyAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccountResponse * SOAP_FMAC4 soap_in__ns1__DeleteCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__DeleteCompanyAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteCompanyAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteCompanyAccountResponse, sizeof(_ns1__DeleteCompanyAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteCompanyAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteCompanyAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeleteCompanyAccountResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteCompanyAccountResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeleteCompanyAccountResult", &(a->_ns1__DeleteCompanyAccountResponse::DeleteCompanyAccountResult), "xsd:string"))
				{	soap_flag_DeleteCompanyAccountResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeleteCompanyAccountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteCompanyAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteCompanyAccountResponse, 0, sizeof(_ns1__DeleteCompanyAccountResponse), 0, soap_copy__ns1__DeleteCompanyAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteCompanyAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteCompanyAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteCompanyAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteCompanyAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteCompanyAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccountResponse * SOAP_FMAC4 soap_get__ns1__DeleteCompanyAccountResponse(struct soap *soap, _ns1__DeleteCompanyAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteCompanyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteCompanyAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteCompanyAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteCompanyAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteCompanyAccountResponse);
		if (size)
			*size = sizeof(_ns1__DeleteCompanyAccountResponse);
		((_ns1__DeleteCompanyAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteCompanyAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteCompanyAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteCompanyAccountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteCompanyAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteCompanyAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteCompanyAccountResponse %p -> %p\n", q, p));
	*(_ns1__DeleteCompanyAccountResponse*)p = *(_ns1__DeleteCompanyAccountResponse*)q;
}

void _ns1__DeleteCompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteCompanyAccount::accountId);
	soap_default_string(soap, &this->_ns1__DeleteCompanyAccount::operatorId);
	soap_default_string(soap, &this->_ns1__DeleteCompanyAccount::sessionId);
	/* transient soap skipped */
}

void _ns1__DeleteCompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteCompanyAccount::accountId);
	soap_serialize_string(soap, &this->_ns1__DeleteCompanyAccount::operatorId);
	soap_serialize_string(soap, &this->_ns1__DeleteCompanyAccount::sessionId);
	/* transient soap skipped */
}

int _ns1__DeleteCompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteCompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteCompanyAccount(struct soap *soap, const char *tag, int id, const _ns1__DeleteCompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteCompanyAccount), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:accountId", -1, &(a->_ns1__DeleteCompanyAccount::accountId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__DeleteCompanyAccount::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__DeleteCompanyAccount::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteCompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteCompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccount * SOAP_FMAC4 soap_in__ns1__DeleteCompanyAccount(struct soap *soap, const char *tag, _ns1__DeleteCompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteCompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteCompanyAccount, sizeof(_ns1__DeleteCompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteCompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteCompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accountId1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accountId", &(a->_ns1__DeleteCompanyAccount::accountId), "xsd:string"))
				{	soap_flag_accountId1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__DeleteCompanyAccount::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__DeleteCompanyAccount::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteCompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteCompanyAccount, 0, sizeof(_ns1__DeleteCompanyAccount), 0, soap_copy__ns1__DeleteCompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteCompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteCompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteCompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteCompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteCompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccount * SOAP_FMAC4 soap_get__ns1__DeleteCompanyAccount(struct soap *soap, _ns1__DeleteCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteCompanyAccount * SOAP_FMAC2 soap_instantiate__ns1__DeleteCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteCompanyAccount);
		if (size)
			*size = sizeof(_ns1__DeleteCompanyAccount);
		((_ns1__DeleteCompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteCompanyAccount);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteCompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteCompanyAccount %p -> %p\n", q, p));
	*(_ns1__DeleteCompanyAccount*)p = *(_ns1__DeleteCompanyAccount*)q;
}

void _ns1__UpdateCompanyAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateCompanyAccountResponse::UpdateCompanyAccountResult);
	/* transient soap skipped */
}

void _ns1__UpdateCompanyAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateCompanyAccountResponse::UpdateCompanyAccountResult);
	/* transient soap skipped */
}

int _ns1__UpdateCompanyAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateCompanyAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateCompanyAccountResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateCompanyAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateCompanyAccountResponse), type))
		return soap->error;
	if (a->UpdateCompanyAccountResult)
		soap_element_result(soap, "ns1:UpdateCompanyAccountResult");
	if (soap_out_string(soap, "ns1:UpdateCompanyAccountResult", -1, &(a->_ns1__UpdateCompanyAccountResponse::UpdateCompanyAccountResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateCompanyAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateCompanyAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccountResponse * SOAP_FMAC4 soap_in__ns1__UpdateCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__UpdateCompanyAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateCompanyAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateCompanyAccountResponse, sizeof(_ns1__UpdateCompanyAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateCompanyAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateCompanyAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateCompanyAccountResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateCompanyAccountResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateCompanyAccountResult", &(a->_ns1__UpdateCompanyAccountResponse::UpdateCompanyAccountResult), "xsd:string"))
				{	soap_flag_UpdateCompanyAccountResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateCompanyAccountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateCompanyAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateCompanyAccountResponse, 0, sizeof(_ns1__UpdateCompanyAccountResponse), 0, soap_copy__ns1__UpdateCompanyAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateCompanyAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateCompanyAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateCompanyAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateCompanyAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateCompanyAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccountResponse * SOAP_FMAC4 soap_get__ns1__UpdateCompanyAccountResponse(struct soap *soap, _ns1__UpdateCompanyAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateCompanyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateCompanyAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateCompanyAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateCompanyAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyAccountResponse);
		if (size)
			*size = sizeof(_ns1__UpdateCompanyAccountResponse);
		((_ns1__UpdateCompanyAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateCompanyAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateCompanyAccountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateCompanyAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateCompanyAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateCompanyAccountResponse %p -> %p\n", q, p));
	*(_ns1__UpdateCompanyAccountResponse*)p = *(_ns1__UpdateCompanyAccountResponse*)q;
}

void _ns1__UpdateCompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdateCompanyAccount::account = NULL;
	soap_default_string(soap, &this->_ns1__UpdateCompanyAccount::operatorId);
	soap_default_string(soap, &this->_ns1__UpdateCompanyAccount::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateCompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CompanyAccount(soap, &this->_ns1__UpdateCompanyAccount::account);
	soap_serialize_string(soap, &this->_ns1__UpdateCompanyAccount::operatorId);
	soap_serialize_string(soap, &this->_ns1__UpdateCompanyAccount::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateCompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateCompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateCompanyAccount(struct soap *soap, const char *tag, int id, const _ns1__UpdateCompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateCompanyAccount), type))
		return soap->error;
	if (soap_out_PointerTons1__CompanyAccount(soap, "ns1:account", -1, &(a->_ns1__UpdateCompanyAccount::account), "ns1:CompanyAccount"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__UpdateCompanyAccount::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateCompanyAccount::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateCompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateCompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccount * SOAP_FMAC4 soap_in__ns1__UpdateCompanyAccount(struct soap *soap, const char *tag, _ns1__UpdateCompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateCompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateCompanyAccount, sizeof(_ns1__UpdateCompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateCompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateCompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CompanyAccount(soap, "ns1:account", &(a->_ns1__UpdateCompanyAccount::account), "ns1:CompanyAccount"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__UpdateCompanyAccount::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateCompanyAccount::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateCompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateCompanyAccount, 0, sizeof(_ns1__UpdateCompanyAccount), 0, soap_copy__ns1__UpdateCompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateCompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateCompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateCompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateCompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateCompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccount * SOAP_FMAC4 soap_get__ns1__UpdateCompanyAccount(struct soap *soap, _ns1__UpdateCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateCompanyAccount * SOAP_FMAC2 soap_instantiate__ns1__UpdateCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyAccount);
		if (size)
			*size = sizeof(_ns1__UpdateCompanyAccount);
		((_ns1__UpdateCompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateCompanyAccount);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateCompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateCompanyAccount %p -> %p\n", q, p));
	*(_ns1__UpdateCompanyAccount*)p = *(_ns1__UpdateCompanyAccount*)q;
}

void _ns1__AddCompanyAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddCompanyAccountResponse::AddCompanyAccountResult);
	/* transient soap skipped */
}

void _ns1__AddCompanyAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddCompanyAccountResponse::AddCompanyAccountResult);
	/* transient soap skipped */
}

int _ns1__AddCompanyAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddCompanyAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddCompanyAccountResponse(struct soap *soap, const char *tag, int id, const _ns1__AddCompanyAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddCompanyAccountResponse), type))
		return soap->error;
	if (a->AddCompanyAccountResult)
		soap_element_result(soap, "ns1:AddCompanyAccountResult");
	if (soap_out_string(soap, "ns1:AddCompanyAccountResult", -1, &(a->_ns1__AddCompanyAccountResponse::AddCompanyAccountResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddCompanyAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddCompanyAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccountResponse * SOAP_FMAC4 soap_in__ns1__AddCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__AddCompanyAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddCompanyAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddCompanyAccountResponse, sizeof(_ns1__AddCompanyAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddCompanyAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddCompanyAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddCompanyAccountResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddCompanyAccountResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddCompanyAccountResult", &(a->_ns1__AddCompanyAccountResponse::AddCompanyAccountResult), "xsd:string"))
				{	soap_flag_AddCompanyAccountResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddCompanyAccountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddCompanyAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddCompanyAccountResponse, 0, sizeof(_ns1__AddCompanyAccountResponse), 0, soap_copy__ns1__AddCompanyAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddCompanyAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddCompanyAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddCompanyAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddCompanyAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddCompanyAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccountResponse * SOAP_FMAC4 soap_get__ns1__AddCompanyAccountResponse(struct soap *soap, _ns1__AddCompanyAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddCompanyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__AddCompanyAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddCompanyAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddCompanyAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddCompanyAccountResponse);
		if (size)
			*size = sizeof(_ns1__AddCompanyAccountResponse);
		((_ns1__AddCompanyAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddCompanyAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddCompanyAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddCompanyAccountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddCompanyAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddCompanyAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddCompanyAccountResponse %p -> %p\n", q, p));
	*(_ns1__AddCompanyAccountResponse*)p = *(_ns1__AddCompanyAccountResponse*)q;
}

void _ns1__AddCompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AddCompanyAccount::account = NULL;
	soap_default_string(soap, &this->_ns1__AddCompanyAccount::operatorId);
	soap_default_string(soap, &this->_ns1__AddCompanyAccount::sessionId);
	/* transient soap skipped */
}

void _ns1__AddCompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CompanyAccount(soap, &this->_ns1__AddCompanyAccount::account);
	soap_serialize_string(soap, &this->_ns1__AddCompanyAccount::operatorId);
	soap_serialize_string(soap, &this->_ns1__AddCompanyAccount::sessionId);
	/* transient soap skipped */
}

int _ns1__AddCompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddCompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddCompanyAccount(struct soap *soap, const char *tag, int id, const _ns1__AddCompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddCompanyAccount), type))
		return soap->error;
	if (soap_out_PointerTons1__CompanyAccount(soap, "ns1:account", -1, &(a->_ns1__AddCompanyAccount::account), "ns1:CompanyAccount"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__AddCompanyAccount::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddCompanyAccount::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddCompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddCompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccount * SOAP_FMAC4 soap_in__ns1__AddCompanyAccount(struct soap *soap, const char *tag, _ns1__AddCompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddCompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddCompanyAccount, sizeof(_ns1__AddCompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddCompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddCompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CompanyAccount(soap, "ns1:account", &(a->_ns1__AddCompanyAccount::account), "ns1:CompanyAccount"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__AddCompanyAccount::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddCompanyAccount::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddCompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddCompanyAccount, 0, sizeof(_ns1__AddCompanyAccount), 0, soap_copy__ns1__AddCompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddCompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddCompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:AddCompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddCompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddCompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccount * SOAP_FMAC4 soap_get__ns1__AddCompanyAccount(struct soap *soap, _ns1__AddCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddCompanyAccount * SOAP_FMAC2 soap_instantiate__ns1__AddCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddCompanyAccount);
		if (size)
			*size = sizeof(_ns1__AddCompanyAccount);
		((_ns1__AddCompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddCompanyAccount);
		for (int i = 0; i < n; i++)
			((_ns1__AddCompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddCompanyAccount %p -> %p\n", q, p));
	*(_ns1__AddCompanyAccount*)p = *(_ns1__AddCompanyAccount*)q;
}

void _ns1__GetCompanyAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCompanyAccountResponse::GetCompanyAccountResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetCompanyAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfCompanyAccount(soap, &this->_ns1__GetCompanyAccountResponse::GetCompanyAccountResult);
	/* transient soap skipped */
}

int _ns1__GetCompanyAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCompanyAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCompanyAccountResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCompanyAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCompanyAccountResponse), type))
		return soap->error;
	if (a->GetCompanyAccountResult)
		soap_element_result(soap, "ns1:GetCompanyAccountResult");
	if (soap_out_PointerTons1__ArrayOfCompanyAccount(soap, "ns1:GetCompanyAccountResult", -1, &(a->_ns1__GetCompanyAccountResponse::GetCompanyAccountResult), "ns1:ArrayOfCompanyAccount"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCompanyAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCompanyAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccountResponse * SOAP_FMAC4 soap_in__ns1__GetCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__GetCompanyAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCompanyAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCompanyAccountResponse, sizeof(_ns1__GetCompanyAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCompanyAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCompanyAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCompanyAccountResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCompanyAccountResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfCompanyAccount(soap, "ns1:GetCompanyAccountResult", &(a->_ns1__GetCompanyAccountResponse::GetCompanyAccountResult), "ns1:ArrayOfCompanyAccount"))
				{	soap_flag_GetCompanyAccountResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetCompanyAccountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCompanyAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCompanyAccountResponse, 0, sizeof(_ns1__GetCompanyAccountResponse), 0, soap_copy__ns1__GetCompanyAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCompanyAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCompanyAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetCompanyAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCompanyAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCompanyAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccountResponse * SOAP_FMAC4 soap_get__ns1__GetCompanyAccountResponse(struct soap *soap, _ns1__GetCompanyAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCompanyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCompanyAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCompanyAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCompanyAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyAccountResponse);
		if (size)
			*size = sizeof(_ns1__GetCompanyAccountResponse);
		((_ns1__GetCompanyAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCompanyAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetCompanyAccountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCompanyAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCompanyAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCompanyAccountResponse %p -> %p\n", q, p));
	*(_ns1__GetCompanyAccountResponse*)p = *(_ns1__GetCompanyAccountResponse*)q;
}

void _ns1__GetCompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetCompanyAccount::top);
	soap_default_string(soap, &this->_ns1__GetCompanyAccount::condition);
	soap_default_string(soap, &this->_ns1__GetCompanyAccount::sessionId);
	/* transient soap skipped */
}

void _ns1__GetCompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetCompanyAccount::condition);
	soap_serialize_string(soap, &this->_ns1__GetCompanyAccount::sessionId);
	/* transient soap skipped */
}

int _ns1__GetCompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCompanyAccount(struct soap *soap, const char *tag, int id, const _ns1__GetCompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCompanyAccount), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetCompanyAccount::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetCompanyAccount::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetCompanyAccount::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccount * SOAP_FMAC4 soap_in__ns1__GetCompanyAccount(struct soap *soap, const char *tag, _ns1__GetCompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCompanyAccount, sizeof(_ns1__GetCompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetCompanyAccount::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetCompanyAccount::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetCompanyAccount::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCompanyAccount, 0, sizeof(_ns1__GetCompanyAccount), 0, soap_copy__ns1__GetCompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetCompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:GetCompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccount * SOAP_FMAC4 soap_get__ns1__GetCompanyAccount(struct soap *soap, _ns1__GetCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCompanyAccount * SOAP_FMAC2 soap_instantiate__ns1__GetCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyAccount);
		if (size)
			*size = sizeof(_ns1__GetCompanyAccount);
		((_ns1__GetCompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCompanyAccount);
		for (int i = 0; i < n; i++)
			((_ns1__GetCompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCompanyAccount %p -> %p\n", q, p));
	*(_ns1__GetCompanyAccount*)p = *(_ns1__GetCompanyAccount*)q;
}

void _ns1__UpdateCompanyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateCompanyInfoResponse::UpdateCompanyInfoResult);
	/* transient soap skipped */
}

void _ns1__UpdateCompanyInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateCompanyInfoResponse::UpdateCompanyInfoResult);
	/* transient soap skipped */
}

int _ns1__UpdateCompanyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateCompanyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateCompanyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateCompanyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateCompanyInfoResponse), type))
		return soap->error;
	if (a->UpdateCompanyInfoResult)
		soap_element_result(soap, "ns1:UpdateCompanyInfoResult");
	if (soap_out_string(soap, "ns1:UpdateCompanyInfoResult", -1, &(a->_ns1__UpdateCompanyInfoResponse::UpdateCompanyInfoResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateCompanyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateCompanyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfoResponse * SOAP_FMAC4 soap_in__ns1__UpdateCompanyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdateCompanyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateCompanyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateCompanyInfoResponse, sizeof(_ns1__UpdateCompanyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateCompanyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateCompanyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateCompanyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateCompanyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateCompanyInfoResult", &(a->_ns1__UpdateCompanyInfoResponse::UpdateCompanyInfoResult), "xsd:string"))
				{	soap_flag_UpdateCompanyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateCompanyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateCompanyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateCompanyInfoResponse, 0, sizeof(_ns1__UpdateCompanyInfoResponse), 0, soap_copy__ns1__UpdateCompanyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateCompanyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateCompanyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateCompanyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateCompanyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateCompanyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfoResponse * SOAP_FMAC4 soap_get__ns1__UpdateCompanyInfoResponse(struct soap *soap, _ns1__UpdateCompanyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateCompanyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateCompanyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateCompanyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateCompanyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateCompanyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyInfoResponse);
		if (size)
			*size = sizeof(_ns1__UpdateCompanyInfoResponse);
		((_ns1__UpdateCompanyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateCompanyInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateCompanyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateCompanyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateCompanyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateCompanyInfoResponse %p -> %p\n", q, p));
	*(_ns1__UpdateCompanyInfoResponse*)p = *(_ns1__UpdateCompanyInfoResponse*)q;
}

void _ns1__UpdateCompanyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdateCompanyInfo::info = NULL;
	soap_default_string(soap, &this->_ns1__UpdateCompanyInfo::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateCompanyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CompanyInfo(soap, &this->_ns1__UpdateCompanyInfo::info);
	soap_serialize_string(soap, &this->_ns1__UpdateCompanyInfo::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateCompanyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateCompanyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateCompanyInfo(struct soap *soap, const char *tag, int id, const _ns1__UpdateCompanyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateCompanyInfo), type))
		return soap->error;
	if (soap_out_PointerTons1__CompanyInfo(soap, "ns1:info", -1, &(a->_ns1__UpdateCompanyInfo::info), "ns1:CompanyInfo"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateCompanyInfo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateCompanyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateCompanyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfo * SOAP_FMAC4 soap_in__ns1__UpdateCompanyInfo(struct soap *soap, const char *tag, _ns1__UpdateCompanyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateCompanyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateCompanyInfo, sizeof(_ns1__UpdateCompanyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateCompanyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateCompanyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_info1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CompanyInfo(soap, "ns1:info", &(a->_ns1__UpdateCompanyInfo::info), "ns1:CompanyInfo"))
				{	soap_flag_info1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateCompanyInfo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateCompanyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateCompanyInfo, 0, sizeof(_ns1__UpdateCompanyInfo), 0, soap_copy__ns1__UpdateCompanyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateCompanyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateCompanyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateCompanyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateCompanyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateCompanyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfo * SOAP_FMAC4 soap_get__ns1__UpdateCompanyInfo(struct soap *soap, _ns1__UpdateCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateCompanyInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdateCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyInfo);
		if (size)
			*size = sizeof(_ns1__UpdateCompanyInfo);
		((_ns1__UpdateCompanyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateCompanyInfo);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateCompanyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateCompanyInfo %p -> %p\n", q, p));
	*(_ns1__UpdateCompanyInfo*)p = *(_ns1__UpdateCompanyInfo*)q;
}

void _ns1__GetCompanyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCompanyInfoResponse::GetCompanyInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetCompanyInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CompanyInfo(soap, &this->_ns1__GetCompanyInfoResponse::GetCompanyInfoResult);
	/* transient soap skipped */
}

int _ns1__GetCompanyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCompanyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCompanyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCompanyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCompanyInfoResponse), type))
		return soap->error;
	if (a->GetCompanyInfoResult)
		soap_element_result(soap, "ns1:GetCompanyInfoResult");
	if (soap_out_PointerTons1__CompanyInfo(soap, "ns1:GetCompanyInfoResult", -1, &(a->_ns1__GetCompanyInfoResponse::GetCompanyInfoResult), "ns1:CompanyInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCompanyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCompanyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfoResponse * SOAP_FMAC4 soap_in__ns1__GetCompanyInfoResponse(struct soap *soap, const char *tag, _ns1__GetCompanyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCompanyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCompanyInfoResponse, sizeof(_ns1__GetCompanyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCompanyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCompanyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCompanyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCompanyInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CompanyInfo(soap, "ns1:GetCompanyInfoResult", &(a->_ns1__GetCompanyInfoResponse::GetCompanyInfoResult), "ns1:CompanyInfo"))
				{	soap_flag_GetCompanyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetCompanyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCompanyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCompanyInfoResponse, 0, sizeof(_ns1__GetCompanyInfoResponse), 0, soap_copy__ns1__GetCompanyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCompanyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCompanyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetCompanyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCompanyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCompanyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfoResponse * SOAP_FMAC4 soap_get__ns1__GetCompanyInfoResponse(struct soap *soap, _ns1__GetCompanyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCompanyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCompanyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCompanyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCompanyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCompanyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetCompanyInfoResponse);
		((_ns1__GetCompanyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCompanyInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetCompanyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCompanyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCompanyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCompanyInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetCompanyInfoResponse*)p = *(_ns1__GetCompanyInfoResponse*)q;
}

void _ns1__GetCompanyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetCompanyInfo::clientType);
	soap_default_string(soap, &this->_ns1__GetCompanyInfo::sessionId);
	/* transient soap skipped */
}

void _ns1__GetCompanyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetCompanyInfo::clientType);
	soap_serialize_string(soap, &this->_ns1__GetCompanyInfo::sessionId);
	/* transient soap skipped */
}

int _ns1__GetCompanyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCompanyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCompanyInfo(struct soap *soap, const char *tag, int id, const _ns1__GetCompanyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCompanyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__GetCompanyInfo::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetCompanyInfo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCompanyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCompanyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfo * SOAP_FMAC4 soap_in__ns1__GetCompanyInfo(struct soap *soap, const char *tag, _ns1__GetCompanyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCompanyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCompanyInfo, sizeof(_ns1__GetCompanyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCompanyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCompanyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__GetCompanyInfo::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetCompanyInfo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCompanyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCompanyInfo, 0, sizeof(_ns1__GetCompanyInfo), 0, soap_copy__ns1__GetCompanyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCompanyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCompanyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetCompanyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCompanyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCompanyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfo * SOAP_FMAC4 soap_get__ns1__GetCompanyInfo(struct soap *soap, _ns1__GetCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCompanyInfo * SOAP_FMAC2 soap_instantiate__ns1__GetCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyInfo);
		if (size)
			*size = sizeof(_ns1__GetCompanyInfo);
		((_ns1__GetCompanyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCompanyInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetCompanyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCompanyInfo %p -> %p\n", q, p));
	*(_ns1__GetCompanyInfo*)p = *(_ns1__GetCompanyInfo*)q;
}

void _ns1__DeletePhoneNumberBelongResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeletePhoneNumberBelongResponse::DeletePhoneNumberBelongResult);
	/* transient soap skipped */
}

void _ns1__DeletePhoneNumberBelongResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeletePhoneNumberBelongResponse::DeletePhoneNumberBelongResult);
	/* transient soap skipped */
}

int _ns1__DeletePhoneNumberBelongResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeletePhoneNumberBelongResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeletePhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, const _ns1__DeletePhoneNumberBelongResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse), type))
		return soap->error;
	if (a->DeletePhoneNumberBelongResult)
		soap_element_result(soap, "ns1:DeletePhoneNumberBelongResult");
	if (soap_out_string(soap, "ns1:DeletePhoneNumberBelongResult", -1, &(a->_ns1__DeletePhoneNumberBelongResponse::DeletePhoneNumberBelongResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeletePhoneNumberBelongResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeletePhoneNumberBelongResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelongResponse * SOAP_FMAC4 soap_in__ns1__DeletePhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__DeletePhoneNumberBelongResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeletePhoneNumberBelongResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse, sizeof(_ns1__DeletePhoneNumberBelongResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeletePhoneNumberBelongResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeletePhoneNumberBelongResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeletePhoneNumberBelongResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeletePhoneNumberBelongResult", &(a->_ns1__DeletePhoneNumberBelongResponse::DeletePhoneNumberBelongResult), "xsd:string"))
				{	soap_flag_DeletePhoneNumberBelongResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeletePhoneNumberBelongResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeletePhoneNumberBelongResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse, 0, sizeof(_ns1__DeletePhoneNumberBelongResponse), 0, soap_copy__ns1__DeletePhoneNumberBelongResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeletePhoneNumberBelongResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeletePhoneNumberBelongResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeletePhoneNumberBelongResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeletePhoneNumberBelongResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelongResponse * SOAP_FMAC4 soap_get__ns1__DeletePhoneNumberBelongResponse(struct soap *soap, _ns1__DeletePhoneNumberBelongResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeletePhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeletePhoneNumberBelongResponse * SOAP_FMAC2 soap_instantiate__ns1__DeletePhoneNumberBelongResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeletePhoneNumberBelongResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletePhoneNumberBelongResponse);
		if (size)
			*size = sizeof(_ns1__DeletePhoneNumberBelongResponse);
		((_ns1__DeletePhoneNumberBelongResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletePhoneNumberBelongResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeletePhoneNumberBelongResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeletePhoneNumberBelongResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeletePhoneNumberBelongResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeletePhoneNumberBelongResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeletePhoneNumberBelongResponse %p -> %p\n", q, p));
	*(_ns1__DeletePhoneNumberBelongResponse*)p = *(_ns1__DeletePhoneNumberBelongResponse*)q;
}

void _ns1__DeletePhoneNumberBelong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeletePhoneNumberBelong::belongId);
	soap_default_string(soap, &this->_ns1__DeletePhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

void _ns1__DeletePhoneNumberBelong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeletePhoneNumberBelong::belongId);
	soap_serialize_string(soap, &this->_ns1__DeletePhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

int _ns1__DeletePhoneNumberBelong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeletePhoneNumberBelong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeletePhoneNumberBelong(struct soap *soap, const char *tag, int id, const _ns1__DeletePhoneNumberBelong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeletePhoneNumberBelong), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:belongId", -1, &(a->_ns1__DeletePhoneNumberBelong::belongId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__DeletePhoneNumberBelong::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeletePhoneNumberBelong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeletePhoneNumberBelong(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelong * SOAP_FMAC4 soap_in__ns1__DeletePhoneNumberBelong(struct soap *soap, const char *tag, _ns1__DeletePhoneNumberBelong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeletePhoneNumberBelong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeletePhoneNumberBelong, sizeof(_ns1__DeletePhoneNumberBelong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeletePhoneNumberBelong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeletePhoneNumberBelong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_belongId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_belongId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:belongId", &(a->_ns1__DeletePhoneNumberBelong::belongId), "xsd:string"))
				{	soap_flag_belongId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__DeletePhoneNumberBelong::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeletePhoneNumberBelong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeletePhoneNumberBelong, 0, sizeof(_ns1__DeletePhoneNumberBelong), 0, soap_copy__ns1__DeletePhoneNumberBelong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeletePhoneNumberBelong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeletePhoneNumberBelong);
	if (this->soap_out(soap, tag?tag:"ns1:DeletePhoneNumberBelong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeletePhoneNumberBelong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeletePhoneNumberBelong(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelong * SOAP_FMAC4 soap_get__ns1__DeletePhoneNumberBelong(struct soap *soap, _ns1__DeletePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeletePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeletePhoneNumberBelong * SOAP_FMAC2 soap_instantiate__ns1__DeletePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeletePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeletePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletePhoneNumberBelong);
		if (size)
			*size = sizeof(_ns1__DeletePhoneNumberBelong);
		((_ns1__DeletePhoneNumberBelong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeletePhoneNumberBelong);
		for (int i = 0; i < n; i++)
			((_ns1__DeletePhoneNumberBelong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeletePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeletePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeletePhoneNumberBelong %p -> %p\n", q, p));
	*(_ns1__DeletePhoneNumberBelong*)p = *(_ns1__DeletePhoneNumberBelong*)q;
}

void _ns1__AddPhoneNumberBelongResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddPhoneNumberBelongResponse::AddPhoneNumberBelongResult);
	/* transient soap skipped */
}

void _ns1__AddPhoneNumberBelongResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddPhoneNumberBelongResponse::AddPhoneNumberBelongResult);
	/* transient soap skipped */
}

int _ns1__AddPhoneNumberBelongResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPhoneNumberBelongResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, const _ns1__AddPhoneNumberBelongResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse), type))
		return soap->error;
	if (a->AddPhoneNumberBelongResult)
		soap_element_result(soap, "ns1:AddPhoneNumberBelongResult");
	if (soap_out_string(soap, "ns1:AddPhoneNumberBelongResult", -1, &(a->_ns1__AddPhoneNumberBelongResponse::AddPhoneNumberBelongResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPhoneNumberBelongResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPhoneNumberBelongResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelongResponse * SOAP_FMAC4 soap_in__ns1__AddPhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__AddPhoneNumberBelongResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPhoneNumberBelongResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse, sizeof(_ns1__AddPhoneNumberBelongResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPhoneNumberBelongResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPhoneNumberBelongResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddPhoneNumberBelongResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddPhoneNumberBelongResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddPhoneNumberBelongResult", &(a->_ns1__AddPhoneNumberBelongResponse::AddPhoneNumberBelongResult), "xsd:string"))
				{	soap_flag_AddPhoneNumberBelongResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddPhoneNumberBelongResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPhoneNumberBelongResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse, 0, sizeof(_ns1__AddPhoneNumberBelongResponse), 0, soap_copy__ns1__AddPhoneNumberBelongResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddPhoneNumberBelongResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddPhoneNumberBelongResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddPhoneNumberBelongResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPhoneNumberBelongResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelongResponse * SOAP_FMAC4 soap_get__ns1__AddPhoneNumberBelongResponse(struct soap *soap, _ns1__AddPhoneNumberBelongResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddPhoneNumberBelongResponse * SOAP_FMAC2 soap_instantiate__ns1__AddPhoneNumberBelongResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPhoneNumberBelongResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddPhoneNumberBelongResponse);
		if (size)
			*size = sizeof(_ns1__AddPhoneNumberBelongResponse);
		((_ns1__AddPhoneNumberBelongResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddPhoneNumberBelongResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPhoneNumberBelongResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddPhoneNumberBelongResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPhoneNumberBelongResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPhoneNumberBelongResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPhoneNumberBelongResponse %p -> %p\n", q, p));
	*(_ns1__AddPhoneNumberBelongResponse*)p = *(_ns1__AddPhoneNumberBelongResponse*)q;
}

void _ns1__AddPhoneNumberBelong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AddPhoneNumberBelong::belong = NULL;
	soap_default_string(soap, &this->_ns1__AddPhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

void _ns1__AddPhoneNumberBelong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PhoneNumberBelong(soap, &this->_ns1__AddPhoneNumberBelong::belong);
	soap_serialize_string(soap, &this->_ns1__AddPhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

int _ns1__AddPhoneNumberBelong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPhoneNumberBelong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPhoneNumberBelong(struct soap *soap, const char *tag, int id, const _ns1__AddPhoneNumberBelong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPhoneNumberBelong), type))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumberBelong(soap, "ns1:belong", -1, &(a->_ns1__AddPhoneNumberBelong::belong), "ns1:PhoneNumberBelong"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddPhoneNumberBelong::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPhoneNumberBelong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPhoneNumberBelong(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelong * SOAP_FMAC4 soap_in__ns1__AddPhoneNumberBelong(struct soap *soap, const char *tag, _ns1__AddPhoneNumberBelong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPhoneNumberBelong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPhoneNumberBelong, sizeof(_ns1__AddPhoneNumberBelong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPhoneNumberBelong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPhoneNumberBelong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_belong1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_belong1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneNumberBelong(soap, "ns1:belong", &(a->_ns1__AddPhoneNumberBelong::belong), "ns1:PhoneNumberBelong"))
				{	soap_flag_belong1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddPhoneNumberBelong::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPhoneNumberBelong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPhoneNumberBelong, 0, sizeof(_ns1__AddPhoneNumberBelong), 0, soap_copy__ns1__AddPhoneNumberBelong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddPhoneNumberBelong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPhoneNumberBelong);
	if (this->soap_out(soap, tag?tag:"ns1:AddPhoneNumberBelong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddPhoneNumberBelong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPhoneNumberBelong(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelong * SOAP_FMAC4 soap_get__ns1__AddPhoneNumberBelong(struct soap *soap, _ns1__AddPhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddPhoneNumberBelong * SOAP_FMAC2 soap_instantiate__ns1__AddPhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddPhoneNumberBelong);
		if (size)
			*size = sizeof(_ns1__AddPhoneNumberBelong);
		((_ns1__AddPhoneNumberBelong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddPhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPhoneNumberBelong);
		for (int i = 0; i < n; i++)
			((_ns1__AddPhoneNumberBelong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPhoneNumberBelong %p -> %p\n", q, p));
	*(_ns1__AddPhoneNumberBelong*)p = *(_ns1__AddPhoneNumberBelong*)q;
}

void _ns1__UpdatePhoneNumberBelongResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePhoneNumberBelongResponse::UpdatePhoneNumberBelongResult);
	/* transient soap skipped */
}

void _ns1__UpdatePhoneNumberBelongResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdatePhoneNumberBelongResponse::UpdatePhoneNumberBelongResult);
	/* transient soap skipped */
}

int _ns1__UpdatePhoneNumberBelongResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePhoneNumberBelongResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdatePhoneNumberBelongResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse), type))
		return soap->error;
	if (a->UpdatePhoneNumberBelongResult)
		soap_element_result(soap, "ns1:UpdatePhoneNumberBelongResult");
	if (soap_out_string(soap, "ns1:UpdatePhoneNumberBelongResult", -1, &(a->_ns1__UpdatePhoneNumberBelongResponse::UpdatePhoneNumberBelongResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePhoneNumberBelongResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePhoneNumberBelongResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelongResponse * SOAP_FMAC4 soap_in__ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__UpdatePhoneNumberBelongResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePhoneNumberBelongResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse, sizeof(_ns1__UpdatePhoneNumberBelongResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePhoneNumberBelongResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdatePhoneNumberBelongResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdatePhoneNumberBelongResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdatePhoneNumberBelongResult", &(a->_ns1__UpdatePhoneNumberBelongResponse::UpdatePhoneNumberBelongResult), "xsd:string"))
				{	soap_flag_UpdatePhoneNumberBelongResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdatePhoneNumberBelongResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePhoneNumberBelongResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse, 0, sizeof(_ns1__UpdatePhoneNumberBelongResponse), 0, soap_copy__ns1__UpdatePhoneNumberBelongResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePhoneNumberBelongResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePhoneNumberBelongResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePhoneNumberBelongResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePhoneNumberBelongResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelongResponse * SOAP_FMAC4 soap_get__ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, _ns1__UpdatePhoneNumberBelongResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePhoneNumberBelongResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePhoneNumberBelongResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePhoneNumberBelongResponse);
		if (size)
			*size = sizeof(_ns1__UpdatePhoneNumberBelongResponse);
		((_ns1__UpdatePhoneNumberBelongResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePhoneNumberBelongResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdatePhoneNumberBelongResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdatePhoneNumberBelongResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdatePhoneNumberBelongResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePhoneNumberBelongResponse %p -> %p\n", q, p));
	*(_ns1__UpdatePhoneNumberBelongResponse*)p = *(_ns1__UpdatePhoneNumberBelongResponse*)q;
}

void _ns1__UpdatePhoneNumberBelong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdatePhoneNumberBelong::belong = NULL;
	soap_default_string(soap, &this->_ns1__UpdatePhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdatePhoneNumberBelong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PhoneNumberBelong(soap, &this->_ns1__UpdatePhoneNumberBelong::belong);
	soap_serialize_string(soap, &this->_ns1__UpdatePhoneNumberBelong::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdatePhoneNumberBelong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePhoneNumberBelong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, int id, const _ns1__UpdatePhoneNumberBelong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePhoneNumberBelong), type))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumberBelong(soap, "ns1:belong", -1, &(a->_ns1__UpdatePhoneNumberBelong::belong), "ns1:PhoneNumberBelong"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdatePhoneNumberBelong::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePhoneNumberBelong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePhoneNumberBelong(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_in__ns1__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, _ns1__UpdatePhoneNumberBelong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePhoneNumberBelong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePhoneNumberBelong, sizeof(_ns1__UpdatePhoneNumberBelong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePhoneNumberBelong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePhoneNumberBelong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_belong1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_belong1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneNumberBelong(soap, "ns1:belong", &(a->_ns1__UpdatePhoneNumberBelong::belong), "ns1:PhoneNumberBelong"))
				{	soap_flag_belong1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdatePhoneNumberBelong::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePhoneNumberBelong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePhoneNumberBelong, 0, sizeof(_ns1__UpdatePhoneNumberBelong), 0, soap_copy__ns1__UpdatePhoneNumberBelong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePhoneNumberBelong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatePhoneNumberBelong);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePhoneNumberBelong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePhoneNumberBelong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePhoneNumberBelong(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_get__ns1__UpdatePhoneNumberBelong(struct soap *soap, _ns1__UpdatePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePhoneNumberBelong * SOAP_FMAC2 soap_instantiate__ns1__UpdatePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePhoneNumberBelong);
		if (size)
			*size = sizeof(_ns1__UpdatePhoneNumberBelong);
		((_ns1__UpdatePhoneNumberBelong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdatePhoneNumberBelong);
		for (int i = 0; i < n; i++)
			((_ns1__UpdatePhoneNumberBelong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdatePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePhoneNumberBelong %p -> %p\n", q, p));
	*(_ns1__UpdatePhoneNumberBelong*)p = *(_ns1__UpdatePhoneNumberBelong*)q;
}

void _ns1__GetPhoneNumberBelongByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPhoneNumberBelongByConditionResponse::GetPhoneNumberBelongByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPhoneNumberBelongByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPhoneNumberBelong(soap, &this->_ns1__GetPhoneNumberBelongByConditionResponse::GetPhoneNumberBelongByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPhoneNumberBelongByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNumberBelongByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNumberBelongByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse), type))
		return soap->error;
	if (a->GetPhoneNumberBelongByConditionResult)
		soap_element_result(soap, "ns1:GetPhoneNumberBelongByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPhoneNumberBelong(soap, "ns1:GetPhoneNumberBelongByConditionResult", -1, &(a->_ns1__GetPhoneNumberBelongByConditionResponse::GetPhoneNumberBelongByConditionResult), "ns1:ArrayOfPhoneNumberBelong"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNumberBelongByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNumberBelongByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNumberBelongByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNumberBelongByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse, sizeof(_ns1__GetPhoneNumberBelongByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNumberBelongByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPhoneNumberBelongByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPhoneNumberBelongByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPhoneNumberBelong(soap, "ns1:GetPhoneNumberBelongByConditionResult", &(a->_ns1__GetPhoneNumberBelongByConditionResponse::GetPhoneNumberBelongByConditionResult), "ns1:ArrayOfPhoneNumberBelong"))
				{	soap_flag_GetPhoneNumberBelongByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPhoneNumberBelongByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNumberBelongByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse, 0, sizeof(_ns1__GetPhoneNumberBelongByConditionResponse), 0, soap_copy__ns1__GetPhoneNumberBelongByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNumberBelongByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNumberBelongByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNumberBelongByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNumberBelongByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, _ns1__GetPhoneNumberBelongByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNumberBelongByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNumberBelongByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNumberBelongByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNumberBelongByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPhoneNumberBelongByConditionResponse);
		((_ns1__GetPhoneNumberBelongByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNumberBelongByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNumberBelongByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNumberBelongByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNumberBelongByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNumberBelongByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPhoneNumberBelongByConditionResponse*)p = *(_ns1__GetPhoneNumberBelongByConditionResponse*)q;
}

void _ns1__GetPhoneNumberBelongByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPhoneNumberBelongByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPhoneNumberBelongByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPhoneNumberBelongByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPhoneNumberBelongByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPhoneNumberBelongByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPhoneNumberBelongByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPhoneNumberBelongByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPhoneNumberBelongByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPhoneNumberBelongByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPhoneNumberBelongByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPhoneNumberBelongByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPhoneNumberBelongByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_in__ns1__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNumberBelongByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPhoneNumberBelongByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition, sizeof(_ns1__GetPhoneNumberBelongByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPhoneNumberBelongByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPhoneNumberBelongByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPhoneNumberBelongByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPhoneNumberBelongByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition, 0, sizeof(_ns1__GetPhoneNumberBelongByCondition), 0, soap_copy__ns1__GetPhoneNumberBelongByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPhoneNumberBelongByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPhoneNumberBelongByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPhoneNumberBelongByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPhoneNumberBelongByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_get__ns1__GetPhoneNumberBelongByCondition(struct soap *soap, _ns1__GetPhoneNumberBelongByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPhoneNumberBelongByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPhoneNumberBelongByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPhoneNumberBelongByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPhoneNumberBelongByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNumberBelongByCondition);
		if (size)
			*size = sizeof(_ns1__GetPhoneNumberBelongByCondition);
		((_ns1__GetPhoneNumberBelongByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPhoneNumberBelongByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPhoneNumberBelongByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPhoneNumberBelongByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPhoneNumberBelongByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPhoneNumberBelongByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPhoneNumberBelongByCondition %p -> %p\n", q, p));
	*(_ns1__GetPhoneNumberBelongByCondition*)p = *(_ns1__GetPhoneNumberBelongByCondition*)q;
}

void _ns1__DeletetReturnProportionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeletetReturnProportionResponse::DeletetReturnProportionResult);
	/* transient soap skipped */
}

void _ns1__DeletetReturnProportionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeletetReturnProportionResponse::DeletetReturnProportionResult);
	/* transient soap skipped */
}

int _ns1__DeletetReturnProportionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeletetReturnProportionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeletetReturnProportionResponse(struct soap *soap, const char *tag, int id, const _ns1__DeletetReturnProportionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeletetReturnProportionResponse), type))
		return soap->error;
	if (a->DeletetReturnProportionResult)
		soap_element_result(soap, "ns1:DeletetReturnProportionResult");
	if (soap_out_string(soap, "ns1:DeletetReturnProportionResult", -1, &(a->_ns1__DeletetReturnProportionResponse::DeletetReturnProportionResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeletetReturnProportionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeletetReturnProportionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportionResponse * SOAP_FMAC4 soap_in__ns1__DeletetReturnProportionResponse(struct soap *soap, const char *tag, _ns1__DeletetReturnProportionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeletetReturnProportionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeletetReturnProportionResponse, sizeof(_ns1__DeletetReturnProportionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeletetReturnProportionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeletetReturnProportionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeletetReturnProportionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeletetReturnProportionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeletetReturnProportionResult", &(a->_ns1__DeletetReturnProportionResponse::DeletetReturnProportionResult), "xsd:string"))
				{	soap_flag_DeletetReturnProportionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeletetReturnProportionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeletetReturnProportionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeletetReturnProportionResponse, 0, sizeof(_ns1__DeletetReturnProportionResponse), 0, soap_copy__ns1__DeletetReturnProportionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeletetReturnProportionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeletetReturnProportionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeletetReturnProportionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeletetReturnProportionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeletetReturnProportionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportionResponse * SOAP_FMAC4 soap_get__ns1__DeletetReturnProportionResponse(struct soap *soap, _ns1__DeletetReturnProportionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeletetReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeletetReturnProportionResponse * SOAP_FMAC2 soap_instantiate__ns1__DeletetReturnProportionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeletetReturnProportionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeletetReturnProportionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletetReturnProportionResponse);
		if (size)
			*size = sizeof(_ns1__DeletetReturnProportionResponse);
		((_ns1__DeletetReturnProportionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletetReturnProportionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeletetReturnProportionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeletetReturnProportionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeletetReturnProportionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeletetReturnProportionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeletetReturnProportionResponse %p -> %p\n", q, p));
	*(_ns1__DeletetReturnProportionResponse*)p = *(_ns1__DeletetReturnProportionResponse*)q;
}

void _ns1__DeletetReturnProportion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeletetReturnProportion::Id);
	soap_default_string(soap, &this->_ns1__DeletetReturnProportion::operatorId);
	soap_default_string(soap, &this->_ns1__DeletetReturnProportion::sessionId);
	/* transient soap skipped */
}

void _ns1__DeletetReturnProportion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeletetReturnProportion::Id);
	soap_serialize_string(soap, &this->_ns1__DeletetReturnProportion::operatorId);
	soap_serialize_string(soap, &this->_ns1__DeletetReturnProportion::sessionId);
	/* transient soap skipped */
}

int _ns1__DeletetReturnProportion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeletetReturnProportion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeletetReturnProportion(struct soap *soap, const char *tag, int id, const _ns1__DeletetReturnProportion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeletetReturnProportion), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Id", -1, &(a->_ns1__DeletetReturnProportion::Id), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__DeletetReturnProportion::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__DeletetReturnProportion::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeletetReturnProportion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeletetReturnProportion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportion * SOAP_FMAC4 soap_in__ns1__DeletetReturnProportion(struct soap *soap, const char *tag, _ns1__DeletetReturnProportion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeletetReturnProportion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeletetReturnProportion, sizeof(_ns1__DeletetReturnProportion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeletetReturnProportion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeletetReturnProportion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Id", &(a->_ns1__DeletetReturnProportion::Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__DeletetReturnProportion::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__DeletetReturnProportion::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeletetReturnProportion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeletetReturnProportion, 0, sizeof(_ns1__DeletetReturnProportion), 0, soap_copy__ns1__DeletetReturnProportion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeletetReturnProportion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeletetReturnProportion);
	if (this->soap_out(soap, tag?tag:"ns1:DeletetReturnProportion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeletetReturnProportion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeletetReturnProportion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportion * SOAP_FMAC4 soap_get__ns1__DeletetReturnProportion(struct soap *soap, _ns1__DeletetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeletetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeletetReturnProportion * SOAP_FMAC2 soap_instantiate__ns1__DeletetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeletetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeletetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletetReturnProportion);
		if (size)
			*size = sizeof(_ns1__DeletetReturnProportion);
		((_ns1__DeletetReturnProportion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeletetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeletetReturnProportion);
		for (int i = 0; i < n; i++)
			((_ns1__DeletetReturnProportion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeletetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeletetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeletetReturnProportion %p -> %p\n", q, p));
	*(_ns1__DeletetReturnProportion*)p = *(_ns1__DeletetReturnProportion*)q;
}

void _ns1__UpdatetReturnProportionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportionResponse::UpdatetReturnProportionResult);
	/* transient soap skipped */
}

void _ns1__UpdatetReturnProportionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportionResponse::UpdatetReturnProportionResult);
	/* transient soap skipped */
}

int _ns1__UpdatetReturnProportionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatetReturnProportionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatetReturnProportionResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdatetReturnProportionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatetReturnProportionResponse), type))
		return soap->error;
	if (a->UpdatetReturnProportionResult)
		soap_element_result(soap, "ns1:UpdatetReturnProportionResult");
	if (soap_out_string(soap, "ns1:UpdatetReturnProportionResult", -1, &(a->_ns1__UpdatetReturnProportionResponse::UpdatetReturnProportionResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatetReturnProportionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatetReturnProportionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportionResponse * SOAP_FMAC4 soap_in__ns1__UpdatetReturnProportionResponse(struct soap *soap, const char *tag, _ns1__UpdatetReturnProportionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatetReturnProportionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatetReturnProportionResponse, sizeof(_ns1__UpdatetReturnProportionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatetReturnProportionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatetReturnProportionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdatetReturnProportionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdatetReturnProportionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdatetReturnProportionResult", &(a->_ns1__UpdatetReturnProportionResponse::UpdatetReturnProportionResult), "xsd:string"))
				{	soap_flag_UpdatetReturnProportionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdatetReturnProportionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatetReturnProportionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatetReturnProportionResponse, 0, sizeof(_ns1__UpdatetReturnProportionResponse), 0, soap_copy__ns1__UpdatetReturnProportionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatetReturnProportionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatetReturnProportionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatetReturnProportionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatetReturnProportionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatetReturnProportionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportionResponse * SOAP_FMAC4 soap_get__ns1__UpdatetReturnProportionResponse(struct soap *soap, _ns1__UpdatetReturnProportionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatetReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatetReturnProportionResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatetReturnProportionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatetReturnProportionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatetReturnProportionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatetReturnProportionResponse);
		if (size)
			*size = sizeof(_ns1__UpdatetReturnProportionResponse);
		((_ns1__UpdatetReturnProportionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatetReturnProportionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdatetReturnProportionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdatetReturnProportionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdatetReturnProportionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatetReturnProportionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatetReturnProportionResponse %p -> %p\n", q, p));
	*(_ns1__UpdatetReturnProportionResponse*)p = *(_ns1__UpdatetReturnProportionResponse*)q;
}

void _ns1__UpdatetReturnProportion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::Id);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::returnClass);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::returnName);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::area);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::level);
	soap_default_double(soap, &this->_ns1__UpdatetReturnProportion::returnProportion);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::content);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::operatorId);
	soap_default_string(soap, &this->_ns1__UpdatetReturnProportion::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdatetReturnProportion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::Id);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::returnClass);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::returnName);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::area);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::level);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::content);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::operatorId);
	soap_serialize_string(soap, &this->_ns1__UpdatetReturnProportion::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdatetReturnProportion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatetReturnProportion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatetReturnProportion(struct soap *soap, const char *tag, int id, const _ns1__UpdatetReturnProportion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatetReturnProportion), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Id", -1, &(a->_ns1__UpdatetReturnProportion::Id), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:returnClass", -1, &(a->_ns1__UpdatetReturnProportion::returnClass), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:returnName", -1, &(a->_ns1__UpdatetReturnProportion::returnName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->_ns1__UpdatetReturnProportion::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:level", -1, &(a->_ns1__UpdatetReturnProportion::level), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnProportion", -1, &(a->_ns1__UpdatetReturnProportion::returnProportion), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__UpdatetReturnProportion::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__UpdatetReturnProportion::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdatetReturnProportion::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatetReturnProportion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatetReturnProportion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportion * SOAP_FMAC4 soap_in__ns1__UpdatetReturnProportion(struct soap *soap, const char *tag, _ns1__UpdatetReturnProportion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatetReturnProportion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatetReturnProportion, sizeof(_ns1__UpdatetReturnProportion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatetReturnProportion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatetReturnProportion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_returnClass1 = 1;
	size_t soap_flag_returnName1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_returnProportion1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Id", &(a->_ns1__UpdatetReturnProportion::Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_returnClass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:returnClass", &(a->_ns1__UpdatetReturnProportion::returnClass), "xsd:string"))
				{	soap_flag_returnClass1--;
					continue;
				}
			if (soap_flag_returnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:returnName", &(a->_ns1__UpdatetReturnProportion::returnName), "xsd:string"))
				{	soap_flag_returnName1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->_ns1__UpdatetReturnProportion::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_level1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:level", &(a->_ns1__UpdatetReturnProportion::level), "xsd:string"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_returnProportion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnProportion", &(a->_ns1__UpdatetReturnProportion::returnProportion), "xsd:double"))
				{	soap_flag_returnProportion1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__UpdatetReturnProportion::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__UpdatetReturnProportion::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdatetReturnProportion::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatetReturnProportion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatetReturnProportion, 0, sizeof(_ns1__UpdatetReturnProportion), 0, soap_copy__ns1__UpdatetReturnProportion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnProportion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UpdatetReturnProportion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatetReturnProportion);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatetReturnProportion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatetReturnProportion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatetReturnProportion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportion * SOAP_FMAC4 soap_get__ns1__UpdatetReturnProportion(struct soap *soap, _ns1__UpdatetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatetReturnProportion * SOAP_FMAC2 soap_instantiate__ns1__UpdatetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatetReturnProportion);
		if (size)
			*size = sizeof(_ns1__UpdatetReturnProportion);
		((_ns1__UpdatetReturnProportion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdatetReturnProportion);
		for (int i = 0; i < n; i++)
			((_ns1__UpdatetReturnProportion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdatetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatetReturnProportion %p -> %p\n", q, p));
	*(_ns1__UpdatetReturnProportion*)p = *(_ns1__UpdatetReturnProportion*)q;
}

void _ns1__AddtReturnProportionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddtReturnProportionResponse::AddtReturnProportionResult);
	/* transient soap skipped */
}

void _ns1__AddtReturnProportionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportionResponse::AddtReturnProportionResult);
	/* transient soap skipped */
}

int _ns1__AddtReturnProportionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddtReturnProportionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddtReturnProportionResponse(struct soap *soap, const char *tag, int id, const _ns1__AddtReturnProportionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddtReturnProportionResponse), type))
		return soap->error;
	if (a->AddtReturnProportionResult)
		soap_element_result(soap, "ns1:AddtReturnProportionResult");
	if (soap_out_string(soap, "ns1:AddtReturnProportionResult", -1, &(a->_ns1__AddtReturnProportionResponse::AddtReturnProportionResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddtReturnProportionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddtReturnProportionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportionResponse * SOAP_FMAC4 soap_in__ns1__AddtReturnProportionResponse(struct soap *soap, const char *tag, _ns1__AddtReturnProportionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddtReturnProportionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddtReturnProportionResponse, sizeof(_ns1__AddtReturnProportionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddtReturnProportionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddtReturnProportionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddtReturnProportionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddtReturnProportionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddtReturnProportionResult", &(a->_ns1__AddtReturnProportionResponse::AddtReturnProportionResult), "xsd:string"))
				{	soap_flag_AddtReturnProportionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddtReturnProportionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddtReturnProportionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddtReturnProportionResponse, 0, sizeof(_ns1__AddtReturnProportionResponse), 0, soap_copy__ns1__AddtReturnProportionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddtReturnProportionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddtReturnProportionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddtReturnProportionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddtReturnProportionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddtReturnProportionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportionResponse * SOAP_FMAC4 soap_get__ns1__AddtReturnProportionResponse(struct soap *soap, _ns1__AddtReturnProportionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddtReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddtReturnProportionResponse * SOAP_FMAC2 soap_instantiate__ns1__AddtReturnProportionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddtReturnProportionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddtReturnProportionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddtReturnProportionResponse);
		if (size)
			*size = sizeof(_ns1__AddtReturnProportionResponse);
		((_ns1__AddtReturnProportionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddtReturnProportionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddtReturnProportionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddtReturnProportionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddtReturnProportionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddtReturnProportionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddtReturnProportionResponse %p -> %p\n", q, p));
	*(_ns1__AddtReturnProportionResponse*)p = *(_ns1__AddtReturnProportionResponse*)q;
}

void _ns1__AddtReturnProportion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::returnClass);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::returnName);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::area);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::level);
	soap_default_double(soap, &this->_ns1__AddtReturnProportion::returnProportion);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::content);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::operatorId);
	soap_default_string(soap, &this->_ns1__AddtReturnProportion::sessionId);
	/* transient soap skipped */
}

void _ns1__AddtReturnProportion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::returnClass);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::returnName);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::area);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::level);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::content);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::operatorId);
	soap_serialize_string(soap, &this->_ns1__AddtReturnProportion::sessionId);
	/* transient soap skipped */
}

int _ns1__AddtReturnProportion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddtReturnProportion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddtReturnProportion(struct soap *soap, const char *tag, int id, const _ns1__AddtReturnProportion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddtReturnProportion), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:returnClass", -1, &(a->_ns1__AddtReturnProportion::returnClass), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:returnName", -1, &(a->_ns1__AddtReturnProportion::returnName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->_ns1__AddtReturnProportion::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:level", -1, &(a->_ns1__AddtReturnProportion::level), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnProportion", -1, &(a->_ns1__AddtReturnProportion::returnProportion), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__AddtReturnProportion::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__AddtReturnProportion::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddtReturnProportion::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddtReturnProportion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddtReturnProportion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportion * SOAP_FMAC4 soap_in__ns1__AddtReturnProportion(struct soap *soap, const char *tag, _ns1__AddtReturnProportion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddtReturnProportion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddtReturnProportion, sizeof(_ns1__AddtReturnProportion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddtReturnProportion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddtReturnProportion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_returnClass1 = 1;
	size_t soap_flag_returnName1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_returnProportion1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnClass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:returnClass", &(a->_ns1__AddtReturnProportion::returnClass), "xsd:string"))
				{	soap_flag_returnClass1--;
					continue;
				}
			if (soap_flag_returnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:returnName", &(a->_ns1__AddtReturnProportion::returnName), "xsd:string"))
				{	soap_flag_returnName1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->_ns1__AddtReturnProportion::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_level1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:level", &(a->_ns1__AddtReturnProportion::level), "xsd:string"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_returnProportion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnProportion", &(a->_ns1__AddtReturnProportion::returnProportion), "xsd:double"))
				{	soap_flag_returnProportion1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__AddtReturnProportion::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__AddtReturnProportion::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddtReturnProportion::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddtReturnProportion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddtReturnProportion, 0, sizeof(_ns1__AddtReturnProportion), 0, soap_copy__ns1__AddtReturnProportion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnProportion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AddtReturnProportion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddtReturnProportion);
	if (this->soap_out(soap, tag?tag:"ns1:AddtReturnProportion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddtReturnProportion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddtReturnProportion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportion * SOAP_FMAC4 soap_get__ns1__AddtReturnProportion(struct soap *soap, _ns1__AddtReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddtReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddtReturnProportion * SOAP_FMAC2 soap_instantiate__ns1__AddtReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddtReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddtReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddtReturnProportion);
		if (size)
			*size = sizeof(_ns1__AddtReturnProportion);
		((_ns1__AddtReturnProportion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddtReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddtReturnProportion);
		for (int i = 0; i < n; i++)
			((_ns1__AddtReturnProportion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddtReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddtReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddtReturnProportion %p -> %p\n", q, p));
	*(_ns1__AddtReturnProportion*)p = *(_ns1__AddtReturnProportion*)q;
}

void _ns1__GetReturnProportionRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetReturnProportionRecordResponse::GetReturnProportionRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetReturnProportionRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfReturnProportion(soap, &this->_ns1__GetReturnProportionRecordResponse::GetReturnProportionRecordResult);
	/* transient soap skipped */
}

int _ns1__GetReturnProportionRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnProportionRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnProportionRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetReturnProportionRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnProportionRecordResponse), type))
		return soap->error;
	if (a->GetReturnProportionRecordResult)
		soap_element_result(soap, "ns1:GetReturnProportionRecordResult");
	if (soap_out_PointerTons1__ArrayOfReturnProportion(soap, "ns1:GetReturnProportionRecordResult", -1, &(a->_ns1__GetReturnProportionRecordResponse::GetReturnProportionRecordResult), "ns1:ArrayOfReturnProportion"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnProportionRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnProportionRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecordResponse * SOAP_FMAC4 soap_in__ns1__GetReturnProportionRecordResponse(struct soap *soap, const char *tag, _ns1__GetReturnProportionRecordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnProportionRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnProportionRecordResponse, sizeof(_ns1__GetReturnProportionRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnProportionRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnProportionRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetReturnProportionRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetReturnProportionRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfReturnProportion(soap, "ns1:GetReturnProportionRecordResult", &(a->_ns1__GetReturnProportionRecordResponse::GetReturnProportionRecordResult), "ns1:ArrayOfReturnProportion"))
				{	soap_flag_GetReturnProportionRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetReturnProportionRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnProportionRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnProportionRecordResponse, 0, sizeof(_ns1__GetReturnProportionRecordResponse), 0, soap_copy__ns1__GetReturnProportionRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReturnProportionRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnProportionRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnProportionRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnProportionRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnProportionRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecordResponse * SOAP_FMAC4 soap_get__ns1__GetReturnProportionRecordResponse(struct soap *soap, _ns1__GetReturnProportionRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnProportionRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnProportionRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetReturnProportionRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnProportionRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnProportionRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnProportionRecordResponse);
		if (size)
			*size = sizeof(_ns1__GetReturnProportionRecordResponse);
		((_ns1__GetReturnProportionRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnProportionRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnProportionRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnProportionRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnProportionRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnProportionRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnProportionRecordResponse %p -> %p\n", q, p));
	*(_ns1__GetReturnProportionRecordResponse*)p = *(_ns1__GetReturnProportionRecordResponse*)q;
}

void _ns1__GetReturnProportionRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetReturnProportionRecord::top);
	soap_default_string(soap, &this->_ns1__GetReturnProportionRecord::condition);
	soap_default_string(soap, &this->_ns1__GetReturnProportionRecord::sessionId);
	/* transient soap skipped */
}

void _ns1__GetReturnProportionRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetReturnProportionRecord::condition);
	soap_serialize_string(soap, &this->_ns1__GetReturnProportionRecord::sessionId);
	/* transient soap skipped */
}

int _ns1__GetReturnProportionRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnProportionRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnProportionRecord(struct soap *soap, const char *tag, int id, const _ns1__GetReturnProportionRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnProportionRecord), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetReturnProportionRecord::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetReturnProportionRecord::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetReturnProportionRecord::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnProportionRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnProportionRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecord * SOAP_FMAC4 soap_in__ns1__GetReturnProportionRecord(struct soap *soap, const char *tag, _ns1__GetReturnProportionRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnProportionRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnProportionRecord, sizeof(_ns1__GetReturnProportionRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnProportionRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnProportionRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetReturnProportionRecord::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetReturnProportionRecord::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetReturnProportionRecord::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnProportionRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnProportionRecord, 0, sizeof(_ns1__GetReturnProportionRecord), 0, soap_copy__ns1__GetReturnProportionRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetReturnProportionRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnProportionRecord);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnProportionRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnProportionRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnProportionRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecord * SOAP_FMAC4 soap_get__ns1__GetReturnProportionRecord(struct soap *soap, _ns1__GetReturnProportionRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnProportionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnProportionRecord * SOAP_FMAC2 soap_instantiate__ns1__GetReturnProportionRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnProportionRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnProportionRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnProportionRecord);
		if (size)
			*size = sizeof(_ns1__GetReturnProportionRecord);
		((_ns1__GetReturnProportionRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnProportionRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnProportionRecord);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnProportionRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnProportionRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnProportionRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnProportionRecord %p -> %p\n", q, p));
	*(_ns1__GetReturnProportionRecord*)p = *(_ns1__GetReturnProportionRecord*)q;
}

void _ns1__InserNoticeToSomeOneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__InserNoticeToSomeOneResponse::InserNoticeToSomeOneResult);
	/* transient soap skipped */
}

void _ns1__InserNoticeToSomeOneResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__InserNoticeToSomeOneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InserNoticeToSomeOneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InserNoticeToSomeOneResponse(struct soap *soap, const char *tag, int id, const _ns1__InserNoticeToSomeOneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:InserNoticeToSomeOneResult");
	if (soap_out_bool(soap, "ns1:InserNoticeToSomeOneResult", -1, &(a->_ns1__InserNoticeToSomeOneResponse::InserNoticeToSomeOneResult), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InserNoticeToSomeOneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InserNoticeToSomeOneResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOneResponse * SOAP_FMAC4 soap_in__ns1__InserNoticeToSomeOneResponse(struct soap *soap, const char *tag, _ns1__InserNoticeToSomeOneResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InserNoticeToSomeOneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse, sizeof(_ns1__InserNoticeToSomeOneResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InserNoticeToSomeOneResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InserNoticeToSomeOneResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InserNoticeToSomeOneResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InserNoticeToSomeOneResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:InserNoticeToSomeOneResult", &(a->_ns1__InserNoticeToSomeOneResponse::InserNoticeToSomeOneResult), "xsd:boolean"))
				{	soap_flag_InserNoticeToSomeOneResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InserNoticeToSomeOneResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InserNoticeToSomeOneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse, 0, sizeof(_ns1__InserNoticeToSomeOneResponse), 0, soap_copy__ns1__InserNoticeToSomeOneResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InserNoticeToSomeOneResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__InserNoticeToSomeOneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InserNoticeToSomeOneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InserNoticeToSomeOneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InserNoticeToSomeOneResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOneResponse * SOAP_FMAC4 soap_get__ns1__InserNoticeToSomeOneResponse(struct soap *soap, _ns1__InserNoticeToSomeOneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InserNoticeToSomeOneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InserNoticeToSomeOneResponse * SOAP_FMAC2 soap_instantiate__ns1__InserNoticeToSomeOneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InserNoticeToSomeOneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InserNoticeToSomeOneResponse);
		if (size)
			*size = sizeof(_ns1__InserNoticeToSomeOneResponse);
		((_ns1__InserNoticeToSomeOneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InserNoticeToSomeOneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__InserNoticeToSomeOneResponse);
		for (int i = 0; i < n; i++)
			((_ns1__InserNoticeToSomeOneResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__InserNoticeToSomeOneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InserNoticeToSomeOneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InserNoticeToSomeOneResponse %p -> %p\n", q, p));
	*(_ns1__InserNoticeToSomeOneResponse*)p = *(_ns1__InserNoticeToSomeOneResponse*)q;
}

void _ns1__InserNoticeToSomeOne::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InserNoticeToSomeOne::noticeId);
	soap_default_string(soap, &this->_ns1__InserNoticeToSomeOne::userId);
	soap_default_string(soap, &this->_ns1__InserNoticeToSomeOne::sessionId);
	/* transient soap skipped */
}

void _ns1__InserNoticeToSomeOne::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InserNoticeToSomeOne::noticeId);
	soap_serialize_string(soap, &this->_ns1__InserNoticeToSomeOne::userId);
	soap_serialize_string(soap, &this->_ns1__InserNoticeToSomeOne::sessionId);
	/* transient soap skipped */
}

int _ns1__InserNoticeToSomeOne::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InserNoticeToSomeOne(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InserNoticeToSomeOne(struct soap *soap, const char *tag, int id, const _ns1__InserNoticeToSomeOne *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InserNoticeToSomeOne), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:noticeId", -1, &(a->_ns1__InserNoticeToSomeOne::noticeId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__InserNoticeToSomeOne::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__InserNoticeToSomeOne::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InserNoticeToSomeOne::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InserNoticeToSomeOne(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOne * SOAP_FMAC4 soap_in__ns1__InserNoticeToSomeOne(struct soap *soap, const char *tag, _ns1__InserNoticeToSomeOne *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InserNoticeToSomeOne *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InserNoticeToSomeOne, sizeof(_ns1__InserNoticeToSomeOne), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InserNoticeToSomeOne)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InserNoticeToSomeOne *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_noticeId1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_noticeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:noticeId", &(a->_ns1__InserNoticeToSomeOne::noticeId), "xsd:string"))
				{	soap_flag_noticeId1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__InserNoticeToSomeOne::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__InserNoticeToSomeOne::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InserNoticeToSomeOne *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InserNoticeToSomeOne, 0, sizeof(_ns1__InserNoticeToSomeOne), 0, soap_copy__ns1__InserNoticeToSomeOne);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InserNoticeToSomeOne::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InserNoticeToSomeOne);
	if (this->soap_out(soap, tag?tag:"ns1:InserNoticeToSomeOne", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InserNoticeToSomeOne::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InserNoticeToSomeOne(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOne * SOAP_FMAC4 soap_get__ns1__InserNoticeToSomeOne(struct soap *soap, _ns1__InserNoticeToSomeOne *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InserNoticeToSomeOne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InserNoticeToSomeOne * SOAP_FMAC2 soap_instantiate__ns1__InserNoticeToSomeOne(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InserNoticeToSomeOne(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InserNoticeToSomeOne, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InserNoticeToSomeOne);
		if (size)
			*size = sizeof(_ns1__InserNoticeToSomeOne);
		((_ns1__InserNoticeToSomeOne*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InserNoticeToSomeOne[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__InserNoticeToSomeOne);
		for (int i = 0; i < n; i++)
			((_ns1__InserNoticeToSomeOne*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__InserNoticeToSomeOne*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InserNoticeToSomeOne(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InserNoticeToSomeOne %p -> %p\n", q, p));
	*(_ns1__InserNoticeToSomeOne*)p = *(_ns1__InserNoticeToSomeOne*)q;
}

void _ns1__DeleteNoticeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteNoticeItemResponse::DeleteNoticeItemResult);
	/* transient soap skipped */
}

void _ns1__DeleteNoticeItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteNoticeItemResponse::DeleteNoticeItemResult);
	/* transient soap skipped */
}

int _ns1__DeleteNoticeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteNoticeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteNoticeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteNoticeItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteNoticeItemResponse), type))
		return soap->error;
	if (a->DeleteNoticeItemResult)
		soap_element_result(soap, "ns1:DeleteNoticeItemResult");
	if (soap_out_string(soap, "ns1:DeleteNoticeItemResult", -1, &(a->_ns1__DeleteNoticeItemResponse::DeleteNoticeItemResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteNoticeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteNoticeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItemResponse * SOAP_FMAC4 soap_in__ns1__DeleteNoticeItemResponse(struct soap *soap, const char *tag, _ns1__DeleteNoticeItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteNoticeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteNoticeItemResponse, sizeof(_ns1__DeleteNoticeItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteNoticeItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteNoticeItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeleteNoticeItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteNoticeItemResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeleteNoticeItemResult", &(a->_ns1__DeleteNoticeItemResponse::DeleteNoticeItemResult), "xsd:string"))
				{	soap_flag_DeleteNoticeItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeleteNoticeItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteNoticeItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteNoticeItemResponse, 0, sizeof(_ns1__DeleteNoticeItemResponse), 0, soap_copy__ns1__DeleteNoticeItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteNoticeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteNoticeItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteNoticeItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteNoticeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteNoticeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItemResponse * SOAP_FMAC4 soap_get__ns1__DeleteNoticeItemResponse(struct soap *soap, _ns1__DeleteNoticeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteNoticeItemResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteNoticeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteNoticeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteNoticeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteNoticeItemResponse);
		if (size)
			*size = sizeof(_ns1__DeleteNoticeItemResponse);
		((_ns1__DeleteNoticeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteNoticeItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteNoticeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteNoticeItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteNoticeItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteNoticeItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteNoticeItemResponse %p -> %p\n", q, p));
	*(_ns1__DeleteNoticeItemResponse*)p = *(_ns1__DeleteNoticeItemResponse*)q;
}

void _ns1__DeleteNoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteNoticeItem::Id);
	soap_default_string(soap, &this->_ns1__DeleteNoticeItem::operatorId);
	soap_default_string(soap, &this->_ns1__DeleteNoticeItem::sessionId);
	/* transient soap skipped */
}

void _ns1__DeleteNoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteNoticeItem::Id);
	soap_serialize_string(soap, &this->_ns1__DeleteNoticeItem::operatorId);
	soap_serialize_string(soap, &this->_ns1__DeleteNoticeItem::sessionId);
	/* transient soap skipped */
}

int _ns1__DeleteNoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteNoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteNoticeItem(struct soap *soap, const char *tag, int id, const _ns1__DeleteNoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteNoticeItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Id", -1, &(a->_ns1__DeleteNoticeItem::Id), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__DeleteNoticeItem::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__DeleteNoticeItem::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteNoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteNoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItem * SOAP_FMAC4 soap_in__ns1__DeleteNoticeItem(struct soap *soap, const char *tag, _ns1__DeleteNoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteNoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteNoticeItem, sizeof(_ns1__DeleteNoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteNoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteNoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Id", &(a->_ns1__DeleteNoticeItem::Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__DeleteNoticeItem::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__DeleteNoticeItem::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteNoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteNoticeItem, 0, sizeof(_ns1__DeleteNoticeItem), 0, soap_copy__ns1__DeleteNoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteNoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteNoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteNoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteNoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteNoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItem * SOAP_FMAC4 soap_get__ns1__DeleteNoticeItem(struct soap *soap, _ns1__DeleteNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteNoticeItem * SOAP_FMAC2 soap_instantiate__ns1__DeleteNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteNoticeItem);
		if (size)
			*size = sizeof(_ns1__DeleteNoticeItem);
		((_ns1__DeleteNoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteNoticeItem);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteNoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteNoticeItem %p -> %p\n", q, p));
	*(_ns1__DeleteNoticeItem*)p = *(_ns1__DeleteNoticeItem*)q;
}

void _ns1__UpdateNoticeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateNoticeItemResponse::UpdateNoticeItemResult);
	/* transient soap skipped */
}

void _ns1__UpdateNoticeItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItemResponse::UpdateNoticeItemResult);
	/* transient soap skipped */
}

int _ns1__UpdateNoticeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateNoticeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateNoticeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateNoticeItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateNoticeItemResponse), type))
		return soap->error;
	if (a->UpdateNoticeItemResult)
		soap_element_result(soap, "ns1:UpdateNoticeItemResult");
	if (soap_out_string(soap, "ns1:UpdateNoticeItemResult", -1, &(a->_ns1__UpdateNoticeItemResponse::UpdateNoticeItemResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateNoticeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateNoticeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItemResponse * SOAP_FMAC4 soap_in__ns1__UpdateNoticeItemResponse(struct soap *soap, const char *tag, _ns1__UpdateNoticeItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateNoticeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateNoticeItemResponse, sizeof(_ns1__UpdateNoticeItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateNoticeItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateNoticeItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateNoticeItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateNoticeItemResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateNoticeItemResult", &(a->_ns1__UpdateNoticeItemResponse::UpdateNoticeItemResult), "xsd:string"))
				{	soap_flag_UpdateNoticeItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateNoticeItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateNoticeItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateNoticeItemResponse, 0, sizeof(_ns1__UpdateNoticeItemResponse), 0, soap_copy__ns1__UpdateNoticeItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateNoticeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateNoticeItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateNoticeItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateNoticeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateNoticeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItemResponse * SOAP_FMAC4 soap_get__ns1__UpdateNoticeItemResponse(struct soap *soap, _ns1__UpdateNoticeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateNoticeItemResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateNoticeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateNoticeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateNoticeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateNoticeItemResponse);
		if (size)
			*size = sizeof(_ns1__UpdateNoticeItemResponse);
		((_ns1__UpdateNoticeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateNoticeItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateNoticeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateNoticeItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateNoticeItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateNoticeItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateNoticeItemResponse %p -> %p\n", q, p));
	*(_ns1__UpdateNoticeItemResponse*)p = *(_ns1__UpdateNoticeItemResponse*)q;
}

void _ns1__UpdateNoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::Id);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::title);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::content);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::type);
	soap_default_bool(soap, &this->_ns1__UpdateNoticeItem::isShow);
	soap_default_int(soap, &this->_ns1__UpdateNoticeItem::weight);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::operatorId);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::clientType);
	soap_default_string(soap, &this->_ns1__UpdateNoticeItem::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateNoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::Id);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::title);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::content);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::type);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::operatorId);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::clientType);
	soap_serialize_string(soap, &this->_ns1__UpdateNoticeItem::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateNoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateNoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateNoticeItem(struct soap *soap, const char *tag, int id, const _ns1__UpdateNoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateNoticeItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Id", -1, &(a->_ns1__UpdateNoticeItem::Id), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:title", -1, &(a->_ns1__UpdateNoticeItem::title), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__UpdateNoticeItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->_ns1__UpdateNoticeItem::type), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isShow", -1, &(a->_ns1__UpdateNoticeItem::isShow), "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "ns1:weight", -1, &(a->_ns1__UpdateNoticeItem::weight), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__UpdateNoticeItem::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__UpdateNoticeItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateNoticeItem::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateNoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateNoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItem * SOAP_FMAC4 soap_in__ns1__UpdateNoticeItem(struct soap *soap, const char *tag, _ns1__UpdateNoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateNoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateNoticeItem, sizeof(_ns1__UpdateNoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateNoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateNoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_isShow1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Id", &(a->_ns1__UpdateNoticeItem::Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:title", &(a->_ns1__UpdateNoticeItem::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__UpdateNoticeItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->_ns1__UpdateNoticeItem::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_isShow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isShow", &(a->_ns1__UpdateNoticeItem::isShow), "xsd:boolean"))
				{	soap_flag_isShow1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:weight", &(a->_ns1__UpdateNoticeItem::weight), "xsd:int"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__UpdateNoticeItem::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__UpdateNoticeItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateNoticeItem::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateNoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateNoticeItem, 0, sizeof(_ns1__UpdateNoticeItem), 0, soap_copy__ns1__UpdateNoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isShow1 > 0 || soap_flag_weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UpdateNoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateNoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateNoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateNoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateNoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItem * SOAP_FMAC4 soap_get__ns1__UpdateNoticeItem(struct soap *soap, _ns1__UpdateNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateNoticeItem * SOAP_FMAC2 soap_instantiate__ns1__UpdateNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateNoticeItem);
		if (size)
			*size = sizeof(_ns1__UpdateNoticeItem);
		((_ns1__UpdateNoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateNoticeItem);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateNoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateNoticeItem %p -> %p\n", q, p));
	*(_ns1__UpdateNoticeItem*)p = *(_ns1__UpdateNoticeItem*)q;
}

void _ns1__AddNoticeItemToSomeoneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeoneResponse::AddNoticeItemToSomeoneResult);
	/* transient soap skipped */
}

void _ns1__AddNoticeItemToSomeoneResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeoneResponse::AddNoticeItemToSomeoneResult);
	/* transient soap skipped */
}

int _ns1__AddNoticeItemToSomeoneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddNoticeItemToSomeoneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, const char *tag, int id, const _ns1__AddNoticeItemToSomeoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse), type))
		return soap->error;
	if (a->AddNoticeItemToSomeoneResult)
		soap_element_result(soap, "ns1:AddNoticeItemToSomeoneResult");
	if (soap_out_string(soap, "ns1:AddNoticeItemToSomeoneResult", -1, &(a->_ns1__AddNoticeItemToSomeoneResponse::AddNoticeItemToSomeoneResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddNoticeItemToSomeoneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddNoticeItemToSomeoneResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeoneResponse * SOAP_FMAC4 soap_in__ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, const char *tag, _ns1__AddNoticeItemToSomeoneResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddNoticeItemToSomeoneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse, sizeof(_ns1__AddNoticeItemToSomeoneResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddNoticeItemToSomeoneResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddNoticeItemToSomeoneResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddNoticeItemToSomeoneResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddNoticeItemToSomeoneResult", &(a->_ns1__AddNoticeItemToSomeoneResponse::AddNoticeItemToSomeoneResult), "xsd:string"))
				{	soap_flag_AddNoticeItemToSomeoneResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddNoticeItemToSomeoneResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddNoticeItemToSomeoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse, 0, sizeof(_ns1__AddNoticeItemToSomeoneResponse), 0, soap_copy__ns1__AddNoticeItemToSomeoneResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddNoticeItemToSomeoneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddNoticeItemToSomeoneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddNoticeItemToSomeoneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddNoticeItemToSomeoneResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeoneResponse * SOAP_FMAC4 soap_get__ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, _ns1__AddNoticeItemToSomeoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddNoticeItemToSomeoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddNoticeItemToSomeoneResponse * SOAP_FMAC2 soap_instantiate__ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddNoticeItemToSomeoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemToSomeoneResponse);
		if (size)
			*size = sizeof(_ns1__AddNoticeItemToSomeoneResponse);
		((_ns1__AddNoticeItemToSomeoneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemToSomeoneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddNoticeItemToSomeoneResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddNoticeItemToSomeoneResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddNoticeItemToSomeoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddNoticeItemToSomeoneResponse %p -> %p\n", q, p));
	*(_ns1__AddNoticeItemToSomeoneResponse*)p = *(_ns1__AddNoticeItemToSomeoneResponse*)q;
}

void _ns1__AddNoticeItemToSomeone::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::title);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::content);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::type);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::publisherId);
	soap_default_bool(soap, &this->_ns1__AddNoticeItemToSomeone::isShow);
	soap_default_int(soap, &this->_ns1__AddNoticeItemToSomeone::weight);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::userId);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::clientType);
	soap_default_string(soap, &this->_ns1__AddNoticeItemToSomeone::sessionId);
	/* transient soap skipped */
}

void _ns1__AddNoticeItemToSomeone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::title);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::content);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::type);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::publisherId);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::userId);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::clientType);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemToSomeone::sessionId);
	/* transient soap skipped */
}

int _ns1__AddNoticeItemToSomeone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddNoticeItemToSomeone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddNoticeItemToSomeone(struct soap *soap, const char *tag, int id, const _ns1__AddNoticeItemToSomeone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddNoticeItemToSomeone), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:title", -1, &(a->_ns1__AddNoticeItemToSomeone::title), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__AddNoticeItemToSomeone::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->_ns1__AddNoticeItemToSomeone::type), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:publisherId", -1, &(a->_ns1__AddNoticeItemToSomeone::publisherId), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isShow", -1, &(a->_ns1__AddNoticeItemToSomeone::isShow), "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "ns1:weight", -1, &(a->_ns1__AddNoticeItemToSomeone::weight), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__AddNoticeItemToSomeone::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__AddNoticeItemToSomeone::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddNoticeItemToSomeone::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddNoticeItemToSomeone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddNoticeItemToSomeone(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeone * SOAP_FMAC4 soap_in__ns1__AddNoticeItemToSomeone(struct soap *soap, const char *tag, _ns1__AddNoticeItemToSomeone *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddNoticeItemToSomeone *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddNoticeItemToSomeone, sizeof(_ns1__AddNoticeItemToSomeone), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddNoticeItemToSomeone)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddNoticeItemToSomeone *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_title1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_publisherId1 = 1;
	size_t soap_flag_isShow1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:title", &(a->_ns1__AddNoticeItemToSomeone::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__AddNoticeItemToSomeone::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->_ns1__AddNoticeItemToSomeone::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_publisherId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:publisherId", &(a->_ns1__AddNoticeItemToSomeone::publisherId), "xsd:string"))
				{	soap_flag_publisherId1--;
					continue;
				}
			if (soap_flag_isShow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isShow", &(a->_ns1__AddNoticeItemToSomeone::isShow), "xsd:boolean"))
				{	soap_flag_isShow1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:weight", &(a->_ns1__AddNoticeItemToSomeone::weight), "xsd:int"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__AddNoticeItemToSomeone::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__AddNoticeItemToSomeone::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddNoticeItemToSomeone::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddNoticeItemToSomeone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddNoticeItemToSomeone, 0, sizeof(_ns1__AddNoticeItemToSomeone), 0, soap_copy__ns1__AddNoticeItemToSomeone);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isShow1 > 0 || soap_flag_weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AddNoticeItemToSomeone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddNoticeItemToSomeone);
	if (this->soap_out(soap, tag?tag:"ns1:AddNoticeItemToSomeone", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddNoticeItemToSomeone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddNoticeItemToSomeone(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeone * SOAP_FMAC4 soap_get__ns1__AddNoticeItemToSomeone(struct soap *soap, _ns1__AddNoticeItemToSomeone *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddNoticeItemToSomeone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddNoticeItemToSomeone * SOAP_FMAC2 soap_instantiate__ns1__AddNoticeItemToSomeone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddNoticeItemToSomeone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddNoticeItemToSomeone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemToSomeone);
		if (size)
			*size = sizeof(_ns1__AddNoticeItemToSomeone);
		((_ns1__AddNoticeItemToSomeone*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemToSomeone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddNoticeItemToSomeone);
		for (int i = 0; i < n; i++)
			((_ns1__AddNoticeItemToSomeone*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddNoticeItemToSomeone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddNoticeItemToSomeone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddNoticeItemToSomeone %p -> %p\n", q, p));
	*(_ns1__AddNoticeItemToSomeone*)p = *(_ns1__AddNoticeItemToSomeone*)q;
}

void _ns1__AddNoticeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddNoticeItemResponse::AddNoticeItemResult);
	/* transient soap skipped */
}

void _ns1__AddNoticeItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddNoticeItemResponse::AddNoticeItemResult);
	/* transient soap skipped */
}

int _ns1__AddNoticeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddNoticeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddNoticeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__AddNoticeItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddNoticeItemResponse), type))
		return soap->error;
	if (a->AddNoticeItemResult)
		soap_element_result(soap, "ns1:AddNoticeItemResult");
	if (soap_out_string(soap, "ns1:AddNoticeItemResult", -1, &(a->_ns1__AddNoticeItemResponse::AddNoticeItemResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddNoticeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddNoticeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemResponse * SOAP_FMAC4 soap_in__ns1__AddNoticeItemResponse(struct soap *soap, const char *tag, _ns1__AddNoticeItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddNoticeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddNoticeItemResponse, sizeof(_ns1__AddNoticeItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddNoticeItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddNoticeItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddNoticeItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddNoticeItemResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddNoticeItemResult", &(a->_ns1__AddNoticeItemResponse::AddNoticeItemResult), "xsd:string"))
				{	soap_flag_AddNoticeItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddNoticeItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddNoticeItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddNoticeItemResponse, 0, sizeof(_ns1__AddNoticeItemResponse), 0, soap_copy__ns1__AddNoticeItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddNoticeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddNoticeItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddNoticeItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddNoticeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddNoticeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemResponse * SOAP_FMAC4 soap_get__ns1__AddNoticeItemResponse(struct soap *soap, _ns1__AddNoticeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddNoticeItemResponse * SOAP_FMAC2 soap_instantiate__ns1__AddNoticeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddNoticeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddNoticeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemResponse);
		if (size)
			*size = sizeof(_ns1__AddNoticeItemResponse);
		((_ns1__AddNoticeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddNoticeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddNoticeItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddNoticeItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddNoticeItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddNoticeItemResponse %p -> %p\n", q, p));
	*(_ns1__AddNoticeItemResponse*)p = *(_ns1__AddNoticeItemResponse*)q;
}

void _ns1__AddNoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddNoticeItem::title);
	soap_default_string(soap, &this->_ns1__AddNoticeItem::content);
	soap_default_string(soap, &this->_ns1__AddNoticeItem::type);
	soap_default_string(soap, &this->_ns1__AddNoticeItem::publisherId);
	soap_default_bool(soap, &this->_ns1__AddNoticeItem::isShow);
	soap_default_int(soap, &this->_ns1__AddNoticeItem::weight);
	soap_default_string(soap, &this->_ns1__AddNoticeItem::clientType);
	soap_default_string(soap, &this->_ns1__AddNoticeItem::sessionId);
	/* transient soap skipped */
}

void _ns1__AddNoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::title);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::content);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::type);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::publisherId);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::clientType);
	soap_serialize_string(soap, &this->_ns1__AddNoticeItem::sessionId);
	/* transient soap skipped */
}

int _ns1__AddNoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddNoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddNoticeItem(struct soap *soap, const char *tag, int id, const _ns1__AddNoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddNoticeItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:title", -1, &(a->_ns1__AddNoticeItem::title), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__AddNoticeItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->_ns1__AddNoticeItem::type), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:publisherId", -1, &(a->_ns1__AddNoticeItem::publisherId), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isShow", -1, &(a->_ns1__AddNoticeItem::isShow), "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "ns1:weight", -1, &(a->_ns1__AddNoticeItem::weight), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__AddNoticeItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddNoticeItem::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddNoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddNoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddNoticeItem * SOAP_FMAC4 soap_in__ns1__AddNoticeItem(struct soap *soap, const char *tag, _ns1__AddNoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddNoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddNoticeItem, sizeof(_ns1__AddNoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddNoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddNoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_title1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_publisherId1 = 1;
	size_t soap_flag_isShow1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:title", &(a->_ns1__AddNoticeItem::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__AddNoticeItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->_ns1__AddNoticeItem::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_publisherId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:publisherId", &(a->_ns1__AddNoticeItem::publisherId), "xsd:string"))
				{	soap_flag_publisherId1--;
					continue;
				}
			if (soap_flag_isShow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isShow", &(a->_ns1__AddNoticeItem::isShow), "xsd:boolean"))
				{	soap_flag_isShow1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:weight", &(a->_ns1__AddNoticeItem::weight), "xsd:int"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__AddNoticeItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddNoticeItem::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddNoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddNoticeItem, 0, sizeof(_ns1__AddNoticeItem), 0, soap_copy__ns1__AddNoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isShow1 > 0 || soap_flag_weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AddNoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddNoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:AddNoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddNoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddNoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddNoticeItem * SOAP_FMAC4 soap_get__ns1__AddNoticeItem(struct soap *soap, _ns1__AddNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddNoticeItem * SOAP_FMAC2 soap_instantiate__ns1__AddNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItem);
		if (size)
			*size = sizeof(_ns1__AddNoticeItem);
		((_ns1__AddNoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddNoticeItem);
		for (int i = 0; i < n; i++)
			((_ns1__AddNoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddNoticeItem %p -> %p\n", q, p));
	*(_ns1__AddNoticeItem*)p = *(_ns1__AddNoticeItem*)q;
}

void _ns1__GetAlertNoticeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAlertNoticeListResponse::GetAlertNoticeListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAlertNoticeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Notice(soap, &this->_ns1__GetAlertNoticeListResponse::GetAlertNoticeListResult);
	/* transient soap skipped */
}

int _ns1__GetAlertNoticeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlertNoticeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlertNoticeListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAlertNoticeListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlertNoticeListResponse), type))
		return soap->error;
	if (a->GetAlertNoticeListResult)
		soap_element_result(soap, "ns1:GetAlertNoticeListResult");
	if (soap_out_PointerTons1__Notice(soap, "ns1:GetAlertNoticeListResult", -1, &(a->_ns1__GetAlertNoticeListResponse::GetAlertNoticeListResult), "ns1:Notice"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlertNoticeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlertNoticeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeListResponse * SOAP_FMAC4 soap_in__ns1__GetAlertNoticeListResponse(struct soap *soap, const char *tag, _ns1__GetAlertNoticeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlertNoticeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlertNoticeListResponse, sizeof(_ns1__GetAlertNoticeListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlertNoticeListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlertNoticeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAlertNoticeListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAlertNoticeListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Notice(soap, "ns1:GetAlertNoticeListResult", &(a->_ns1__GetAlertNoticeListResponse::GetAlertNoticeListResult), "ns1:Notice"))
				{	soap_flag_GetAlertNoticeListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAlertNoticeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlertNoticeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlertNoticeListResponse, 0, sizeof(_ns1__GetAlertNoticeListResponse), 0, soap_copy__ns1__GetAlertNoticeListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlertNoticeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlertNoticeListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlertNoticeListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlertNoticeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlertNoticeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeListResponse * SOAP_FMAC4 soap_get__ns1__GetAlertNoticeListResponse(struct soap *soap, _ns1__GetAlertNoticeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlertNoticeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlertNoticeListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAlertNoticeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlertNoticeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlertNoticeListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlertNoticeListResponse);
		if (size)
			*size = sizeof(_ns1__GetAlertNoticeListResponse);
		((_ns1__GetAlertNoticeListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlertNoticeListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAlertNoticeListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetAlertNoticeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAlertNoticeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlertNoticeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlertNoticeListResponse %p -> %p\n", q, p));
	*(_ns1__GetAlertNoticeListResponse*)p = *(_ns1__GetAlertNoticeListResponse*)q;
}

void _ns1__GetAlertNoticeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAlertNoticeList::userId);
	soap_default_string(soap, &this->_ns1__GetAlertNoticeList::clientType);
	soap_default_string(soap, &this->_ns1__GetAlertNoticeList::sessionId);
	/* transient soap skipped */
}

void _ns1__GetAlertNoticeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAlertNoticeList::userId);
	soap_serialize_string(soap, &this->_ns1__GetAlertNoticeList::clientType);
	soap_serialize_string(soap, &this->_ns1__GetAlertNoticeList::sessionId);
	/* transient soap skipped */
}

int _ns1__GetAlertNoticeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlertNoticeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlertNoticeList(struct soap *soap, const char *tag, int id, const _ns1__GetAlertNoticeList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlertNoticeList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__GetAlertNoticeList::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__GetAlertNoticeList::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetAlertNoticeList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlertNoticeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlertNoticeList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeList * SOAP_FMAC4 soap_in__ns1__GetAlertNoticeList(struct soap *soap, const char *tag, _ns1__GetAlertNoticeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlertNoticeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlertNoticeList, sizeof(_ns1__GetAlertNoticeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlertNoticeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlertNoticeList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__GetAlertNoticeList::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__GetAlertNoticeList::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetAlertNoticeList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlertNoticeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlertNoticeList, 0, sizeof(_ns1__GetAlertNoticeList), 0, soap_copy__ns1__GetAlertNoticeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlertNoticeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlertNoticeList);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlertNoticeList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlertNoticeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlertNoticeList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeList * SOAP_FMAC4 soap_get__ns1__GetAlertNoticeList(struct soap *soap, _ns1__GetAlertNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlertNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlertNoticeList * SOAP_FMAC2 soap_instantiate__ns1__GetAlertNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlertNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlertNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlertNoticeList);
		if (size)
			*size = sizeof(_ns1__GetAlertNoticeList);
		((_ns1__GetAlertNoticeList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlertNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAlertNoticeList);
		for (int i = 0; i < n; i++)
			((_ns1__GetAlertNoticeList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAlertNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlertNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlertNoticeList %p -> %p\n", q, p));
	*(_ns1__GetAlertNoticeList*)p = *(_ns1__GetAlertNoticeList*)q;
}

void _ns1__GetNoticeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetNoticeItemResponse::GetNoticeItemResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetNoticeItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__NoticeItem(soap, &this->_ns1__GetNoticeItemResponse::GetNoticeItemResult);
	/* transient soap skipped */
}

int _ns1__GetNoticeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeItemResponse), type))
		return soap->error;
	if (a->GetNoticeItemResult)
		soap_element_result(soap, "ns1:GetNoticeItemResult");
	if (soap_out_PointerTons1__NoticeItem(soap, "ns1:GetNoticeItemResult", -1, &(a->_ns1__GetNoticeItemResponse::GetNoticeItemResult), "ns1:NoticeItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeItemResponse * SOAP_FMAC4 soap_in__ns1__GetNoticeItemResponse(struct soap *soap, const char *tag, _ns1__GetNoticeItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeItemResponse, sizeof(_ns1__GetNoticeItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetNoticeItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNoticeItemResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoticeItem(soap, "ns1:GetNoticeItemResult", &(a->_ns1__GetNoticeItemResponse::GetNoticeItemResult), "ns1:NoticeItem"))
				{	soap_flag_GetNoticeItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetNoticeItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeItemResponse, 0, sizeof(_ns1__GetNoticeItemResponse), 0, soap_copy__ns1__GetNoticeItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetNoticeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeItemResponse * SOAP_FMAC4 soap_get__ns1__GetNoticeItemResponse(struct soap *soap, _ns1__GetNoticeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeItemResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeItemResponse);
		if (size)
			*size = sizeof(_ns1__GetNoticeItemResponse);
		((_ns1__GetNoticeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeItemResponse %p -> %p\n", q, p));
	*(_ns1__GetNoticeItemResponse*)p = *(_ns1__GetNoticeItemResponse*)q;
}

void _ns1__GetNoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetNoticeItem::noticeId);
	soap_default_string(soap, &this->_ns1__GetNoticeItem::sessionId);
	/* transient soap skipped */
}

void _ns1__GetNoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetNoticeItem::noticeId);
	soap_serialize_string(soap, &this->_ns1__GetNoticeItem::sessionId);
	/* transient soap skipped */
}

int _ns1__GetNoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeItem(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:noticeId", -1, &(a->_ns1__GetNoticeItem::noticeId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetNoticeItem::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeItem * SOAP_FMAC4 soap_in__ns1__GetNoticeItem(struct soap *soap, const char *tag, _ns1__GetNoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeItem, sizeof(_ns1__GetNoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_noticeId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_noticeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:noticeId", &(a->_ns1__GetNoticeItem::noticeId), "xsd:string"))
				{	soap_flag_noticeId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetNoticeItem::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeItem, 0, sizeof(_ns1__GetNoticeItem), 0, soap_copy__ns1__GetNoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetNoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeItem * SOAP_FMAC4 soap_get__ns1__GetNoticeItem(struct soap *soap, _ns1__GetNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeItem * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeItem);
		if (size)
			*size = sizeof(_ns1__GetNoticeItem);
		((_ns1__GetNoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeItem);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeItem %p -> %p\n", q, p));
	*(_ns1__GetNoticeItem*)p = *(_ns1__GetNoticeItem*)q;
}

void _ns1__GetNoticeListByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetNoticeListByConditionResponse::GetNoticeListByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetNoticeListByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Notice(soap, &this->_ns1__GetNoticeListByConditionResponse::GetNoticeListByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetNoticeListByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeListByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeListByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeListByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeListByConditionResponse), type))
		return soap->error;
	if (a->GetNoticeListByConditionResult)
		soap_element_result(soap, "ns1:GetNoticeListByConditionResult");
	if (soap_out_PointerTons1__Notice(soap, "ns1:GetNoticeListByConditionResult", -1, &(a->_ns1__GetNoticeListByConditionResponse::GetNoticeListByConditionResult), "ns1:Notice"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeListByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeListByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetNoticeListByConditionResponse(struct soap *soap, const char *tag, _ns1__GetNoticeListByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeListByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeListByConditionResponse, sizeof(_ns1__GetNoticeListByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeListByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeListByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetNoticeListByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNoticeListByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Notice(soap, "ns1:GetNoticeListByConditionResult", &(a->_ns1__GetNoticeListByConditionResponse::GetNoticeListByConditionResult), "ns1:Notice"))
				{	soap_flag_GetNoticeListByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetNoticeListByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeListByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeListByConditionResponse, 0, sizeof(_ns1__GetNoticeListByConditionResponse), 0, soap_copy__ns1__GetNoticeListByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetNoticeListByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeListByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeListByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeListByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeListByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetNoticeListByConditionResponse(struct soap *soap, _ns1__GetNoticeListByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeListByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeListByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeListByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeListByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeListByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetNoticeListByConditionResponse);
		((_ns1__GetNoticeListByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeListByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeListByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeListByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeListByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeListByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetNoticeListByConditionResponse*)p = *(_ns1__GetNoticeListByConditionResponse*)q;
}

void _ns1__GetNoticeListByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetNoticeListByCondition::pageSize);
	soap_default_int(soap, &this->_ns1__GetNoticeListByCondition::pageIndex);
	soap_default_string(soap, &this->_ns1__GetNoticeListByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetNoticeListByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetNoticeListByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetNoticeListByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetNoticeListByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetNoticeListByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeListByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeListByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeListByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeListByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->_ns1__GetNoticeListByCondition::pageSize), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageIndex", -1, &(a->_ns1__GetNoticeListByCondition::pageIndex), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetNoticeListByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetNoticeListByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeListByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeListByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByCondition * SOAP_FMAC4 soap_in__ns1__GetNoticeListByCondition(struct soap *soap, const char *tag, _ns1__GetNoticeListByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeListByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeListByCondition, sizeof(_ns1__GetNoticeListByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeListByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeListByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_pageIndex1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->_ns1__GetNoticeListByCondition::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_pageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageIndex", &(a->_ns1__GetNoticeListByCondition::pageIndex), "xsd:int"))
				{	soap_flag_pageIndex1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetNoticeListByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetNoticeListByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeListByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeListByCondition, 0, sizeof(_ns1__GetNoticeListByCondition), 0, soap_copy__ns1__GetNoticeListByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize1 > 0 || soap_flag_pageIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetNoticeListByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeListByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeListByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeListByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeListByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByCondition * SOAP_FMAC4 soap_get__ns1__GetNoticeListByCondition(struct soap *soap, _ns1__GetNoticeListByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeListByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeListByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeListByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeListByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeListByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListByCondition);
		if (size)
			*size = sizeof(_ns1__GetNoticeListByCondition);
		((_ns1__GetNoticeListByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeListByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeListByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeListByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeListByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeListByCondition %p -> %p\n", q, p));
	*(_ns1__GetNoticeListByCondition*)p = *(_ns1__GetNoticeListByCondition*)q;
}

void _ns1__GetNoticeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetNoticeListResponse::GetNoticeListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetNoticeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Notice(soap, &this->_ns1__GetNoticeListResponse::GetNoticeListResult);
	/* transient soap skipped */
}

int _ns1__GetNoticeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeListResponse), type))
		return soap->error;
	if (a->GetNoticeListResult)
		soap_element_result(soap, "ns1:GetNoticeListResult");
	if (soap_out_PointerTons1__Notice(soap, "ns1:GetNoticeListResult", -1, &(a->_ns1__GetNoticeListResponse::GetNoticeListResult), "ns1:Notice"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeListResponse * SOAP_FMAC4 soap_in__ns1__GetNoticeListResponse(struct soap *soap, const char *tag, _ns1__GetNoticeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeListResponse, sizeof(_ns1__GetNoticeListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetNoticeListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetNoticeListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Notice(soap, "ns1:GetNoticeListResult", &(a->_ns1__GetNoticeListResponse::GetNoticeListResult), "ns1:Notice"))
				{	soap_flag_GetNoticeListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetNoticeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeListResponse, 0, sizeof(_ns1__GetNoticeListResponse), 0, soap_copy__ns1__GetNoticeListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetNoticeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeListResponse * SOAP_FMAC4 soap_get__ns1__GetNoticeListResponse(struct soap *soap, _ns1__GetNoticeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListResponse);
		if (size)
			*size = sizeof(_ns1__GetNoticeListResponse);
		((_ns1__GetNoticeListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeListResponse %p -> %p\n", q, p));
	*(_ns1__GetNoticeListResponse*)p = *(_ns1__GetNoticeListResponse*)q;
}

void _ns1__GetNoticeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetNoticeList::pageSize);
	soap_default_int(soap, &this->_ns1__GetNoticeList::pageIndex);
	soap_default_string(soap, &this->_ns1__GetNoticeList::sessionId);
	/* transient soap skipped */
}

void _ns1__GetNoticeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetNoticeList::sessionId);
	/* transient soap skipped */
}

int _ns1__GetNoticeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetNoticeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetNoticeList(struct soap *soap, const char *tag, int id, const _ns1__GetNoticeList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetNoticeList), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->_ns1__GetNoticeList::pageSize), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageIndex", -1, &(a->_ns1__GetNoticeList::pageIndex), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetNoticeList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetNoticeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetNoticeList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetNoticeList * SOAP_FMAC4 soap_in__ns1__GetNoticeList(struct soap *soap, const char *tag, _ns1__GetNoticeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetNoticeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetNoticeList, sizeof(_ns1__GetNoticeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetNoticeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetNoticeList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_pageIndex1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->_ns1__GetNoticeList::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_pageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageIndex", &(a->_ns1__GetNoticeList::pageIndex), "xsd:int"))
				{	soap_flag_pageIndex1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetNoticeList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetNoticeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetNoticeList, 0, sizeof(_ns1__GetNoticeList), 0, soap_copy__ns1__GetNoticeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize1 > 0 || soap_flag_pageIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetNoticeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetNoticeList);
	if (this->soap_out(soap, tag?tag:"ns1:GetNoticeList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetNoticeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetNoticeList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetNoticeList * SOAP_FMAC4 soap_get__ns1__GetNoticeList(struct soap *soap, _ns1__GetNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetNoticeList * SOAP_FMAC2 soap_instantiate__ns1__GetNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeList);
		if (size)
			*size = sizeof(_ns1__GetNoticeList);
		((_ns1__GetNoticeList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetNoticeList);
		for (int i = 0; i < n; i++)
			((_ns1__GetNoticeList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetNoticeList %p -> %p\n", q, p));
	*(_ns1__GetNoticeList*)p = *(_ns1__GetNoticeList*)q;
}

void _ns1__GetTableStatisticsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTableStatisticsResponse::GetTableStatisticsResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTableStatisticsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TableStatistics(soap, &this->_ns1__GetTableStatisticsResponse::GetTableStatisticsResult);
	/* transient soap skipped */
}

int _ns1__GetTableStatisticsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTableStatisticsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTableStatisticsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTableStatisticsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTableStatisticsResponse), type))
		return soap->error;
	if (a->GetTableStatisticsResult)
		soap_element_result(soap, "ns1:GetTableStatisticsResult");
	if (soap_out_PointerTons1__TableStatistics(soap, "ns1:GetTableStatisticsResult", -1, &(a->_ns1__GetTableStatisticsResponse::GetTableStatisticsResult), "ns1:TableStatistics"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTableStatisticsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTableStatisticsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTableStatisticsResponse * SOAP_FMAC4 soap_in__ns1__GetTableStatisticsResponse(struct soap *soap, const char *tag, _ns1__GetTableStatisticsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTableStatisticsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTableStatisticsResponse, sizeof(_ns1__GetTableStatisticsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTableStatisticsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTableStatisticsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTableStatisticsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTableStatisticsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TableStatistics(soap, "ns1:GetTableStatisticsResult", &(a->_ns1__GetTableStatisticsResponse::GetTableStatisticsResult), "ns1:TableStatistics"))
				{	soap_flag_GetTableStatisticsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetTableStatisticsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTableStatisticsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTableStatisticsResponse, 0, sizeof(_ns1__GetTableStatisticsResponse), 0, soap_copy__ns1__GetTableStatisticsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTableStatisticsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTableStatisticsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetTableStatisticsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTableStatisticsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTableStatisticsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTableStatisticsResponse * SOAP_FMAC4 soap_get__ns1__GetTableStatisticsResponse(struct soap *soap, _ns1__GetTableStatisticsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTableStatisticsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTableStatisticsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTableStatisticsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTableStatisticsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTableStatisticsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTableStatisticsResponse);
		if (size)
			*size = sizeof(_ns1__GetTableStatisticsResponse);
		((_ns1__GetTableStatisticsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTableStatisticsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTableStatisticsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetTableStatisticsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTableStatisticsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTableStatisticsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTableStatisticsResponse %p -> %p\n", q, p));
	*(_ns1__GetTableStatisticsResponse*)p = *(_ns1__GetTableStatisticsResponse*)q;
}

void _ns1__GetTableStatistics::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTableStatistics::tableName);
	soap_default_string(soap, &this->_ns1__GetTableStatistics::sumItem1);
	soap_default_string(soap, &this->_ns1__GetTableStatistics::sumItem2);
	soap_default_string(soap, &this->_ns1__GetTableStatistics::condition);
	soap_default_string(soap, &this->_ns1__GetTableStatistics::sessionId);
	/* transient soap skipped */
}

void _ns1__GetTableStatistics::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetTableStatistics::tableName);
	soap_serialize_string(soap, &this->_ns1__GetTableStatistics::sumItem1);
	soap_serialize_string(soap, &this->_ns1__GetTableStatistics::sumItem2);
	soap_serialize_string(soap, &this->_ns1__GetTableStatistics::condition);
	soap_serialize_string(soap, &this->_ns1__GetTableStatistics::sessionId);
	/* transient soap skipped */
}

int _ns1__GetTableStatistics::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTableStatistics(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTableStatistics(struct soap *soap, const char *tag, int id, const _ns1__GetTableStatistics *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTableStatistics), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tableName", -1, &(a->_ns1__GetTableStatistics::tableName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sumItem1", -1, &(a->_ns1__GetTableStatistics::sumItem1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sumItem2", -1, &(a->_ns1__GetTableStatistics::sumItem2), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetTableStatistics::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetTableStatistics::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTableStatistics::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTableStatistics(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTableStatistics * SOAP_FMAC4 soap_in__ns1__GetTableStatistics(struct soap *soap, const char *tag, _ns1__GetTableStatistics *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTableStatistics *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTableStatistics, sizeof(_ns1__GetTableStatistics), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTableStatistics)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTableStatistics *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tableName1 = 1;
	size_t soap_flag_sumItem11 = 1;
	size_t soap_flag_sumItem21 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:tableName", &(a->_ns1__GetTableStatistics::tableName), "xsd:string"))
				{	soap_flag_tableName1--;
					continue;
				}
			if (soap_flag_sumItem11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sumItem1", &(a->_ns1__GetTableStatistics::sumItem1), "xsd:string"))
				{	soap_flag_sumItem11--;
					continue;
				}
			if (soap_flag_sumItem21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sumItem2", &(a->_ns1__GetTableStatistics::sumItem2), "xsd:string"))
				{	soap_flag_sumItem21--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetTableStatistics::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetTableStatistics::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTableStatistics *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTableStatistics, 0, sizeof(_ns1__GetTableStatistics), 0, soap_copy__ns1__GetTableStatistics);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTableStatistics::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTableStatistics);
	if (this->soap_out(soap, tag?tag:"ns1:GetTableStatistics", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTableStatistics::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTableStatistics(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTableStatistics * SOAP_FMAC4 soap_get__ns1__GetTableStatistics(struct soap *soap, _ns1__GetTableStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTableStatistics * SOAP_FMAC2 soap_instantiate__ns1__GetTableStatistics(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTableStatistics(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTableStatistics, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTableStatistics);
		if (size)
			*size = sizeof(_ns1__GetTableStatistics);
		((_ns1__GetTableStatistics*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTableStatistics[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTableStatistics);
		for (int i = 0; i < n; i++)
			((_ns1__GetTableStatistics*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTableStatistics*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTableStatistics(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTableStatistics %p -> %p\n", q, p));
	*(_ns1__GetTableStatistics*)p = *(_ns1__GetTableStatistics*)q;
}

void _ns1__UpdateFunctionRightResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateFunctionRightResponse::UpdateFunctionRightResult);
	/* transient soap skipped */
}

void _ns1__UpdateFunctionRightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateFunctionRightResponse::UpdateFunctionRightResult);
	/* transient soap skipped */
}

int _ns1__UpdateFunctionRightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateFunctionRightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateFunctionRightResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateFunctionRightResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateFunctionRightResponse), type))
		return soap->error;
	if (a->UpdateFunctionRightResult)
		soap_element_result(soap, "ns1:UpdateFunctionRightResult");
	if (soap_out_string(soap, "ns1:UpdateFunctionRightResult", -1, &(a->_ns1__UpdateFunctionRightResponse::UpdateFunctionRightResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateFunctionRightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateFunctionRightResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRightResponse * SOAP_FMAC4 soap_in__ns1__UpdateFunctionRightResponse(struct soap *soap, const char *tag, _ns1__UpdateFunctionRightResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateFunctionRightResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateFunctionRightResponse, sizeof(_ns1__UpdateFunctionRightResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateFunctionRightResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateFunctionRightResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateFunctionRightResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateFunctionRightResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateFunctionRightResult", &(a->_ns1__UpdateFunctionRightResponse::UpdateFunctionRightResult), "xsd:string"))
				{	soap_flag_UpdateFunctionRightResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateFunctionRightResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateFunctionRightResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateFunctionRightResponse, 0, sizeof(_ns1__UpdateFunctionRightResponse), 0, soap_copy__ns1__UpdateFunctionRightResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateFunctionRightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateFunctionRightResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateFunctionRightResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateFunctionRightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateFunctionRightResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRightResponse * SOAP_FMAC4 soap_get__ns1__UpdateFunctionRightResponse(struct soap *soap, _ns1__UpdateFunctionRightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateFunctionRightResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateFunctionRightResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateFunctionRightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateFunctionRightResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateFunctionRightResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateFunctionRightResponse);
		if (size)
			*size = sizeof(_ns1__UpdateFunctionRightResponse);
		((_ns1__UpdateFunctionRightResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateFunctionRightResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateFunctionRightResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateFunctionRightResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateFunctionRightResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateFunctionRightResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateFunctionRightResponse %p -> %p\n", q, p));
	*(_ns1__UpdateFunctionRightResponse*)p = *(_ns1__UpdateFunctionRightResponse*)q;
}

void _ns1__UpdateFunctionRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateFunctionRight::functionId);
	soap_default_int(soap, &this->_ns1__UpdateFunctionRight::right);
	soap_default_string(soap, &this->_ns1__UpdateFunctionRight::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateFunctionRight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateFunctionRight::functionId);
	soap_serialize_string(soap, &this->_ns1__UpdateFunctionRight::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateFunctionRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateFunctionRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateFunctionRight(struct soap *soap, const char *tag, int id, const _ns1__UpdateFunctionRight *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateFunctionRight), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:functionId", -1, &(a->_ns1__UpdateFunctionRight::functionId), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:right", -1, &(a->_ns1__UpdateFunctionRight::right), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateFunctionRight::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateFunctionRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateFunctionRight(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRight * SOAP_FMAC4 soap_in__ns1__UpdateFunctionRight(struct soap *soap, const char *tag, _ns1__UpdateFunctionRight *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateFunctionRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateFunctionRight, sizeof(_ns1__UpdateFunctionRight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateFunctionRight)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateFunctionRight *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_functionId1 = 1;
	size_t soap_flag_right1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_functionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:functionId", &(a->_ns1__UpdateFunctionRight::functionId), "xsd:string"))
				{	soap_flag_functionId1--;
					continue;
				}
			if (soap_flag_right1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:right", &(a->_ns1__UpdateFunctionRight::right), "xsd:int"))
				{	soap_flag_right1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateFunctionRight::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateFunctionRight *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateFunctionRight, 0, sizeof(_ns1__UpdateFunctionRight), 0, soap_copy__ns1__UpdateFunctionRight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_right1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UpdateFunctionRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateFunctionRight);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateFunctionRight", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateFunctionRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateFunctionRight(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRight * SOAP_FMAC4 soap_get__ns1__UpdateFunctionRight(struct soap *soap, _ns1__UpdateFunctionRight *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateFunctionRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateFunctionRight * SOAP_FMAC2 soap_instantiate__ns1__UpdateFunctionRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateFunctionRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateFunctionRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateFunctionRight);
		if (size)
			*size = sizeof(_ns1__UpdateFunctionRight);
		((_ns1__UpdateFunctionRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateFunctionRight[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateFunctionRight);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateFunctionRight*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateFunctionRight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateFunctionRight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateFunctionRight %p -> %p\n", q, p));
	*(_ns1__UpdateFunctionRight*)p = *(_ns1__UpdateFunctionRight*)q;
}

void _ns1__UpdateUserFunctionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateUserFunctionListResponse::UpdateUserFunctionListResult);
	/* transient soap skipped */
}

void _ns1__UpdateUserFunctionListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateUserFunctionListResponse::UpdateUserFunctionListResult);
	/* transient soap skipped */
}

int _ns1__UpdateUserFunctionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateUserFunctionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateUserFunctionListResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateUserFunctionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateUserFunctionListResponse), type))
		return soap->error;
	if (a->UpdateUserFunctionListResult)
		soap_element_result(soap, "ns1:UpdateUserFunctionListResult");
	if (soap_out_string(soap, "ns1:UpdateUserFunctionListResult", -1, &(a->_ns1__UpdateUserFunctionListResponse::UpdateUserFunctionListResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateUserFunctionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateUserFunctionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionListResponse * SOAP_FMAC4 soap_in__ns1__UpdateUserFunctionListResponse(struct soap *soap, const char *tag, _ns1__UpdateUserFunctionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateUserFunctionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateUserFunctionListResponse, sizeof(_ns1__UpdateUserFunctionListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateUserFunctionListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateUserFunctionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateUserFunctionListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateUserFunctionListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateUserFunctionListResult", &(a->_ns1__UpdateUserFunctionListResponse::UpdateUserFunctionListResult), "xsd:string"))
				{	soap_flag_UpdateUserFunctionListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateUserFunctionListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateUserFunctionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateUserFunctionListResponse, 0, sizeof(_ns1__UpdateUserFunctionListResponse), 0, soap_copy__ns1__UpdateUserFunctionListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateUserFunctionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateUserFunctionListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateUserFunctionListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateUserFunctionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateUserFunctionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionListResponse * SOAP_FMAC4 soap_get__ns1__UpdateUserFunctionListResponse(struct soap *soap, _ns1__UpdateUserFunctionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateUserFunctionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateUserFunctionListResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateUserFunctionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateUserFunctionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateUserFunctionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateUserFunctionListResponse);
		if (size)
			*size = sizeof(_ns1__UpdateUserFunctionListResponse);
		((_ns1__UpdateUserFunctionListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateUserFunctionListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateUserFunctionListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateUserFunctionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateUserFunctionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateUserFunctionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateUserFunctionListResponse %p -> %p\n", q, p));
	*(_ns1__UpdateUserFunctionListResponse*)p = *(_ns1__UpdateUserFunctionListResponse*)q;
}

void _ns1__UpdateUserFunctionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateUserFunctionList::userIdOrWokerId);
	soap_default_string(soap, &this->_ns1__UpdateUserFunctionList::operateId);
	this->_ns1__UpdateUserFunctionList::functionList = NULL;
	soap_default_string(soap, &this->_ns1__UpdateUserFunctionList::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateUserFunctionList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateUserFunctionList::userIdOrWokerId);
	soap_serialize_string(soap, &this->_ns1__UpdateUserFunctionList::operateId);
	soap_serialize_PointerTons1__ArrayOfSystemFunction(soap, &this->_ns1__UpdateUserFunctionList::functionList);
	soap_serialize_string(soap, &this->_ns1__UpdateUserFunctionList::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateUserFunctionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateUserFunctionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateUserFunctionList(struct soap *soap, const char *tag, int id, const _ns1__UpdateUserFunctionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateUserFunctionList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userIdOrWokerId", -1, &(a->_ns1__UpdateUserFunctionList::userIdOrWokerId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operateId", -1, &(a->_ns1__UpdateUserFunctionList::operateId), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSystemFunction(soap, "ns1:functionList", -1, &(a->_ns1__UpdateUserFunctionList::functionList), "ns1:ArrayOfSystemFunction"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateUserFunctionList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateUserFunctionList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateUserFunctionList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionList * SOAP_FMAC4 soap_in__ns1__UpdateUserFunctionList(struct soap *soap, const char *tag, _ns1__UpdateUserFunctionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateUserFunctionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateUserFunctionList, sizeof(_ns1__UpdateUserFunctionList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateUserFunctionList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateUserFunctionList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userIdOrWokerId1 = 1;
	size_t soap_flag_operateId1 = 1;
	size_t soap_flag_functionList1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userIdOrWokerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userIdOrWokerId", &(a->_ns1__UpdateUserFunctionList::userIdOrWokerId), "xsd:string"))
				{	soap_flag_userIdOrWokerId1--;
					continue;
				}
			if (soap_flag_operateId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operateId", &(a->_ns1__UpdateUserFunctionList::operateId), "xsd:string"))
				{	soap_flag_operateId1--;
					continue;
				}
			if (soap_flag_functionList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSystemFunction(soap, "ns1:functionList", &(a->_ns1__UpdateUserFunctionList::functionList), "ns1:ArrayOfSystemFunction"))
				{	soap_flag_functionList1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateUserFunctionList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateUserFunctionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateUserFunctionList, 0, sizeof(_ns1__UpdateUserFunctionList), 0, soap_copy__ns1__UpdateUserFunctionList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateUserFunctionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateUserFunctionList);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateUserFunctionList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateUserFunctionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateUserFunctionList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionList * SOAP_FMAC4 soap_get__ns1__UpdateUserFunctionList(struct soap *soap, _ns1__UpdateUserFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateUserFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateUserFunctionList * SOAP_FMAC2 soap_instantiate__ns1__UpdateUserFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateUserFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateUserFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateUserFunctionList);
		if (size)
			*size = sizeof(_ns1__UpdateUserFunctionList);
		((_ns1__UpdateUserFunctionList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateUserFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateUserFunctionList);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateUserFunctionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateUserFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateUserFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateUserFunctionList %p -> %p\n", q, p));
	*(_ns1__UpdateUserFunctionList*)p = *(_ns1__UpdateUserFunctionList*)q;
}

void _ns1__GetFunctionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFunctionListResponse::GetFunctionListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetFunctionListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSystemFunction(soap, &this->_ns1__GetFunctionListResponse::GetFunctionListResult);
	/* transient soap skipped */
}

int _ns1__GetFunctionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFunctionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFunctionListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFunctionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFunctionListResponse), type))
		return soap->error;
	if (a->GetFunctionListResult)
		soap_element_result(soap, "ns1:GetFunctionListResult");
	if (soap_out_PointerTons1__ArrayOfSystemFunction(soap, "ns1:GetFunctionListResult", -1, &(a->_ns1__GetFunctionListResponse::GetFunctionListResult), "ns1:ArrayOfSystemFunction"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFunctionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFunctionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFunctionListResponse * SOAP_FMAC4 soap_in__ns1__GetFunctionListResponse(struct soap *soap, const char *tag, _ns1__GetFunctionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFunctionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFunctionListResponse, sizeof(_ns1__GetFunctionListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetFunctionListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetFunctionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetFunctionListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFunctionListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSystemFunction(soap, "ns1:GetFunctionListResult", &(a->_ns1__GetFunctionListResponse::GetFunctionListResult), "ns1:ArrayOfSystemFunction"))
				{	soap_flag_GetFunctionListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetFunctionListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFunctionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFunctionListResponse, 0, sizeof(_ns1__GetFunctionListResponse), 0, soap_copy__ns1__GetFunctionListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetFunctionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetFunctionListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetFunctionListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFunctionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFunctionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFunctionListResponse * SOAP_FMAC4 soap_get__ns1__GetFunctionListResponse(struct soap *soap, _ns1__GetFunctionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFunctionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetFunctionListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFunctionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFunctionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetFunctionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetFunctionListResponse);
		if (size)
			*size = sizeof(_ns1__GetFunctionListResponse);
		((_ns1__GetFunctionListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetFunctionListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetFunctionListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetFunctionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetFunctionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetFunctionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetFunctionListResponse %p -> %p\n", q, p));
	*(_ns1__GetFunctionListResponse*)p = *(_ns1__GetFunctionListResponse*)q;
}

void _ns1__GetFunctionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetFunctionList::condition);
	soap_default_string(soap, &this->_ns1__GetFunctionList::sessionId);
	/* transient soap skipped */
}

void _ns1__GetFunctionList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetFunctionList::condition);
	soap_serialize_string(soap, &this->_ns1__GetFunctionList::sessionId);
	/* transient soap skipped */
}

int _ns1__GetFunctionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFunctionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFunctionList(struct soap *soap, const char *tag, int id, const _ns1__GetFunctionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFunctionList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetFunctionList::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetFunctionList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFunctionList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFunctionList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFunctionList * SOAP_FMAC4 soap_in__ns1__GetFunctionList(struct soap *soap, const char *tag, _ns1__GetFunctionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFunctionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFunctionList, sizeof(_ns1__GetFunctionList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetFunctionList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetFunctionList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetFunctionList::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetFunctionList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFunctionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFunctionList, 0, sizeof(_ns1__GetFunctionList), 0, soap_copy__ns1__GetFunctionList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetFunctionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetFunctionList);
	if (this->soap_out(soap, tag?tag:"ns1:GetFunctionList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFunctionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFunctionList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFunctionList * SOAP_FMAC4 soap_get__ns1__GetFunctionList(struct soap *soap, _ns1__GetFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetFunctionList * SOAP_FMAC2 soap_instantiate__ns1__GetFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetFunctionList);
		if (size)
			*size = sizeof(_ns1__GetFunctionList);
		((_ns1__GetFunctionList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetFunctionList);
		for (int i = 0; i < n; i++)
			((_ns1__GetFunctionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetFunctionList %p -> %p\n", q, p));
	*(_ns1__GetFunctionList*)p = *(_ns1__GetFunctionList*)q;
}

void _ns1__UpdateDicContentByCategoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDicContentByCategoryResponse::UpdateDicContentByCategoryResult);
	/* transient soap skipped */
}

void _ns1__UpdateDicContentByCategoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateDicContentByCategoryResponse::UpdateDicContentByCategoryResult);
	/* transient soap skipped */
}

int _ns1__UpdateDicContentByCategoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDicContentByCategoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDicContentByCategoryResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateDicContentByCategoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse), type))
		return soap->error;
	if (a->UpdateDicContentByCategoryResult)
		soap_element_result(soap, "ns1:UpdateDicContentByCategoryResult");
	if (soap_out_string(soap, "ns1:UpdateDicContentByCategoryResult", -1, &(a->_ns1__UpdateDicContentByCategoryResponse::UpdateDicContentByCategoryResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDicContentByCategoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDicContentByCategoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategoryResponse * SOAP_FMAC4 soap_in__ns1__UpdateDicContentByCategoryResponse(struct soap *soap, const char *tag, _ns1__UpdateDicContentByCategoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDicContentByCategoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse, sizeof(_ns1__UpdateDicContentByCategoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDicContentByCategoryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateDicContentByCategoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateDicContentByCategoryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateDicContentByCategoryResult", &(a->_ns1__UpdateDicContentByCategoryResponse::UpdateDicContentByCategoryResult), "xsd:string"))
				{	soap_flag_UpdateDicContentByCategoryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateDicContentByCategoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDicContentByCategoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse, 0, sizeof(_ns1__UpdateDicContentByCategoryResponse), 0, soap_copy__ns1__UpdateDicContentByCategoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateDicContentByCategoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDicContentByCategoryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDicContentByCategoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDicContentByCategoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategoryResponse * SOAP_FMAC4 soap_get__ns1__UpdateDicContentByCategoryResponse(struct soap *soap, _ns1__UpdateDicContentByCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDicContentByCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDicContentByCategoryResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateDicContentByCategoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDicContentByCategoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentByCategoryResponse);
		if (size)
			*size = sizeof(_ns1__UpdateDicContentByCategoryResponse);
		((_ns1__UpdateDicContentByCategoryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentByCategoryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateDicContentByCategoryResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateDicContentByCategoryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateDicContentByCategoryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDicContentByCategoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDicContentByCategoryResponse %p -> %p\n", q, p));
	*(_ns1__UpdateDicContentByCategoryResponse*)p = *(_ns1__UpdateDicContentByCategoryResponse*)q;
}

void _ns1__UpdateDicContentByCategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDicContentByCategory::category);
	this->_ns1__UpdateDicContentByCategory::contentList = NULL;
	soap_default_string(soap, &this->_ns1__UpdateDicContentByCategory::operatorId);
	soap_default_string(soap, &this->_ns1__UpdateDicContentByCategory::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateDicContentByCategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateDicContentByCategory::category);
	soap_serialize_PointerTons1__ArrayOfDIC_USCOREContent(soap, &this->_ns1__UpdateDicContentByCategory::contentList);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContentByCategory::operatorId);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContentByCategory::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateDicContentByCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDicContentByCategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDicContentByCategory(struct soap *soap, const char *tag, int id, const _ns1__UpdateDicContentByCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDicContentByCategory), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:category", -1, &(a->_ns1__UpdateDicContentByCategory::category), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDIC_USCOREContent(soap, "ns1:contentList", -1, &(a->_ns1__UpdateDicContentByCategory::contentList), "ns1:ArrayOfDIC_Content"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__UpdateDicContentByCategory::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateDicContentByCategory::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDicContentByCategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDicContentByCategory(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategory * SOAP_FMAC4 soap_in__ns1__UpdateDicContentByCategory(struct soap *soap, const char *tag, _ns1__UpdateDicContentByCategory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDicContentByCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDicContentByCategory, sizeof(_ns1__UpdateDicContentByCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDicContentByCategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDicContentByCategory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_category1 = 1;
	size_t soap_flag_contentList1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:category", &(a->_ns1__UpdateDicContentByCategory::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_contentList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDIC_USCOREContent(soap, "ns1:contentList", &(a->_ns1__UpdateDicContentByCategory::contentList), "ns1:ArrayOfDIC_Content"))
				{	soap_flag_contentList1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__UpdateDicContentByCategory::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateDicContentByCategory::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDicContentByCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDicContentByCategory, 0, sizeof(_ns1__UpdateDicContentByCategory), 0, soap_copy__ns1__UpdateDicContentByCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateDicContentByCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateDicContentByCategory);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDicContentByCategory", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDicContentByCategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDicContentByCategory(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategory * SOAP_FMAC4 soap_get__ns1__UpdateDicContentByCategory(struct soap *soap, _ns1__UpdateDicContentByCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDicContentByCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDicContentByCategory * SOAP_FMAC2 soap_instantiate__ns1__UpdateDicContentByCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDicContentByCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDicContentByCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentByCategory);
		if (size)
			*size = sizeof(_ns1__UpdateDicContentByCategory);
		((_ns1__UpdateDicContentByCategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentByCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateDicContentByCategory);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateDicContentByCategory*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateDicContentByCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDicContentByCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDicContentByCategory %p -> %p\n", q, p));
	*(_ns1__UpdateDicContentByCategory*)p = *(_ns1__UpdateDicContentByCategory*)q;
}

void _ns1__DeleteDicContentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteDicContentResponse::DeleteDicContentResult);
	/* transient soap skipped */
}

void _ns1__DeleteDicContentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteDicContentResponse::DeleteDicContentResult);
	/* transient soap skipped */
}

int _ns1__DeleteDicContentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteDicContentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteDicContentResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteDicContentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteDicContentResponse), type))
		return soap->error;
	if (a->DeleteDicContentResult)
		soap_element_result(soap, "ns1:DeleteDicContentResult");
	if (soap_out_string(soap, "ns1:DeleteDicContentResult", -1, &(a->_ns1__DeleteDicContentResponse::DeleteDicContentResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteDicContentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteDicContentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteDicContentResponse * SOAP_FMAC4 soap_in__ns1__DeleteDicContentResponse(struct soap *soap, const char *tag, _ns1__DeleteDicContentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteDicContentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteDicContentResponse, sizeof(_ns1__DeleteDicContentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteDicContentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteDicContentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeleteDicContentResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteDicContentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeleteDicContentResult", &(a->_ns1__DeleteDicContentResponse::DeleteDicContentResult), "xsd:string"))
				{	soap_flag_DeleteDicContentResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeleteDicContentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteDicContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteDicContentResponse, 0, sizeof(_ns1__DeleteDicContentResponse), 0, soap_copy__ns1__DeleteDicContentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteDicContentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteDicContentResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteDicContentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteDicContentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteDicContentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteDicContentResponse * SOAP_FMAC4 soap_get__ns1__DeleteDicContentResponse(struct soap *soap, _ns1__DeleteDicContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteDicContentResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteDicContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteDicContentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteDicContentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteDicContentResponse);
		if (size)
			*size = sizeof(_ns1__DeleteDicContentResponse);
		((_ns1__DeleteDicContentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteDicContentResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteDicContentResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteDicContentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteDicContentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteDicContentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteDicContentResponse %p -> %p\n", q, p));
	*(_ns1__DeleteDicContentResponse*)p = *(_ns1__DeleteDicContentResponse*)q;
}

void _ns1__DeleteDicContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteDicContent::category);
	soap_default_string(soap, &this->_ns1__DeleteDicContent::name);
	soap_default_string(soap, &this->_ns1__DeleteDicContent::operatorId);
	soap_default_string(soap, &this->_ns1__DeleteDicContent::sessionId);
	/* transient soap skipped */
}

void _ns1__DeleteDicContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__DeleteDicContent::category);
	soap_serialize_string(soap, &this->_ns1__DeleteDicContent::name);
	soap_serialize_string(soap, &this->_ns1__DeleteDicContent::operatorId);
	soap_serialize_string(soap, &this->_ns1__DeleteDicContent::sessionId);
	/* transient soap skipped */
}

int _ns1__DeleteDicContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteDicContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteDicContent(struct soap *soap, const char *tag, int id, const _ns1__DeleteDicContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteDicContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:category", -1, &(a->_ns1__DeleteDicContent::category), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->_ns1__DeleteDicContent::name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__DeleteDicContent::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__DeleteDicContent::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteDicContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteDicContent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteDicContent * SOAP_FMAC4 soap_in__ns1__DeleteDicContent(struct soap *soap, const char *tag, _ns1__DeleteDicContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteDicContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteDicContent, sizeof(_ns1__DeleteDicContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteDicContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteDicContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_category1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:category", &(a->_ns1__DeleteDicContent::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->_ns1__DeleteDicContent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__DeleteDicContent::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__DeleteDicContent::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteDicContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteDicContent, 0, sizeof(_ns1__DeleteDicContent), 0, soap_copy__ns1__DeleteDicContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DeleteDicContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteDicContent);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteDicContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteDicContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteDicContent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteDicContent * SOAP_FMAC4 soap_get__ns1__DeleteDicContent(struct soap *soap, _ns1__DeleteDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteDicContent * SOAP_FMAC2 soap_instantiate__ns1__DeleteDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteDicContent);
		if (size)
			*size = sizeof(_ns1__DeleteDicContent);
		((_ns1__DeleteDicContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteDicContent);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteDicContent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteDicContent %p -> %p\n", q, p));
	*(_ns1__DeleteDicContent*)p = *(_ns1__DeleteDicContent*)q;
}

void _ns1__UpdateDicContentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDicContentResponse::UpdateDicContentResult);
	/* transient soap skipped */
}

void _ns1__UpdateDicContentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateDicContentResponse::UpdateDicContentResult);
	/* transient soap skipped */
}

int _ns1__UpdateDicContentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDicContentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDicContentResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateDicContentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDicContentResponse), type))
		return soap->error;
	if (a->UpdateDicContentResult)
		soap_element_result(soap, "ns1:UpdateDicContentResult");
	if (soap_out_string(soap, "ns1:UpdateDicContentResult", -1, &(a->_ns1__UpdateDicContentResponse::UpdateDicContentResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDicContentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDicContentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentResponse * SOAP_FMAC4 soap_in__ns1__UpdateDicContentResponse(struct soap *soap, const char *tag, _ns1__UpdateDicContentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDicContentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDicContentResponse, sizeof(_ns1__UpdateDicContentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDicContentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDicContentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateDicContentResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateDicContentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateDicContentResult", &(a->_ns1__UpdateDicContentResponse::UpdateDicContentResult), "xsd:string"))
				{	soap_flag_UpdateDicContentResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateDicContentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDicContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDicContentResponse, 0, sizeof(_ns1__UpdateDicContentResponse), 0, soap_copy__ns1__UpdateDicContentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateDicContentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateDicContentResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDicContentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDicContentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDicContentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentResponse * SOAP_FMAC4 soap_get__ns1__UpdateDicContentResponse(struct soap *soap, _ns1__UpdateDicContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDicContentResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateDicContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDicContentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDicContentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentResponse);
		if (size)
			*size = sizeof(_ns1__UpdateDicContentResponse);
		((_ns1__UpdateDicContentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContentResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateDicContentResponse);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateDicContentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateDicContentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDicContentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDicContentResponse %p -> %p\n", q, p));
	*(_ns1__UpdateDicContentResponse*)p = *(_ns1__UpdateDicContentResponse*)q;
}

void _ns1__UpdateDicContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDicContent::category);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::name);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::code);
	soap_default_bool(soap, &this->_ns1__UpdateDicContent::enabled);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::content);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::val1);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::val2);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::operatorId);
	soap_default_string(soap, &this->_ns1__UpdateDicContent::sessionId);
	/* transient soap skipped */
}

void _ns1__UpdateDicContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::category);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::name);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::code);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::content);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::val1);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::val2);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::operatorId);
	soap_serialize_string(soap, &this->_ns1__UpdateDicContent::sessionId);
	/* transient soap skipped */
}

int _ns1__UpdateDicContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDicContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDicContent(struct soap *soap, const char *tag, int id, const _ns1__UpdateDicContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDicContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:category", -1, &(a->_ns1__UpdateDicContent::category), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->_ns1__UpdateDicContent::name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:code", -1, &(a->_ns1__UpdateDicContent::code), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:enabled", -1, &(a->_ns1__UpdateDicContent::enabled), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__UpdateDicContent::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val1", -1, &(a->_ns1__UpdateDicContent::val1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val2", -1, &(a->_ns1__UpdateDicContent::val2), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__UpdateDicContent::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__UpdateDicContent::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDicContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDicContent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDicContent * SOAP_FMAC4 soap_in__ns1__UpdateDicContent(struct soap *soap, const char *tag, _ns1__UpdateDicContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDicContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDicContent, sizeof(_ns1__UpdateDicContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDicContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDicContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_category1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_val11 = 1;
	size_t soap_flag_val21 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:category", &(a->_ns1__UpdateDicContent::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->_ns1__UpdateDicContent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:code", &(a->_ns1__UpdateDicContent::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:enabled", &(a->_ns1__UpdateDicContent::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__UpdateDicContent::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_val11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val1", &(a->_ns1__UpdateDicContent::val1), "xsd:string"))
				{	soap_flag_val11--;
					continue;
				}
			if (soap_flag_val21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val2", &(a->_ns1__UpdateDicContent::val2), "xsd:string"))
				{	soap_flag_val21--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__UpdateDicContent::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__UpdateDicContent::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDicContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDicContent, 0, sizeof(_ns1__UpdateDicContent), 0, soap_copy__ns1__UpdateDicContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UpdateDicContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateDicContent);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDicContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDicContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDicContent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDicContent * SOAP_FMAC4 soap_get__ns1__UpdateDicContent(struct soap *soap, _ns1__UpdateDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDicContent * SOAP_FMAC2 soap_instantiate__ns1__UpdateDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContent);
		if (size)
			*size = sizeof(_ns1__UpdateDicContent);
		((_ns1__UpdateDicContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__UpdateDicContent);
		for (int i = 0; i < n; i++)
			((_ns1__UpdateDicContent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__UpdateDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDicContent %p -> %p\n", q, p));
	*(_ns1__UpdateDicContent*)p = *(_ns1__UpdateDicContent*)q;
}

void _ns1__InsertDicContentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InsertDicContentResponse::InsertDicContentResult);
	/* transient soap skipped */
}

void _ns1__InsertDicContentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InsertDicContentResponse::InsertDicContentResult);
	/* transient soap skipped */
}

int _ns1__InsertDicContentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertDicContentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertDicContentResponse(struct soap *soap, const char *tag, int id, const _ns1__InsertDicContentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertDicContentResponse), type))
		return soap->error;
	if (a->InsertDicContentResult)
		soap_element_result(soap, "ns1:InsertDicContentResult");
	if (soap_out_string(soap, "ns1:InsertDicContentResult", -1, &(a->_ns1__InsertDicContentResponse::InsertDicContentResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertDicContentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertDicContentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertDicContentResponse * SOAP_FMAC4 soap_in__ns1__InsertDicContentResponse(struct soap *soap, const char *tag, _ns1__InsertDicContentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertDicContentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertDicContentResponse, sizeof(_ns1__InsertDicContentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InsertDicContentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InsertDicContentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InsertDicContentResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InsertDicContentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InsertDicContentResult", &(a->_ns1__InsertDicContentResponse::InsertDicContentResult), "xsd:string"))
				{	soap_flag_InsertDicContentResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InsertDicContentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsertDicContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertDicContentResponse, 0, sizeof(_ns1__InsertDicContentResponse), 0, soap_copy__ns1__InsertDicContentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InsertDicContentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InsertDicContentResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InsertDicContentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertDicContentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertDicContentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertDicContentResponse * SOAP_FMAC4 soap_get__ns1__InsertDicContentResponse(struct soap *soap, _ns1__InsertDicContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InsertDicContentResponse * SOAP_FMAC2 soap_instantiate__ns1__InsertDicContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertDicContentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InsertDicContentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InsertDicContentResponse);
		if (size)
			*size = sizeof(_ns1__InsertDicContentResponse);
		((_ns1__InsertDicContentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InsertDicContentResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__InsertDicContentResponse);
		for (int i = 0; i < n; i++)
			((_ns1__InsertDicContentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__InsertDicContentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InsertDicContentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InsertDicContentResponse %p -> %p\n", q, p));
	*(_ns1__InsertDicContentResponse*)p = *(_ns1__InsertDicContentResponse*)q;
}

void _ns1__InsertDicContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InsertDicContent::category);
	soap_default_string(soap, &this->_ns1__InsertDicContent::name);
	soap_default_string(soap, &this->_ns1__InsertDicContent::code);
	soap_default_bool(soap, &this->_ns1__InsertDicContent::enabled);
	soap_default_string(soap, &this->_ns1__InsertDicContent::content);
	soap_default_string(soap, &this->_ns1__InsertDicContent::val1);
	soap_default_string(soap, &this->_ns1__InsertDicContent::val2);
	soap_default_string(soap, &this->_ns1__InsertDicContent::operatorId);
	soap_default_string(soap, &this->_ns1__InsertDicContent::sessionId);
	/* transient soap skipped */
}

void _ns1__InsertDicContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::category);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::name);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::code);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::content);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::val1);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::val2);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::operatorId);
	soap_serialize_string(soap, &this->_ns1__InsertDicContent::sessionId);
	/* transient soap skipped */
}

int _ns1__InsertDicContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertDicContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertDicContent(struct soap *soap, const char *tag, int id, const _ns1__InsertDicContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertDicContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:category", -1, &(a->_ns1__InsertDicContent::category), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->_ns1__InsertDicContent::name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:code", -1, &(a->_ns1__InsertDicContent::code), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:enabled", -1, &(a->_ns1__InsertDicContent::enabled), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__InsertDicContent::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val1", -1, &(a->_ns1__InsertDicContent::val1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val2", -1, &(a->_ns1__InsertDicContent::val2), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:operatorId", -1, &(a->_ns1__InsertDicContent::operatorId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__InsertDicContent::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertDicContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertDicContent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertDicContent * SOAP_FMAC4 soap_in__ns1__InsertDicContent(struct soap *soap, const char *tag, _ns1__InsertDicContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertDicContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertDicContent, sizeof(_ns1__InsertDicContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InsertDicContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InsertDicContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_category1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_val11 = 1;
	size_t soap_flag_val21 = 1;
	size_t soap_flag_operatorId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:category", &(a->_ns1__InsertDicContent::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->_ns1__InsertDicContent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:code", &(a->_ns1__InsertDicContent::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:enabled", &(a->_ns1__InsertDicContent::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__InsertDicContent::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_val11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val1", &(a->_ns1__InsertDicContent::val1), "xsd:string"))
				{	soap_flag_val11--;
					continue;
				}
			if (soap_flag_val21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val2", &(a->_ns1__InsertDicContent::val2), "xsd:string"))
				{	soap_flag_val21--;
					continue;
				}
			if (soap_flag_operatorId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operatorId", &(a->_ns1__InsertDicContent::operatorId), "xsd:string"))
				{	soap_flag_operatorId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__InsertDicContent::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InsertDicContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertDicContent, 0, sizeof(_ns1__InsertDicContent), 0, soap_copy__ns1__InsertDicContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__InsertDicContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InsertDicContent);
	if (this->soap_out(soap, tag?tag:"ns1:InsertDicContent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertDicContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertDicContent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertDicContent * SOAP_FMAC4 soap_get__ns1__InsertDicContent(struct soap *soap, _ns1__InsertDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InsertDicContent * SOAP_FMAC2 soap_instantiate__ns1__InsertDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InsertDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InsertDicContent);
		if (size)
			*size = sizeof(_ns1__InsertDicContent);
		((_ns1__InsertDicContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InsertDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__InsertDicContent);
		for (int i = 0; i < n; i++)
			((_ns1__InsertDicContent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__InsertDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InsertDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InsertDicContent %p -> %p\n", q, p));
	*(_ns1__InsertDicContent*)p = *(_ns1__InsertDicContent*)q;
}

void _ns1__GetAllCategoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllCategoryResponse::GetAllCategoryResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllCategoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDIC_USCORECategory(soap, &this->_ns1__GetAllCategoryResponse::GetAllCategoryResult);
	/* transient soap skipped */
}

int _ns1__GetAllCategoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCategoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCategoryResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAllCategoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCategoryResponse), type))
		return soap->error;
	if (a->GetAllCategoryResult)
		soap_element_result(soap, "ns1:GetAllCategoryResult");
	if (soap_out_PointerTons1__ArrayOfDIC_USCORECategory(soap, "ns1:GetAllCategoryResult", -1, &(a->_ns1__GetAllCategoryResponse::GetAllCategoryResult), "ns1:ArrayOfDIC_Category"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCategoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCategoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCategoryResponse * SOAP_FMAC4 soap_in__ns1__GetAllCategoryResponse(struct soap *soap, const char *tag, _ns1__GetAllCategoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCategoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCategoryResponse, sizeof(_ns1__GetAllCategoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCategoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCategoryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAllCategoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAllCategoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDIC_USCORECategory(soap, "ns1:GetAllCategoryResult", &(a->_ns1__GetAllCategoryResponse::GetAllCategoryResult), "ns1:ArrayOfDIC_Category"))
				{	soap_flag_GetAllCategoryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAllCategoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCategoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCategoryResponse, 0, sizeof(_ns1__GetAllCategoryResponse), 0, soap_copy__ns1__GetAllCategoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCategoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCategoryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCategoryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCategoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCategoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCategoryResponse * SOAP_FMAC4 soap_get__ns1__GetAllCategoryResponse(struct soap *soap, _ns1__GetAllCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCategoryResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllCategoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCategoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCategoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCategoryResponse);
		if (size)
			*size = sizeof(_ns1__GetAllCategoryResponse);
		((_ns1__GetAllCategoryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCategoryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAllCategoryResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetAllCategoryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAllCategoryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCategoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCategoryResponse %p -> %p\n", q, p));
	*(_ns1__GetAllCategoryResponse*)p = *(_ns1__GetAllCategoryResponse*)q;
}

void _ns1__GetAllCategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAllCategory::sessionId);
	/* transient soap skipped */
}

void _ns1__GetAllCategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAllCategory::sessionId);
	/* transient soap skipped */
}

int _ns1__GetAllCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCategory(struct soap *soap, const char *tag, int id, const _ns1__GetAllCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCategory), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetAllCategory::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCategory(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCategory * SOAP_FMAC4 soap_in__ns1__GetAllCategory(struct soap *soap, const char *tag, _ns1__GetAllCategory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCategory, sizeof(_ns1__GetAllCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCategory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetAllCategory::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCategory, 0, sizeof(_ns1__GetAllCategory), 0, soap_copy__ns1__GetAllCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCategory);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCategory", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCategory(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCategory * SOAP_FMAC4 soap_get__ns1__GetAllCategory(struct soap *soap, _ns1__GetAllCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCategory * SOAP_FMAC2 soap_instantiate__ns1__GetAllCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCategory);
		if (size)
			*size = sizeof(_ns1__GetAllCategory);
		((_ns1__GetAllCategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAllCategory);
		for (int i = 0; i < n; i++)
			((_ns1__GetAllCategory*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAllCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCategory %p -> %p\n", q, p));
	*(_ns1__GetAllCategory*)p = *(_ns1__GetAllCategory*)q;
}

void _ns1__GetDicContentByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDicContentByConditionResponse::GetDicContentByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDicContentByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDIC_USCOREContent(soap, &this->_ns1__GetDicContentByConditionResponse::GetDicContentByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetDicContentByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDicContentByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDicContentByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDicContentByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDicContentByConditionResponse), type))
		return soap->error;
	if (a->GetDicContentByConditionResult)
		soap_element_result(soap, "ns1:GetDicContentByConditionResult");
	if (soap_out_PointerTons1__ArrayOfDIC_USCOREContent(soap, "ns1:GetDicContentByConditionResult", -1, &(a->_ns1__GetDicContentByConditionResponse::GetDicContentByConditionResult), "ns1:ArrayOfDIC_Content"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDicContentByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDicContentByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDicContentByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetDicContentByConditionResponse(struct soap *soap, const char *tag, _ns1__GetDicContentByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDicContentByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDicContentByConditionResponse, sizeof(_ns1__GetDicContentByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDicContentByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDicContentByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetDicContentByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDicContentByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDIC_USCOREContent(soap, "ns1:GetDicContentByConditionResult", &(a->_ns1__GetDicContentByConditionResponse::GetDicContentByConditionResult), "ns1:ArrayOfDIC_Content"))
				{	soap_flag_GetDicContentByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetDicContentByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDicContentByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDicContentByConditionResponse, 0, sizeof(_ns1__GetDicContentByConditionResponse), 0, soap_copy__ns1__GetDicContentByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDicContentByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDicContentByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetDicContentByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDicContentByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDicContentByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDicContentByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetDicContentByConditionResponse(struct soap *soap, _ns1__GetDicContentByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDicContentByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDicContentByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDicContentByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDicContentByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDicContentByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDicContentByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetDicContentByConditionResponse);
		((_ns1__GetDicContentByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDicContentByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDicContentByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetDicContentByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDicContentByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDicContentByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDicContentByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetDicContentByConditionResponse*)p = *(_ns1__GetDicContentByConditionResponse*)q;
}

void _ns1__GetDicContentByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDicContentByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetDicContentByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetDicContentByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetDicContentByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetDicContentByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetDicContentByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDicContentByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDicContentByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetDicContentByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDicContentByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetDicContentByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetDicContentByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDicContentByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDicContentByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDicContentByCondition * SOAP_FMAC4 soap_in__ns1__GetDicContentByCondition(struct soap *soap, const char *tag, _ns1__GetDicContentByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDicContentByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDicContentByCondition, sizeof(_ns1__GetDicContentByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDicContentByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDicContentByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetDicContentByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetDicContentByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDicContentByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDicContentByCondition, 0, sizeof(_ns1__GetDicContentByCondition), 0, soap_copy__ns1__GetDicContentByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDicContentByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDicContentByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetDicContentByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDicContentByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDicContentByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDicContentByCondition * SOAP_FMAC4 soap_get__ns1__GetDicContentByCondition(struct soap *soap, _ns1__GetDicContentByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDicContentByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDicContentByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetDicContentByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDicContentByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDicContentByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDicContentByCondition);
		if (size)
			*size = sizeof(_ns1__GetDicContentByCondition);
		((_ns1__GetDicContentByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDicContentByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDicContentByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetDicContentByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDicContentByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDicContentByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDicContentByCondition %p -> %p\n", q, p));
	*(_ns1__GetDicContentByCondition*)p = *(_ns1__GetDicContentByCondition*)q;
}

void _ns1__GetAcountPaymentRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAcountPaymentRecordResponse::GetAcountPaymentRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAcountPaymentRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfAcountPaymentItem(soap, &this->_ns1__GetAcountPaymentRecordResponse::GetAcountPaymentRecordResult);
	/* transient soap skipped */
}

int _ns1__GetAcountPaymentRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAcountPaymentRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAcountPaymentRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAcountPaymentRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse), type))
		return soap->error;
	if (a->GetAcountPaymentRecordResult)
		soap_element_result(soap, "ns1:GetAcountPaymentRecordResult");
	if (soap_out_PointerTons1__ArrayOfAcountPaymentItem(soap, "ns1:GetAcountPaymentRecordResult", -1, &(a->_ns1__GetAcountPaymentRecordResponse::GetAcountPaymentRecordResult), "ns1:ArrayOfAcountPaymentItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAcountPaymentRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAcountPaymentRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecordResponse * SOAP_FMAC4 soap_in__ns1__GetAcountPaymentRecordResponse(struct soap *soap, const char *tag, _ns1__GetAcountPaymentRecordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAcountPaymentRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse, sizeof(_ns1__GetAcountPaymentRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAcountPaymentRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAcountPaymentRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAcountPaymentRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAcountPaymentRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAcountPaymentItem(soap, "ns1:GetAcountPaymentRecordResult", &(a->_ns1__GetAcountPaymentRecordResponse::GetAcountPaymentRecordResult), "ns1:ArrayOfAcountPaymentItem"))
				{	soap_flag_GetAcountPaymentRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAcountPaymentRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAcountPaymentRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse, 0, sizeof(_ns1__GetAcountPaymentRecordResponse), 0, soap_copy__ns1__GetAcountPaymentRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAcountPaymentRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAcountPaymentRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAcountPaymentRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAcountPaymentRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecordResponse * SOAP_FMAC4 soap_get__ns1__GetAcountPaymentRecordResponse(struct soap *soap, _ns1__GetAcountPaymentRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAcountPaymentRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAcountPaymentRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAcountPaymentRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAcountPaymentRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAcountPaymentRecordResponse);
		if (size)
			*size = sizeof(_ns1__GetAcountPaymentRecordResponse);
		((_ns1__GetAcountPaymentRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAcountPaymentRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAcountPaymentRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetAcountPaymentRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAcountPaymentRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAcountPaymentRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAcountPaymentRecordResponse %p -> %p\n", q, p));
	*(_ns1__GetAcountPaymentRecordResponse*)p = *(_ns1__GetAcountPaymentRecordResponse*)q;
}

void _ns1__GetAcountPaymentRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetAcountPaymentRecord::top);
	soap_default_string(soap, &this->_ns1__GetAcountPaymentRecord::condition);
	soap_default_string(soap, &this->_ns1__GetAcountPaymentRecord::sessionId);
	/* transient soap skipped */
}

void _ns1__GetAcountPaymentRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAcountPaymentRecord::condition);
	soap_serialize_string(soap, &this->_ns1__GetAcountPaymentRecord::sessionId);
	/* transient soap skipped */
}

int _ns1__GetAcountPaymentRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAcountPaymentRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAcountPaymentRecord(struct soap *soap, const char *tag, int id, const _ns1__GetAcountPaymentRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAcountPaymentRecord), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetAcountPaymentRecord::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetAcountPaymentRecord::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetAcountPaymentRecord::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAcountPaymentRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAcountPaymentRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecord * SOAP_FMAC4 soap_in__ns1__GetAcountPaymentRecord(struct soap *soap, const char *tag, _ns1__GetAcountPaymentRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAcountPaymentRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAcountPaymentRecord, sizeof(_ns1__GetAcountPaymentRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAcountPaymentRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAcountPaymentRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetAcountPaymentRecord::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetAcountPaymentRecord::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetAcountPaymentRecord::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAcountPaymentRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAcountPaymentRecord, 0, sizeof(_ns1__GetAcountPaymentRecord), 0, soap_copy__ns1__GetAcountPaymentRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetAcountPaymentRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAcountPaymentRecord);
	if (this->soap_out(soap, tag?tag:"ns1:GetAcountPaymentRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAcountPaymentRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAcountPaymentRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecord * SOAP_FMAC4 soap_get__ns1__GetAcountPaymentRecord(struct soap *soap, _ns1__GetAcountPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAcountPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAcountPaymentRecord * SOAP_FMAC2 soap_instantiate__ns1__GetAcountPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAcountPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAcountPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAcountPaymentRecord);
		if (size)
			*size = sizeof(_ns1__GetAcountPaymentRecord);
		((_ns1__GetAcountPaymentRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAcountPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetAcountPaymentRecord);
		for (int i = 0; i < n; i++)
			((_ns1__GetAcountPaymentRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetAcountPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAcountPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAcountPaymentRecord %p -> %p\n", q, p));
	*(_ns1__GetAcountPaymentRecord*)p = *(_ns1__GetAcountPaymentRecord*)q;
}

void _ns1__GetReturnRecordDealResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetReturnRecordDealResponse::GetReturnRecordDealResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetReturnRecordDealResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfReturnedItem(soap, &this->_ns1__GetReturnRecordDealResponse::GetReturnRecordDealResult);
	/* transient soap skipped */
}

int _ns1__GetReturnRecordDealResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnRecordDealResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnRecordDealResponse(struct soap *soap, const char *tag, int id, const _ns1__GetReturnRecordDealResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnRecordDealResponse), type))
		return soap->error;
	if (a->GetReturnRecordDealResult)
		soap_element_result(soap, "ns1:GetReturnRecordDealResult");
	if (soap_out_PointerTons1__ArrayOfReturnedItem(soap, "ns1:GetReturnRecordDealResult", -1, &(a->_ns1__GetReturnRecordDealResponse::GetReturnRecordDealResult), "ns1:ArrayOfReturnedItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnRecordDealResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnRecordDealResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDealResponse * SOAP_FMAC4 soap_in__ns1__GetReturnRecordDealResponse(struct soap *soap, const char *tag, _ns1__GetReturnRecordDealResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnRecordDealResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnRecordDealResponse, sizeof(_ns1__GetReturnRecordDealResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnRecordDealResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnRecordDealResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetReturnRecordDealResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetReturnRecordDealResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfReturnedItem(soap, "ns1:GetReturnRecordDealResult", &(a->_ns1__GetReturnRecordDealResponse::GetReturnRecordDealResult), "ns1:ArrayOfReturnedItem"))
				{	soap_flag_GetReturnRecordDealResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetReturnRecordDealResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnRecordDealResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnRecordDealResponse, 0, sizeof(_ns1__GetReturnRecordDealResponse), 0, soap_copy__ns1__GetReturnRecordDealResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReturnRecordDealResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnRecordDealResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnRecordDealResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnRecordDealResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnRecordDealResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDealResponse * SOAP_FMAC4 soap_get__ns1__GetReturnRecordDealResponse(struct soap *soap, _ns1__GetReturnRecordDealResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnRecordDealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnRecordDealResponse * SOAP_FMAC2 soap_instantiate__ns1__GetReturnRecordDealResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnRecordDealResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnRecordDealResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordDealResponse);
		if (size)
			*size = sizeof(_ns1__GetReturnRecordDealResponse);
		((_ns1__GetReturnRecordDealResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordDealResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnRecordDealResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnRecordDealResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnRecordDealResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnRecordDealResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnRecordDealResponse %p -> %p\n", q, p));
	*(_ns1__GetReturnRecordDealResponse*)p = *(_ns1__GetReturnRecordDealResponse*)q;
}

void _ns1__GetReturnRecordDeal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetReturnRecordDeal::top);
	soap_default_string(soap, &this->_ns1__GetReturnRecordDeal::condition);
	soap_default_string(soap, &this->_ns1__GetReturnRecordDeal::sessionId);
	/* transient soap skipped */
}

void _ns1__GetReturnRecordDeal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetReturnRecordDeal::condition);
	soap_serialize_string(soap, &this->_ns1__GetReturnRecordDeal::sessionId);
	/* transient soap skipped */
}

int _ns1__GetReturnRecordDeal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnRecordDeal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnRecordDeal(struct soap *soap, const char *tag, int id, const _ns1__GetReturnRecordDeal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnRecordDeal), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetReturnRecordDeal::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetReturnRecordDeal::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetReturnRecordDeal::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnRecordDeal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnRecordDeal(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDeal * SOAP_FMAC4 soap_in__ns1__GetReturnRecordDeal(struct soap *soap, const char *tag, _ns1__GetReturnRecordDeal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnRecordDeal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnRecordDeal, sizeof(_ns1__GetReturnRecordDeal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnRecordDeal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnRecordDeal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetReturnRecordDeal::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetReturnRecordDeal::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetReturnRecordDeal::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnRecordDeal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnRecordDeal, 0, sizeof(_ns1__GetReturnRecordDeal), 0, soap_copy__ns1__GetReturnRecordDeal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetReturnRecordDeal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnRecordDeal);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnRecordDeal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnRecordDeal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnRecordDeal(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDeal * SOAP_FMAC4 soap_get__ns1__GetReturnRecordDeal(struct soap *soap, _ns1__GetReturnRecordDeal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnRecordDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnRecordDeal * SOAP_FMAC2 soap_instantiate__ns1__GetReturnRecordDeal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnRecordDeal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnRecordDeal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordDeal);
		if (size)
			*size = sizeof(_ns1__GetReturnRecordDeal);
		((_ns1__GetReturnRecordDeal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordDeal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnRecordDeal);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnRecordDeal*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnRecordDeal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnRecordDeal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnRecordDeal %p -> %p\n", q, p));
	*(_ns1__GetReturnRecordDeal*)p = *(_ns1__GetReturnRecordDeal*)q;
}

void _ns1__GetReturnRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetReturnRecordResponse::GetReturnRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetReturnRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfReturnedItem(soap, &this->_ns1__GetReturnRecordResponse::GetReturnRecordResult);
	/* transient soap skipped */
}

int _ns1__GetReturnRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetReturnRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnRecordResponse), type))
		return soap->error;
	if (a->GetReturnRecordResult)
		soap_element_result(soap, "ns1:GetReturnRecordResult");
	if (soap_out_PointerTons1__ArrayOfReturnedItem(soap, "ns1:GetReturnRecordResult", -1, &(a->_ns1__GetReturnRecordResponse::GetReturnRecordResult), "ns1:ArrayOfReturnedItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordResponse * SOAP_FMAC4 soap_in__ns1__GetReturnRecordResponse(struct soap *soap, const char *tag, _ns1__GetReturnRecordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnRecordResponse, sizeof(_ns1__GetReturnRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetReturnRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetReturnRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfReturnedItem(soap, "ns1:GetReturnRecordResult", &(a->_ns1__GetReturnRecordResponse::GetReturnRecordResult), "ns1:ArrayOfReturnedItem"))
				{	soap_flag_GetReturnRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetReturnRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnRecordResponse, 0, sizeof(_ns1__GetReturnRecordResponse), 0, soap_copy__ns1__GetReturnRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReturnRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordResponse * SOAP_FMAC4 soap_get__ns1__GetReturnRecordResponse(struct soap *soap, _ns1__GetReturnRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetReturnRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordResponse);
		if (size)
			*size = sizeof(_ns1__GetReturnRecordResponse);
		((_ns1__GetReturnRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnRecordResponse %p -> %p\n", q, p));
	*(_ns1__GetReturnRecordResponse*)p = *(_ns1__GetReturnRecordResponse*)q;
}

void _ns1__GetReturnRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetReturnRecord::top);
	soap_default_string(soap, &this->_ns1__GetReturnRecord::condition);
	soap_default_string(soap, &this->_ns1__GetReturnRecord::sessionId);
	/* transient soap skipped */
}

void _ns1__GetReturnRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetReturnRecord::condition);
	soap_serialize_string(soap, &this->_ns1__GetReturnRecord::sessionId);
	/* transient soap skipped */
}

int _ns1__GetReturnRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnRecord(struct soap *soap, const char *tag, int id, const _ns1__GetReturnRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnRecord), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetReturnRecord::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetReturnRecord::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetReturnRecord::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnRecord * SOAP_FMAC4 soap_in__ns1__GetReturnRecord(struct soap *soap, const char *tag, _ns1__GetReturnRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnRecord, sizeof(_ns1__GetReturnRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetReturnRecord::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetReturnRecord::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetReturnRecord::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnRecord, 0, sizeof(_ns1__GetReturnRecord), 0, soap_copy__ns1__GetReturnRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetReturnRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnRecord);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnRecord * SOAP_FMAC4 soap_get__ns1__GetReturnRecord(struct soap *soap, _ns1__GetReturnRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnRecord * SOAP_FMAC2 soap_instantiate__ns1__GetReturnRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecord);
		if (size)
			*size = sizeof(_ns1__GetReturnRecord);
		((_ns1__GetReturnRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnRecord);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnRecord %p -> %p\n", q, p));
	*(_ns1__GetReturnRecord*)p = *(_ns1__GetReturnRecord*)q;
}

void _ns1__GetUserFunctionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetUserFunctionResponse::GetUserFunctionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetUserFunctionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSystemFunction(soap, &this->_ns1__GetUserFunctionResponse::GetUserFunctionResult);
	/* transient soap skipped */
}

int _ns1__GetUserFunctionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserFunctionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserFunctionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUserFunctionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserFunctionResponse), type))
		return soap->error;
	if (a->GetUserFunctionResult)
		soap_element_result(soap, "ns1:GetUserFunctionResult");
	if (soap_out_PointerTons1__ArrayOfSystemFunction(soap, "ns1:GetUserFunctionResult", -1, &(a->_ns1__GetUserFunctionResponse::GetUserFunctionResult), "ns1:ArrayOfSystemFunction"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserFunctionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserFunctionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserFunctionResponse * SOAP_FMAC4 soap_in__ns1__GetUserFunctionResponse(struct soap *soap, const char *tag, _ns1__GetUserFunctionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserFunctionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserFunctionResponse, sizeof(_ns1__GetUserFunctionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserFunctionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserFunctionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetUserFunctionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUserFunctionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSystemFunction(soap, "ns1:GetUserFunctionResult", &(a->_ns1__GetUserFunctionResponse::GetUserFunctionResult), "ns1:ArrayOfSystemFunction"))
				{	soap_flag_GetUserFunctionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetUserFunctionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserFunctionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserFunctionResponse, 0, sizeof(_ns1__GetUserFunctionResponse), 0, soap_copy__ns1__GetUserFunctionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserFunctionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserFunctionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserFunctionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserFunctionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserFunctionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserFunctionResponse * SOAP_FMAC4 soap_get__ns1__GetUserFunctionResponse(struct soap *soap, _ns1__GetUserFunctionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserFunctionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserFunctionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUserFunctionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserFunctionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserFunctionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserFunctionResponse);
		if (size)
			*size = sizeof(_ns1__GetUserFunctionResponse);
		((_ns1__GetUserFunctionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserFunctionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetUserFunctionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetUserFunctionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetUserFunctionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserFunctionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserFunctionResponse %p -> %p\n", q, p));
	*(_ns1__GetUserFunctionResponse*)p = *(_ns1__GetUserFunctionResponse*)q;
}

void _ns1__GetUserFunction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUserFunction::userId);
	soap_default_string(soap, &this->_ns1__GetUserFunction::sessionId);
	/* transient soap skipped */
}

void _ns1__GetUserFunction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetUserFunction::userId);
	soap_serialize_string(soap, &this->_ns1__GetUserFunction::sessionId);
	/* transient soap skipped */
}

int _ns1__GetUserFunction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserFunction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserFunction(struct soap *soap, const char *tag, int id, const _ns1__GetUserFunction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserFunction), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__GetUserFunction::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetUserFunction::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserFunction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserFunction(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserFunction * SOAP_FMAC4 soap_in__ns1__GetUserFunction(struct soap *soap, const char *tag, _ns1__GetUserFunction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserFunction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserFunction, sizeof(_ns1__GetUserFunction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserFunction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserFunction *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__GetUserFunction::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetUserFunction::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserFunction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserFunction, 0, sizeof(_ns1__GetUserFunction), 0, soap_copy__ns1__GetUserFunction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserFunction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserFunction);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserFunction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserFunction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserFunction(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserFunction * SOAP_FMAC4 soap_get__ns1__GetUserFunction(struct soap *soap, _ns1__GetUserFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserFunction * SOAP_FMAC2 soap_instantiate__ns1__GetUserFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserFunction);
		if (size)
			*size = sizeof(_ns1__GetUserFunction);
		((_ns1__GetUserFunction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserFunction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetUserFunction);
		for (int i = 0; i < n; i++)
			((_ns1__GetUserFunction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetUserFunction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserFunction %p -> %p\n", q, p));
	*(_ns1__GetUserFunction*)p = *(_ns1__GetUserFunction*)q;
}

void _ns1__GetWorkNameListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetWorkNameListResponse::GetWorkNameListResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetWorkNameListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfWorker(soap, &this->_ns1__GetWorkNameListResponse::GetWorkNameListResult);
	/* transient soap skipped */
}

int _ns1__GetWorkNameListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWorkNameListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWorkNameListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetWorkNameListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWorkNameListResponse), type))
		return soap->error;
	if (a->GetWorkNameListResult)
		soap_element_result(soap, "ns1:GetWorkNameListResult");
	if (soap_out_PointerTons1__ArrayOfWorker(soap, "ns1:GetWorkNameListResult", -1, &(a->_ns1__GetWorkNameListResponse::GetWorkNameListResult), "ns1:ArrayOfWorker"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWorkNameListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWorkNameListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWorkNameListResponse * SOAP_FMAC4 soap_in__ns1__GetWorkNameListResponse(struct soap *soap, const char *tag, _ns1__GetWorkNameListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWorkNameListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWorkNameListResponse, sizeof(_ns1__GetWorkNameListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetWorkNameListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetWorkNameListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetWorkNameListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWorkNameListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfWorker(soap, "ns1:GetWorkNameListResult", &(a->_ns1__GetWorkNameListResponse::GetWorkNameListResult), "ns1:ArrayOfWorker"))
				{	soap_flag_GetWorkNameListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetWorkNameListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWorkNameListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWorkNameListResponse, 0, sizeof(_ns1__GetWorkNameListResponse), 0, soap_copy__ns1__GetWorkNameListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetWorkNameListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetWorkNameListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetWorkNameListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWorkNameListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWorkNameListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWorkNameListResponse * SOAP_FMAC4 soap_get__ns1__GetWorkNameListResponse(struct soap *soap, _ns1__GetWorkNameListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWorkNameListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetWorkNameListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWorkNameListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWorkNameListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetWorkNameListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetWorkNameListResponse);
		if (size)
			*size = sizeof(_ns1__GetWorkNameListResponse);
		((_ns1__GetWorkNameListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetWorkNameListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetWorkNameListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetWorkNameListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetWorkNameListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetWorkNameListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetWorkNameListResponse %p -> %p\n", q, p));
	*(_ns1__GetWorkNameListResponse*)p = *(_ns1__GetWorkNameListResponse*)q;
}

void _ns1__GetWorkNameList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetWorkNameList::condition);
	/* transient soap skipped */
}

void _ns1__GetWorkNameList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetWorkNameList::condition);
	/* transient soap skipped */
}

int _ns1__GetWorkNameList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWorkNameList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWorkNameList(struct soap *soap, const char *tag, int id, const _ns1__GetWorkNameList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWorkNameList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetWorkNameList::condition), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWorkNameList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWorkNameList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWorkNameList * SOAP_FMAC4 soap_in__ns1__GetWorkNameList(struct soap *soap, const char *tag, _ns1__GetWorkNameList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWorkNameList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWorkNameList, sizeof(_ns1__GetWorkNameList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetWorkNameList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetWorkNameList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetWorkNameList::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWorkNameList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWorkNameList, 0, sizeof(_ns1__GetWorkNameList), 0, soap_copy__ns1__GetWorkNameList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetWorkNameList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetWorkNameList);
	if (this->soap_out(soap, tag?tag:"ns1:GetWorkNameList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWorkNameList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWorkNameList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWorkNameList * SOAP_FMAC4 soap_get__ns1__GetWorkNameList(struct soap *soap, _ns1__GetWorkNameList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWorkNameList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetWorkNameList * SOAP_FMAC2 soap_instantiate__ns1__GetWorkNameList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWorkNameList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetWorkNameList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetWorkNameList);
		if (size)
			*size = sizeof(_ns1__GetWorkNameList);
		((_ns1__GetWorkNameList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetWorkNameList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetWorkNameList);
		for (int i = 0; i < n; i++)
			((_ns1__GetWorkNameList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetWorkNameList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetWorkNameList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetWorkNameList %p -> %p\n", q, p));
	*(_ns1__GetWorkNameList*)p = *(_ns1__GetWorkNameList*)q;
}

void _ns1__CharegeReturnedMoneyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->_ns1__CharegeReturnedMoneyResponse::CharegeReturnedMoneyResult);
	/* transient soap skipped */
}

void _ns1__CharegeReturnedMoneyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__CharegeReturnedMoneyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CharegeReturnedMoneyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CharegeReturnedMoneyResponse(struct soap *soap, const char *tag, int id, const _ns1__CharegeReturnedMoneyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CharegeReturnedMoneyResult");
	if (soap_out_double(soap, "ns1:CharegeReturnedMoneyResult", -1, &(a->_ns1__CharegeReturnedMoneyResponse::CharegeReturnedMoneyResult), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CharegeReturnedMoneyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CharegeReturnedMoneyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoneyResponse * SOAP_FMAC4 soap_in__ns1__CharegeReturnedMoneyResponse(struct soap *soap, const char *tag, _ns1__CharegeReturnedMoneyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CharegeReturnedMoneyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse, sizeof(_ns1__CharegeReturnedMoneyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CharegeReturnedMoneyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CharegeReturnedMoneyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CharegeReturnedMoneyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CharegeReturnedMoneyResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:CharegeReturnedMoneyResult", &(a->_ns1__CharegeReturnedMoneyResponse::CharegeReturnedMoneyResult), "xsd:double"))
				{	soap_flag_CharegeReturnedMoneyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CharegeReturnedMoneyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CharegeReturnedMoneyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse, 0, sizeof(_ns1__CharegeReturnedMoneyResponse), 0, soap_copy__ns1__CharegeReturnedMoneyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CharegeReturnedMoneyResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CharegeReturnedMoneyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:CharegeReturnedMoneyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CharegeReturnedMoneyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CharegeReturnedMoneyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoneyResponse * SOAP_FMAC4 soap_get__ns1__CharegeReturnedMoneyResponse(struct soap *soap, _ns1__CharegeReturnedMoneyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CharegeReturnedMoneyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CharegeReturnedMoneyResponse * SOAP_FMAC2 soap_instantiate__ns1__CharegeReturnedMoneyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CharegeReturnedMoneyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CharegeReturnedMoneyResponse);
		if (size)
			*size = sizeof(_ns1__CharegeReturnedMoneyResponse);
		((_ns1__CharegeReturnedMoneyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CharegeReturnedMoneyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CharegeReturnedMoneyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CharegeReturnedMoneyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CharegeReturnedMoneyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CharegeReturnedMoneyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CharegeReturnedMoneyResponse %p -> %p\n", q, p));
	*(_ns1__CharegeReturnedMoneyResponse*)p = *(_ns1__CharegeReturnedMoneyResponse*)q;
}

void _ns1__CharegeReturnedMoney::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CharegeReturnedMoney::userId);
	soap_default_string(soap, &this->_ns1__CharegeReturnedMoney::clientType);
	soap_default_string(soap, &this->_ns1__CharegeReturnedMoney::clientLevel);
	soap_default_string(soap, &this->_ns1__CharegeReturnedMoney::sessionId);
	/* transient soap skipped */
}

void _ns1__CharegeReturnedMoney::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__CharegeReturnedMoney::userId);
	soap_serialize_string(soap, &this->_ns1__CharegeReturnedMoney::clientType);
	soap_serialize_string(soap, &this->_ns1__CharegeReturnedMoney::clientLevel);
	soap_serialize_string(soap, &this->_ns1__CharegeReturnedMoney::sessionId);
	/* transient soap skipped */
}

int _ns1__CharegeReturnedMoney::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CharegeReturnedMoney(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CharegeReturnedMoney(struct soap *soap, const char *tag, int id, const _ns1__CharegeReturnedMoney *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CharegeReturnedMoney), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__CharegeReturnedMoney::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__CharegeReturnedMoney::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientLevel", -1, &(a->_ns1__CharegeReturnedMoney::clientLevel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__CharegeReturnedMoney::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CharegeReturnedMoney::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CharegeReturnedMoney(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoney * SOAP_FMAC4 soap_in__ns1__CharegeReturnedMoney(struct soap *soap, const char *tag, _ns1__CharegeReturnedMoney *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CharegeReturnedMoney *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CharegeReturnedMoney, sizeof(_ns1__CharegeReturnedMoney), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CharegeReturnedMoney)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CharegeReturnedMoney *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_clientLevel1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__CharegeReturnedMoney::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__CharegeReturnedMoney::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_clientLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientLevel", &(a->_ns1__CharegeReturnedMoney::clientLevel), "xsd:string"))
				{	soap_flag_clientLevel1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__CharegeReturnedMoney::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CharegeReturnedMoney *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CharegeReturnedMoney, 0, sizeof(_ns1__CharegeReturnedMoney), 0, soap_copy__ns1__CharegeReturnedMoney);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__CharegeReturnedMoney::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CharegeReturnedMoney);
	if (this->soap_out(soap, tag?tag:"ns1:CharegeReturnedMoney", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CharegeReturnedMoney::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CharegeReturnedMoney(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoney * SOAP_FMAC4 soap_get__ns1__CharegeReturnedMoney(struct soap *soap, _ns1__CharegeReturnedMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CharegeReturnedMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CharegeReturnedMoney * SOAP_FMAC2 soap_instantiate__ns1__CharegeReturnedMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CharegeReturnedMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CharegeReturnedMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CharegeReturnedMoney);
		if (size)
			*size = sizeof(_ns1__CharegeReturnedMoney);
		((_ns1__CharegeReturnedMoney*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CharegeReturnedMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CharegeReturnedMoney);
		for (int i = 0; i < n; i++)
			((_ns1__CharegeReturnedMoney*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CharegeReturnedMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CharegeReturnedMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CharegeReturnedMoney %p -> %p\n", q, p));
	*(_ns1__CharegeReturnedMoney*)p = *(_ns1__CharegeReturnedMoney*)q;
}

void _ns1__GetReturnInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetReturnInfoResponse::GetReturnInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetReturnInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReturnInfo(soap, &this->_ns1__GetReturnInfoResponse::GetReturnInfoResult);
	/* transient soap skipped */
}

int _ns1__GetReturnInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetReturnInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnInfoResponse), type))
		return soap->error;
	if (a->GetReturnInfoResult)
		soap_element_result(soap, "ns1:GetReturnInfoResult");
	if (soap_out_PointerTons1__ReturnInfo(soap, "ns1:GetReturnInfoResult", -1, &(a->_ns1__GetReturnInfoResponse::GetReturnInfoResult), "ns1:ReturnInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnInfoResponse * SOAP_FMAC4 soap_in__ns1__GetReturnInfoResponse(struct soap *soap, const char *tag, _ns1__GetReturnInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnInfoResponse, sizeof(_ns1__GetReturnInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetReturnInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetReturnInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnInfo(soap, "ns1:GetReturnInfoResult", &(a->_ns1__GetReturnInfoResponse::GetReturnInfoResult), "ns1:ReturnInfo"))
				{	soap_flag_GetReturnInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetReturnInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnInfoResponse, 0, sizeof(_ns1__GetReturnInfoResponse), 0, soap_copy__ns1__GetReturnInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReturnInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnInfoResponse * SOAP_FMAC4 soap_get__ns1__GetReturnInfoResponse(struct soap *soap, _ns1__GetReturnInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetReturnInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetReturnInfoResponse);
		((_ns1__GetReturnInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetReturnInfoResponse*)p = *(_ns1__GetReturnInfoResponse*)q;
}

void _ns1__GetReturnInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetReturnInfo::userId);
	soap_default_string(soap, &this->_ns1__GetReturnInfo::clientLevel);
	soap_default_string(soap, &this->_ns1__GetReturnInfo::sessionId);
	/* transient soap skipped */
}

void _ns1__GetReturnInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetReturnInfo::userId);
	soap_serialize_string(soap, &this->_ns1__GetReturnInfo::clientLevel);
	soap_serialize_string(soap, &this->_ns1__GetReturnInfo::sessionId);
	/* transient soap skipped */
}

int _ns1__GetReturnInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReturnInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReturnInfo(struct soap *soap, const char *tag, int id, const _ns1__GetReturnInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReturnInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__GetReturnInfo::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientLevel", -1, &(a->_ns1__GetReturnInfo::clientLevel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetReturnInfo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReturnInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReturnInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReturnInfo * SOAP_FMAC4 soap_in__ns1__GetReturnInfo(struct soap *soap, const char *tag, _ns1__GetReturnInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReturnInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReturnInfo, sizeof(_ns1__GetReturnInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReturnInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReturnInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_clientLevel1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__GetReturnInfo::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_clientLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientLevel", &(a->_ns1__GetReturnInfo::clientLevel), "xsd:string"))
				{	soap_flag_clientLevel1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetReturnInfo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReturnInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReturnInfo, 0, sizeof(_ns1__GetReturnInfo), 0, soap_copy__ns1__GetReturnInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReturnInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetReturnInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetReturnInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReturnInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReturnInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReturnInfo * SOAP_FMAC4 soap_get__ns1__GetReturnInfo(struct soap *soap, _ns1__GetReturnInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReturnInfo * SOAP_FMAC2 soap_instantiate__ns1__GetReturnInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReturnInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReturnInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnInfo);
		if (size)
			*size = sizeof(_ns1__GetReturnInfo);
		((_ns1__GetReturnInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetReturnInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetReturnInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetReturnInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetReturnInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReturnInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReturnInfo %p -> %p\n", q, p));
	*(_ns1__GetReturnInfo*)p = *(_ns1__GetReturnInfo*)q;
}

void _ns1__AddAcountPaymentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddAcountPaymentResponse::AddAcountPaymentResult);
	/* transient soap skipped */
}

void _ns1__AddAcountPaymentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddAcountPaymentResponse::AddAcountPaymentResult);
	/* transient soap skipped */
}

int _ns1__AddAcountPaymentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddAcountPaymentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddAcountPaymentResponse(struct soap *soap, const char *tag, int id, const _ns1__AddAcountPaymentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddAcountPaymentResponse), type))
		return soap->error;
	if (a->AddAcountPaymentResult)
		soap_element_result(soap, "ns1:AddAcountPaymentResult");
	if (soap_out_string(soap, "ns1:AddAcountPaymentResult", -1, &(a->_ns1__AddAcountPaymentResponse::AddAcountPaymentResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddAcountPaymentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddAcountPaymentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddAcountPaymentResponse * SOAP_FMAC4 soap_in__ns1__AddAcountPaymentResponse(struct soap *soap, const char *tag, _ns1__AddAcountPaymentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddAcountPaymentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddAcountPaymentResponse, sizeof(_ns1__AddAcountPaymentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddAcountPaymentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddAcountPaymentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddAcountPaymentResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddAcountPaymentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddAcountPaymentResult", &(a->_ns1__AddAcountPaymentResponse::AddAcountPaymentResult), "xsd:string"))
				{	soap_flag_AddAcountPaymentResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddAcountPaymentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddAcountPaymentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddAcountPaymentResponse, 0, sizeof(_ns1__AddAcountPaymentResponse), 0, soap_copy__ns1__AddAcountPaymentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddAcountPaymentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddAcountPaymentResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddAcountPaymentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddAcountPaymentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddAcountPaymentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddAcountPaymentResponse * SOAP_FMAC4 soap_get__ns1__AddAcountPaymentResponse(struct soap *soap, _ns1__AddAcountPaymentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddAcountPaymentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddAcountPaymentResponse * SOAP_FMAC2 soap_instantiate__ns1__AddAcountPaymentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddAcountPaymentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddAcountPaymentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddAcountPaymentResponse);
		if (size)
			*size = sizeof(_ns1__AddAcountPaymentResponse);
		((_ns1__AddAcountPaymentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddAcountPaymentResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddAcountPaymentResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddAcountPaymentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddAcountPaymentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddAcountPaymentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddAcountPaymentResponse %p -> %p\n", q, p));
	*(_ns1__AddAcountPaymentResponse*)p = *(_ns1__AddAcountPaymentResponse*)q;
}

void _ns1__AddAcountPayment::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddAcountPayment::username);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::userId);
	soap_default_float(soap, &this->_ns1__AddAcountPayment::money);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::payType);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::bankName);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::subBankName);
	soap_default_LONG64(soap, &this->_ns1__AddAcountPayment::payTime);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::content);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::clientType);
	soap_default_string(soap, &this->_ns1__AddAcountPayment::sessionId);
	/* transient soap skipped */
}

void _ns1__AddAcountPayment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::username);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::userId);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::payType);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::bankName);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::subBankName);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::content);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::clientType);
	soap_serialize_string(soap, &this->_ns1__AddAcountPayment::sessionId);
	/* transient soap skipped */
}

int _ns1__AddAcountPayment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddAcountPayment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddAcountPayment(struct soap *soap, const char *tag, int id, const _ns1__AddAcountPayment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddAcountPayment), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, &(a->_ns1__AddAcountPayment::username), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__AddAcountPayment::userId), "xsd:string"))
		return soap->error;
	if (soap_out_float(soap, "ns1:money", -1, &(a->_ns1__AddAcountPayment::money), "xsd:float"))
		return soap->error;
	if (soap_out_string(soap, "ns1:payType", -1, &(a->_ns1__AddAcountPayment::payType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:bankName", -1, &(a->_ns1__AddAcountPayment::bankName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:subBankName", -1, &(a->_ns1__AddAcountPayment::subBankName), "xsd:string"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:payTime", -1, &(a->_ns1__AddAcountPayment::payTime), "xsd:long"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__AddAcountPayment::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__AddAcountPayment::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AddAcountPayment::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddAcountPayment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddAcountPayment(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddAcountPayment * SOAP_FMAC4 soap_in__ns1__AddAcountPayment(struct soap *soap, const char *tag, _ns1__AddAcountPayment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddAcountPayment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddAcountPayment, sizeof(_ns1__AddAcountPayment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddAcountPayment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddAcountPayment *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_username1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_payType1 = 1;
	size_t soap_flag_bankName1 = 1;
	size_t soap_flag_subBankName1 = 1;
	size_t soap_flag_payTime1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__AddAcountPayment::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__AddAcountPayment::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns1:money", &(a->_ns1__AddAcountPayment::money), "xsd:float"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_payType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:payType", &(a->_ns1__AddAcountPayment::payType), "xsd:string"))
				{	soap_flag_payType1--;
					continue;
				}
			if (soap_flag_bankName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:bankName", &(a->_ns1__AddAcountPayment::bankName), "xsd:string"))
				{	soap_flag_bankName1--;
					continue;
				}
			if (soap_flag_subBankName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:subBankName", &(a->_ns1__AddAcountPayment::subBankName), "xsd:string"))
				{	soap_flag_subBankName1--;
					continue;
				}
			if (soap_flag_payTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:payTime", &(a->_ns1__AddAcountPayment::payTime), "xsd:long"))
				{	soap_flag_payTime1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__AddAcountPayment::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__AddAcountPayment::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AddAcountPayment::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddAcountPayment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddAcountPayment, 0, sizeof(_ns1__AddAcountPayment), 0, soap_copy__ns1__AddAcountPayment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_money1 > 0 || soap_flag_payTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AddAcountPayment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddAcountPayment);
	if (this->soap_out(soap, tag?tag:"ns1:AddAcountPayment", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddAcountPayment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddAcountPayment(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddAcountPayment * SOAP_FMAC4 soap_get__ns1__AddAcountPayment(struct soap *soap, _ns1__AddAcountPayment *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddAcountPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddAcountPayment * SOAP_FMAC2 soap_instantiate__ns1__AddAcountPayment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddAcountPayment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddAcountPayment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddAcountPayment);
		if (size)
			*size = sizeof(_ns1__AddAcountPayment);
		((_ns1__AddAcountPayment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddAcountPayment[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddAcountPayment);
		for (int i = 0; i < n; i++)
			((_ns1__AddAcountPayment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddAcountPayment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddAcountPayment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddAcountPayment %p -> %p\n", q, p));
	*(_ns1__AddAcountPayment*)p = *(_ns1__AddAcountPayment*)q;
}

void _ns1__AlterUserInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterUserInfoResponse::AlterUserInfoResult);
	/* transient soap skipped */
}

void _ns1__AlterUserInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AlterUserInfoResponse::AlterUserInfoResult);
	/* transient soap skipped */
}

int _ns1__AlterUserInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterUserInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterUserInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__AlterUserInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterUserInfoResponse), type))
		return soap->error;
	if (a->AlterUserInfoResult)
		soap_element_result(soap, "ns1:AlterUserInfoResult");
	if (soap_out_string(soap, "ns1:AlterUserInfoResult", -1, &(a->_ns1__AlterUserInfoResponse::AlterUserInfoResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterUserInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterUserInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterUserInfoResponse * SOAP_FMAC4 soap_in__ns1__AlterUserInfoResponse(struct soap *soap, const char *tag, _ns1__AlterUserInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterUserInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterUserInfoResponse, sizeof(_ns1__AlterUserInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AlterUserInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AlterUserInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AlterUserInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlterUserInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AlterUserInfoResult", &(a->_ns1__AlterUserInfoResponse::AlterUserInfoResult), "xsd:string"))
				{	soap_flag_AlterUserInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AlterUserInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterUserInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterUserInfoResponse, 0, sizeof(_ns1__AlterUserInfoResponse), 0, soap_copy__ns1__AlterUserInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AlterUserInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AlterUserInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AlterUserInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterUserInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterUserInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterUserInfoResponse * SOAP_FMAC4 soap_get__ns1__AlterUserInfoResponse(struct soap *soap, _ns1__AlterUserInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AlterUserInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__AlterUserInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterUserInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AlterUserInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterUserInfoResponse);
		if (size)
			*size = sizeof(_ns1__AlterUserInfoResponse);
		((_ns1__AlterUserInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterUserInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AlterUserInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AlterUserInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AlterUserInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AlterUserInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AlterUserInfoResponse %p -> %p\n", q, p));
	*(_ns1__AlterUserInfoResponse*)p = *(_ns1__AlterUserInfoResponse*)q;
}

void _ns1__AlterUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterUserInfo::user_USCOREid);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::adrTel);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::address);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::shopName);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::mobilePhone);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::realName);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::identifyNo);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::workerName);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::moneyTail);
	soap_default_string(soap, &this->_ns1__AlterUserInfo::sessionId);
	/* transient soap skipped */
}

void _ns1__AlterUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::user_USCOREid);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::adrTel);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::address);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::shopName);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::mobilePhone);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::realName);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::identifyNo);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::workerName);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::moneyTail);
	soap_serialize_string(soap, &this->_ns1__AlterUserInfo::sessionId);
	/* transient soap skipped */
}

int _ns1__AlterUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterUserInfo(struct soap *soap, const char *tag, int id, const _ns1__AlterUserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterUserInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:user_id", -1, &(a->_ns1__AlterUserInfo::user_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:adrTel", -1, &(a->_ns1__AlterUserInfo::adrTel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:address", -1, &(a->_ns1__AlterUserInfo::address), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:shopName", -1, &(a->_ns1__AlterUserInfo::shopName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:mobilePhone", -1, &(a->_ns1__AlterUserInfo::mobilePhone), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:realName", -1, &(a->_ns1__AlterUserInfo::realName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:identifyNo", -1, &(a->_ns1__AlterUserInfo::identifyNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerName", -1, &(a->_ns1__AlterUserInfo::workerName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:moneyTail", -1, &(a->_ns1__AlterUserInfo::moneyTail), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AlterUserInfo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterUserInfo * SOAP_FMAC4 soap_in__ns1__AlterUserInfo(struct soap *soap, const char *tag, _ns1__AlterUserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterUserInfo, sizeof(_ns1__AlterUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AlterUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AlterUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_user_USCOREid1 = 1;
	size_t soap_flag_adrTel1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_shopName1 = 1;
	size_t soap_flag_mobilePhone1 = 1;
	size_t soap_flag_realName1 = 1;
	size_t soap_flag_identifyNo1 = 1;
	size_t soap_flag_workerName1 = 1;
	size_t soap_flag_moneyTail1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:user_id", &(a->_ns1__AlterUserInfo::user_USCOREid), "xsd:string"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			if (soap_flag_adrTel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:adrTel", &(a->_ns1__AlterUserInfo::adrTel), "xsd:string"))
				{	soap_flag_adrTel1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:address", &(a->_ns1__AlterUserInfo::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_shopName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:shopName", &(a->_ns1__AlterUserInfo::shopName), "xsd:string"))
				{	soap_flag_shopName1--;
					continue;
				}
			if (soap_flag_mobilePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mobilePhone", &(a->_ns1__AlterUserInfo::mobilePhone), "xsd:string"))
				{	soap_flag_mobilePhone1--;
					continue;
				}
			if (soap_flag_realName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:realName", &(a->_ns1__AlterUserInfo::realName), "xsd:string"))
				{	soap_flag_realName1--;
					continue;
				}
			if (soap_flag_identifyNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:identifyNo", &(a->_ns1__AlterUserInfo::identifyNo), "xsd:string"))
				{	soap_flag_identifyNo1--;
					continue;
				}
			if (soap_flag_workerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerName", &(a->_ns1__AlterUserInfo::workerName), "xsd:string"))
				{	soap_flag_workerName1--;
					continue;
				}
			if (soap_flag_moneyTail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moneyTail", &(a->_ns1__AlterUserInfo::moneyTail), "xsd:string"))
				{	soap_flag_moneyTail1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AlterUserInfo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterUserInfo, 0, sizeof(_ns1__AlterUserInfo), 0, soap_copy__ns1__AlterUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AlterUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AlterUserInfo);
	if (this->soap_out(soap, tag?tag:"ns1:AlterUserInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterUserInfo * SOAP_FMAC4 soap_get__ns1__AlterUserInfo(struct soap *soap, _ns1__AlterUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AlterUserInfo * SOAP_FMAC2 soap_instantiate__ns1__AlterUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AlterUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterUserInfo);
		if (size)
			*size = sizeof(_ns1__AlterUserInfo);
		((_ns1__AlterUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AlterUserInfo);
		for (int i = 0; i < n; i++)
			((_ns1__AlterUserInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AlterUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AlterUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AlterUserInfo %p -> %p\n", q, p));
	*(_ns1__AlterUserInfo*)p = *(_ns1__AlterUserInfo*)q;
}

void _ns1__AlterPswResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterPswResponse::AlterPswResult);
	/* transient soap skipped */
}

void _ns1__AlterPswResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AlterPswResponse::AlterPswResult);
	/* transient soap skipped */
}

int _ns1__AlterPswResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterPswResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterPswResponse(struct soap *soap, const char *tag, int id, const _ns1__AlterPswResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterPswResponse), type))
		return soap->error;
	if (a->AlterPswResult)
		soap_element_result(soap, "ns1:AlterPswResult");
	if (soap_out_string(soap, "ns1:AlterPswResult", -1, &(a->_ns1__AlterPswResponse::AlterPswResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterPswResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterPswResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterPswResponse * SOAP_FMAC4 soap_in__ns1__AlterPswResponse(struct soap *soap, const char *tag, _ns1__AlterPswResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterPswResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterPswResponse, sizeof(_ns1__AlterPswResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AlterPswResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AlterPswResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AlterPswResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlterPswResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AlterPswResult", &(a->_ns1__AlterPswResponse::AlterPswResult), "xsd:string"))
				{	soap_flag_AlterPswResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AlterPswResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterPswResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterPswResponse, 0, sizeof(_ns1__AlterPswResponse), 0, soap_copy__ns1__AlterPswResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AlterPswResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AlterPswResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AlterPswResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterPswResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterPswResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterPswResponse * SOAP_FMAC4 soap_get__ns1__AlterPswResponse(struct soap *soap, _ns1__AlterPswResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterPswResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AlterPswResponse * SOAP_FMAC2 soap_instantiate__ns1__AlterPswResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterPswResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AlterPswResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterPswResponse);
		if (size)
			*size = sizeof(_ns1__AlterPswResponse);
		((_ns1__AlterPswResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterPswResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AlterPswResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AlterPswResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AlterPswResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AlterPswResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AlterPswResponse %p -> %p\n", q, p));
	*(_ns1__AlterPswResponse*)p = *(_ns1__AlterPswResponse*)q;
}

void _ns1__AlterPsw::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterPsw::user_USCOREid);
	soap_default_string(soap, &this->_ns1__AlterPsw::newPsw);
	soap_default_string(soap, &this->_ns1__AlterPsw::sessionId);
	/* transient soap skipped */
}

void _ns1__AlterPsw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AlterPsw::user_USCOREid);
	soap_serialize_string(soap, &this->_ns1__AlterPsw::newPsw);
	soap_serialize_string(soap, &this->_ns1__AlterPsw::sessionId);
	/* transient soap skipped */
}

int _ns1__AlterPsw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterPsw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterPsw(struct soap *soap, const char *tag, int id, const _ns1__AlterPsw *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterPsw), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:user_id", -1, &(a->_ns1__AlterPsw::user_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:newPsw", -1, &(a->_ns1__AlterPsw::newPsw), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__AlterPsw::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterPsw::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterPsw(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterPsw * SOAP_FMAC4 soap_in__ns1__AlterPsw(struct soap *soap, const char *tag, _ns1__AlterPsw *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterPsw *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterPsw, sizeof(_ns1__AlterPsw), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AlterPsw)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AlterPsw *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_user_USCOREid1 = 1;
	size_t soap_flag_newPsw1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:user_id", &(a->_ns1__AlterPsw::user_USCOREid), "xsd:string"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			if (soap_flag_newPsw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:newPsw", &(a->_ns1__AlterPsw::newPsw), "xsd:string"))
				{	soap_flag_newPsw1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__AlterPsw::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterPsw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterPsw, 0, sizeof(_ns1__AlterPsw), 0, soap_copy__ns1__AlterPsw);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AlterPsw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AlterPsw);
	if (this->soap_out(soap, tag?tag:"ns1:AlterPsw", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterPsw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterPsw(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterPsw * SOAP_FMAC4 soap_get__ns1__AlterPsw(struct soap *soap, _ns1__AlterPsw *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterPsw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AlterPsw * SOAP_FMAC2 soap_instantiate__ns1__AlterPsw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterPsw(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AlterPsw, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterPsw);
		if (size)
			*size = sizeof(_ns1__AlterPsw);
		((_ns1__AlterPsw*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AlterPsw[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AlterPsw);
		for (int i = 0; i < n; i++)
			((_ns1__AlterPsw*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AlterPsw*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AlterPsw(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AlterPsw %p -> %p\n", q, p));
	*(_ns1__AlterPsw*)p = *(_ns1__AlterPsw*)q;
}

void _ns1__RegisterUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RegisterUserResponse::RegisterUserResult);
	/* transient soap skipped */
}

void _ns1__RegisterUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RegisterUserResponse::RegisterUserResult);
	/* transient soap skipped */
}

int _ns1__RegisterUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RegisterUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RegisterUserResponse(struct soap *soap, const char *tag, int id, const _ns1__RegisterUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RegisterUserResponse), type))
		return soap->error;
	if (a->RegisterUserResult)
		soap_element_result(soap, "ns1:RegisterUserResult");
	if (soap_out_string(soap, "ns1:RegisterUserResult", -1, &(a->_ns1__RegisterUserResponse::RegisterUserResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RegisterUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RegisterUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RegisterUserResponse * SOAP_FMAC4 soap_in__ns1__RegisterUserResponse(struct soap *soap, const char *tag, _ns1__RegisterUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RegisterUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RegisterUserResponse, sizeof(_ns1__RegisterUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RegisterUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RegisterUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RegisterUserResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RegisterUserResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:RegisterUserResult", &(a->_ns1__RegisterUserResponse::RegisterUserResult), "xsd:string"))
				{	soap_flag_RegisterUserResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RegisterUserResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RegisterUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RegisterUserResponse, 0, sizeof(_ns1__RegisterUserResponse), 0, soap_copy__ns1__RegisterUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RegisterUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RegisterUserResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RegisterUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RegisterUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RegisterUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RegisterUserResponse * SOAP_FMAC4 soap_get__ns1__RegisterUserResponse(struct soap *soap, _ns1__RegisterUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RegisterUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RegisterUserResponse * SOAP_FMAC2 soap_instantiate__ns1__RegisterUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RegisterUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RegisterUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RegisterUserResponse);
		if (size)
			*size = sizeof(_ns1__RegisterUserResponse);
		((_ns1__RegisterUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RegisterUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RegisterUserResponse);
		for (int i = 0; i < n; i++)
			((_ns1__RegisterUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RegisterUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RegisterUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RegisterUserResponse %p -> %p\n", q, p));
	*(_ns1__RegisterUserResponse*)p = *(_ns1__RegisterUserResponse*)q;
}

void _ns1__RegisterUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RegisterUser::username);
	soap_default_string(soap, &this->_ns1__RegisterUser::password);
	soap_default_string(soap, &this->_ns1__RegisterUser::mac);
	soap_default_string(soap, &this->_ns1__RegisterUser::adrTel);
	soap_default_string(soap, &this->_ns1__RegisterUser::address);
	soap_default_string(soap, &this->_ns1__RegisterUser::shopName);
	soap_default_string(soap, &this->_ns1__RegisterUser::mobilePhone);
	soap_default_string(soap, &this->_ns1__RegisterUser::realName);
	soap_default_string(soap, &this->_ns1__RegisterUser::identifyNo);
	soap_default_string(soap, &this->_ns1__RegisterUser::workerName);
	soap_default_string(soap, &this->_ns1__RegisterUser::workerId);
	soap_default_string(soap, &this->_ns1__RegisterUser::moneyTail);
	soap_default_string(soap, &this->_ns1__RegisterUser::clientType);
	/* transient soap skipped */
}

void _ns1__RegisterUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RegisterUser::username);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::password);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::mac);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::adrTel);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::address);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::shopName);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::mobilePhone);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::realName);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::identifyNo);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::workerName);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::workerId);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::moneyTail);
	soap_serialize_string(soap, &this->_ns1__RegisterUser::clientType);
	/* transient soap skipped */
}

int _ns1__RegisterUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RegisterUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RegisterUser(struct soap *soap, const char *tag, int id, const _ns1__RegisterUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RegisterUser), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, &(a->_ns1__RegisterUser::username), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:password", -1, &(a->_ns1__RegisterUser::password), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:mac", -1, &(a->_ns1__RegisterUser::mac), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:adrTel", -1, &(a->_ns1__RegisterUser::adrTel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:address", -1, &(a->_ns1__RegisterUser::address), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:shopName", -1, &(a->_ns1__RegisterUser::shopName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:mobilePhone", -1, &(a->_ns1__RegisterUser::mobilePhone), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:realName", -1, &(a->_ns1__RegisterUser::realName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:identifyNo", -1, &(a->_ns1__RegisterUser::identifyNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerName", -1, &(a->_ns1__RegisterUser::workerName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerId", -1, &(a->_ns1__RegisterUser::workerId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:moneyTail", -1, &(a->_ns1__RegisterUser::moneyTail), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__RegisterUser::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RegisterUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RegisterUser(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RegisterUser * SOAP_FMAC4 soap_in__ns1__RegisterUser(struct soap *soap, const char *tag, _ns1__RegisterUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RegisterUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RegisterUser, sizeof(_ns1__RegisterUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RegisterUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RegisterUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_username1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_adrTel1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_shopName1 = 1;
	size_t soap_flag_mobilePhone1 = 1;
	size_t soap_flag_realName1 = 1;
	size_t soap_flag_identifyNo1 = 1;
	size_t soap_flag_workerName1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_moneyTail1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__RegisterUser::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:password", &(a->_ns1__RegisterUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mac", &(a->_ns1__RegisterUser::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_adrTel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:adrTel", &(a->_ns1__RegisterUser::adrTel), "xsd:string"))
				{	soap_flag_adrTel1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:address", &(a->_ns1__RegisterUser::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_shopName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:shopName", &(a->_ns1__RegisterUser::shopName), "xsd:string"))
				{	soap_flag_shopName1--;
					continue;
				}
			if (soap_flag_mobilePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mobilePhone", &(a->_ns1__RegisterUser::mobilePhone), "xsd:string"))
				{	soap_flag_mobilePhone1--;
					continue;
				}
			if (soap_flag_realName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:realName", &(a->_ns1__RegisterUser::realName), "xsd:string"))
				{	soap_flag_realName1--;
					continue;
				}
			if (soap_flag_identifyNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:identifyNo", &(a->_ns1__RegisterUser::identifyNo), "xsd:string"))
				{	soap_flag_identifyNo1--;
					continue;
				}
			if (soap_flag_workerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerName", &(a->_ns1__RegisterUser::workerName), "xsd:string"))
				{	soap_flag_workerName1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerId", &(a->_ns1__RegisterUser::workerId), "xsd:string"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_moneyTail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moneyTail", &(a->_ns1__RegisterUser::moneyTail), "xsd:string"))
				{	soap_flag_moneyTail1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__RegisterUser::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RegisterUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RegisterUser, 0, sizeof(_ns1__RegisterUser), 0, soap_copy__ns1__RegisterUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RegisterUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RegisterUser);
	if (this->soap_out(soap, tag?tag:"ns1:RegisterUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RegisterUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RegisterUser(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RegisterUser * SOAP_FMAC4 soap_get__ns1__RegisterUser(struct soap *soap, _ns1__RegisterUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RegisterUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RegisterUser * SOAP_FMAC2 soap_instantiate__ns1__RegisterUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RegisterUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RegisterUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RegisterUser);
		if (size)
			*size = sizeof(_ns1__RegisterUser);
		((_ns1__RegisterUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RegisterUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RegisterUser);
		for (int i = 0; i < n; i++)
			((_ns1__RegisterUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RegisterUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RegisterUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RegisterUser %p -> %p\n", q, p));
	*(_ns1__RegisterUser*)p = *(_ns1__RegisterUser*)q;
}

void _ns1__GetUserInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetUserInfoResponse::GetUserInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetUserInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__User(soap, &this->_ns1__GetUserInfoResponse::GetUserInfoResult);
	/* transient soap skipped */
}

int _ns1__GetUserInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUserInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserInfoResponse), type))
		return soap->error;
	if (a->GetUserInfoResult)
		soap_element_result(soap, "ns1:GetUserInfoResult");
	if (soap_out_PointerTons1__User(soap, "ns1:GetUserInfoResult", -1, &(a->_ns1__GetUserInfoResponse::GetUserInfoResult), "ns1:User"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserInfoResponse * SOAP_FMAC4 soap_in__ns1__GetUserInfoResponse(struct soap *soap, const char *tag, _ns1__GetUserInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserInfoResponse, sizeof(_ns1__GetUserInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetUserInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUserInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__User(soap, "ns1:GetUserInfoResult", &(a->_ns1__GetUserInfoResponse::GetUserInfoResult), "ns1:User"))
				{	soap_flag_GetUserInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetUserInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserInfoResponse, 0, sizeof(_ns1__GetUserInfoResponse), 0, soap_copy__ns1__GetUserInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserInfoResponse * SOAP_FMAC4 soap_get__ns1__GetUserInfoResponse(struct soap *soap, _ns1__GetUserInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUserInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetUserInfoResponse);
		((_ns1__GetUserInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetUserInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetUserInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetUserInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetUserInfoResponse*)p = *(_ns1__GetUserInfoResponse*)q;
}

void _ns1__GetUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUserInfo::username);
	soap_default_string(soap, &this->_ns1__GetUserInfo::password);
	soap_default_string(soap, &this->_ns1__GetUserInfo::clientType);
	soap_default_string(soap, &this->_ns1__GetUserInfo::sessionId);
	/* transient soap skipped */
}

void _ns1__GetUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetUserInfo::username);
	soap_serialize_string(soap, &this->_ns1__GetUserInfo::password);
	soap_serialize_string(soap, &this->_ns1__GetUserInfo::clientType);
	soap_serialize_string(soap, &this->_ns1__GetUserInfo::sessionId);
	/* transient soap skipped */
}

int _ns1__GetUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserInfo(struct soap *soap, const char *tag, int id, const _ns1__GetUserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, &(a->_ns1__GetUserInfo::username), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:password", -1, &(a->_ns1__GetUserInfo::password), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__GetUserInfo::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetUserInfo::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserInfo * SOAP_FMAC4 soap_in__ns1__GetUserInfo(struct soap *soap, const char *tag, _ns1__GetUserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserInfo, sizeof(_ns1__GetUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_username1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__GetUserInfo::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:password", &(a->_ns1__GetUserInfo::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__GetUserInfo::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetUserInfo::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserInfo, 0, sizeof(_ns1__GetUserInfo), 0, soap_copy__ns1__GetUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserInfo * SOAP_FMAC4 soap_get__ns1__GetUserInfo(struct soap *soap, _ns1__GetUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserInfo * SOAP_FMAC2 soap_instantiate__ns1__GetUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserInfo);
		if (size)
			*size = sizeof(_ns1__GetUserInfo);
		((_ns1__GetUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetUserInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetUserInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserInfo %p -> %p\n", q, p));
	*(_ns1__GetUserInfo*)p = *(_ns1__GetUserInfo*)q;
}

void _ns1__TestLoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__TestLoginResponse::TestLoginResult);
	/* transient soap skipped */
}

void _ns1__TestLoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__TestLoginResponse::TestLoginResult);
	/* transient soap skipped */
}

int _ns1__TestLoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TestLoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TestLoginResponse(struct soap *soap, const char *tag, int id, const _ns1__TestLoginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TestLoginResponse), type))
		return soap->error;
	if (a->TestLoginResult)
		soap_element_result(soap, "ns1:TestLoginResult");
	if (soap_out_string(soap, "ns1:TestLoginResult", -1, &(a->_ns1__TestLoginResponse::TestLoginResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TestLoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TestLoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TestLoginResponse * SOAP_FMAC4 soap_in__ns1__TestLoginResponse(struct soap *soap, const char *tag, _ns1__TestLoginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TestLoginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TestLoginResponse, sizeof(_ns1__TestLoginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TestLoginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TestLoginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TestLoginResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestLoginResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TestLoginResult", &(a->_ns1__TestLoginResponse::TestLoginResult), "xsd:string"))
				{	soap_flag_TestLoginResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:TestLoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TestLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TestLoginResponse, 0, sizeof(_ns1__TestLoginResponse), 0, soap_copy__ns1__TestLoginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__TestLoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__TestLoginResponse);
	if (this->soap_out(soap, tag?tag:"ns1:TestLoginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TestLoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TestLoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TestLoginResponse * SOAP_FMAC4 soap_get__ns1__TestLoginResponse(struct soap *soap, _ns1__TestLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TestLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TestLoginResponse * SOAP_FMAC2 soap_instantiate__ns1__TestLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TestLoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TestLoginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestLoginResponse);
		if (size)
			*size = sizeof(_ns1__TestLoginResponse);
		((_ns1__TestLoginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestLoginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__TestLoginResponse);
		for (int i = 0; i < n; i++)
			((_ns1__TestLoginResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__TestLoginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TestLoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TestLoginResponse %p -> %p\n", q, p));
	*(_ns1__TestLoginResponse*)p = *(_ns1__TestLoginResponse*)q;
}

void _ns1__TestLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__TestLogin::Username);
	soap_default_string(soap, &this->_ns1__TestLogin::Password);
	soap_default_string(soap, &this->_ns1__TestLogin::Mac);
	soap_default_string(soap, &this->_ns1__TestLogin::ip);
	soap_default_string(soap, &this->_ns1__TestLogin::clientType);
	/* transient soap skipped */
}

void _ns1__TestLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__TestLogin::Username);
	soap_serialize_string(soap, &this->_ns1__TestLogin::Password);
	soap_serialize_string(soap, &this->_ns1__TestLogin::Mac);
	soap_serialize_string(soap, &this->_ns1__TestLogin::ip);
	soap_serialize_string(soap, &this->_ns1__TestLogin::clientType);
	/* transient soap skipped */
}

int _ns1__TestLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TestLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TestLogin(struct soap *soap, const char *tag, int id, const _ns1__TestLogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TestLogin), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &(a->_ns1__TestLogin::Username), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &(a->_ns1__TestLogin::Password), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Mac", -1, &(a->_ns1__TestLogin::Mac), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:ip", -1, &(a->_ns1__TestLogin::ip), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__TestLogin::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TestLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TestLogin(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TestLogin * SOAP_FMAC4 soap_in__ns1__TestLogin(struct soap *soap, const char *tag, _ns1__TestLogin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TestLogin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TestLogin, sizeof(_ns1__TestLogin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TestLogin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TestLogin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Mac1 = 1;
	size_t soap_flag_ip1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &(a->_ns1__TestLogin::Username), "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &(a->_ns1__TestLogin::Password), "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap_flag_Mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Mac", &(a->_ns1__TestLogin::Mac), "xsd:string"))
				{	soap_flag_Mac1--;
					continue;
				}
			if (soap_flag_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ip", &(a->_ns1__TestLogin::ip), "xsd:string"))
				{	soap_flag_ip1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__TestLogin::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TestLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TestLogin, 0, sizeof(_ns1__TestLogin), 0, soap_copy__ns1__TestLogin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__TestLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__TestLogin);
	if (this->soap_out(soap, tag?tag:"ns1:TestLogin", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TestLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TestLogin(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TestLogin * SOAP_FMAC4 soap_get__ns1__TestLogin(struct soap *soap, _ns1__TestLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TestLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TestLogin * SOAP_FMAC2 soap_instantiate__ns1__TestLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TestLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TestLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestLogin);
		if (size)
			*size = sizeof(_ns1__TestLogin);
		((_ns1__TestLogin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestLogin[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__TestLogin);
		for (int i = 0; i < n; i++)
			((_ns1__TestLogin*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__TestLogin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TestLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TestLogin %p -> %p\n", q, p));
	*(_ns1__TestLogin*)p = *(_ns1__TestLogin*)q;
}

void _ns1__loggoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__loggoutResponse::loggoutResult);
	/* transient soap skipped */
}

void _ns1__loggoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__loggoutResponse::loggoutResult);
	/* transient soap skipped */
}

int _ns1__loggoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loggoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loggoutResponse(struct soap *soap, const char *tag, int id, const _ns1__loggoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loggoutResponse), type))
		return soap->error;
	if (a->loggoutResult)
		soap_element_result(soap, "ns1:loggoutResult");
	if (soap_out_string(soap, "ns1:loggoutResult", -1, &(a->_ns1__loggoutResponse::loggoutResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__loggoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loggoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loggoutResponse * SOAP_FMAC4 soap_in__ns1__loggoutResponse(struct soap *soap, const char *tag, _ns1__loggoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loggoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loggoutResponse, sizeof(_ns1__loggoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__loggoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__loggoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loggoutResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loggoutResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:loggoutResult", &(a->_ns1__loggoutResponse::loggoutResult), "xsd:string"))
				{	soap_flag_loggoutResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:loggoutResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__loggoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loggoutResponse, 0, sizeof(_ns1__loggoutResponse), 0, soap_copy__ns1__loggoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__loggoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__loggoutResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loggoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loggoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loggoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loggoutResponse * SOAP_FMAC4 soap_get__ns1__loggoutResponse(struct soap *soap, _ns1__loggoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loggoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__loggoutResponse * SOAP_FMAC2 soap_instantiate__ns1__loggoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loggoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loggoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loggoutResponse);
		if (size)
			*size = sizeof(_ns1__loggoutResponse);
		((_ns1__loggoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loggoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__loggoutResponse);
		for (int i = 0; i < n; i++)
			((_ns1__loggoutResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__loggoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__loggoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__loggoutResponse %p -> %p\n", q, p));
	*(_ns1__loggoutResponse*)p = *(_ns1__loggoutResponse*)q;
}

void _ns1__loggout::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__loggout::userId);
	soap_default_string(soap, &this->_ns1__loggout::sessionId);
	/* transient soap skipped */
}

void _ns1__loggout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__loggout::userId);
	soap_serialize_string(soap, &this->_ns1__loggout::sessionId);
	/* transient soap skipped */
}

int _ns1__loggout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loggout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loggout(struct soap *soap, const char *tag, int id, const _ns1__loggout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loggout), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__loggout::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__loggout::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__loggout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loggout(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loggout * SOAP_FMAC4 soap_in__ns1__loggout(struct soap *soap, const char *tag, _ns1__loggout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loggout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loggout, sizeof(_ns1__loggout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__loggout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__loggout *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__loggout::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__loggout::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__loggout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loggout, 0, sizeof(_ns1__loggout), 0, soap_copy__ns1__loggout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__loggout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__loggout);
	if (this->soap_out(soap, tag?tag:"ns1:loggout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loggout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loggout(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loggout * SOAP_FMAC4 soap_get__ns1__loggout(struct soap *soap, _ns1__loggout *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loggout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__loggout * SOAP_FMAC2 soap_instantiate__ns1__loggout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loggout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loggout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loggout);
		if (size)
			*size = sizeof(_ns1__loggout);
		((_ns1__loggout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loggout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__loggout);
		for (int i = 0; i < n; i++)
			((_ns1__loggout*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__loggout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__loggout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__loggout %p -> %p\n", q, p));
	*(_ns1__loggout*)p = *(_ns1__loggout*)q;
}

void _ns1__HelloWorldResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__HelloWorldResponse::HelloWorldResult);
	/* transient soap skipped */
}

void _ns1__HelloWorldResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__HelloWorldResponse::HelloWorldResult);
	/* transient soap skipped */
}

int _ns1__HelloWorldResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorldResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorldResponse(struct soap *soap, const char *tag, int id, const _ns1__HelloWorldResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorldResponse), type))
		return soap->error;
	if (a->HelloWorldResult)
		soap_element_result(soap, "ns1:HelloWorldResult");
	if (soap_out_string(soap, "ns1:HelloWorldResult", -1, &(a->_ns1__HelloWorldResponse::HelloWorldResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorldResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorldResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_in__ns1__HelloWorldResponse(struct soap *soap, const char *tag, _ns1__HelloWorldResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorldResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__HelloWorldResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__HelloWorldResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_HelloWorldResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HelloWorldResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:HelloWorldResult", &(a->_ns1__HelloWorldResponse::HelloWorldResult), "xsd:string"))
				{	soap_flag_HelloWorldResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:HelloWorldResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorldResponse, 0, sizeof(_ns1__HelloWorldResponse), 0, soap_copy__ns1__HelloWorldResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__HelloWorldResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__HelloWorldResponse);
	if (this->soap_out(soap, tag?tag:"ns1:HelloWorldResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorldResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorldResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_get__ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__HelloWorldResponse * SOAP_FMAC2 soap_instantiate__ns1__HelloWorldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorldResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__HelloWorldResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__HelloWorldResponse);
		if (size)
			*size = sizeof(_ns1__HelloWorldResponse);
		((_ns1__HelloWorldResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__HelloWorldResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__HelloWorldResponse);
		for (int i = 0; i < n; i++)
			((_ns1__HelloWorldResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__HelloWorldResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__HelloWorldResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__HelloWorldResponse %p -> %p\n", q, p));
	*(_ns1__HelloWorldResponse*)p = *(_ns1__HelloWorldResponse*)q;
}

void _ns1__HelloWorld::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__HelloWorld::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__HelloWorld::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorld(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorld(struct soap *soap, const char *tag, int id, const _ns1__HelloWorld *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorld), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorld::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorld(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_in__ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorld *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__HelloWorld)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__HelloWorld *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorld, 0, sizeof(_ns1__HelloWorld), 0, soap_copy__ns1__HelloWorld);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__HelloWorld::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__HelloWorld);
	if (this->soap_out(soap, tag?tag:"ns1:HelloWorld", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorld::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorld(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_get__ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__HelloWorld * SOAP_FMAC2 soap_instantiate__ns1__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorld(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__HelloWorld, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__HelloWorld);
		if (size)
			*size = sizeof(_ns1__HelloWorld);
		((_ns1__HelloWorld*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__HelloWorld[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__HelloWorld);
		for (int i = 0; i < n; i++)
			((_ns1__HelloWorld*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__HelloWorld*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__HelloWorld(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__HelloWorld %p -> %p\n", q, p));
	*(_ns1__HelloWorld*)p = *(_ns1__HelloWorld*)q;
}

void _ns1__GetPayPublicTelHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayPublicTelHistoryByConditionResponse::GetPayPublicTelHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayPublicTelHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayPublicTelItem(soap, &this->_ns1__GetPayPublicTelHistoryByConditionResponse::GetPayPublicTelHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayPublicTelHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayPublicTelHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPayPublicTelHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPayPublicTelHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayPublicTelItem(soap, "ns1:GetPayPublicTelHistoryByConditionResult", -1, &(a->_ns1__GetPayPublicTelHistoryByConditionResponse::GetPayPublicTelHistoryByConditionResult), "ns1:ArrayOfPayPublicTelItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayPublicTelHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayPublicTelHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayPublicTelHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse, sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayPublicTelHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayPublicTelHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayPublicTelHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayPublicTelItem(soap, "ns1:GetPayPublicTelHistoryByConditionResult", &(a->_ns1__GetPayPublicTelHistoryByConditionResponse::GetPayPublicTelHistoryByConditionResult), "ns1:ArrayOfPayPublicTelItem"))
				{	soap_flag_GetPayPublicTelHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayPublicTelHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayPublicTelHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse, 0, sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse), 0, soap_copy__ns1__GetPayPublicTelHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayPublicTelHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayPublicTelHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayPublicTelHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayPublicTelHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayPublicTelHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayPublicTelHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse);
		((_ns1__GetPayPublicTelHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayPublicTelHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayPublicTelHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayPublicTelHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayPublicTelHistoryByConditionResponse*)p = *(_ns1__GetPayPublicTelHistoryByConditionResponse*)q;
}

void _ns1__GetPayPublicTelHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPayPublicTelHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayPublicTelHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayPublicTelHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayPublicTelHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayPublicTelHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayPublicTelHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayPublicTelHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayPublicTelHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayPublicTelHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayPublicTelHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayPublicTelHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayPublicTelHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition, sizeof(_ns1__GetPayPublicTelHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayPublicTelHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayPublicTelHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayPublicTelHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayPublicTelHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition, 0, sizeof(_ns1__GetPayPublicTelHistoryByCondition), 0, soap_copy__ns1__GetPayPublicTelHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayPublicTelHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayPublicTelHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayPublicTelHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayPublicTelHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, _ns1__GetPayPublicTelHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayPublicTelHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayPublicTelHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayPublicTelHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayPublicTelHistoryByCondition);
		((_ns1__GetPayPublicTelHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayPublicTelHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayPublicTelHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayPublicTelHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayPublicTelHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayPublicTelHistoryByCondition*)p = *(_ns1__GetPayPublicTelHistoryByCondition*)q;
}

void _ns1__GetPayPublicTelByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayPublicTelByConditionResponse::GetPayPublicTelByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayPublicTelByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayPublicTelItem(soap, &this->_ns1__GetPayPublicTelByConditionResponse::GetPayPublicTelByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayPublicTelByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayPublicTelByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayPublicTelByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayPublicTelByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse), type))
		return soap->error;
	if (a->GetPayPublicTelByConditionResult)
		soap_element_result(soap, "ns1:GetPayPublicTelByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayPublicTelItem(soap, "ns1:GetPayPublicTelByConditionResult", -1, &(a->_ns1__GetPayPublicTelByConditionResponse::GetPayPublicTelByConditionResult), "ns1:ArrayOfPayPublicTelItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayPublicTelByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayPublicTelByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayPublicTelByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayPublicTelByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayPublicTelByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse, sizeof(_ns1__GetPayPublicTelByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayPublicTelByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayPublicTelByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayPublicTelByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayPublicTelItem(soap, "ns1:GetPayPublicTelByConditionResult", &(a->_ns1__GetPayPublicTelByConditionResponse::GetPayPublicTelByConditionResult), "ns1:ArrayOfPayPublicTelItem"))
				{	soap_flag_GetPayPublicTelByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayPublicTelByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayPublicTelByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse, 0, sizeof(_ns1__GetPayPublicTelByConditionResponse), 0, soap_copy__ns1__GetPayPublicTelByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayPublicTelByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayPublicTelByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayPublicTelByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayPublicTelByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayPublicTelByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayPublicTelByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayPublicTelByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayPublicTelByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayPublicTelByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayPublicTelByConditionResponse);
		((_ns1__GetPayPublicTelByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayPublicTelByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayPublicTelByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayPublicTelByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayPublicTelByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayPublicTelByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayPublicTelByConditionResponse*)p = *(_ns1__GetPayPublicTelByConditionResponse*)q;
}

void _ns1__GetPayPublicTelByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPayPublicTelByCondition::top);
	soap_default_string(soap, &this->_ns1__GetPayPublicTelByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayPublicTelByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayPublicTelByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayPublicTelByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayPublicTelByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayPublicTelByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayPublicTelByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayPublicTelByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayPublicTelByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayPublicTelByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetPayPublicTelByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayPublicTelByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayPublicTelByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayPublicTelByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayPublicTelByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByCondition * SOAP_FMAC4 soap_in__ns1__GetPayPublicTelByCondition(struct soap *soap, const char *tag, _ns1__GetPayPublicTelByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayPublicTelByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayPublicTelByCondition, sizeof(_ns1__GetPayPublicTelByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayPublicTelByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayPublicTelByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetPayPublicTelByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayPublicTelByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayPublicTelByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayPublicTelByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayPublicTelByCondition, 0, sizeof(_ns1__GetPayPublicTelByCondition), 0, soap_copy__ns1__GetPayPublicTelByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPayPublicTelByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayPublicTelByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayPublicTelByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayPublicTelByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayPublicTelByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByCondition * SOAP_FMAC4 soap_get__ns1__GetPayPublicTelByCondition(struct soap *soap, _ns1__GetPayPublicTelByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayPublicTelByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayPublicTelByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayPublicTelByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayPublicTelByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayPublicTelByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayPublicTelByCondition);
		((_ns1__GetPayPublicTelByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayPublicTelByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayPublicTelByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayPublicTelByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayPublicTelByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayPublicTelByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayPublicTelByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayPublicTelByCondition*)p = *(_ns1__GetPayPublicTelByCondition*)q;
}

void _ns1__GetPayGameHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayGameHistoryByConditionResponse::GetPayGameHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayGameHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayGameItem(soap, &this->_ns1__GetPayGameHistoryByConditionResponse::GetPayGameHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayGameHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayGameHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayGameHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPayGameHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPayGameHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayGameItem(soap, "ns1:GetPayGameHistoryByConditionResult", -1, &(a->_ns1__GetPayGameHistoryByConditionResponse::GetPayGameHistoryByConditionResult), "ns1:ArrayOfPayGameItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayGameHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayGameHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayGameHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayGameHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse, sizeof(_ns1__GetPayGameHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayGameHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayGameHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayGameHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayGameItem(soap, "ns1:GetPayGameHistoryByConditionResult", &(a->_ns1__GetPayGameHistoryByConditionResponse::GetPayGameHistoryByConditionResult), "ns1:ArrayOfPayGameItem"))
				{	soap_flag_GetPayGameHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayGameHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayGameHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse, 0, sizeof(_ns1__GetPayGameHistoryByConditionResponse), 0, soap_copy__ns1__GetPayGameHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayGameHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayGameHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayGameHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayGameHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, _ns1__GetPayGameHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayGameHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayGameHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayGameHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayGameHistoryByConditionResponse);
		((_ns1__GetPayGameHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayGameHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayGameHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayGameHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayGameHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayGameHistoryByConditionResponse*)p = *(_ns1__GetPayGameHistoryByConditionResponse*)q;
}

void _ns1__GetPayGameHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPayGameHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayGameHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayGameHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayGameHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayGameHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayGameHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayGameHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayGameHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayGameHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayGameHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayGameHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayGameHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayGameHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayGameHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayGameHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayGameHistoryByCondition, sizeof(_ns1__GetPayGameHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayGameHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayGameHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayGameHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayGameHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayGameHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayGameHistoryByCondition, 0, sizeof(_ns1__GetPayGameHistoryByCondition), 0, soap_copy__ns1__GetPayGameHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayGameHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayGameHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayGameHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayGameHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayGameHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPayGameHistoryByCondition(struct soap *soap, _ns1__GetPayGameHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayGameHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayGameHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayGameHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayGameHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayGameHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayGameHistoryByCondition);
		((_ns1__GetPayGameHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayGameHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayGameHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayGameHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayGameHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayGameHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayGameHistoryByCondition*)p = *(_ns1__GetPayGameHistoryByCondition*)q;
}

void _ns1__GetPayGameByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayGameByConditionResponse::GetPayGameByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayGameByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayGameItem(soap, &this->_ns1__GetPayGameByConditionResponse::GetPayGameByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayGameByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayGameByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayGameByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayGameByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayGameByConditionResponse), type))
		return soap->error;
	if (a->GetPayGameByConditionResult)
		soap_element_result(soap, "ns1:GetPayGameByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayGameItem(soap, "ns1:GetPayGameByConditionResult", -1, &(a->_ns1__GetPayGameByConditionResponse::GetPayGameByConditionResult), "ns1:ArrayOfPayGameItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayGameByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayGameByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayGameByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayGameByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayGameByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayGameByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayGameByConditionResponse, sizeof(_ns1__GetPayGameByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayGameByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayGameByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayGameByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayGameByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayGameItem(soap, "ns1:GetPayGameByConditionResult", &(a->_ns1__GetPayGameByConditionResponse::GetPayGameByConditionResult), "ns1:ArrayOfPayGameItem"))
				{	soap_flag_GetPayGameByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayGameByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayGameByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayGameByConditionResponse, 0, sizeof(_ns1__GetPayGameByConditionResponse), 0, soap_copy__ns1__GetPayGameByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayGameByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayGameByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayGameByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayGameByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayGameByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayGameByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayGameByConditionResponse(struct soap *soap, _ns1__GetPayGameByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayGameByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayGameByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayGameByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayGameByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayGameByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayGameByConditionResponse);
		((_ns1__GetPayGameByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayGameByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayGameByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayGameByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayGameByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayGameByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayGameByConditionResponse*)p = *(_ns1__GetPayGameByConditionResponse*)q;
}

void _ns1__GetPayGameByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPayGameByCondition::top);
	soap_default_string(soap, &this->_ns1__GetPayGameByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayGameByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayGameByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayGameByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayGameByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayGameByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayGameByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayGameByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayGameByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayGameByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetPayGameByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayGameByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayGameByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayGameByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayGameByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayGameByCondition * SOAP_FMAC4 soap_in__ns1__GetPayGameByCondition(struct soap *soap, const char *tag, _ns1__GetPayGameByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayGameByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayGameByCondition, sizeof(_ns1__GetPayGameByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayGameByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayGameByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetPayGameByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayGameByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayGameByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayGameByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayGameByCondition, 0, sizeof(_ns1__GetPayGameByCondition), 0, soap_copy__ns1__GetPayGameByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPayGameByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayGameByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayGameByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayGameByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayGameByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayGameByCondition * SOAP_FMAC4 soap_get__ns1__GetPayGameByCondition(struct soap *soap, _ns1__GetPayGameByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayGameByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayGameByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayGameByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayGameByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayGameByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayGameByCondition);
		((_ns1__GetPayGameByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayGameByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayGameByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayGameByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayGameByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayGameByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayGameByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayGameByCondition*)p = *(_ns1__GetPayGameByCondition*)q;
}

void _ns1__GetPayInternetHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayInternetHistoryByConditionResponse::GetPayInternetHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayInternetHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayInternetItem(soap, &this->_ns1__GetPayInternetHistoryByConditionResponse::GetPayInternetHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayInternetHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayInternetHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayInternetHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPayInternetHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPayInternetHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayInternetItem(soap, "ns1:GetPayInternetHistoryByConditionResult", -1, &(a->_ns1__GetPayInternetHistoryByConditionResponse::GetPayInternetHistoryByConditionResult), "ns1:ArrayOfPayInternetItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayInternetHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayInternetHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayInternetHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayInternetHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse, sizeof(_ns1__GetPayInternetHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayInternetHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayInternetHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayInternetHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayInternetItem(soap, "ns1:GetPayInternetHistoryByConditionResult", &(a->_ns1__GetPayInternetHistoryByConditionResponse::GetPayInternetHistoryByConditionResult), "ns1:ArrayOfPayInternetItem"))
				{	soap_flag_GetPayInternetHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayInternetHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayInternetHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse, 0, sizeof(_ns1__GetPayInternetHistoryByConditionResponse), 0, soap_copy__ns1__GetPayInternetHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayInternetHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayInternetHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayInternetHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayInternetHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, _ns1__GetPayInternetHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayInternetHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayInternetHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayInternetHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayInternetHistoryByConditionResponse);
		((_ns1__GetPayInternetHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayInternetHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayInternetHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayInternetHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayInternetHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayInternetHistoryByConditionResponse*)p = *(_ns1__GetPayInternetHistoryByConditionResponse*)q;
}

void _ns1__GetPayInternetHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPayInternetHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayInternetHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayInternetHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayInternetHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayInternetHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayInternetHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayInternetHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayInternetHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayInternetHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayInternetHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayInternetHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayInternetHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayInternetHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayInternetHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition, sizeof(_ns1__GetPayInternetHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayInternetHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayInternetHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayInternetHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayInternetHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayInternetHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition, 0, sizeof(_ns1__GetPayInternetHistoryByCondition), 0, soap_copy__ns1__GetPayInternetHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayInternetHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayInternetHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayInternetHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayInternetHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPayInternetHistoryByCondition(struct soap *soap, _ns1__GetPayInternetHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayInternetHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayInternetHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayInternetHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayInternetHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayInternetHistoryByCondition);
		((_ns1__GetPayInternetHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayInternetHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayInternetHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayInternetHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayInternetHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayInternetHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayInternetHistoryByCondition*)p = *(_ns1__GetPayInternetHistoryByCondition*)q;
}

void _ns1__GetPayInternetByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPayInternetByConditionResponse::GetPayInternetByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPayInternetByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPayInternetItem(soap, &this->_ns1__GetPayInternetByConditionResponse::GetPayInternetByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPayInternetByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayInternetByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayInternetByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPayInternetByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayInternetByConditionResponse), type))
		return soap->error;
	if (a->GetPayInternetByConditionResult)
		soap_element_result(soap, "ns1:GetPayInternetByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPayInternetItem(soap, "ns1:GetPayInternetByConditionResult", -1, &(a->_ns1__GetPayInternetByConditionResponse::GetPayInternetByConditionResult), "ns1:ArrayOfPayInternetItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayInternetByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayInternetByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPayInternetByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayInternetByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayInternetByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayInternetByConditionResponse, sizeof(_ns1__GetPayInternetByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayInternetByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayInternetByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPayInternetByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPayInternetByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayInternetItem(soap, "ns1:GetPayInternetByConditionResult", &(a->_ns1__GetPayInternetByConditionResponse::GetPayInternetByConditionResult), "ns1:ArrayOfPayInternetItem"))
				{	soap_flag_GetPayInternetByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPayInternetByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayInternetByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayInternetByConditionResponse, 0, sizeof(_ns1__GetPayInternetByConditionResponse), 0, soap_copy__ns1__GetPayInternetByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPayInternetByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayInternetByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayInternetByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayInternetByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayInternetByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPayInternetByConditionResponse(struct soap *soap, _ns1__GetPayInternetByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayInternetByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayInternetByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPayInternetByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayInternetByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayInternetByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPayInternetByConditionResponse);
		((_ns1__GetPayInternetByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayInternetByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayInternetByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayInternetByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayInternetByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayInternetByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPayInternetByConditionResponse*)p = *(_ns1__GetPayInternetByConditionResponse*)q;
}

void _ns1__GetPayInternetByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPayInternetByCondition::top);
	soap_default_string(soap, &this->_ns1__GetPayInternetByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPayInternetByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPayInternetByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPayInternetByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPayInternetByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPayInternetByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPayInternetByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPayInternetByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPayInternetByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPayInternetByCondition), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetPayInternetByCondition::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPayInternetByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPayInternetByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPayInternetByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPayInternetByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByCondition * SOAP_FMAC4 soap_in__ns1__GetPayInternetByCondition(struct soap *soap, const char *tag, _ns1__GetPayInternetByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPayInternetByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPayInternetByCondition, sizeof(_ns1__GetPayInternetByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPayInternetByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPayInternetByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetPayInternetByCondition::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPayInternetByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPayInternetByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPayInternetByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPayInternetByCondition, 0, sizeof(_ns1__GetPayInternetByCondition), 0, soap_copy__ns1__GetPayInternetByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPayInternetByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPayInternetByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPayInternetByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPayInternetByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPayInternetByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByCondition * SOAP_FMAC4 soap_get__ns1__GetPayInternetByCondition(struct soap *soap, _ns1__GetPayInternetByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPayInternetByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPayInternetByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPayInternetByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPayInternetByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPayInternetByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetByCondition);
		if (size)
			*size = sizeof(_ns1__GetPayInternetByCondition);
		((_ns1__GetPayInternetByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPayInternetByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPayInternetByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPayInternetByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPayInternetByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPayInternetByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPayInternetByCondition %p -> %p\n", q, p));
	*(_ns1__GetPayInternetByCondition*)p = *(_ns1__GetPayInternetByCondition*)q;
}

void _ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPaymentOrPaymentHistoryByConditionResponse::GetPaymentOrPaymentHistoryByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPaymentItem(soap, &this->_ns1__GetPaymentOrPaymentHistoryByConditionResponse::GetPaymentOrPaymentHistoryByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentOrPaymentHistoryByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse), type))
		return soap->error;
	if (a->GetPaymentOrPaymentHistoryByConditionResult)
		soap_element_result(soap, "ns1:GetPaymentOrPaymentHistoryByConditionResult");
	if (soap_out_PointerTons1__ArrayOfPaymentItem(soap, "ns1:GetPaymentOrPaymentHistoryByConditionResult", -1, &(a->_ns1__GetPaymentOrPaymentHistoryByConditionResponse::GetPaymentOrPaymentHistoryByConditionResult), "ns1:ArrayOfPaymentItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPaymentOrPaymentHistoryByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse, sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPaymentOrPaymentHistoryByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPaymentOrPaymentHistoryByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPaymentItem(soap, "ns1:GetPaymentOrPaymentHistoryByConditionResult", &(a->_ns1__GetPaymentOrPaymentHistoryByConditionResponse::GetPaymentOrPaymentHistoryByConditionResult), "ns1:ArrayOfPaymentItem"))
				{	soap_flag_GetPaymentOrPaymentHistoryByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPaymentOrPaymentHistoryByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse, 0, sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse), 0, soap_copy__ns1__GetPaymentOrPaymentHistoryByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentOrPaymentHistoryByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentOrPaymentHistoryByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentOrPaymentHistoryByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentOrPaymentHistoryByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentOrPaymentHistoryByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse);
		((_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentOrPaymentHistoryByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentOrPaymentHistoryByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)p = *(_ns1__GetPaymentOrPaymentHistoryByConditionResponse*)q;
}

void _ns1__GetPaymentOrPaymentHistoryByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPaymentOrPaymentHistoryByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetPaymentOrPaymentHistoryByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPaymentOrPaymentHistoryByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPaymentOrPaymentHistoryByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetPaymentOrPaymentHistoryByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPaymentOrPaymentHistoryByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPaymentOrPaymentHistoryByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPaymentOrPaymentHistoryByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentOrPaymentHistoryByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_in__ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentOrPaymentHistoryByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition, sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentOrPaymentHistoryByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPaymentOrPaymentHistoryByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPaymentOrPaymentHistoryByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentOrPaymentHistoryByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition, 0, sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition), 0, soap_copy__ns1__GetPaymentOrPaymentHistoryByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPaymentOrPaymentHistoryByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentOrPaymentHistoryByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentOrPaymentHistoryByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentOrPaymentHistoryByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_get__ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentOrPaymentHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentOrPaymentHistoryByCondition);
		if (size)
			*size = sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition);
		((_ns1__GetPaymentOrPaymentHistoryByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentOrPaymentHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentOrPaymentHistoryByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentOrPaymentHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentOrPaymentHistoryByCondition %p -> %p\n", q, p));
	*(_ns1__GetPaymentOrPaymentHistoryByCondition*)p = *(_ns1__GetPaymentOrPaymentHistoryByCondition*)q;
}

void _ns1__GetTransactionStaticsByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTransactionStaticsByConditionResponse::GetTransactionStaticsByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTransactionStaticsByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfTransStaticsItem(soap, &this->_ns1__GetTransactionStaticsByConditionResponse::GetTransactionStaticsByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetTransactionStaticsByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTransactionStaticsByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTransactionStaticsByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse), type))
		return soap->error;
	if (a->GetTransactionStaticsByConditionResult)
		soap_element_result(soap, "ns1:GetTransactionStaticsByConditionResult");
	if (soap_out_PointerTons1__ArrayOfTransStaticsItem(soap, "ns1:GetTransactionStaticsByConditionResult", -1, &(a->_ns1__GetTransactionStaticsByConditionResponse::GetTransactionStaticsByConditionResult), "ns1:ArrayOfTransStaticsItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTransactionStaticsByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTransactionStaticsByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, const char *tag, _ns1__GetTransactionStaticsByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTransactionStaticsByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse, sizeof(_ns1__GetTransactionStaticsByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTransactionStaticsByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTransactionStaticsByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTransactionStaticsByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTransStaticsItem(soap, "ns1:GetTransactionStaticsByConditionResult", &(a->_ns1__GetTransactionStaticsByConditionResponse::GetTransactionStaticsByConditionResult), "ns1:ArrayOfTransStaticsItem"))
				{	soap_flag_GetTransactionStaticsByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetTransactionStaticsByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTransactionStaticsByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse, 0, sizeof(_ns1__GetTransactionStaticsByConditionResponse), 0, soap_copy__ns1__GetTransactionStaticsByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTransactionStaticsByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetTransactionStaticsByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTransactionStaticsByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTransactionStaticsByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, _ns1__GetTransactionStaticsByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTransactionStaticsByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTransactionStaticsByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTransactionStaticsByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionStaticsByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetTransactionStaticsByConditionResponse);
		((_ns1__GetTransactionStaticsByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionStaticsByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTransactionStaticsByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetTransactionStaticsByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTransactionStaticsByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTransactionStaticsByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetTransactionStaticsByConditionResponse*)p = *(_ns1__GetTransactionStaticsByConditionResponse*)q;
}

void _ns1__GetTransactionStaticsByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTransactionStaticsByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetTransactionStaticsByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetTransactionStaticsByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetTransactionStaticsByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetTransactionStaticsByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetTransactionStaticsByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTransactionStaticsByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetTransactionStaticsByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTransactionStaticsByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetTransactionStaticsByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetTransactionStaticsByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTransactionStaticsByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTransactionStaticsByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_in__ns1__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, _ns1__GetTransactionStaticsByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTransactionStaticsByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTransactionStaticsByCondition, sizeof(_ns1__GetTransactionStaticsByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTransactionStaticsByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTransactionStaticsByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetTransactionStaticsByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetTransactionStaticsByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTransactionStaticsByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTransactionStaticsByCondition, 0, sizeof(_ns1__GetTransactionStaticsByCondition), 0, soap_copy__ns1__GetTransactionStaticsByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTransactionStaticsByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTransactionStaticsByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetTransactionStaticsByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTransactionStaticsByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTransactionStaticsByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_get__ns1__GetTransactionStaticsByCondition(struct soap *soap, _ns1__GetTransactionStaticsByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTransactionStaticsByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTransactionStaticsByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetTransactionStaticsByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTransactionStaticsByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTransactionStaticsByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionStaticsByCondition);
		if (size)
			*size = sizeof(_ns1__GetTransactionStaticsByCondition);
		((_ns1__GetTransactionStaticsByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionStaticsByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTransactionStaticsByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetTransactionStaticsByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTransactionStaticsByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTransactionStaticsByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTransactionStaticsByCondition %p -> %p\n", q, p));
	*(_ns1__GetTransactionStaticsByCondition*)p = *(_ns1__GetTransactionStaticsByCondition*)q;
}

void _ns1__GetTransactionByConditionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTransactionByConditionResponse::GetTransactionByConditionResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTransactionByConditionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfTransaction(soap, &this->_ns1__GetTransactionByConditionResponse::GetTransactionByConditionResult);
	/* transient soap skipped */
}

int _ns1__GetTransactionByConditionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTransactionByConditionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTransactionByConditionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTransactionByConditionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTransactionByConditionResponse), type))
		return soap->error;
	if (a->GetTransactionByConditionResult)
		soap_element_result(soap, "ns1:GetTransactionByConditionResult");
	if (soap_out_PointerTons1__ArrayOfTransaction(soap, "ns1:GetTransactionByConditionResult", -1, &(a->_ns1__GetTransactionByConditionResponse::GetTransactionByConditionResult), "ns1:ArrayOfTransaction"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTransactionByConditionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTransactionByConditionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTransactionByConditionResponse * SOAP_FMAC4 soap_in__ns1__GetTransactionByConditionResponse(struct soap *soap, const char *tag, _ns1__GetTransactionByConditionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTransactionByConditionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTransactionByConditionResponse, sizeof(_ns1__GetTransactionByConditionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTransactionByConditionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTransactionByConditionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTransactionByConditionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTransactionByConditionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTransaction(soap, "ns1:GetTransactionByConditionResult", &(a->_ns1__GetTransactionByConditionResponse::GetTransactionByConditionResult), "ns1:ArrayOfTransaction"))
				{	soap_flag_GetTransactionByConditionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetTransactionByConditionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTransactionByConditionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTransactionByConditionResponse, 0, sizeof(_ns1__GetTransactionByConditionResponse), 0, soap_copy__ns1__GetTransactionByConditionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTransactionByConditionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTransactionByConditionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetTransactionByConditionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTransactionByConditionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTransactionByConditionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTransactionByConditionResponse * SOAP_FMAC4 soap_get__ns1__GetTransactionByConditionResponse(struct soap *soap, _ns1__GetTransactionByConditionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTransactionByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTransactionByConditionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTransactionByConditionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTransactionByConditionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTransactionByConditionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionByConditionResponse);
		if (size)
			*size = sizeof(_ns1__GetTransactionByConditionResponse);
		((_ns1__GetTransactionByConditionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionByConditionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTransactionByConditionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetTransactionByConditionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTransactionByConditionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTransactionByConditionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTransactionByConditionResponse %p -> %p\n", q, p));
	*(_ns1__GetTransactionByConditionResponse*)p = *(_ns1__GetTransactionByConditionResponse*)q;
}

void _ns1__GetTransactionByCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTransactionByCondition::condition);
	soap_default_string(soap, &this->_ns1__GetTransactionByCondition::sessionId);
	/* transient soap skipped */
}

void _ns1__GetTransactionByCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetTransactionByCondition::condition);
	soap_serialize_string(soap, &this->_ns1__GetTransactionByCondition::sessionId);
	/* transient soap skipped */
}

int _ns1__GetTransactionByCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTransactionByCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTransactionByCondition(struct soap *soap, const char *tag, int id, const _ns1__GetTransactionByCondition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTransactionByCondition), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetTransactionByCondition::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetTransactionByCondition::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTransactionByCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTransactionByCondition(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTransactionByCondition * SOAP_FMAC4 soap_in__ns1__GetTransactionByCondition(struct soap *soap, const char *tag, _ns1__GetTransactionByCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTransactionByCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTransactionByCondition, sizeof(_ns1__GetTransactionByCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetTransactionByCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetTransactionByCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetTransactionByCondition::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetTransactionByCondition::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTransactionByCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTransactionByCondition, 0, sizeof(_ns1__GetTransactionByCondition), 0, soap_copy__ns1__GetTransactionByCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetTransactionByCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetTransactionByCondition);
	if (this->soap_out(soap, tag?tag:"ns1:GetTransactionByCondition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTransactionByCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTransactionByCondition(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTransactionByCondition * SOAP_FMAC4 soap_get__ns1__GetTransactionByCondition(struct soap *soap, _ns1__GetTransactionByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTransactionByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetTransactionByCondition * SOAP_FMAC2 soap_instantiate__ns1__GetTransactionByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTransactionByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetTransactionByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionByCondition);
		if (size)
			*size = sizeof(_ns1__GetTransactionByCondition);
		((_ns1__GetTransactionByCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetTransactionByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetTransactionByCondition);
		for (int i = 0; i < n; i++)
			((_ns1__GetTransactionByCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetTransactionByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetTransactionByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetTransactionByCondition %p -> %p\n", q, p));
	*(_ns1__GetTransactionByCondition*)p = *(_ns1__GetTransactionByCondition*)q;
}

void _ns1__GetPaymentItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPaymentItemResponse::GetPaymentItemResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPaymentItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PaymentItem(soap, &this->_ns1__GetPaymentItemResponse::GetPaymentItemResult);
	/* transient soap skipped */
}

int _ns1__GetPaymentItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentItemResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentItemResponse), type))
		return soap->error;
	if (a->GetPaymentItemResult)
		soap_element_result(soap, "ns1:GetPaymentItemResult");
	if (soap_out_PointerTons1__PaymentItem(soap, "ns1:GetPaymentItemResult", -1, &(a->_ns1__GetPaymentItemResponse::GetPaymentItemResult), "ns1:PaymentItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentItemResponse * SOAP_FMAC4 soap_in__ns1__GetPaymentItemResponse(struct soap *soap, const char *tag, _ns1__GetPaymentItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentItemResponse, sizeof(_ns1__GetPaymentItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPaymentItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPaymentItemResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PaymentItem(soap, "ns1:GetPaymentItemResult", &(a->_ns1__GetPaymentItemResponse::GetPaymentItemResult), "ns1:PaymentItem"))
				{	soap_flag_GetPaymentItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPaymentItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentItemResponse, 0, sizeof(_ns1__GetPaymentItemResponse), 0, soap_copy__ns1__GetPaymentItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPaymentItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentItemResponse * SOAP_FMAC4 soap_get__ns1__GetPaymentItemResponse(struct soap *soap, _ns1__GetPaymentItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentItemResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentItemResponse);
		if (size)
			*size = sizeof(_ns1__GetPaymentItemResponse);
		((_ns1__GetPaymentItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentItemResponse %p -> %p\n", q, p));
	*(_ns1__GetPaymentItemResponse*)p = *(_ns1__GetPaymentItemResponse*)q;
}

void _ns1__GetPaymentItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPaymentItem::condition);
	soap_default_string(soap, &this->_ns1__GetPaymentItem::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPaymentItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPaymentItem::condition);
	soap_serialize_string(soap, &this->_ns1__GetPaymentItem::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPaymentItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentItem(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPaymentItem::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPaymentItem::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentItem * SOAP_FMAC4 soap_in__ns1__GetPaymentItem(struct soap *soap, const char *tag, _ns1__GetPaymentItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentItem, sizeof(_ns1__GetPaymentItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPaymentItem::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPaymentItem::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentItem, 0, sizeof(_ns1__GetPaymentItem), 0, soap_copy__ns1__GetPaymentItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPaymentItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentItem);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentItem * SOAP_FMAC4 soap_get__ns1__GetPaymentItem(struct soap *soap, _ns1__GetPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentItem * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentItem);
		if (size)
			*size = sizeof(_ns1__GetPaymentItem);
		((_ns1__GetPaymentItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentItem);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentItem %p -> %p\n", q, p));
	*(_ns1__GetPaymentItem*)p = *(_ns1__GetPaymentItem*)q;
}

void _ns1__GetPaymentRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPaymentRecordResponse::GetPaymentRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetPaymentRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPaymentItem(soap, &this->_ns1__GetPaymentRecordResponse::GetPaymentRecordResult);
	/* transient soap skipped */
}

int _ns1__GetPaymentRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentRecordResponse), type))
		return soap->error;
	if (a->GetPaymentRecordResult)
		soap_element_result(soap, "ns1:GetPaymentRecordResult");
	if (soap_out_PointerTons1__ArrayOfPaymentItem(soap, "ns1:GetPaymentRecordResult", -1, &(a->_ns1__GetPaymentRecordResponse::GetPaymentRecordResult), "ns1:ArrayOfPaymentItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecordResponse * SOAP_FMAC4 soap_in__ns1__GetPaymentRecordResponse(struct soap *soap, const char *tag, _ns1__GetPaymentRecordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentRecordResponse, sizeof(_ns1__GetPaymentRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPaymentRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPaymentRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPaymentItem(soap, "ns1:GetPaymentRecordResult", &(a->_ns1__GetPaymentRecordResponse::GetPaymentRecordResult), "ns1:ArrayOfPaymentItem"))
				{	soap_flag_GetPaymentRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPaymentRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentRecordResponse, 0, sizeof(_ns1__GetPaymentRecordResponse), 0, soap_copy__ns1__GetPaymentRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPaymentRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecordResponse * SOAP_FMAC4 soap_get__ns1__GetPaymentRecordResponse(struct soap *soap, _ns1__GetPaymentRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentRecordResponse);
		if (size)
			*size = sizeof(_ns1__GetPaymentRecordResponse);
		((_ns1__GetPaymentRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentRecordResponse %p -> %p\n", q, p));
	*(_ns1__GetPaymentRecordResponse*)p = *(_ns1__GetPaymentRecordResponse*)q;
}

void _ns1__GetPaymentRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPaymentRecord::top);
	soap_default_string(soap, &this->_ns1__GetPaymentRecord::condition);
	soap_default_string(soap, &this->_ns1__GetPaymentRecord::sessionId);
	/* transient soap skipped */
}

void _ns1__GetPaymentRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPaymentRecord::condition);
	soap_serialize_string(soap, &this->_ns1__GetPaymentRecord::sessionId);
	/* transient soap skipped */
}

int _ns1__GetPaymentRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPaymentRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPaymentRecord(struct soap *soap, const char *tag, int id, const _ns1__GetPaymentRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPaymentRecord), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetPaymentRecord::top), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:condition", -1, &(a->_ns1__GetPaymentRecord::condition), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetPaymentRecord::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPaymentRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPaymentRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecord * SOAP_FMAC4 soap_in__ns1__GetPaymentRecord(struct soap *soap, const char *tag, _ns1__GetPaymentRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPaymentRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPaymentRecord, sizeof(_ns1__GetPaymentRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPaymentRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPaymentRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_top1 = 1;
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetPaymentRecord::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:condition", &(a->_ns1__GetPaymentRecord::condition), "xsd:string"))
				{	soap_flag_condition1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetPaymentRecord::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPaymentRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPaymentRecord, 0, sizeof(_ns1__GetPaymentRecord), 0, soap_copy__ns1__GetPaymentRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetPaymentRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPaymentRecord);
	if (this->soap_out(soap, tag?tag:"ns1:GetPaymentRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPaymentRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPaymentRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecord * SOAP_FMAC4 soap_get__ns1__GetPaymentRecord(struct soap *soap, _ns1__GetPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPaymentRecord * SOAP_FMAC2 soap_instantiate__ns1__GetPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentRecord);
		if (size)
			*size = sizeof(_ns1__GetPaymentRecord);
		((_ns1__GetPaymentRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPaymentRecord);
		for (int i = 0; i < n; i++)
			((_ns1__GetPaymentRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPaymentRecord %p -> %p\n", q, p));
	*(_ns1__GetPaymentRecord*)p = *(_ns1__GetPaymentRecord*)q;
}

void _ns1__PayPublicTelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayPublicTelResponse::PayPublicTelResult);
	/* transient soap skipped */
}

void _ns1__PayPublicTelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayPublicTelResponse::PayPublicTelResult);
	/* transient soap skipped */
}

int _ns1__PayPublicTelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayPublicTelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayPublicTelResponse(struct soap *soap, const char *tag, int id, const _ns1__PayPublicTelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayPublicTelResponse), type))
		return soap->error;
	if (a->PayPublicTelResult)
		soap_element_result(soap, "ns1:PayPublicTelResult");
	if (soap_out_string(soap, "ns1:PayPublicTelResult", -1, &(a->_ns1__PayPublicTelResponse::PayPublicTelResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayPublicTelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayPublicTelResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayPublicTelResponse * SOAP_FMAC4 soap_in__ns1__PayPublicTelResponse(struct soap *soap, const char *tag, _ns1__PayPublicTelResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayPublicTelResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayPublicTelResponse, sizeof(_ns1__PayPublicTelResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayPublicTelResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayPublicTelResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayPublicTelResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayPublicTelResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PayPublicTelResult", &(a->_ns1__PayPublicTelResponse::PayPublicTelResult), "xsd:string"))
				{	soap_flag_PayPublicTelResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayPublicTelResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayPublicTelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayPublicTelResponse, 0, sizeof(_ns1__PayPublicTelResponse), 0, soap_copy__ns1__PayPublicTelResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayPublicTelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayPublicTelResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayPublicTelResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayPublicTelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayPublicTelResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayPublicTelResponse * SOAP_FMAC4 soap_get__ns1__PayPublicTelResponse(struct soap *soap, _ns1__PayPublicTelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayPublicTelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayPublicTelResponse * SOAP_FMAC2 soap_instantiate__ns1__PayPublicTelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayPublicTelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayPublicTelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayPublicTelResponse);
		if (size)
			*size = sizeof(_ns1__PayPublicTelResponse);
		((_ns1__PayPublicTelResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayPublicTelResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayPublicTelResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayPublicTelResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayPublicTelResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayPublicTelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayPublicTelResponse %p -> %p\n", q, p));
	*(_ns1__PayPublicTelResponse*)p = *(_ns1__PayPublicTelResponse*)q;
}

void _ns1__PayPublicTel::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayPublicTel::telType);
	soap_default_string(soap, &this->_ns1__PayPublicTel::telAccount);
	soap_default_string(soap, &this->_ns1__PayPublicTel::money);
	soap_default_string(soap, &this->_ns1__PayPublicTel::content);
	soap_default_string(soap, &this->_ns1__PayPublicTel::userId);
	soap_default_string(soap, &this->_ns1__PayPublicTel::userName);
	soap_default_string(soap, &this->_ns1__PayPublicTel::sessionId);
	soap_default_string(soap, &this->_ns1__PayPublicTel::clientType);
	/* transient soap skipped */
}

void _ns1__PayPublicTel::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::telType);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::telAccount);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::money);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::content);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::userId);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::userName);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::sessionId);
	soap_serialize_string(soap, &this->_ns1__PayPublicTel::clientType);
	/* transient soap skipped */
}

int _ns1__PayPublicTel::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayPublicTel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayPublicTel(struct soap *soap, const char *tag, int id, const _ns1__PayPublicTel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayPublicTel), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:telType", -1, &(a->_ns1__PayPublicTel::telType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:telAccount", -1, &(a->_ns1__PayPublicTel::telAccount), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:money", -1, &(a->_ns1__PayPublicTel::money), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__PayPublicTel::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayPublicTel::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayPublicTel::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayPublicTel::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__PayPublicTel::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayPublicTel::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayPublicTel(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayPublicTel * SOAP_FMAC4 soap_in__ns1__PayPublicTel(struct soap *soap, const char *tag, _ns1__PayPublicTel *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayPublicTel *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayPublicTel, sizeof(_ns1__PayPublicTel), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayPublicTel)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayPublicTel *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_telType1 = 1;
	size_t soap_flag_telAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_telType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telType", &(a->_ns1__PayPublicTel::telType), "xsd:string"))
				{	soap_flag_telType1--;
					continue;
				}
			if (soap_flag_telAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telAccount", &(a->_ns1__PayPublicTel::telAccount), "xsd:string"))
				{	soap_flag_telAccount1--;
					continue;
				}
			if (soap_flag_money1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:money", &(a->_ns1__PayPublicTel::money), "xsd:string"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__PayPublicTel::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayPublicTel::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayPublicTel::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayPublicTel::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__PayPublicTel::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayPublicTel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayPublicTel, 0, sizeof(_ns1__PayPublicTel), 0, soap_copy__ns1__PayPublicTel);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayPublicTel::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayPublicTel);
	if (this->soap_out(soap, tag?tag:"ns1:PayPublicTel", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayPublicTel::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayPublicTel(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayPublicTel * SOAP_FMAC4 soap_get__ns1__PayPublicTel(struct soap *soap, _ns1__PayPublicTel *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayPublicTel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayPublicTel * SOAP_FMAC2 soap_instantiate__ns1__PayPublicTel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayPublicTel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayPublicTel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayPublicTel);
		if (size)
			*size = sizeof(_ns1__PayPublicTel);
		((_ns1__PayPublicTel*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayPublicTel[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayPublicTel);
		for (int i = 0; i < n; i++)
			((_ns1__PayPublicTel*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayPublicTel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayPublicTel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayPublicTel %p -> %p\n", q, p));
	*(_ns1__PayPublicTel*)p = *(_ns1__PayPublicTel*)q;
}

void _ns1__PayGameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayGameResponse::PayGameResult);
	/* transient soap skipped */
}

void _ns1__PayGameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayGameResponse::PayGameResult);
	/* transient soap skipped */
}

int _ns1__PayGameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayGameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayGameResponse(struct soap *soap, const char *tag, int id, const _ns1__PayGameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayGameResponse), type))
		return soap->error;
	if (a->PayGameResult)
		soap_element_result(soap, "ns1:PayGameResult");
	if (soap_out_string(soap, "ns1:PayGameResult", -1, &(a->_ns1__PayGameResponse::PayGameResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayGameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayGameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayGameResponse * SOAP_FMAC4 soap_in__ns1__PayGameResponse(struct soap *soap, const char *tag, _ns1__PayGameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayGameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayGameResponse, sizeof(_ns1__PayGameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayGameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayGameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayGameResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayGameResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PayGameResult", &(a->_ns1__PayGameResponse::PayGameResult), "xsd:string"))
				{	soap_flag_PayGameResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayGameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayGameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayGameResponse, 0, sizeof(_ns1__PayGameResponse), 0, soap_copy__ns1__PayGameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayGameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayGameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayGameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayGameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayGameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayGameResponse * SOAP_FMAC4 soap_get__ns1__PayGameResponse(struct soap *soap, _ns1__PayGameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayGameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayGameResponse * SOAP_FMAC2 soap_instantiate__ns1__PayGameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayGameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayGameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayGameResponse);
		if (size)
			*size = sizeof(_ns1__PayGameResponse);
		((_ns1__PayGameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayGameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayGameResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayGameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayGameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayGameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayGameResponse %p -> %p\n", q, p));
	*(_ns1__PayGameResponse*)p = *(_ns1__PayGameResponse*)q;
}

void _ns1__PayGame::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayGame::gameType);
	soap_default_string(soap, &this->_ns1__PayGame::gameAccount);
	soap_default_string(soap, &this->_ns1__PayGame::money);
	soap_default_string(soap, &this->_ns1__PayGame::content);
	soap_default_string(soap, &this->_ns1__PayGame::userId);
	soap_default_string(soap, &this->_ns1__PayGame::userName);
	soap_default_string(soap, &this->_ns1__PayGame::sessionId);
	soap_default_string(soap, &this->_ns1__PayGame::clientType);
	/* transient soap skipped */
}

void _ns1__PayGame::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayGame::gameType);
	soap_serialize_string(soap, &this->_ns1__PayGame::gameAccount);
	soap_serialize_string(soap, &this->_ns1__PayGame::money);
	soap_serialize_string(soap, &this->_ns1__PayGame::content);
	soap_serialize_string(soap, &this->_ns1__PayGame::userId);
	soap_serialize_string(soap, &this->_ns1__PayGame::userName);
	soap_serialize_string(soap, &this->_ns1__PayGame::sessionId);
	soap_serialize_string(soap, &this->_ns1__PayGame::clientType);
	/* transient soap skipped */
}

int _ns1__PayGame::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayGame(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayGame(struct soap *soap, const char *tag, int id, const _ns1__PayGame *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayGame), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:gameType", -1, &(a->_ns1__PayGame::gameType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:gameAccount", -1, &(a->_ns1__PayGame::gameAccount), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:money", -1, &(a->_ns1__PayGame::money), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__PayGame::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayGame::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayGame::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayGame::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__PayGame::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayGame::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayGame(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayGame * SOAP_FMAC4 soap_in__ns1__PayGame(struct soap *soap, const char *tag, _ns1__PayGame *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayGame *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayGame, sizeof(_ns1__PayGame), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayGame)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayGame *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gameType1 = 1;
	size_t soap_flag_gameAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gameType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gameType", &(a->_ns1__PayGame::gameType), "xsd:string"))
				{	soap_flag_gameType1--;
					continue;
				}
			if (soap_flag_gameAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gameAccount", &(a->_ns1__PayGame::gameAccount), "xsd:string"))
				{	soap_flag_gameAccount1--;
					continue;
				}
			if (soap_flag_money1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:money", &(a->_ns1__PayGame::money), "xsd:string"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__PayGame::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayGame::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayGame::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayGame::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__PayGame::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayGame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayGame, 0, sizeof(_ns1__PayGame), 0, soap_copy__ns1__PayGame);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayGame::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayGame);
	if (this->soap_out(soap, tag?tag:"ns1:PayGame", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayGame::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayGame(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayGame * SOAP_FMAC4 soap_get__ns1__PayGame(struct soap *soap, _ns1__PayGame *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayGame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayGame * SOAP_FMAC2 soap_instantiate__ns1__PayGame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayGame(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayGame, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayGame);
		if (size)
			*size = sizeof(_ns1__PayGame);
		((_ns1__PayGame*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayGame[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayGame);
		for (int i = 0; i < n; i++)
			((_ns1__PayGame*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayGame*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayGame(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayGame %p -> %p\n", q, p));
	*(_ns1__PayGame*)p = *(_ns1__PayGame*)q;
}

void _ns1__RequstInternetRollbackResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RequstInternetRollbackResponse::RequstInternetRollbackResult);
	/* transient soap skipped */
}

void _ns1__RequstInternetRollbackResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RequstInternetRollbackResponse::RequstInternetRollbackResult);
	/* transient soap skipped */
}

int _ns1__RequstInternetRollbackResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RequstInternetRollbackResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RequstInternetRollbackResponse(struct soap *soap, const char *tag, int id, const _ns1__RequstInternetRollbackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RequstInternetRollbackResponse), type))
		return soap->error;
	if (a->RequstInternetRollbackResult)
		soap_element_result(soap, "ns1:RequstInternetRollbackResult");
	if (soap_out_string(soap, "ns1:RequstInternetRollbackResult", -1, &(a->_ns1__RequstInternetRollbackResponse::RequstInternetRollbackResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RequstInternetRollbackResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RequstInternetRollbackResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollbackResponse * SOAP_FMAC4 soap_in__ns1__RequstInternetRollbackResponse(struct soap *soap, const char *tag, _ns1__RequstInternetRollbackResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RequstInternetRollbackResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RequstInternetRollbackResponse, sizeof(_ns1__RequstInternetRollbackResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RequstInternetRollbackResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RequstInternetRollbackResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RequstInternetRollbackResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequstInternetRollbackResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:RequstInternetRollbackResult", &(a->_ns1__RequstInternetRollbackResponse::RequstInternetRollbackResult), "xsd:string"))
				{	soap_flag_RequstInternetRollbackResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RequstInternetRollbackResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RequstInternetRollbackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RequstInternetRollbackResponse, 0, sizeof(_ns1__RequstInternetRollbackResponse), 0, soap_copy__ns1__RequstInternetRollbackResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RequstInternetRollbackResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RequstInternetRollbackResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RequstInternetRollbackResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RequstInternetRollbackResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RequstInternetRollbackResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollbackResponse * SOAP_FMAC4 soap_get__ns1__RequstInternetRollbackResponse(struct soap *soap, _ns1__RequstInternetRollbackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RequstInternetRollbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RequstInternetRollbackResponse * SOAP_FMAC2 soap_instantiate__ns1__RequstInternetRollbackResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RequstInternetRollbackResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RequstInternetRollbackResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstInternetRollbackResponse);
		if (size)
			*size = sizeof(_ns1__RequstInternetRollbackResponse);
		((_ns1__RequstInternetRollbackResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstInternetRollbackResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RequstInternetRollbackResponse);
		for (int i = 0; i < n; i++)
			((_ns1__RequstInternetRollbackResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RequstInternetRollbackResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RequstInternetRollbackResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RequstInternetRollbackResponse %p -> %p\n", q, p));
	*(_ns1__RequstInternetRollbackResponse*)p = *(_ns1__RequstInternetRollbackResponse*)q;
}

void _ns1__RequstInternetRollback::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RequstInternetRollback::paymentId);
	soap_default_string(soap, &this->_ns1__RequstInternetRollback::userId);
	soap_default_string(soap, &this->_ns1__RequstInternetRollback::type);
	soap_default_string(soap, &this->_ns1__RequstInternetRollback::sessionId);
	/* transient soap skipped */
}

void _ns1__RequstInternetRollback::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RequstInternetRollback::paymentId);
	soap_serialize_string(soap, &this->_ns1__RequstInternetRollback::userId);
	soap_serialize_string(soap, &this->_ns1__RequstInternetRollback::type);
	soap_serialize_string(soap, &this->_ns1__RequstInternetRollback::sessionId);
	/* transient soap skipped */
}

int _ns1__RequstInternetRollback::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RequstInternetRollback(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RequstInternetRollback(struct soap *soap, const char *tag, int id, const _ns1__RequstInternetRollback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RequstInternetRollback), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentId", -1, &(a->_ns1__RequstInternetRollback::paymentId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__RequstInternetRollback::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->_ns1__RequstInternetRollback::type), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__RequstInternetRollback::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RequstInternetRollback::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RequstInternetRollback(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollback * SOAP_FMAC4 soap_in__ns1__RequstInternetRollback(struct soap *soap, const char *tag, _ns1__RequstInternetRollback *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RequstInternetRollback *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RequstInternetRollback, sizeof(_ns1__RequstInternetRollback), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RequstInternetRollback)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RequstInternetRollback *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_paymentId1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentId", &(a->_ns1__RequstInternetRollback::paymentId), "xsd:string"))
				{	soap_flag_paymentId1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__RequstInternetRollback::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->_ns1__RequstInternetRollback::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__RequstInternetRollback::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RequstInternetRollback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RequstInternetRollback, 0, sizeof(_ns1__RequstInternetRollback), 0, soap_copy__ns1__RequstInternetRollback);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RequstInternetRollback::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RequstInternetRollback);
	if (this->soap_out(soap, tag?tag:"ns1:RequstInternetRollback", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RequstInternetRollback::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RequstInternetRollback(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollback * SOAP_FMAC4 soap_get__ns1__RequstInternetRollback(struct soap *soap, _ns1__RequstInternetRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RequstInternetRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RequstInternetRollback * SOAP_FMAC2 soap_instantiate__ns1__RequstInternetRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RequstInternetRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RequstInternetRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstInternetRollback);
		if (size)
			*size = sizeof(_ns1__RequstInternetRollback);
		((_ns1__RequstInternetRollback*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstInternetRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RequstInternetRollback);
		for (int i = 0; i < n; i++)
			((_ns1__RequstInternetRollback*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RequstInternetRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RequstInternetRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RequstInternetRollback %p -> %p\n", q, p));
	*(_ns1__RequstInternetRollback*)p = *(_ns1__RequstInternetRollback*)q;
}

void _ns1__PayInternetWithListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PayInternetWithListResponse::PayInternetWithListResult = NULL;
	/* transient soap skipped */
}

void _ns1__PayInternetWithListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PayWithListResult(soap, &this->_ns1__PayInternetWithListResponse::PayInternetWithListResult);
	/* transient soap skipped */
}

int _ns1__PayInternetWithListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayInternetWithListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayInternetWithListResponse(struct soap *soap, const char *tag, int id, const _ns1__PayInternetWithListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayInternetWithListResponse), type))
		return soap->error;
	if (a->PayInternetWithListResult)
		soap_element_result(soap, "ns1:PayInternetWithListResult");
	if (soap_out_PointerTons1__PayWithListResult(soap, "ns1:PayInternetWithListResult", -1, &(a->_ns1__PayInternetWithListResponse::PayInternetWithListResult), "ns1:PayWithListResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayInternetWithListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayInternetWithListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayInternetWithListResponse * SOAP_FMAC4 soap_in__ns1__PayInternetWithListResponse(struct soap *soap, const char *tag, _ns1__PayInternetWithListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayInternetWithListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayInternetWithListResponse, sizeof(_ns1__PayInternetWithListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayInternetWithListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayInternetWithListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayInternetWithListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayInternetWithListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PayWithListResult(soap, "ns1:PayInternetWithListResult", &(a->_ns1__PayInternetWithListResponse::PayInternetWithListResult), "ns1:PayWithListResult"))
				{	soap_flag_PayInternetWithListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayInternetWithListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayInternetWithListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayInternetWithListResponse, 0, sizeof(_ns1__PayInternetWithListResponse), 0, soap_copy__ns1__PayInternetWithListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayInternetWithListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayInternetWithListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayInternetWithListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayInternetWithListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayInternetWithListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayInternetWithListResponse * SOAP_FMAC4 soap_get__ns1__PayInternetWithListResponse(struct soap *soap, _ns1__PayInternetWithListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayInternetWithListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayInternetWithListResponse * SOAP_FMAC2 soap_instantiate__ns1__PayInternetWithListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayInternetWithListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayInternetWithListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetWithListResponse);
		if (size)
			*size = sizeof(_ns1__PayInternetWithListResponse);
		((_ns1__PayInternetWithListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetWithListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayInternetWithListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayInternetWithListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayInternetWithListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayInternetWithListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayInternetWithListResponse %p -> %p\n", q, p));
	*(_ns1__PayInternetWithListResponse*)p = *(_ns1__PayInternetWithListResponse*)q;
}

void _ns1__PayInternetWithList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayInternetWithList::data);
	soap_default_string(soap, &this->_ns1__PayInternetWithList::userId);
	soap_default_string(soap, &this->_ns1__PayInternetWithList::userName);
	soap_default_string(soap, &this->_ns1__PayInternetWithList::sessionId);
	/* transient soap skipped */
}

void _ns1__PayInternetWithList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayInternetWithList::data);
	soap_serialize_string(soap, &this->_ns1__PayInternetWithList::userId);
	soap_serialize_string(soap, &this->_ns1__PayInternetWithList::userName);
	soap_serialize_string(soap, &this->_ns1__PayInternetWithList::sessionId);
	/* transient soap skipped */
}

int _ns1__PayInternetWithList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayInternetWithList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayInternetWithList(struct soap *soap, const char *tag, int id, const _ns1__PayInternetWithList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayInternetWithList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:data", -1, &(a->_ns1__PayInternetWithList::data), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayInternetWithList::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayInternetWithList::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayInternetWithList::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayInternetWithList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayInternetWithList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayInternetWithList * SOAP_FMAC4 soap_in__ns1__PayInternetWithList(struct soap *soap, const char *tag, _ns1__PayInternetWithList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayInternetWithList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayInternetWithList, sizeof(_ns1__PayInternetWithList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayInternetWithList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayInternetWithList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_data1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:data", &(a->_ns1__PayInternetWithList::data), "xsd:string"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayInternetWithList::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayInternetWithList::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayInternetWithList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayInternetWithList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayInternetWithList, 0, sizeof(_ns1__PayInternetWithList), 0, soap_copy__ns1__PayInternetWithList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayInternetWithList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayInternetWithList);
	if (this->soap_out(soap, tag?tag:"ns1:PayInternetWithList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayInternetWithList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayInternetWithList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayInternetWithList * SOAP_FMAC4 soap_get__ns1__PayInternetWithList(struct soap *soap, _ns1__PayInternetWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayInternetWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayInternetWithList * SOAP_FMAC2 soap_instantiate__ns1__PayInternetWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayInternetWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayInternetWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetWithList);
		if (size)
			*size = sizeof(_ns1__PayInternetWithList);
		((_ns1__PayInternetWithList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayInternetWithList);
		for (int i = 0; i < n; i++)
			((_ns1__PayInternetWithList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayInternetWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayInternetWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayInternetWithList %p -> %p\n", q, p));
	*(_ns1__PayInternetWithList*)p = *(_ns1__PayInternetWithList*)q;
}

void _ns1__PayInternetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayInternetResponse::PayInternetResult);
	/* transient soap skipped */
}

void _ns1__PayInternetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayInternetResponse::PayInternetResult);
	/* transient soap skipped */
}

int _ns1__PayInternetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayInternetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayInternetResponse(struct soap *soap, const char *tag, int id, const _ns1__PayInternetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayInternetResponse), type))
		return soap->error;
	if (a->PayInternetResult)
		soap_element_result(soap, "ns1:PayInternetResult");
	if (soap_out_string(soap, "ns1:PayInternetResult", -1, &(a->_ns1__PayInternetResponse::PayInternetResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayInternetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayInternetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayInternetResponse * SOAP_FMAC4 soap_in__ns1__PayInternetResponse(struct soap *soap, const char *tag, _ns1__PayInternetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayInternetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayInternetResponse, sizeof(_ns1__PayInternetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayInternetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayInternetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayInternetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayInternetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PayInternetResult", &(a->_ns1__PayInternetResponse::PayInternetResult), "xsd:string"))
				{	soap_flag_PayInternetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayInternetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayInternetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayInternetResponse, 0, sizeof(_ns1__PayInternetResponse), 0, soap_copy__ns1__PayInternetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayInternetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayInternetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayInternetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayInternetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayInternetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayInternetResponse * SOAP_FMAC4 soap_get__ns1__PayInternetResponse(struct soap *soap, _ns1__PayInternetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayInternetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayInternetResponse * SOAP_FMAC2 soap_instantiate__ns1__PayInternetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayInternetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayInternetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetResponse);
		if (size)
			*size = sizeof(_ns1__PayInternetResponse);
		((_ns1__PayInternetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayInternetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayInternetResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayInternetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayInternetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayInternetResponse %p -> %p\n", q, p));
	*(_ns1__PayInternetResponse*)p = *(_ns1__PayInternetResponse*)q;
}

void _ns1__PayInternet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayInternet::internetType);
	soap_default_string(soap, &this->_ns1__PayInternet::internetAccount);
	soap_default_string(soap, &this->_ns1__PayInternet::money);
	soap_default_string(soap, &this->_ns1__PayInternet::content);
	soap_default_string(soap, &this->_ns1__PayInternet::userId);
	soap_default_string(soap, &this->_ns1__PayInternet::userName);
	soap_default_string(soap, &this->_ns1__PayInternet::sessionId);
	soap_default_string(soap, &this->_ns1__PayInternet::clientType);
	/* transient soap skipped */
}

void _ns1__PayInternet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayInternet::internetType);
	soap_serialize_string(soap, &this->_ns1__PayInternet::internetAccount);
	soap_serialize_string(soap, &this->_ns1__PayInternet::money);
	soap_serialize_string(soap, &this->_ns1__PayInternet::content);
	soap_serialize_string(soap, &this->_ns1__PayInternet::userId);
	soap_serialize_string(soap, &this->_ns1__PayInternet::userName);
	soap_serialize_string(soap, &this->_ns1__PayInternet::sessionId);
	soap_serialize_string(soap, &this->_ns1__PayInternet::clientType);
	/* transient soap skipped */
}

int _ns1__PayInternet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayInternet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayInternet(struct soap *soap, const char *tag, int id, const _ns1__PayInternet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayInternet), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:internetType", -1, &(a->_ns1__PayInternet::internetType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:internetAccount", -1, &(a->_ns1__PayInternet::internetAccount), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:money", -1, &(a->_ns1__PayInternet::money), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->_ns1__PayInternet::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayInternet::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayInternet::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayInternet::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__PayInternet::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayInternet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayInternet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayInternet * SOAP_FMAC4 soap_in__ns1__PayInternet(struct soap *soap, const char *tag, _ns1__PayInternet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayInternet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayInternet, sizeof(_ns1__PayInternet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayInternet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayInternet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_internetType1 = 1;
	size_t soap_flag_internetAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_internetType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:internetType", &(a->_ns1__PayInternet::internetType), "xsd:string"))
				{	soap_flag_internetType1--;
					continue;
				}
			if (soap_flag_internetAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:internetAccount", &(a->_ns1__PayInternet::internetAccount), "xsd:string"))
				{	soap_flag_internetAccount1--;
					continue;
				}
			if (soap_flag_money1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:money", &(a->_ns1__PayInternet::money), "xsd:string"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->_ns1__PayInternet::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayInternet::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayInternet::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayInternet::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__PayInternet::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayInternet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayInternet, 0, sizeof(_ns1__PayInternet), 0, soap_copy__ns1__PayInternet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayInternet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayInternet);
	if (this->soap_out(soap, tag?tag:"ns1:PayInternet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayInternet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayInternet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayInternet * SOAP_FMAC4 soap_get__ns1__PayInternet(struct soap *soap, _ns1__PayInternet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayInternet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayInternet * SOAP_FMAC2 soap_instantiate__ns1__PayInternet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayInternet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayInternet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternet);
		if (size)
			*size = sizeof(_ns1__PayInternet);
		((_ns1__PayInternet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayInternet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayInternet);
		for (int i = 0; i < n; i++)
			((_ns1__PayInternet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayInternet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayInternet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayInternet %p -> %p\n", q, p));
	*(_ns1__PayInternet*)p = *(_ns1__PayInternet*)q;
}

void _ns1__RequstRollbackResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RequstRollbackResponse::RequstRollbackResult);
	/* transient soap skipped */
}

void _ns1__RequstRollbackResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RequstRollbackResponse::RequstRollbackResult);
	/* transient soap skipped */
}

int _ns1__RequstRollbackResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RequstRollbackResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RequstRollbackResponse(struct soap *soap, const char *tag, int id, const _ns1__RequstRollbackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RequstRollbackResponse), type))
		return soap->error;
	if (a->RequstRollbackResult)
		soap_element_result(soap, "ns1:RequstRollbackResult");
	if (soap_out_string(soap, "ns1:RequstRollbackResult", -1, &(a->_ns1__RequstRollbackResponse::RequstRollbackResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RequstRollbackResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RequstRollbackResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RequstRollbackResponse * SOAP_FMAC4 soap_in__ns1__RequstRollbackResponse(struct soap *soap, const char *tag, _ns1__RequstRollbackResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RequstRollbackResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RequstRollbackResponse, sizeof(_ns1__RequstRollbackResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RequstRollbackResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RequstRollbackResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RequstRollbackResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequstRollbackResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:RequstRollbackResult", &(a->_ns1__RequstRollbackResponse::RequstRollbackResult), "xsd:string"))
				{	soap_flag_RequstRollbackResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RequstRollbackResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RequstRollbackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RequstRollbackResponse, 0, sizeof(_ns1__RequstRollbackResponse), 0, soap_copy__ns1__RequstRollbackResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RequstRollbackResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RequstRollbackResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RequstRollbackResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RequstRollbackResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RequstRollbackResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RequstRollbackResponse * SOAP_FMAC4 soap_get__ns1__RequstRollbackResponse(struct soap *soap, _ns1__RequstRollbackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RequstRollbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RequstRollbackResponse * SOAP_FMAC2 soap_instantiate__ns1__RequstRollbackResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RequstRollbackResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RequstRollbackResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstRollbackResponse);
		if (size)
			*size = sizeof(_ns1__RequstRollbackResponse);
		((_ns1__RequstRollbackResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstRollbackResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RequstRollbackResponse);
		for (int i = 0; i < n; i++)
			((_ns1__RequstRollbackResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RequstRollbackResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RequstRollbackResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RequstRollbackResponse %p -> %p\n", q, p));
	*(_ns1__RequstRollbackResponse*)p = *(_ns1__RequstRollbackResponse*)q;
}

void _ns1__RequstRollback::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RequstRollback::paymentId);
	soap_default_string(soap, &this->_ns1__RequstRollback::userId);
	soap_default_string(soap, &this->_ns1__RequstRollback::type);
	soap_default_string(soap, &this->_ns1__RequstRollback::sessionId);
	/* transient soap skipped */
}

void _ns1__RequstRollback::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RequstRollback::paymentId);
	soap_serialize_string(soap, &this->_ns1__RequstRollback::userId);
	soap_serialize_string(soap, &this->_ns1__RequstRollback::type);
	soap_serialize_string(soap, &this->_ns1__RequstRollback::sessionId);
	/* transient soap skipped */
}

int _ns1__RequstRollback::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RequstRollback(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RequstRollback(struct soap *soap, const char *tag, int id, const _ns1__RequstRollback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RequstRollback), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentId", -1, &(a->_ns1__RequstRollback::paymentId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__RequstRollback::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->_ns1__RequstRollback::type), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__RequstRollback::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RequstRollback::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RequstRollback(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RequstRollback * SOAP_FMAC4 soap_in__ns1__RequstRollback(struct soap *soap, const char *tag, _ns1__RequstRollback *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RequstRollback *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RequstRollback, sizeof(_ns1__RequstRollback), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RequstRollback)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RequstRollback *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_paymentId1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentId", &(a->_ns1__RequstRollback::paymentId), "xsd:string"))
				{	soap_flag_paymentId1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__RequstRollback::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->_ns1__RequstRollback::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__RequstRollback::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RequstRollback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RequstRollback, 0, sizeof(_ns1__RequstRollback), 0, soap_copy__ns1__RequstRollback);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RequstRollback::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RequstRollback);
	if (this->soap_out(soap, tag?tag:"ns1:RequstRollback", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RequstRollback::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RequstRollback(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RequstRollback * SOAP_FMAC4 soap_get__ns1__RequstRollback(struct soap *soap, _ns1__RequstRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RequstRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RequstRollback * SOAP_FMAC2 soap_instantiate__ns1__RequstRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RequstRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RequstRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstRollback);
		if (size)
			*size = sizeof(_ns1__RequstRollback);
		((_ns1__RequstRollback*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RequstRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RequstRollback);
		for (int i = 0; i < n; i++)
			((_ns1__RequstRollback*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RequstRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RequstRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RequstRollback %p -> %p\n", q, p));
	*(_ns1__RequstRollback*)p = *(_ns1__RequstRollback*)q;
}

void _ns1__PayMoneyWithListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PayMoneyWithListResponse::PayMoneyWithListResult = NULL;
	/* transient soap skipped */
}

void _ns1__PayMoneyWithListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PayWithListResult(soap, &this->_ns1__PayMoneyWithListResponse::PayMoneyWithListResult);
	/* transient soap skipped */
}

int _ns1__PayMoneyWithListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayMoneyWithListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayMoneyWithListResponse(struct soap *soap, const char *tag, int id, const _ns1__PayMoneyWithListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayMoneyWithListResponse), type))
		return soap->error;
	if (a->PayMoneyWithListResult)
		soap_element_result(soap, "ns1:PayMoneyWithListResult");
	if (soap_out_PointerTons1__PayWithListResult(soap, "ns1:PayMoneyWithListResult", -1, &(a->_ns1__PayMoneyWithListResponse::PayMoneyWithListResult), "ns1:PayWithListResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayMoneyWithListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayMoneyWithListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithListResponse * SOAP_FMAC4 soap_in__ns1__PayMoneyWithListResponse(struct soap *soap, const char *tag, _ns1__PayMoneyWithListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayMoneyWithListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayMoneyWithListResponse, sizeof(_ns1__PayMoneyWithListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayMoneyWithListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayMoneyWithListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayMoneyWithListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayMoneyWithListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PayWithListResult(soap, "ns1:PayMoneyWithListResult", &(a->_ns1__PayMoneyWithListResponse::PayMoneyWithListResult), "ns1:PayWithListResult"))
				{	soap_flag_PayMoneyWithListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayMoneyWithListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayMoneyWithListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayMoneyWithListResponse, 0, sizeof(_ns1__PayMoneyWithListResponse), 0, soap_copy__ns1__PayMoneyWithListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayMoneyWithListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayMoneyWithListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayMoneyWithListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayMoneyWithListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayMoneyWithListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithListResponse * SOAP_FMAC4 soap_get__ns1__PayMoneyWithListResponse(struct soap *soap, _ns1__PayMoneyWithListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayMoneyWithListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayMoneyWithListResponse * SOAP_FMAC2 soap_instantiate__ns1__PayMoneyWithListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayMoneyWithListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayMoneyWithListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyWithListResponse);
		if (size)
			*size = sizeof(_ns1__PayMoneyWithListResponse);
		((_ns1__PayMoneyWithListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyWithListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayMoneyWithListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayMoneyWithListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayMoneyWithListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayMoneyWithListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayMoneyWithListResponse %p -> %p\n", q, p));
	*(_ns1__PayMoneyWithListResponse*)p = *(_ns1__PayMoneyWithListResponse*)q;
}

void _ns1__PayMoneyWithList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayMoneyWithList::data);
	soap_default_string(soap, &this->_ns1__PayMoneyWithList::userId);
	soap_default_string(soap, &this->_ns1__PayMoneyWithList::userName);
	soap_default_string(soap, &this->_ns1__PayMoneyWithList::sessionId);
	soap_default_string(soap, &this->_ns1__PayMoneyWithList::SP);
	/* transient soap skipped */
}

void _ns1__PayMoneyWithList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayMoneyWithList::data);
	soap_serialize_string(soap, &this->_ns1__PayMoneyWithList::userId);
	soap_serialize_string(soap, &this->_ns1__PayMoneyWithList::userName);
	soap_serialize_string(soap, &this->_ns1__PayMoneyWithList::sessionId);
	soap_serialize_string(soap, &this->_ns1__PayMoneyWithList::SP);
	/* transient soap skipped */
}

int _ns1__PayMoneyWithList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayMoneyWithList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayMoneyWithList(struct soap *soap, const char *tag, int id, const _ns1__PayMoneyWithList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayMoneyWithList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:data", -1, &(a->_ns1__PayMoneyWithList::data), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayMoneyWithList::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayMoneyWithList::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayMoneyWithList::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->_ns1__PayMoneyWithList::SP), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayMoneyWithList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayMoneyWithList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithList * SOAP_FMAC4 soap_in__ns1__PayMoneyWithList(struct soap *soap, const char *tag, _ns1__PayMoneyWithList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayMoneyWithList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayMoneyWithList, sizeof(_ns1__PayMoneyWithList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayMoneyWithList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayMoneyWithList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_data1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_SP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:data", &(a->_ns1__PayMoneyWithList::data), "xsd:string"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayMoneyWithList::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayMoneyWithList::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayMoneyWithList::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->_ns1__PayMoneyWithList::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayMoneyWithList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayMoneyWithList, 0, sizeof(_ns1__PayMoneyWithList), 0, soap_copy__ns1__PayMoneyWithList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayMoneyWithList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayMoneyWithList);
	if (this->soap_out(soap, tag?tag:"ns1:PayMoneyWithList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayMoneyWithList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayMoneyWithList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithList * SOAP_FMAC4 soap_get__ns1__PayMoneyWithList(struct soap *soap, _ns1__PayMoneyWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayMoneyWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayMoneyWithList * SOAP_FMAC2 soap_instantiate__ns1__PayMoneyWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayMoneyWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayMoneyWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyWithList);
		if (size)
			*size = sizeof(_ns1__PayMoneyWithList);
		((_ns1__PayMoneyWithList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayMoneyWithList);
		for (int i = 0; i < n; i++)
			((_ns1__PayMoneyWithList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayMoneyWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayMoneyWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayMoneyWithList %p -> %p\n", q, p));
	*(_ns1__PayMoneyWithList*)p = *(_ns1__PayMoneyWithList*)q;
}

void _ns1__PayMoneyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayMoneyResponse::PayMoneyResult);
	/* transient soap skipped */
}

void _ns1__PayMoneyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayMoneyResponse::PayMoneyResult);
	/* transient soap skipped */
}

int _ns1__PayMoneyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayMoneyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayMoneyResponse(struct soap *soap, const char *tag, int id, const _ns1__PayMoneyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayMoneyResponse), type))
		return soap->error;
	if (a->PayMoneyResult)
		soap_element_result(soap, "ns1:PayMoneyResult");
	if (soap_out_string(soap, "ns1:PayMoneyResult", -1, &(a->_ns1__PayMoneyResponse::PayMoneyResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayMoneyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayMoneyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayMoneyResponse * SOAP_FMAC4 soap_in__ns1__PayMoneyResponse(struct soap *soap, const char *tag, _ns1__PayMoneyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayMoneyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayMoneyResponse, sizeof(_ns1__PayMoneyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayMoneyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayMoneyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PayMoneyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PayMoneyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PayMoneyResult", &(a->_ns1__PayMoneyResponse::PayMoneyResult), "xsd:string"))
				{	soap_flag_PayMoneyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PayMoneyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayMoneyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayMoneyResponse, 0, sizeof(_ns1__PayMoneyResponse), 0, soap_copy__ns1__PayMoneyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayMoneyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayMoneyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PayMoneyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayMoneyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayMoneyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayMoneyResponse * SOAP_FMAC4 soap_get__ns1__PayMoneyResponse(struct soap *soap, _ns1__PayMoneyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayMoneyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayMoneyResponse * SOAP_FMAC2 soap_instantiate__ns1__PayMoneyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayMoneyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayMoneyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyResponse);
		if (size)
			*size = sizeof(_ns1__PayMoneyResponse);
		((_ns1__PayMoneyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoneyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayMoneyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PayMoneyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayMoneyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayMoneyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayMoneyResponse %p -> %p\n", q, p));
	*(_ns1__PayMoneyResponse*)p = *(_ns1__PayMoneyResponse*)q;
}

void _ns1__PayMoney::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PayMoney::phoneNo);
	soap_default_string(soap, &this->_ns1__PayMoney::money);
	soap_default_string(soap, &this->_ns1__PayMoney::userId);
	soap_default_string(soap, &this->_ns1__PayMoney::userName);
	soap_default_string(soap, &this->_ns1__PayMoney::sessionId);
	soap_default_string(soap, &this->_ns1__PayMoney::SP);
	/* transient soap skipped */
}

void _ns1__PayMoney::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PayMoney::phoneNo);
	soap_serialize_string(soap, &this->_ns1__PayMoney::money);
	soap_serialize_string(soap, &this->_ns1__PayMoney::userId);
	soap_serialize_string(soap, &this->_ns1__PayMoney::userName);
	soap_serialize_string(soap, &this->_ns1__PayMoney::sessionId);
	soap_serialize_string(soap, &this->_ns1__PayMoney::SP);
	/* transient soap skipped */
}

int _ns1__PayMoney::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PayMoney(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PayMoney(struct soap *soap, const char *tag, int id, const _ns1__PayMoney *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PayMoney), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:phoneNo", -1, &(a->_ns1__PayMoney::phoneNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:money", -1, &(a->_ns1__PayMoney::money), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userId", -1, &(a->_ns1__PayMoney::userId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__PayMoney::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__PayMoney::sessionId), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->_ns1__PayMoney::SP), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PayMoney::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PayMoney(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PayMoney * SOAP_FMAC4 soap_in__ns1__PayMoney(struct soap *soap, const char *tag, _ns1__PayMoney *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PayMoney *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PayMoney, sizeof(_ns1__PayMoney), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PayMoney)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PayMoney *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_phoneNo1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_SP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_phoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:phoneNo", &(a->_ns1__PayMoney::phoneNo), "xsd:string"))
				{	soap_flag_phoneNo1--;
					continue;
				}
			if (soap_flag_money1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:money", &(a->_ns1__PayMoney::money), "xsd:string"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userId", &(a->_ns1__PayMoney::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__PayMoney::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__PayMoney::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->_ns1__PayMoney::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PayMoney *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PayMoney, 0, sizeof(_ns1__PayMoney), 0, soap_copy__ns1__PayMoney);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__PayMoney::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PayMoney);
	if (this->soap_out(soap, tag?tag:"ns1:PayMoney", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PayMoney::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PayMoney(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PayMoney * SOAP_FMAC4 soap_get__ns1__PayMoney(struct soap *soap, _ns1__PayMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PayMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PayMoney * SOAP_FMAC2 soap_instantiate__ns1__PayMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PayMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PayMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoney);
		if (size)
			*size = sizeof(_ns1__PayMoney);
		((_ns1__PayMoney*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PayMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PayMoney);
		for (int i = 0; i < n; i++)
			((_ns1__PayMoney*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PayMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PayMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PayMoney %p -> %p\n", q, p));
	*(_ns1__PayMoney*)p = *(_ns1__PayMoney*)q;
}

void _ns1__GetLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLocationResponse::GetLocationResult);
	/* transient soap skipped */
}

void _ns1__GetLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLocationResponse::GetLocationResult);
	/* transient soap skipped */
}

int _ns1__GetLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLocationResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLocationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLocationResponse), type))
		return soap->error;
	if (a->GetLocationResult)
		soap_element_result(soap, "ns1:GetLocationResult");
	if (soap_out_string(soap, "ns1:GetLocationResult", -1, &(a->_ns1__GetLocationResponse::GetLocationResult), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLocationResponse * SOAP_FMAC4 soap_in__ns1__GetLocationResponse(struct soap *soap, const char *tag, _ns1__GetLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLocationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLocationResponse, sizeof(_ns1__GetLocationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLocationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLocationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLocationResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLocationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetLocationResult", &(a->_ns1__GetLocationResponse::GetLocationResult), "xsd:string"))
				{	soap_flag_GetLocationResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLocationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLocationResponse, 0, sizeof(_ns1__GetLocationResponse), 0, soap_copy__ns1__GetLocationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLocationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLocationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLocationResponse * SOAP_FMAC4 soap_get__ns1__GetLocationResponse(struct soap *soap, _ns1__GetLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLocationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLocationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLocationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocationResponse);
		if (size)
			*size = sizeof(_ns1__GetLocationResponse);
		((_ns1__GetLocationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetLocationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetLocationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetLocationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLocationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLocationResponse %p -> %p\n", q, p));
	*(_ns1__GetLocationResponse*)p = *(_ns1__GetLocationResponse*)q;
}

void _ns1__GetLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLocation::phoneNo);
	soap_default_string(soap, &this->_ns1__GetLocation::clientType);
	soap_default_string(soap, &this->_ns1__GetLocation::sessionId);
	/* transient soap skipped */
}

void _ns1__GetLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLocation::phoneNo);
	soap_serialize_string(soap, &this->_ns1__GetLocation::clientType);
	soap_serialize_string(soap, &this->_ns1__GetLocation::sessionId);
	/* transient soap skipped */
}

int _ns1__GetLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLocation(struct soap *soap, const char *tag, int id, const _ns1__GetLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLocation), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:phoneNo", -1, &(a->_ns1__GetLocation::phoneNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->_ns1__GetLocation::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sessionId", -1, &(a->_ns1__GetLocation::sessionId), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLocation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLocation * SOAP_FMAC4 soap_in__ns1__GetLocation(struct soap *soap, const char *tag, _ns1__GetLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLocation, sizeof(_ns1__GetLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_phoneNo1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_phoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:phoneNo", &(a->_ns1__GetLocation::phoneNo), "xsd:string"))
				{	soap_flag_phoneNo1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->_ns1__GetLocation::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sessionId", &(a->_ns1__GetLocation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLocation, 0, sizeof(_ns1__GetLocation), 0, soap_copy__ns1__GetLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLocation);
	if (this->soap_out(soap, tag?tag:"ns1:GetLocation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLocation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLocation * SOAP_FMAC4 soap_get__ns1__GetLocation(struct soap *soap, _ns1__GetLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLocation * SOAP_FMAC2 soap_instantiate__ns1__GetLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocation);
		if (size)
			*size = sizeof(_ns1__GetLocation);
		((_ns1__GetLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetLocation);
		for (int i = 0; i < n; i++)
			((_ns1__GetLocation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLocation %p -> %p\n", q, p));
	*(_ns1__GetLocation*)p = *(_ns1__GetLocation*)q;
}

void ns1__StockCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__StockCardItem::Id);
	soap_default_string(soap, &this->ns1__StockCardItem::cardType);
	soap_default_string(soap, &this->ns1__StockCardItem::cardName);
	soap_default_string(soap, &this->ns1__StockCardItem::cardSeq);
	soap_default_string(soap, &this->ns1__StockCardItem::cardPsw);
	soap_default_time(soap, &this->ns1__StockCardItem::getDate);
	soap_default_ns2__guid(soap, &this->ns1__StockCardItem::getterId);
	soap_default_string(soap, &this->ns1__StockCardItem::getterName);
	soap_default_time(soap, &this->ns1__StockCardItem::sellDate);
	soap_default_ns2__guid(soap, &this->ns1__StockCardItem::userId);
	soap_default_string(soap, &this->ns1__StockCardItem::userName);
	soap_default_string(soap, &this->ns1__StockCardItem::state);
	/* transient soap skipped */
}

void ns1__StockCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__StockCardItem::Id);
	soap_serialize_string(soap, &this->ns1__StockCardItem::cardType);
	soap_serialize_string(soap, &this->ns1__StockCardItem::cardName);
	soap_serialize_string(soap, &this->ns1__StockCardItem::cardSeq);
	soap_serialize_string(soap, &this->ns1__StockCardItem::cardPsw);
	soap_serialize_ns2__guid(soap, &this->ns1__StockCardItem::getterId);
	soap_serialize_string(soap, &this->ns1__StockCardItem::getterName);
	soap_serialize_ns2__guid(soap, &this->ns1__StockCardItem::userId);
	soap_serialize_string(soap, &this->ns1__StockCardItem::userName);
	soap_serialize_string(soap, &this->ns1__StockCardItem::state);
	/* transient soap skipped */
}

int ns1__StockCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StockCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StockCardItem(struct soap *soap, const char *tag, int id, const ns1__StockCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StockCardItem), type))
		return soap->error;
	if (a->ns1__StockCardItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__StockCardItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardType", -1, &(a->ns1__StockCardItem::cardType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardName", -1, &(a->ns1__StockCardItem::cardName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardSeq", -1, &(a->ns1__StockCardItem::cardSeq), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardPsw", -1, &(a->ns1__StockCardItem::cardPsw), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:getDate", -1, &(a->ns1__StockCardItem::getDate), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__StockCardItem::getterId)
	{	if (soap_out_ns2__guid(soap, "ns1:getterId", -1, &a->ns1__StockCardItem::getterId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getterId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:getterName", -1, &(a->ns1__StockCardItem::getterName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:sellDate", -1, &(a->ns1__StockCardItem::sellDate), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__StockCardItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__StockCardItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__StockCardItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__StockCardItem::state), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StockCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StockCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StockCardItem * SOAP_FMAC4 soap_in_ns1__StockCardItem(struct soap *soap, const char *tag, ns1__StockCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StockCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StockCardItem, sizeof(ns1__StockCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StockCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StockCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardName1 = 1;
	size_t soap_flag_cardSeq1 = 1;
	size_t soap_flag_cardPsw1 = 1;
	size_t soap_flag_getDate1 = 1;
	size_t soap_flag_getterId1 = 1;
	size_t soap_flag_getterName1 = 1;
	size_t soap_flag_sellDate1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__StockCardItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardType", &(a->ns1__StockCardItem::cardType), "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardName", &(a->ns1__StockCardItem::cardName), "xsd:string"))
				{	soap_flag_cardName1--;
					continue;
				}
			if (soap_flag_cardSeq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardSeq", &(a->ns1__StockCardItem::cardSeq), "xsd:string"))
				{	soap_flag_cardSeq1--;
					continue;
				}
			if (soap_flag_cardPsw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardPsw", &(a->ns1__StockCardItem::cardPsw), "xsd:string"))
				{	soap_flag_cardPsw1--;
					continue;
				}
			if (soap_flag_getDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:getDate", &(a->ns1__StockCardItem::getDate), "xsd:dateTime"))
				{	soap_flag_getDate1--;
					continue;
				}
			if (soap_flag_getterId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:getterId", &(a->ns1__StockCardItem::getterId), "ns2:guid"))
				{	soap_flag_getterId1--;
					continue;
				}
			if (soap_flag_getterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getterName", &(a->ns1__StockCardItem::getterName), "xsd:string"))
				{	soap_flag_getterName1--;
					continue;
				}
			if (soap_flag_sellDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:sellDate", &(a->ns1__StockCardItem::sellDate), "xsd:dateTime"))
				{	soap_flag_sellDate1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__StockCardItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__StockCardItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__StockCardItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StockCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StockCardItem, 0, sizeof(ns1__StockCardItem), 0, soap_copy_ns1__StockCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_getDate1 > 0 || soap_flag_getterId1 > 0 || soap_flag_sellDate1 > 0 || soap_flag_userId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__StockCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StockCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:StockCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StockCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StockCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StockCardItem * SOAP_FMAC4 soap_get_ns1__StockCardItem(struct soap *soap, ns1__StockCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StockCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StockCardItem * SOAP_FMAC2 soap_instantiate_ns1__StockCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StockCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StockCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StockCardItem);
		if (size)
			*size = sizeof(ns1__StockCardItem);
		((ns1__StockCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StockCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StockCardItem);
		for (int i = 0; i < n; i++)
			((ns1__StockCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StockCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StockCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StockCardItem %p -> %p\n", q, p));
	*(ns1__StockCardItem*)p = *(ns1__StockCardItem*)q;
}

void ns1__ArrayOfStockCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfStockCardItem::__sizeStockCardItem = 0;
	this->ns1__ArrayOfStockCardItem::StockCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfStockCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfStockCardItem::StockCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfStockCardItem::__sizeStockCardItem; i++)
		{
			soap_serialize_PointerTons1__StockCardItem(soap, this->ns1__ArrayOfStockCardItem::StockCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfStockCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfStockCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfStockCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfStockCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfStockCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfStockCardItem::StockCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfStockCardItem::__sizeStockCardItem; i++)
			if (soap_out_PointerTons1__StockCardItem(soap, "ns1:StockCardItem", -1, a->ns1__ArrayOfStockCardItem::StockCardItem + i, "ns1:StockCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfStockCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfStockCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfStockCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfStockCardItem(struct soap *soap, const char *tag, ns1__ArrayOfStockCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfStockCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfStockCardItem, sizeof(ns1__ArrayOfStockCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfStockCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfStockCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_StockCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:StockCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfStockCardItem::StockCardItem == NULL)
				{	if (soap_blist_StockCardItem1 == NULL)
						soap_blist_StockCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfStockCardItem::StockCardItem = (ns1__StockCardItem **)soap_push_block(soap, soap_blist_StockCardItem1, sizeof(ns1__StockCardItem *));
					if (a->ns1__ArrayOfStockCardItem::StockCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfStockCardItem::StockCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__StockCardItem(soap, "ns1:StockCardItem", a->ns1__ArrayOfStockCardItem::StockCardItem, "ns1:StockCardItem"))
				{	a->ns1__ArrayOfStockCardItem::__sizeStockCardItem++;
					a->ns1__ArrayOfStockCardItem::StockCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfStockCardItem::StockCardItem)
			soap_pop_block(soap, soap_blist_StockCardItem1);
		if (a->ns1__ArrayOfStockCardItem::__sizeStockCardItem)
			a->ns1__ArrayOfStockCardItem::StockCardItem = (ns1__StockCardItem **)soap_save_block(soap, soap_blist_StockCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfStockCardItem::StockCardItem = NULL;
			if (soap_blist_StockCardItem1)
				soap_end_block(soap, soap_blist_StockCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfStockCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfStockCardItem, 0, sizeof(ns1__ArrayOfStockCardItem), 0, soap_copy_ns1__ArrayOfStockCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfStockCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfStockCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfStockCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfStockCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfStockCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfStockCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfStockCardItem(struct soap *soap, ns1__ArrayOfStockCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfStockCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfStockCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfStockCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfStockCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfStockCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStockCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfStockCardItem);
		((ns1__ArrayOfStockCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStockCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfStockCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfStockCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfStockCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfStockCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfStockCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfStockCardItem*)p = *(ns1__ArrayOfStockCardItem*)q;
}

void ns1__OtherCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OtherCardItem::cardType);
	soap_default_string(soap, &this->ns1__OtherCardItem::cardName);
	soap_default_double(soap, &this->ns1__OtherCardItem::cardPrice);
	/* transient soap skipped */
}

void ns1__OtherCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OtherCardItem::cardType);
	soap_serialize_string(soap, &this->ns1__OtherCardItem::cardName);
	/* transient soap skipped */
}

int ns1__OtherCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OtherCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtherCardItem(struct soap *soap, const char *tag, int id, const ns1__OtherCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtherCardItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardType", -1, &(a->ns1__OtherCardItem::cardType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardName", -1, &(a->ns1__OtherCardItem::cardName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:cardPrice", -1, &(a->ns1__OtherCardItem::cardPrice), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__OtherCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OtherCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OtherCardItem * SOAP_FMAC4 soap_in_ns1__OtherCardItem(struct soap *soap, const char *tag, ns1__OtherCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OtherCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtherCardItem, sizeof(ns1__OtherCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OtherCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OtherCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardName1 = 1;
	size_t soap_flag_cardPrice1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardType", &(a->ns1__OtherCardItem::cardType), "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardName", &(a->ns1__OtherCardItem::cardName), "xsd:string"))
				{	soap_flag_cardName1--;
					continue;
				}
			if (soap_flag_cardPrice1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:cardPrice", &(a->ns1__OtherCardItem::cardPrice), "xsd:double"))
				{	soap_flag_cardPrice1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OtherCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtherCardItem, 0, sizeof(ns1__OtherCardItem), 0, soap_copy_ns1__OtherCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cardPrice1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__OtherCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OtherCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:OtherCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OtherCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OtherCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OtherCardItem * SOAP_FMAC4 soap_get_ns1__OtherCardItem(struct soap *soap, ns1__OtherCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OtherCardItem * SOAP_FMAC2 soap_instantiate_ns1__OtherCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OtherCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OtherCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OtherCardItem);
		if (size)
			*size = sizeof(ns1__OtherCardItem);
		((ns1__OtherCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OtherCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OtherCardItem);
		for (int i = 0; i < n; i++)
			((ns1__OtherCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OtherCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OtherCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OtherCardItem %p -> %p\n", q, p));
	*(ns1__OtherCardItem*)p = *(ns1__OtherCardItem*)q;
}

void ns1__ArrayOfOtherCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfOtherCardItem::__sizeOtherCardItem = 0;
	this->ns1__ArrayOfOtherCardItem::OtherCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfOtherCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfOtherCardItem::OtherCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfOtherCardItem::__sizeOtherCardItem; i++)
		{
			soap_serialize_PointerTons1__OtherCardItem(soap, this->ns1__ArrayOfOtherCardItem::OtherCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfOtherCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfOtherCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfOtherCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfOtherCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfOtherCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfOtherCardItem::OtherCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfOtherCardItem::__sizeOtherCardItem; i++)
			if (soap_out_PointerTons1__OtherCardItem(soap, "ns1:OtherCardItem", -1, a->ns1__ArrayOfOtherCardItem::OtherCardItem + i, "ns1:OtherCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfOtherCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfOtherCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfOtherCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfOtherCardItem(struct soap *soap, const char *tag, ns1__ArrayOfOtherCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfOtherCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfOtherCardItem, sizeof(ns1__ArrayOfOtherCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfOtherCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfOtherCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_OtherCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:OtherCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfOtherCardItem::OtherCardItem == NULL)
				{	if (soap_blist_OtherCardItem1 == NULL)
						soap_blist_OtherCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfOtherCardItem::OtherCardItem = (ns1__OtherCardItem **)soap_push_block(soap, soap_blist_OtherCardItem1, sizeof(ns1__OtherCardItem *));
					if (a->ns1__ArrayOfOtherCardItem::OtherCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfOtherCardItem::OtherCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__OtherCardItem(soap, "ns1:OtherCardItem", a->ns1__ArrayOfOtherCardItem::OtherCardItem, "ns1:OtherCardItem"))
				{	a->ns1__ArrayOfOtherCardItem::__sizeOtherCardItem++;
					a->ns1__ArrayOfOtherCardItem::OtherCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfOtherCardItem::OtherCardItem)
			soap_pop_block(soap, soap_blist_OtherCardItem1);
		if (a->ns1__ArrayOfOtherCardItem::__sizeOtherCardItem)
			a->ns1__ArrayOfOtherCardItem::OtherCardItem = (ns1__OtherCardItem **)soap_save_block(soap, soap_blist_OtherCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfOtherCardItem::OtherCardItem = NULL;
			if (soap_blist_OtherCardItem1)
				soap_end_block(soap, soap_blist_OtherCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfOtherCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfOtherCardItem, 0, sizeof(ns1__ArrayOfOtherCardItem), 0, soap_copy_ns1__ArrayOfOtherCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfOtherCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfOtherCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfOtherCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfOtherCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfOtherCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfOtherCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfOtherCardItem(struct soap *soap, ns1__ArrayOfOtherCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfOtherCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfOtherCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfOtherCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfOtherCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfOtherCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfOtherCardItem);
		((ns1__ArrayOfOtherCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfOtherCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfOtherCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfOtherCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfOtherCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfOtherCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfOtherCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfOtherCardItem*)p = *(ns1__ArrayOfOtherCardItem*)q;
}

void ns1__SellOtherCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__SellOtherCardItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__SellOtherCardItem::userId);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::userName);
	soap_default_time(soap, &this->ns1__SellOtherCardItem::datetime);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::cardType);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::cardName);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::cardSeq);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::cardPsw);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::state);
	soap_default_ns2__guid(soap, &this->ns1__SellOtherCardItem::workerId);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::workerName);
	soap_default_double(soap, &this->ns1__SellOtherCardItem::chargeMoney);
	soap_default_double(soap, &this->ns1__SellOtherCardItem::moneyBefore);
	soap_default_double(soap, &this->ns1__SellOtherCardItem::moneyAfter);
	soap_default_string(soap, &this->ns1__SellOtherCardItem::clientType);
	/* transient soap skipped */
}

void ns1__SellOtherCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__SellOtherCardItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__SellOtherCardItem::userId);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::userName);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::cardType);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::cardName);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::cardSeq);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::cardPsw);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__SellOtherCardItem::workerId);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::workerName);
	soap_serialize_string(soap, &this->ns1__SellOtherCardItem::clientType);
	/* transient soap skipped */
}

int ns1__SellOtherCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellOtherCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellOtherCardItem(struct soap *soap, const char *tag, int id, const ns1__SellOtherCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellOtherCardItem), type))
		return soap->error;
	if (a->ns1__SellOtherCardItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__SellOtherCardItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__SellOtherCardItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__SellOtherCardItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__SellOtherCardItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:datetime", -1, &(a->ns1__SellOtherCardItem::datetime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardType", -1, &(a->ns1__SellOtherCardItem::cardType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardName", -1, &(a->ns1__SellOtherCardItem::cardName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardSeq", -1, &(a->ns1__SellOtherCardItem::cardSeq), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardPsw", -1, &(a->ns1__SellOtherCardItem::cardPsw), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__SellOtherCardItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__SellOtherCardItem::workerId)
	{	if (soap_out_ns2__guid(soap, "ns1:workerId", -1, &a->ns1__SellOtherCardItem::workerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerName", -1, &(a->ns1__SellOtherCardItem::workerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:chargeMoney", -1, &(a->ns1__SellOtherCardItem::chargeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__SellOtherCardItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__SellOtherCardItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__SellOtherCardItem::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellOtherCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellOtherCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellOtherCardItem * SOAP_FMAC4 soap_in_ns1__SellOtherCardItem(struct soap *soap, const char *tag, ns1__SellOtherCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellOtherCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellOtherCardItem, sizeof(ns1__SellOtherCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellOtherCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellOtherCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_datetime1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardName1 = 1;
	size_t soap_flag_cardSeq1 = 1;
	size_t soap_flag_cardPsw1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_workerName1 = 1;
	size_t soap_flag_chargeMoney1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__SellOtherCardItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__SellOtherCardItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__SellOtherCardItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:datetime", &(a->ns1__SellOtherCardItem::datetime), "xsd:dateTime"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardType", &(a->ns1__SellOtherCardItem::cardType), "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardName", &(a->ns1__SellOtherCardItem::cardName), "xsd:string"))
				{	soap_flag_cardName1--;
					continue;
				}
			if (soap_flag_cardSeq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardSeq", &(a->ns1__SellOtherCardItem::cardSeq), "xsd:string"))
				{	soap_flag_cardSeq1--;
					continue;
				}
			if (soap_flag_cardPsw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardPsw", &(a->ns1__SellOtherCardItem::cardPsw), "xsd:string"))
				{	soap_flag_cardPsw1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__SellOtherCardItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workerId", &(a->ns1__SellOtherCardItem::workerId), "ns2:guid"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_workerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerName", &(a->ns1__SellOtherCardItem::workerName), "xsd:string"))
				{	soap_flag_workerName1--;
					continue;
				}
			if (soap_flag_chargeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:chargeMoney", &(a->ns1__SellOtherCardItem::chargeMoney), "xsd:double"))
				{	soap_flag_chargeMoney1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__SellOtherCardItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__SellOtherCardItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__SellOtherCardItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellOtherCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellOtherCardItem, 0, sizeof(ns1__SellOtherCardItem), 0, soap_copy_ns1__SellOtherCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_datetime1 > 0 || soap_flag_workerId1 > 0 || soap_flag_chargeMoney1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__SellOtherCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellOtherCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:SellOtherCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SellOtherCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellOtherCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellOtherCardItem * SOAP_FMAC4 soap_get_ns1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SellOtherCardItem * SOAP_FMAC2 soap_instantiate_ns1__SellOtherCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellOtherCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellOtherCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SellOtherCardItem);
		if (size)
			*size = sizeof(ns1__SellOtherCardItem);
		((ns1__SellOtherCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SellOtherCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellOtherCardItem);
		for (int i = 0; i < n; i++)
			((ns1__SellOtherCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellOtherCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellOtherCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellOtherCardItem %p -> %p\n", q, p));
	*(ns1__SellOtherCardItem*)p = *(ns1__SellOtherCardItem*)q;
}

void ns1__ArrayOfSellOtherCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfSellOtherCardItem::__sizeSellOtherCardItem = 0;
	this->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfSellOtherCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfSellOtherCardItem::__sizeSellOtherCardItem; i++)
		{
			soap_serialize_PointerTons1__SellOtherCardItem(soap, this->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfSellOtherCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSellOtherCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSellOtherCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSellOtherCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfSellOtherCardItem::__sizeSellOtherCardItem; i++)
			if (soap_out_PointerTons1__SellOtherCardItem(soap, "ns1:SellOtherCardItem", -1, a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem + i, "ns1:SellOtherCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSellOtherCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSellOtherCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSellOtherCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfSellOtherCardItem(struct soap *soap, const char *tag, ns1__ArrayOfSellOtherCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSellOtherCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem, sizeof(ns1__ArrayOfSellOtherCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSellOtherCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSellOtherCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_SellOtherCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:SellOtherCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem == NULL)
				{	if (soap_blist_SellOtherCardItem1 == NULL)
						soap_blist_SellOtherCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = (ns1__SellOtherCardItem **)soap_push_block(soap, soap_blist_SellOtherCardItem1, sizeof(ns1__SellOtherCardItem *));
					if (a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__SellOtherCardItem(soap, "ns1:SellOtherCardItem", a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem, "ns1:SellOtherCardItem"))
				{	a->ns1__ArrayOfSellOtherCardItem::__sizeSellOtherCardItem++;
					a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem)
			soap_pop_block(soap, soap_blist_SellOtherCardItem1);
		if (a->ns1__ArrayOfSellOtherCardItem::__sizeSellOtherCardItem)
			a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = (ns1__SellOtherCardItem **)soap_save_block(soap, soap_blist_SellOtherCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfSellOtherCardItem::SellOtherCardItem = NULL;
			if (soap_blist_SellOtherCardItem1)
				soap_end_block(soap, soap_blist_SellOtherCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSellOtherCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem, 0, sizeof(ns1__ArrayOfSellOtherCardItem), 0, soap_copy_ns1__ArrayOfSellOtherCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSellOtherCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSellOtherCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSellOtherCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSellOtherCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSellOtherCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfSellOtherCardItem(struct soap *soap, ns1__ArrayOfSellOtherCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSellOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSellOtherCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSellOtherCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSellOtherCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSellOtherCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfSellOtherCardItem);
		((ns1__ArrayOfSellOtherCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSellOtherCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSellOtherCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSellOtherCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSellOtherCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSellOtherCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSellOtherCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfSellOtherCardItem*)p = *(ns1__ArrayOfSellOtherCardItem*)q;
}

void ns1__BusinessItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__BusinessItem::Id);
	soap_default_string(soap, &this->ns1__BusinessItem::businessName);
	soap_default_string(soap, &this->ns1__BusinessItem::businessSpec);
	soap_default_ns2__guid(soap, &this->ns1__BusinessItem::userId);
	soap_default_string(soap, &this->ns1__BusinessItem::userName);
	soap_default_string(soap, &this->ns1__BusinessItem::sp);
	soap_default_string(soap, &this->ns1__BusinessItem::no);
	soap_default_string(soap, &this->ns1__BusinessItem::passwd);
	soap_default_time(soap, &this->ns1__BusinessItem::datetime);
	soap_default_string(soap, &this->ns1__BusinessItem::state);
	soap_default_string(soap, &this->ns1__BusinessItem::content);
	soap_default_string(soap, &this->ns1__BusinessItem::replay);
	soap_default_ns2__guid(soap, &this->ns1__BusinessItem::workerId);
	soap_default_string(soap, &this->ns1__BusinessItem::workerName);
	soap_default_string(soap, &this->ns1__BusinessItem::clientType);
	soap_default_double(soap, &this->ns1__BusinessItem::returnMoney);
	/* transient soap skipped */
}

void ns1__BusinessItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__BusinessItem::Id);
	soap_serialize_string(soap, &this->ns1__BusinessItem::businessName);
	soap_serialize_string(soap, &this->ns1__BusinessItem::businessSpec);
	soap_serialize_ns2__guid(soap, &this->ns1__BusinessItem::userId);
	soap_serialize_string(soap, &this->ns1__BusinessItem::userName);
	soap_serialize_string(soap, &this->ns1__BusinessItem::sp);
	soap_serialize_string(soap, &this->ns1__BusinessItem::no);
	soap_serialize_string(soap, &this->ns1__BusinessItem::passwd);
	soap_serialize_string(soap, &this->ns1__BusinessItem::state);
	soap_serialize_string(soap, &this->ns1__BusinessItem::content);
	soap_serialize_string(soap, &this->ns1__BusinessItem::replay);
	soap_serialize_ns2__guid(soap, &this->ns1__BusinessItem::workerId);
	soap_serialize_string(soap, &this->ns1__BusinessItem::workerName);
	soap_serialize_string(soap, &this->ns1__BusinessItem::clientType);
	/* transient soap skipped */
}

int ns1__BusinessItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BusinessItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BusinessItem(struct soap *soap, const char *tag, int id, const ns1__BusinessItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BusinessItem), type))
		return soap->error;
	if (a->ns1__BusinessItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__BusinessItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:businessName", -1, &(a->ns1__BusinessItem::businessName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:businessSpec", -1, &(a->ns1__BusinessItem::businessSpec), "xsd:string"))
		return soap->error;
	if (a->ns1__BusinessItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__BusinessItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__BusinessItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sp", -1, &(a->ns1__BusinessItem::sp), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:no", -1, &(a->ns1__BusinessItem::no), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:passwd", -1, &(a->ns1__BusinessItem::passwd), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:datetime", -1, &(a->ns1__BusinessItem::datetime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__BusinessItem::state), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__BusinessItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:replay", -1, &(a->ns1__BusinessItem::replay), "xsd:string"))
		return soap->error;
	if (a->ns1__BusinessItem::workerId)
	{	if (soap_out_ns2__guid(soap, "ns1:workerId", -1, &a->ns1__BusinessItem::workerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerName", -1, &(a->ns1__BusinessItem::workerName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__BusinessItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__BusinessItem::returnMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BusinessItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BusinessItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BusinessItem * SOAP_FMAC4 soap_in_ns1__BusinessItem(struct soap *soap, const char *tag, ns1__BusinessItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BusinessItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BusinessItem, sizeof(ns1__BusinessItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BusinessItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BusinessItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_businessName1 = 1;
	size_t soap_flag_businessSpec1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_sp1 = 1;
	size_t soap_flag_no1 = 1;
	size_t soap_flag_passwd1 = 1;
	size_t soap_flag_datetime1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_replay1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_workerName1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__BusinessItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_businessName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:businessName", &(a->ns1__BusinessItem::businessName), "xsd:string"))
				{	soap_flag_businessName1--;
					continue;
				}
			if (soap_flag_businessSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:businessSpec", &(a->ns1__BusinessItem::businessSpec), "xsd:string"))
				{	soap_flag_businessSpec1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__BusinessItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__BusinessItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_sp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sp", &(a->ns1__BusinessItem::sp), "xsd:string"))
				{	soap_flag_sp1--;
					continue;
				}
			if (soap_flag_no1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:no", &(a->ns1__BusinessItem::no), "xsd:string"))
				{	soap_flag_no1--;
					continue;
				}
			if (soap_flag_passwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:passwd", &(a->ns1__BusinessItem::passwd), "xsd:string"))
				{	soap_flag_passwd1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:datetime", &(a->ns1__BusinessItem::datetime), "xsd:dateTime"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__BusinessItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__BusinessItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_replay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:replay", &(a->ns1__BusinessItem::replay), "xsd:string"))
				{	soap_flag_replay1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workerId", &(a->ns1__BusinessItem::workerId), "ns2:guid"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_workerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerName", &(a->ns1__BusinessItem::workerName), "xsd:string"))
				{	soap_flag_workerName1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__BusinessItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__BusinessItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BusinessItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BusinessItem, 0, sizeof(ns1__BusinessItem), 0, soap_copy_ns1__BusinessItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_datetime1 > 0 || soap_flag_workerId1 > 0 || soap_flag_returnMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__BusinessItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BusinessItem);
	if (this->soap_out(soap, tag?tag:"ns1:BusinessItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BusinessItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BusinessItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BusinessItem * SOAP_FMAC4 soap_get_ns1__BusinessItem(struct soap *soap, ns1__BusinessItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BusinessItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__BusinessItem * SOAP_FMAC2 soap_instantiate_ns1__BusinessItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BusinessItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BusinessItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__BusinessItem);
		if (size)
			*size = sizeof(ns1__BusinessItem);
		((ns1__BusinessItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__BusinessItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BusinessItem);
		for (int i = 0; i < n; i++)
			((ns1__BusinessItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BusinessItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BusinessItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BusinessItem %p -> %p\n", q, p));
	*(ns1__BusinessItem*)p = *(ns1__BusinessItem*)q;
}

void ns1__ArrayOfBusinessItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfBusinessItem::__sizeBusinessItem = 0;
	this->ns1__ArrayOfBusinessItem::BusinessItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfBusinessItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfBusinessItem::BusinessItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfBusinessItem::__sizeBusinessItem; i++)
		{
			soap_serialize_PointerTons1__BusinessItem(soap, this->ns1__ArrayOfBusinessItem::BusinessItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfBusinessItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfBusinessItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfBusinessItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfBusinessItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfBusinessItem), type))
		return soap->error;
	if (a->ns1__ArrayOfBusinessItem::BusinessItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfBusinessItem::__sizeBusinessItem; i++)
			if (soap_out_PointerTons1__BusinessItem(soap, "ns1:BusinessItem", -1, a->ns1__ArrayOfBusinessItem::BusinessItem + i, "ns1:BusinessItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfBusinessItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfBusinessItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfBusinessItem * SOAP_FMAC4 soap_in_ns1__ArrayOfBusinessItem(struct soap *soap, const char *tag, ns1__ArrayOfBusinessItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfBusinessItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfBusinessItem, sizeof(ns1__ArrayOfBusinessItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfBusinessItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfBusinessItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_BusinessItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:BusinessItem", 1, NULL))
			{	if (a->ns1__ArrayOfBusinessItem::BusinessItem == NULL)
				{	if (soap_blist_BusinessItem1 == NULL)
						soap_blist_BusinessItem1 = soap_new_block(soap);
					a->ns1__ArrayOfBusinessItem::BusinessItem = (ns1__BusinessItem **)soap_push_block(soap, soap_blist_BusinessItem1, sizeof(ns1__BusinessItem *));
					if (a->ns1__ArrayOfBusinessItem::BusinessItem == NULL)
						return NULL;
					*a->ns1__ArrayOfBusinessItem::BusinessItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__BusinessItem(soap, "ns1:BusinessItem", a->ns1__ArrayOfBusinessItem::BusinessItem, "ns1:BusinessItem"))
				{	a->ns1__ArrayOfBusinessItem::__sizeBusinessItem++;
					a->ns1__ArrayOfBusinessItem::BusinessItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfBusinessItem::BusinessItem)
			soap_pop_block(soap, soap_blist_BusinessItem1);
		if (a->ns1__ArrayOfBusinessItem::__sizeBusinessItem)
			a->ns1__ArrayOfBusinessItem::BusinessItem = (ns1__BusinessItem **)soap_save_block(soap, soap_blist_BusinessItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfBusinessItem::BusinessItem = NULL;
			if (soap_blist_BusinessItem1)
				soap_end_block(soap, soap_blist_BusinessItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfBusinessItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfBusinessItem, 0, sizeof(ns1__ArrayOfBusinessItem), 0, soap_copy_ns1__ArrayOfBusinessItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfBusinessItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfBusinessItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfBusinessItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfBusinessItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfBusinessItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfBusinessItem * SOAP_FMAC4 soap_get_ns1__ArrayOfBusinessItem(struct soap *soap, ns1__ArrayOfBusinessItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfBusinessItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfBusinessItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfBusinessItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfBusinessItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfBusinessItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfBusinessItem);
		if (size)
			*size = sizeof(ns1__ArrayOfBusinessItem);
		((ns1__ArrayOfBusinessItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfBusinessItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfBusinessItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfBusinessItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfBusinessItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfBusinessItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfBusinessItem %p -> %p\n", q, p));
	*(ns1__ArrayOfBusinessItem*)p = *(ns1__ArrayOfBusinessItem*)q;
}

void ns1__SellCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__SellCardItem::Id);
	soap_default_string(soap, &this->ns1__SellCardItem::telNo);
	soap_default_string(soap, &this->ns1__SellCardItem::miniNo);
	soap_default_time(soap, &this->ns1__SellCardItem::sellTime);
	soap_default_string(soap, &this->ns1__SellCardItem::passwd);
	soap_default_string(soap, &this->ns1__SellCardItem::brand);
	soap_default_string(soap, &this->ns1__SellCardItem::brandNo);
	soap_default_string(soap, &this->ns1__SellCardItem::cardPrice);
	soap_default_bool(soap, &this->ns1__SellCardItem::isOtherService);
	soap_default_double(soap, &this->ns1__SellCardItem::chargeMoney);
	soap_default_double(soap, &this->ns1__SellCardItem::moneyBefore);
	soap_default_double(soap, &this->ns1__SellCardItem::moneyAfter);
	soap_default_string(soap, &this->ns1__SellCardItem::state);
	soap_default_ns2__guid(soap, &this->ns1__SellCardItem::user_USCOREid);
	soap_default_string(soap, &this->ns1__SellCardItem::user_USCOREname);
	soap_default_ns2__guid(soap, &this->ns1__SellCardItem::work_USCOREid);
	soap_default_string(soap, &this->ns1__SellCardItem::work_USCOREname);
	soap_default_ns2__guid(soap, &this->ns1__SellCardItem::manager_USCOREid);
	soap_default_string(soap, &this->ns1__SellCardItem::manager_USCOREname);
	soap_default_string(soap, &this->ns1__SellCardItem::SP);
	soap_default_string(soap, &this->ns1__SellCardItem::clientType);
	soap_default_string(soap, &this->ns1__SellCardItem::noSection);
	soap_default_double(soap, &this->ns1__SellCardItem::noPrice);
	soap_default_string(soap, &this->ns1__SellCardItem::area);
	/* transient soap skipped */
}

void ns1__SellCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__SellCardItem::Id);
	soap_serialize_string(soap, &this->ns1__SellCardItem::telNo);
	soap_serialize_string(soap, &this->ns1__SellCardItem::miniNo);
	soap_serialize_string(soap, &this->ns1__SellCardItem::passwd);
	soap_serialize_string(soap, &this->ns1__SellCardItem::brand);
	soap_serialize_string(soap, &this->ns1__SellCardItem::brandNo);
	soap_serialize_string(soap, &this->ns1__SellCardItem::cardPrice);
	soap_serialize_string(soap, &this->ns1__SellCardItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__SellCardItem::user_USCOREid);
	soap_serialize_string(soap, &this->ns1__SellCardItem::user_USCOREname);
	soap_serialize_ns2__guid(soap, &this->ns1__SellCardItem::work_USCOREid);
	soap_serialize_string(soap, &this->ns1__SellCardItem::work_USCOREname);
	soap_serialize_ns2__guid(soap, &this->ns1__SellCardItem::manager_USCOREid);
	soap_serialize_string(soap, &this->ns1__SellCardItem::manager_USCOREname);
	soap_serialize_string(soap, &this->ns1__SellCardItem::SP);
	soap_serialize_string(soap, &this->ns1__SellCardItem::clientType);
	soap_serialize_string(soap, &this->ns1__SellCardItem::noSection);
	soap_serialize_string(soap, &this->ns1__SellCardItem::area);
	/* transient soap skipped */
}

int ns1__SellCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SellCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SellCardItem(struct soap *soap, const char *tag, int id, const ns1__SellCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SellCardItem), type))
		return soap->error;
	if (a->ns1__SellCardItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__SellCardItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:telNo", -1, &(a->ns1__SellCardItem::telNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:miniNo", -1, &(a->ns1__SellCardItem::miniNo), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:sellTime", -1, &(a->ns1__SellCardItem::sellTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:passwd", -1, &(a->ns1__SellCardItem::passwd), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:brand", -1, &(a->ns1__SellCardItem::brand), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:brandNo", -1, &(a->ns1__SellCardItem::brandNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardPrice", -1, &(a->ns1__SellCardItem::cardPrice), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isOtherService", -1, &(a->ns1__SellCardItem::isOtherService), "xsd:boolean"))
		return soap->error;
	if (soap_out_double(soap, "ns1:chargeMoney", -1, &(a->ns1__SellCardItem::chargeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__SellCardItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__SellCardItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__SellCardItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__SellCardItem::user_USCOREid)
	{	if (soap_out_ns2__guid(soap, "ns1:user_id", -1, &a->ns1__SellCardItem::user_USCOREid, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:user_id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:user_name", -1, &(a->ns1__SellCardItem::user_USCOREname), "xsd:string"))
		return soap->error;
	if (a->ns1__SellCardItem::work_USCOREid)
	{	if (soap_out_ns2__guid(soap, "ns1:work_id", -1, &a->ns1__SellCardItem::work_USCOREid, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:work_id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__SellCardItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (a->ns1__SellCardItem::manager_USCOREid)
	{	if (soap_out_ns2__guid(soap, "ns1:manager_id", -1, &a->ns1__SellCardItem::manager_USCOREid, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:manager_id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager_name", -1, &(a->ns1__SellCardItem::manager_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->ns1__SellCardItem::SP), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__SellCardItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:noSection", -1, &(a->ns1__SellCardItem::noSection), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:noPrice", -1, &(a->ns1__SellCardItem::noPrice), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__SellCardItem::area), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SellCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SellCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SellCardItem * SOAP_FMAC4 soap_in_ns1__SellCardItem(struct soap *soap, const char *tag, ns1__SellCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SellCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SellCardItem, sizeof(ns1__SellCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SellCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SellCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_telNo1 = 1;
	size_t soap_flag_miniNo1 = 1;
	size_t soap_flag_sellTime1 = 1;
	size_t soap_flag_passwd1 = 1;
	size_t soap_flag_brand1 = 1;
	size_t soap_flag_brandNo1 = 1;
	size_t soap_flag_cardPrice1 = 1;
	size_t soap_flag_isOtherService1 = 1;
	size_t soap_flag_chargeMoney1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	size_t soap_flag_user_USCOREname1 = 1;
	size_t soap_flag_work_USCOREid1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_manager_USCOREid1 = 1;
	size_t soap_flag_manager_USCOREname1 = 1;
	size_t soap_flag_SP1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_noSection1 = 1;
	size_t soap_flag_noPrice1 = 1;
	size_t soap_flag_area1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__SellCardItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_telNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telNo", &(a->ns1__SellCardItem::telNo), "xsd:string"))
				{	soap_flag_telNo1--;
					continue;
				}
			if (soap_flag_miniNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:miniNo", &(a->ns1__SellCardItem::miniNo), "xsd:string"))
				{	soap_flag_miniNo1--;
					continue;
				}
			if (soap_flag_sellTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:sellTime", &(a->ns1__SellCardItem::sellTime), "xsd:dateTime"))
				{	soap_flag_sellTime1--;
					continue;
				}
			if (soap_flag_passwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:passwd", &(a->ns1__SellCardItem::passwd), "xsd:string"))
				{	soap_flag_passwd1--;
					continue;
				}
			if (soap_flag_brand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:brand", &(a->ns1__SellCardItem::brand), "xsd:string"))
				{	soap_flag_brand1--;
					continue;
				}
			if (soap_flag_brandNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:brandNo", &(a->ns1__SellCardItem::brandNo), "xsd:string"))
				{	soap_flag_brandNo1--;
					continue;
				}
			if (soap_flag_cardPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardPrice", &(a->ns1__SellCardItem::cardPrice), "xsd:string"))
				{	soap_flag_cardPrice1--;
					continue;
				}
			if (soap_flag_isOtherService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isOtherService", &(a->ns1__SellCardItem::isOtherService), "xsd:boolean"))
				{	soap_flag_isOtherService1--;
					continue;
				}
			if (soap_flag_chargeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:chargeMoney", &(a->ns1__SellCardItem::chargeMoney), "xsd:double"))
				{	soap_flag_chargeMoney1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__SellCardItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__SellCardItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__SellCardItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:user_id", &(a->ns1__SellCardItem::user_USCOREid), "ns2:guid"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			if (soap_flag_user_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:user_name", &(a->ns1__SellCardItem::user_USCOREname), "xsd:string"))
				{	soap_flag_user_USCOREname1--;
					continue;
				}
			if (soap_flag_work_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:work_id", &(a->ns1__SellCardItem::work_USCOREid), "ns2:guid"))
				{	soap_flag_work_USCOREid1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__SellCardItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_manager_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:manager_id", &(a->ns1__SellCardItem::manager_USCOREid), "ns2:guid"))
				{	soap_flag_manager_USCOREid1--;
					continue;
				}
			if (soap_flag_manager_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager_name", &(a->ns1__SellCardItem::manager_USCOREname), "xsd:string"))
				{	soap_flag_manager_USCOREname1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->ns1__SellCardItem::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__SellCardItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_noSection1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:noSection", &(a->ns1__SellCardItem::noSection), "xsd:string"))
				{	soap_flag_noSection1--;
					continue;
				}
			if (soap_flag_noPrice1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:noPrice", &(a->ns1__SellCardItem::noPrice), "xsd:double"))
				{	soap_flag_noPrice1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__SellCardItem::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SellCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SellCardItem, 0, sizeof(ns1__SellCardItem), 0, soap_copy_ns1__SellCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_sellTime1 > 0 || soap_flag_isOtherService1 > 0 || soap_flag_chargeMoney1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0 || soap_flag_user_USCOREid1 > 0 || soap_flag_work_USCOREid1 > 0 || soap_flag_manager_USCOREid1 > 0 || soap_flag_noPrice1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__SellCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SellCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:SellCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SellCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SellCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SellCardItem * SOAP_FMAC4 soap_get_ns1__SellCardItem(struct soap *soap, ns1__SellCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SellCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SellCardItem * SOAP_FMAC2 soap_instantiate_ns1__SellCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SellCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SellCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SellCardItem);
		if (size)
			*size = sizeof(ns1__SellCardItem);
		((ns1__SellCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SellCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SellCardItem);
		for (int i = 0; i < n; i++)
			((ns1__SellCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SellCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SellCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SellCardItem %p -> %p\n", q, p));
	*(ns1__SellCardItem*)p = *(ns1__SellCardItem*)q;
}

void ns1__ArrayOfSellCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfSellCardItem::__sizeSellCardItem = 0;
	this->ns1__ArrayOfSellCardItem::SellCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfSellCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfSellCardItem::SellCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfSellCardItem::__sizeSellCardItem; i++)
		{
			soap_serialize_PointerTons1__SellCardItem(soap, this->ns1__ArrayOfSellCardItem::SellCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfSellCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSellCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSellCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSellCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSellCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfSellCardItem::SellCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfSellCardItem::__sizeSellCardItem; i++)
			if (soap_out_PointerTons1__SellCardItem(soap, "ns1:SellCardItem", -1, a->ns1__ArrayOfSellCardItem::SellCardItem + i, "ns1:SellCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSellCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSellCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSellCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfSellCardItem(struct soap *soap, const char *tag, ns1__ArrayOfSellCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSellCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSellCardItem, sizeof(ns1__ArrayOfSellCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSellCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSellCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_SellCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:SellCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfSellCardItem::SellCardItem == NULL)
				{	if (soap_blist_SellCardItem1 == NULL)
						soap_blist_SellCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfSellCardItem::SellCardItem = (ns1__SellCardItem **)soap_push_block(soap, soap_blist_SellCardItem1, sizeof(ns1__SellCardItem *));
					if (a->ns1__ArrayOfSellCardItem::SellCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfSellCardItem::SellCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__SellCardItem(soap, "ns1:SellCardItem", a->ns1__ArrayOfSellCardItem::SellCardItem, "ns1:SellCardItem"))
				{	a->ns1__ArrayOfSellCardItem::__sizeSellCardItem++;
					a->ns1__ArrayOfSellCardItem::SellCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfSellCardItem::SellCardItem)
			soap_pop_block(soap, soap_blist_SellCardItem1);
		if (a->ns1__ArrayOfSellCardItem::__sizeSellCardItem)
			a->ns1__ArrayOfSellCardItem::SellCardItem = (ns1__SellCardItem **)soap_save_block(soap, soap_blist_SellCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfSellCardItem::SellCardItem = NULL;
			if (soap_blist_SellCardItem1)
				soap_end_block(soap, soap_blist_SellCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSellCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSellCardItem, 0, sizeof(ns1__ArrayOfSellCardItem), 0, soap_copy_ns1__ArrayOfSellCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSellCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSellCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSellCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSellCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSellCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSellCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfSellCardItem(struct soap *soap, ns1__ArrayOfSellCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSellCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSellCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSellCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSellCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSellCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSellCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfSellCardItem);
		((ns1__ArrayOfSellCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSellCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSellCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSellCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSellCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSellCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSellCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfSellCardItem*)p = *(ns1__ArrayOfSellCardItem*)q;
}

void ns1__CardService::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__CardService::Id);
	soap_default_string(soap, &this->ns1__CardService::SP);
	soap_default_string(soap, &this->ns1__CardService::serviceName);
	soap_default_bool(soap, &this->ns1__CardService::isFreq);
	soap_default_string(soap, &this->ns1__CardService::serviceSpec);
	/* transient soap skipped */
}

void ns1__CardService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__CardService::Id);
	soap_serialize_string(soap, &this->ns1__CardService::SP);
	soap_serialize_string(soap, &this->ns1__CardService::serviceName);
	soap_serialize_string(soap, &this->ns1__CardService::serviceSpec);
	/* transient soap skipped */
}

int ns1__CardService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CardService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CardService(struct soap *soap, const char *tag, int id, const ns1__CardService *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CardService), type))
		return soap->error;
	if (a->ns1__CardService::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__CardService::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->ns1__CardService::SP), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:serviceName", -1, &(a->ns1__CardService::serviceName), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isFreq", -1, &(a->ns1__CardService::isFreq), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:serviceSpec", -1, &(a->ns1__CardService::serviceSpec), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CardService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CardService(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CardService * SOAP_FMAC4 soap_in_ns1__CardService(struct soap *soap, const char *tag, ns1__CardService *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CardService *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CardService, sizeof(ns1__CardService), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CardService)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CardService *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_SP1 = 1;
	size_t soap_flag_serviceName1 = 1;
	size_t soap_flag_isFreq1 = 1;
	size_t soap_flag_serviceSpec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__CardService::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->ns1__CardService::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			if (soap_flag_serviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:serviceName", &(a->ns1__CardService::serviceName), "xsd:string"))
				{	soap_flag_serviceName1--;
					continue;
				}
			if (soap_flag_isFreq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isFreq", &(a->ns1__CardService::isFreq), "xsd:boolean"))
				{	soap_flag_isFreq1--;
					continue;
				}
			if (soap_flag_serviceSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:serviceSpec", &(a->ns1__CardService::serviceSpec), "xsd:string"))
				{	soap_flag_serviceSpec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CardService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CardService, 0, sizeof(ns1__CardService), 0, soap_copy_ns1__CardService);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_isFreq1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CardService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CardService);
	if (this->soap_out(soap, tag?tag:"ns1:CardService", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CardService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CardService(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CardService * SOAP_FMAC4 soap_get_ns1__CardService(struct soap *soap, ns1__CardService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CardService * SOAP_FMAC2 soap_instantiate_ns1__CardService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CardService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CardService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CardService);
		if (size)
			*size = sizeof(ns1__CardService);
		((ns1__CardService*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CardService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CardService);
		for (int i = 0; i < n; i++)
			((ns1__CardService*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CardService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CardService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CardService %p -> %p\n", q, p));
	*(ns1__CardService*)p = *(ns1__CardService*)q;
}

void ns1__ArrayOfCardService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfCardService::__sizeCardService = 0;
	this->ns1__ArrayOfCardService::CardService = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfCardService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfCardService::CardService)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfCardService::__sizeCardService; i++)
		{
			soap_serialize_PointerTons1__CardService(soap, this->ns1__ArrayOfCardService::CardService + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfCardService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCardService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCardService(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCardService *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfCardService), type))
		return soap->error;
	if (a->ns1__ArrayOfCardService::CardService)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfCardService::__sizeCardService; i++)
			if (soap_out_PointerTons1__CardService(soap, "ns1:CardService", -1, a->ns1__ArrayOfCardService::CardService + i, "ns1:CardService"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCardService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfCardService(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCardService * SOAP_FMAC4 soap_in_ns1__ArrayOfCardService(struct soap *soap, const char *tag, ns1__ArrayOfCardService *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCardService *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfCardService, sizeof(ns1__ArrayOfCardService), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfCardService)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfCardService *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CardService1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:CardService", 1, NULL))
			{	if (a->ns1__ArrayOfCardService::CardService == NULL)
				{	if (soap_blist_CardService1 == NULL)
						soap_blist_CardService1 = soap_new_block(soap);
					a->ns1__ArrayOfCardService::CardService = (ns1__CardService **)soap_push_block(soap, soap_blist_CardService1, sizeof(ns1__CardService *));
					if (a->ns1__ArrayOfCardService::CardService == NULL)
						return NULL;
					*a->ns1__ArrayOfCardService::CardService = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__CardService(soap, "ns1:CardService", a->ns1__ArrayOfCardService::CardService, "ns1:CardService"))
				{	a->ns1__ArrayOfCardService::__sizeCardService++;
					a->ns1__ArrayOfCardService::CardService = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfCardService::CardService)
			soap_pop_block(soap, soap_blist_CardService1);
		if (a->ns1__ArrayOfCardService::__sizeCardService)
			a->ns1__ArrayOfCardService::CardService = (ns1__CardService **)soap_save_block(soap, soap_blist_CardService1, NULL, 1);
		else
		{	a->ns1__ArrayOfCardService::CardService = NULL;
			if (soap_blist_CardService1)
				soap_end_block(soap, soap_blist_CardService1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCardService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfCardService, 0, sizeof(ns1__ArrayOfCardService), 0, soap_copy_ns1__ArrayOfCardService);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfCardService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfCardService);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfCardService", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfCardService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCardService(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCardService * SOAP_FMAC4 soap_get_ns1__ArrayOfCardService(struct soap *soap, ns1__ArrayOfCardService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfCardService * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCardService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCardService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfCardService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfCardService);
		if (size)
			*size = sizeof(ns1__ArrayOfCardService);
		((ns1__ArrayOfCardService*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfCardService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfCardService);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfCardService*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfCardService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfCardService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfCardService %p -> %p\n", q, p));
	*(ns1__ArrayOfCardService*)p = *(ns1__ArrayOfCardService*)q;
}

void ns1__PayMiniCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PayMiniCardItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__PayMiniCardItem::userId);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::userName);
	soap_default_time(soap, &this->ns1__PayMiniCardItem::addDateTime);
	soap_default_ns2__guid(soap, &this->ns1__PayMiniCardItem::managerId);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::managerName);
	soap_default_double(soap, &this->ns1__PayMiniCardItem::money);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::content);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::state);
	soap_default_ns2__guid(soap, &this->ns1__PayMiniCardItem::workId);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::work_USCOREname);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::workType);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::clientType);
	soap_default_string(soap, &this->ns1__PayMiniCardItem::SP);
	soap_default_int(soap, &this->ns1__PayMiniCardItem::cardNum);
	soap_default_double(soap, &this->ns1__PayMiniCardItem::moneyBefore);
	soap_default_double(soap, &this->ns1__PayMiniCardItem::moneyAfter);
	/* transient soap skipped */
}

void ns1__PayMiniCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PayMiniCardItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__PayMiniCardItem::userId);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::userName);
	soap_serialize_ns2__guid(soap, &this->ns1__PayMiniCardItem::managerId);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::managerName);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::content);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__PayMiniCardItem::workId);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::work_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::workType);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::clientType);
	soap_serialize_string(soap, &this->ns1__PayMiniCardItem::SP);
	/* transient soap skipped */
}

int ns1__PayMiniCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayMiniCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayMiniCardItem(struct soap *soap, const char *tag, int id, const ns1__PayMiniCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayMiniCardItem), type))
		return soap->error;
	if (a->ns1__PayMiniCardItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PayMiniCardItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__PayMiniCardItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__PayMiniCardItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__PayMiniCardItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:addDateTime", -1, &(a->ns1__PayMiniCardItem::addDateTime), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__PayMiniCardItem::managerId)
	{	if (soap_out_ns2__guid(soap, "ns1:managerId", -1, &a->ns1__PayMiniCardItem::managerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:managerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:managerName", -1, &(a->ns1__PayMiniCardItem::managerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__PayMiniCardItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__PayMiniCardItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PayMiniCardItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__PayMiniCardItem::workId)
	{	if (soap_out_ns2__guid(soap, "ns1:workId", -1, &a->ns1__PayMiniCardItem::workId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__PayMiniCardItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workType", -1, &(a->ns1__PayMiniCardItem::workType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__PayMiniCardItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->ns1__PayMiniCardItem::SP), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:cardNum", -1, &(a->ns1__PayMiniCardItem::cardNum), "xsd:int"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__PayMiniCardItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__PayMiniCardItem::moneyAfter), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayMiniCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayMiniCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayMiniCardItem * SOAP_FMAC4 soap_in_ns1__PayMiniCardItem(struct soap *soap, const char *tag, ns1__PayMiniCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayMiniCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayMiniCardItem, sizeof(ns1__PayMiniCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayMiniCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayMiniCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_addDateTime1 = 1;
	size_t soap_flag_managerId1 = 1;
	size_t soap_flag_managerName1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workId1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_workType1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_SP1 = 1;
	size_t soap_flag_cardNum1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PayMiniCardItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__PayMiniCardItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__PayMiniCardItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_addDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:addDateTime", &(a->ns1__PayMiniCardItem::addDateTime), "xsd:dateTime"))
				{	soap_flag_addDateTime1--;
					continue;
				}
			if (soap_flag_managerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:managerId", &(a->ns1__PayMiniCardItem::managerId), "ns2:guid"))
				{	soap_flag_managerId1--;
					continue;
				}
			if (soap_flag_managerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:managerName", &(a->ns1__PayMiniCardItem::managerName), "xsd:string"))
				{	soap_flag_managerName1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__PayMiniCardItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__PayMiniCardItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PayMiniCardItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workId", &(a->ns1__PayMiniCardItem::workId), "ns2:guid"))
				{	soap_flag_workId1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__PayMiniCardItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_workType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workType", &(a->ns1__PayMiniCardItem::workType), "xsd:string"))
				{	soap_flag_workType1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__PayMiniCardItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->ns1__PayMiniCardItem::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			if (soap_flag_cardNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:cardNum", &(a->ns1__PayMiniCardItem::cardNum), "xsd:int"))
				{	soap_flag_cardNum1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__PayMiniCardItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__PayMiniCardItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayMiniCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayMiniCardItem, 0, sizeof(ns1__PayMiniCardItem), 0, soap_copy_ns1__PayMiniCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_addDateTime1 > 0 || soap_flag_managerId1 > 0 || soap_flag_money1 > 0 || soap_flag_workId1 > 0 || soap_flag_cardNum1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayMiniCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayMiniCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:PayMiniCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayMiniCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayMiniCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayMiniCardItem * SOAP_FMAC4 soap_get_ns1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayMiniCardItem * SOAP_FMAC2 soap_instantiate_ns1__PayMiniCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayMiniCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayMiniCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayMiniCardItem);
		if (size)
			*size = sizeof(ns1__PayMiniCardItem);
		((ns1__PayMiniCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayMiniCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayMiniCardItem);
		for (int i = 0; i < n; i++)
			((ns1__PayMiniCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayMiniCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayMiniCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayMiniCardItem %p -> %p\n", q, p));
	*(ns1__PayMiniCardItem*)p = *(ns1__PayMiniCardItem*)q;
}

void ns1__ArrayOfPayMiniCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPayMiniCardItem::__sizePayMiniCardItem = 0;
	this->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPayMiniCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPayMiniCardItem::__sizePayMiniCardItem; i++)
		{
			soap_serialize_PointerTons1__PayMiniCardItem(soap, this->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPayMiniCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPayMiniCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPayMiniCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPayMiniCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPayMiniCardItem::__sizePayMiniCardItem; i++)
			if (soap_out_PointerTons1__PayMiniCardItem(soap, "ns1:PayMiniCardItem", -1, a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem + i, "ns1:PayMiniCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPayMiniCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPayMiniCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPayMiniCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPayMiniCardItem(struct soap *soap, const char *tag, ns1__ArrayOfPayMiniCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPayMiniCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem, sizeof(ns1__ArrayOfPayMiniCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPayMiniCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPayMiniCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PayMiniCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PayMiniCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem == NULL)
				{	if (soap_blist_PayMiniCardItem1 == NULL)
						soap_blist_PayMiniCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = (ns1__PayMiniCardItem **)soap_push_block(soap, soap_blist_PayMiniCardItem1, sizeof(ns1__PayMiniCardItem *));
					if (a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PayMiniCardItem(soap, "ns1:PayMiniCardItem", a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem, "ns1:PayMiniCardItem"))
				{	a->ns1__ArrayOfPayMiniCardItem::__sizePayMiniCardItem++;
					a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem)
			soap_pop_block(soap, soap_blist_PayMiniCardItem1);
		if (a->ns1__ArrayOfPayMiniCardItem::__sizePayMiniCardItem)
			a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = (ns1__PayMiniCardItem **)soap_save_block(soap, soap_blist_PayMiniCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPayMiniCardItem::PayMiniCardItem = NULL;
			if (soap_blist_PayMiniCardItem1)
				soap_end_block(soap, soap_blist_PayMiniCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPayMiniCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem, 0, sizeof(ns1__ArrayOfPayMiniCardItem), 0, soap_copy_ns1__ArrayOfPayMiniCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPayMiniCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPayMiniCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPayMiniCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPayMiniCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPayMiniCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPayMiniCardItem(struct soap *soap, ns1__ArrayOfPayMiniCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPayMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPayMiniCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPayMiniCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPayMiniCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayMiniCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPayMiniCardItem);
		((ns1__ArrayOfPayMiniCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayMiniCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPayMiniCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPayMiniCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPayMiniCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPayMiniCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPayMiniCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPayMiniCardItem*)p = *(ns1__ArrayOfPayMiniCardItem*)q;
}

void ns1__MiniCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__MiniCardItem::id);
	soap_default_string(soap, &this->ns1__MiniCardItem::cardNo);
	soap_default_string(soap, &this->ns1__MiniCardItem::noSection);
	soap_default_string(soap, &this->ns1__MiniCardItem::SP);
	soap_default_string(soap, &this->ns1__MiniCardItem::state);
	soap_default_ns2__guid(soap, &this->ns1__MiniCardItem::getWorkerId);
	soap_default_string(soap, &this->ns1__MiniCardItem::getWorkerName);
	soap_default_ns2__guid(soap, &this->ns1__MiniCardItem::workerId);
	soap_default_string(soap, &this->ns1__MiniCardItem::workerName);
	soap_default_ns2__guid(soap, &this->ns1__MiniCardItem::userId);
	soap_default_string(soap, &this->ns1__MiniCardItem::userName);
	soap_default_time(soap, &this->ns1__MiniCardItem::getDate);
	soap_default_time(soap, &this->ns1__MiniCardItem::assignDate);
	soap_default_time(soap, &this->ns1__MiniCardItem::sellDate);
	soap_default_time(soap, &this->ns1__MiniCardItem::usedDate);
	/* transient soap skipped */
}

void ns1__MiniCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__MiniCardItem::id);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::cardNo);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::noSection);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::SP);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__MiniCardItem::getWorkerId);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::getWorkerName);
	soap_serialize_ns2__guid(soap, &this->ns1__MiniCardItem::workerId);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::workerName);
	soap_serialize_ns2__guid(soap, &this->ns1__MiniCardItem::userId);
	soap_serialize_string(soap, &this->ns1__MiniCardItem::userName);
	/* transient soap skipped */
}

int ns1__MiniCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MiniCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MiniCardItem(struct soap *soap, const char *tag, int id, const ns1__MiniCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MiniCardItem), type))
		return soap->error;
	if (a->ns1__MiniCardItem::id)
	{	if (soap_out_ns2__guid(soap, "ns1:id", -1, &a->ns1__MiniCardItem::id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:cardNo", -1, &(a->ns1__MiniCardItem::cardNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:noSection", -1, &(a->ns1__MiniCardItem::noSection), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->ns1__MiniCardItem::SP), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__MiniCardItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__MiniCardItem::getWorkerId)
	{	if (soap_out_ns2__guid(soap, "ns1:getWorkerId", -1, &a->ns1__MiniCardItem::getWorkerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getWorkerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:getWorkerName", -1, &(a->ns1__MiniCardItem::getWorkerName), "xsd:string"))
		return soap->error;
	if (a->ns1__MiniCardItem::workerId)
	{	if (soap_out_ns2__guid(soap, "ns1:workerId", -1, &a->ns1__MiniCardItem::workerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workerName", -1, &(a->ns1__MiniCardItem::workerName), "xsd:string"))
		return soap->error;
	if (a->ns1__MiniCardItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__MiniCardItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__MiniCardItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:getDate", -1, &(a->ns1__MiniCardItem::getDate), "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "ns1:assignDate", -1, &(a->ns1__MiniCardItem::assignDate), "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "ns1:sellDate", -1, &(a->ns1__MiniCardItem::sellDate), "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "ns1:usedDate", -1, &(a->ns1__MiniCardItem::usedDate), "xsd:dateTime"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MiniCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MiniCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MiniCardItem * SOAP_FMAC4 soap_in_ns1__MiniCardItem(struct soap *soap, const char *tag, ns1__MiniCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MiniCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MiniCardItem, sizeof(ns1__MiniCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MiniCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MiniCardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_cardNo1 = 1;
	size_t soap_flag_noSection1 = 1;
	size_t soap_flag_SP1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_getWorkerId1 = 1;
	size_t soap_flag_getWorkerName1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_workerName1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_getDate1 = 1;
	size_t soap_flag_assignDate1 = 1;
	size_t soap_flag_sellDate1 = 1;
	size_t soap_flag_usedDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:id", &(a->ns1__MiniCardItem::id), "ns2:guid"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_cardNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cardNo", &(a->ns1__MiniCardItem::cardNo), "xsd:string"))
				{	soap_flag_cardNo1--;
					continue;
				}
			if (soap_flag_noSection1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:noSection", &(a->ns1__MiniCardItem::noSection), "xsd:string"))
				{	soap_flag_noSection1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->ns1__MiniCardItem::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__MiniCardItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_getWorkerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:getWorkerId", &(a->ns1__MiniCardItem::getWorkerId), "ns2:guid"))
				{	soap_flag_getWorkerId1--;
					continue;
				}
			if (soap_flag_getWorkerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getWorkerName", &(a->ns1__MiniCardItem::getWorkerName), "xsd:string"))
				{	soap_flag_getWorkerName1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workerId", &(a->ns1__MiniCardItem::workerId), "ns2:guid"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_workerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workerName", &(a->ns1__MiniCardItem::workerName), "xsd:string"))
				{	soap_flag_workerName1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__MiniCardItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__MiniCardItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_getDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:getDate", &(a->ns1__MiniCardItem::getDate), "xsd:dateTime"))
				{	soap_flag_getDate1--;
					continue;
				}
			if (soap_flag_assignDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:assignDate", &(a->ns1__MiniCardItem::assignDate), "xsd:dateTime"))
				{	soap_flag_assignDate1--;
					continue;
				}
			if (soap_flag_sellDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:sellDate", &(a->ns1__MiniCardItem::sellDate), "xsd:dateTime"))
				{	soap_flag_sellDate1--;
					continue;
				}
			if (soap_flag_usedDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:usedDate", &(a->ns1__MiniCardItem::usedDate), "xsd:dateTime"))
				{	soap_flag_usedDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MiniCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MiniCardItem, 0, sizeof(ns1__MiniCardItem), 0, soap_copy_ns1__MiniCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_getWorkerId1 > 0 || soap_flag_workerId1 > 0 || soap_flag_userId1 > 0 || soap_flag_getDate1 > 0 || soap_flag_assignDate1 > 0 || soap_flag_sellDate1 > 0 || soap_flag_usedDate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__MiniCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MiniCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:MiniCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MiniCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MiniCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MiniCardItem * SOAP_FMAC4 soap_get_ns1__MiniCardItem(struct soap *soap, ns1__MiniCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__MiniCardItem * SOAP_FMAC2 soap_instantiate_ns1__MiniCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MiniCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MiniCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__MiniCardItem);
		if (size)
			*size = sizeof(ns1__MiniCardItem);
		((ns1__MiniCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__MiniCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MiniCardItem);
		for (int i = 0; i < n; i++)
			((ns1__MiniCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MiniCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MiniCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MiniCardItem %p -> %p\n", q, p));
	*(ns1__MiniCardItem*)p = *(ns1__MiniCardItem*)q;
}

void ns1__ArrayOfMiniCardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfMiniCardItem::__sizeMiniCardItem = 0;
	this->ns1__ArrayOfMiniCardItem::MiniCardItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfMiniCardItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfMiniCardItem::MiniCardItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfMiniCardItem::__sizeMiniCardItem; i++)
		{
			soap_serialize_PointerTons1__MiniCardItem(soap, this->ns1__ArrayOfMiniCardItem::MiniCardItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfMiniCardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfMiniCardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfMiniCardItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfMiniCardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfMiniCardItem), type))
		return soap->error;
	if (a->ns1__ArrayOfMiniCardItem::MiniCardItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfMiniCardItem::__sizeMiniCardItem; i++)
			if (soap_out_PointerTons1__MiniCardItem(soap, "ns1:MiniCardItem", -1, a->ns1__ArrayOfMiniCardItem::MiniCardItem + i, "ns1:MiniCardItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfMiniCardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfMiniCardItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfMiniCardItem * SOAP_FMAC4 soap_in_ns1__ArrayOfMiniCardItem(struct soap *soap, const char *tag, ns1__ArrayOfMiniCardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfMiniCardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfMiniCardItem, sizeof(ns1__ArrayOfMiniCardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfMiniCardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfMiniCardItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_MiniCardItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:MiniCardItem", 1, NULL))
			{	if (a->ns1__ArrayOfMiniCardItem::MiniCardItem == NULL)
				{	if (soap_blist_MiniCardItem1 == NULL)
						soap_blist_MiniCardItem1 = soap_new_block(soap);
					a->ns1__ArrayOfMiniCardItem::MiniCardItem = (ns1__MiniCardItem **)soap_push_block(soap, soap_blist_MiniCardItem1, sizeof(ns1__MiniCardItem *));
					if (a->ns1__ArrayOfMiniCardItem::MiniCardItem == NULL)
						return NULL;
					*a->ns1__ArrayOfMiniCardItem::MiniCardItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__MiniCardItem(soap, "ns1:MiniCardItem", a->ns1__ArrayOfMiniCardItem::MiniCardItem, "ns1:MiniCardItem"))
				{	a->ns1__ArrayOfMiniCardItem::__sizeMiniCardItem++;
					a->ns1__ArrayOfMiniCardItem::MiniCardItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfMiniCardItem::MiniCardItem)
			soap_pop_block(soap, soap_blist_MiniCardItem1);
		if (a->ns1__ArrayOfMiniCardItem::__sizeMiniCardItem)
			a->ns1__ArrayOfMiniCardItem::MiniCardItem = (ns1__MiniCardItem **)soap_save_block(soap, soap_blist_MiniCardItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfMiniCardItem::MiniCardItem = NULL;
			if (soap_blist_MiniCardItem1)
				soap_end_block(soap, soap_blist_MiniCardItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfMiniCardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfMiniCardItem, 0, sizeof(ns1__ArrayOfMiniCardItem), 0, soap_copy_ns1__ArrayOfMiniCardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfMiniCardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfMiniCardItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfMiniCardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfMiniCardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfMiniCardItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfMiniCardItem * SOAP_FMAC4 soap_get_ns1__ArrayOfMiniCardItem(struct soap *soap, ns1__ArrayOfMiniCardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfMiniCardItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfMiniCardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfMiniCardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfMiniCardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfMiniCardItem);
		if (size)
			*size = sizeof(ns1__ArrayOfMiniCardItem);
		((ns1__ArrayOfMiniCardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfMiniCardItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfMiniCardItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfMiniCardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfMiniCardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfMiniCardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfMiniCardItem %p -> %p\n", q, p));
	*(ns1__ArrayOfMiniCardItem*)p = *(ns1__ArrayOfMiniCardItem*)q;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfString::__sizestring = 0;
	this->ns1__ArrayOfString::string = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfString::__sizestring; i++)
		{
			soap_serialize_string(soap, this->ns1__ArrayOfString::string + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (a->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfString::__sizestring; i++)
			if (soap_out_string(soap, "ns1:string", -1, a->ns1__ArrayOfString::string + i, "xsd:string"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:string", 1, NULL))
			{	if (a->ns1__ArrayOfString::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns1__ArrayOfString::string = (char **)soap_push_block(soap, soap_blist_string1, sizeof(char *));
					if (a->ns1__ArrayOfString::string == NULL)
						return NULL;
					*a->ns1__ArrayOfString::string = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:string", a->ns1__ArrayOfString::string, "xsd:string"))
				{	a->ns1__ArrayOfString::__sizestring++;
					a->ns1__ArrayOfString::string = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfString::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns1__ArrayOfString::__sizestring)
			a->ns1__ArrayOfString::string = (char **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns1__ArrayOfString::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfString", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfString);
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfString[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}

void ns1__PhoneNoItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PhoneNoItem::id);
	soap_default_string(soap, &this->ns1__PhoneNoItem::No);
	soap_default_string(soap, &this->ns1__PhoneNoItem::NoSection);
	soap_default_string(soap, &this->ns1__PhoneNoItem::inNetPolicy);
	soap_default_double(soap, &this->ns1__PhoneNoItem::NoPrice);
	soap_default_string(soap, &this->ns1__PhoneNoItem::area);
	soap_default_int(soap, &this->ns1__PhoneNoItem::weight);
	soap_default_string(soap, &this->ns1__PhoneNoItem::state);
	soap_default_time(soap, &this->ns1__PhoneNoItem::lockDateime);
	soap_default_ns2__guid(soap, &this->ns1__PhoneNoItem::getterId);
	soap_default_string(soap, &this->ns1__PhoneNoItem::getterName);
	soap_default_time(soap, &this->ns1__PhoneNoItem::getDateime);
	soap_default_ns2__guid(soap, &this->ns1__PhoneNoItem::assignerId);
	soap_default_string(soap, &this->ns1__PhoneNoItem::assignerName);
	soap_default_time(soap, &this->ns1__PhoneNoItem::assignDateime);
	soap_default_ns2__guid(soap, &this->ns1__PhoneNoItem::userId);
	soap_default_string(soap, &this->ns1__PhoneNoItem::userName);
	soap_default_time(soap, &this->ns1__PhoneNoItem::usedDateime);
	soap_default_string(soap, &this->ns1__PhoneNoItem::sp);
	/* transient soap skipped */
}

void ns1__PhoneNoItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PhoneNoItem::id);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::No);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::NoSection);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::inNetPolicy);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::area);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__PhoneNoItem::getterId);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::getterName);
	soap_serialize_ns2__guid(soap, &this->ns1__PhoneNoItem::assignerId);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::assignerName);
	soap_serialize_ns2__guid(soap, &this->ns1__PhoneNoItem::userId);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::userName);
	soap_serialize_string(soap, &this->ns1__PhoneNoItem::sp);
	/* transient soap skipped */
}

int ns1__PhoneNoItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneNoItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneNoItem(struct soap *soap, const char *tag, int id, const ns1__PhoneNoItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneNoItem), type))
		return soap->error;
	if (a->ns1__PhoneNoItem::id)
	{	if (soap_out_ns2__guid(soap, "ns1:id", -1, &a->ns1__PhoneNoItem::id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:No", -1, &(a->ns1__PhoneNoItem::No), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:NoSection", -1, &(a->ns1__PhoneNoItem::NoSection), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:inNetPolicy", -1, &(a->ns1__PhoneNoItem::inNetPolicy), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:NoPrice", -1, &(a->ns1__PhoneNoItem::NoPrice), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__PhoneNoItem::area), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:weight", -1, &(a->ns1__PhoneNoItem::weight), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PhoneNoItem::state), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:lockDateime", -1, &(a->ns1__PhoneNoItem::lockDateime), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__PhoneNoItem::getterId)
	{	if (soap_out_ns2__guid(soap, "ns1:getterId", -1, &a->ns1__PhoneNoItem::getterId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getterId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:getterName", -1, &(a->ns1__PhoneNoItem::getterName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:getDateime", -1, &(a->ns1__PhoneNoItem::getDateime), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__PhoneNoItem::assignerId)
	{	if (soap_out_ns2__guid(soap, "ns1:assignerId", -1, &a->ns1__PhoneNoItem::assignerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:assignerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:assignerName", -1, &(a->ns1__PhoneNoItem::assignerName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:assignDateime", -1, &(a->ns1__PhoneNoItem::assignDateime), "xsd:dateTime"))
		return soap->error;
	if (a->ns1__PhoneNoItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__PhoneNoItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__PhoneNoItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:usedDateime", -1, &(a->ns1__PhoneNoItem::usedDateime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:sp", -1, &(a->ns1__PhoneNoItem::sp), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PhoneNoItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneNoItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneNoItem * SOAP_FMAC4 soap_in_ns1__PhoneNoItem(struct soap *soap, const char *tag, ns1__PhoneNoItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PhoneNoItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneNoItem, sizeof(ns1__PhoneNoItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PhoneNoItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PhoneNoItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_No1 = 1;
	size_t soap_flag_NoSection1 = 1;
	size_t soap_flag_inNetPolicy1 = 1;
	size_t soap_flag_NoPrice1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_lockDateime1 = 1;
	size_t soap_flag_getterId1 = 1;
	size_t soap_flag_getterName1 = 1;
	size_t soap_flag_getDateime1 = 1;
	size_t soap_flag_assignerId1 = 1;
	size_t soap_flag_assignerName1 = 1;
	size_t soap_flag_assignDateime1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_usedDateime1 = 1;
	size_t soap_flag_sp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:id", &(a->ns1__PhoneNoItem::id), "ns2:guid"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_No1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:No", &(a->ns1__PhoneNoItem::No), "xsd:string"))
				{	soap_flag_No1--;
					continue;
				}
			if (soap_flag_NoSection1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NoSection", &(a->ns1__PhoneNoItem::NoSection), "xsd:string"))
				{	soap_flag_NoSection1--;
					continue;
				}
			if (soap_flag_inNetPolicy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:inNetPolicy", &(a->ns1__PhoneNoItem::inNetPolicy), "xsd:string"))
				{	soap_flag_inNetPolicy1--;
					continue;
				}
			if (soap_flag_NoPrice1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:NoPrice", &(a->ns1__PhoneNoItem::NoPrice), "xsd:double"))
				{	soap_flag_NoPrice1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__PhoneNoItem::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:weight", &(a->ns1__PhoneNoItem::weight), "xsd:int"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PhoneNoItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_lockDateime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:lockDateime", &(a->ns1__PhoneNoItem::lockDateime), "xsd:dateTime"))
				{	soap_flag_lockDateime1--;
					continue;
				}
			if (soap_flag_getterId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:getterId", &(a->ns1__PhoneNoItem::getterId), "ns2:guid"))
				{	soap_flag_getterId1--;
					continue;
				}
			if (soap_flag_getterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getterName", &(a->ns1__PhoneNoItem::getterName), "xsd:string"))
				{	soap_flag_getterName1--;
					continue;
				}
			if (soap_flag_getDateime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:getDateime", &(a->ns1__PhoneNoItem::getDateime), "xsd:dateTime"))
				{	soap_flag_getDateime1--;
					continue;
				}
			if (soap_flag_assignerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:assignerId", &(a->ns1__PhoneNoItem::assignerId), "ns2:guid"))
				{	soap_flag_assignerId1--;
					continue;
				}
			if (soap_flag_assignerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:assignerName", &(a->ns1__PhoneNoItem::assignerName), "xsd:string"))
				{	soap_flag_assignerName1--;
					continue;
				}
			if (soap_flag_assignDateime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:assignDateime", &(a->ns1__PhoneNoItem::assignDateime), "xsd:dateTime"))
				{	soap_flag_assignDateime1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__PhoneNoItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__PhoneNoItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_usedDateime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:usedDateime", &(a->ns1__PhoneNoItem::usedDateime), "xsd:dateTime"))
				{	soap_flag_usedDateime1--;
					continue;
				}
			if (soap_flag_sp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sp", &(a->ns1__PhoneNoItem::sp), "xsd:string"))
				{	soap_flag_sp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNoItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PhoneNoItem, 0, sizeof(ns1__PhoneNoItem), 0, soap_copy_ns1__PhoneNoItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_NoPrice1 > 0 || soap_flag_weight1 > 0 || soap_flag_lockDateime1 > 0 || soap_flag_getterId1 > 0 || soap_flag_getDateime1 > 0 || soap_flag_assignerId1 > 0 || soap_flag_assignDateime1 > 0 || soap_flag_userId1 > 0 || soap_flag_usedDateime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PhoneNoItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PhoneNoItem);
	if (this->soap_out(soap, tag?tag:"ns1:PhoneNoItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PhoneNoItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneNoItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneNoItem * SOAP_FMAC4 soap_get_ns1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneNoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PhoneNoItem * SOAP_FMAC2 soap_instantiate_ns1__PhoneNoItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneNoItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneNoItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNoItem);
		if (size)
			*size = sizeof(ns1__PhoneNoItem);
		((ns1__PhoneNoItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNoItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PhoneNoItem);
		for (int i = 0; i < n; i++)
			((ns1__PhoneNoItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PhoneNoItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PhoneNoItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PhoneNoItem %p -> %p\n", q, p));
	*(ns1__PhoneNoItem*)p = *(ns1__PhoneNoItem*)q;
}

void ns1__ArrayOfPhoneNoItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPhoneNoItem::__sizePhoneNoItem = 0;
	this->ns1__ArrayOfPhoneNoItem::PhoneNoItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPhoneNoItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPhoneNoItem::PhoneNoItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPhoneNoItem::__sizePhoneNoItem; i++)
		{
			soap_serialize_PointerTons1__PhoneNoItem(soap, this->ns1__ArrayOfPhoneNoItem::PhoneNoItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPhoneNoItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPhoneNoItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPhoneNoItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPhoneNoItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPhoneNoItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPhoneNoItem::PhoneNoItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPhoneNoItem::__sizePhoneNoItem; i++)
			if (soap_out_PointerTons1__PhoneNoItem(soap, "ns1:PhoneNoItem", -1, a->ns1__ArrayOfPhoneNoItem::PhoneNoItem + i, "ns1:PhoneNoItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPhoneNoItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPhoneNoItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNoItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPhoneNoItem(struct soap *soap, const char *tag, ns1__ArrayOfPhoneNoItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPhoneNoItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPhoneNoItem, sizeof(ns1__ArrayOfPhoneNoItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPhoneNoItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPhoneNoItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PhoneNoItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PhoneNoItem", 1, NULL))
			{	if (a->ns1__ArrayOfPhoneNoItem::PhoneNoItem == NULL)
				{	if (soap_blist_PhoneNoItem1 == NULL)
						soap_blist_PhoneNoItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPhoneNoItem::PhoneNoItem = (ns1__PhoneNoItem **)soap_push_block(soap, soap_blist_PhoneNoItem1, sizeof(ns1__PhoneNoItem *));
					if (a->ns1__ArrayOfPhoneNoItem::PhoneNoItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPhoneNoItem::PhoneNoItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PhoneNoItem(soap, "ns1:PhoneNoItem", a->ns1__ArrayOfPhoneNoItem::PhoneNoItem, "ns1:PhoneNoItem"))
				{	a->ns1__ArrayOfPhoneNoItem::__sizePhoneNoItem++;
					a->ns1__ArrayOfPhoneNoItem::PhoneNoItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPhoneNoItem::PhoneNoItem)
			soap_pop_block(soap, soap_blist_PhoneNoItem1);
		if (a->ns1__ArrayOfPhoneNoItem::__sizePhoneNoItem)
			a->ns1__ArrayOfPhoneNoItem::PhoneNoItem = (ns1__PhoneNoItem **)soap_save_block(soap, soap_blist_PhoneNoItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPhoneNoItem::PhoneNoItem = NULL;
			if (soap_blist_PhoneNoItem1)
				soap_end_block(soap, soap_blist_PhoneNoItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPhoneNoItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPhoneNoItem, 0, sizeof(ns1__ArrayOfPhoneNoItem), 0, soap_copy_ns1__ArrayOfPhoneNoItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPhoneNoItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPhoneNoItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPhoneNoItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPhoneNoItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPhoneNoItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNoItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPhoneNoItem(struct soap *soap, ns1__ArrayOfPhoneNoItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPhoneNoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPhoneNoItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPhoneNoItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPhoneNoItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPhoneNoItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPhoneNoItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPhoneNoItem);
		((ns1__ArrayOfPhoneNoItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPhoneNoItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPhoneNoItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPhoneNoItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPhoneNoItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPhoneNoItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPhoneNoItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPhoneNoItem*)p = *(ns1__ArrayOfPhoneNoItem*)q;
}

void ns1__PhoneNoList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__PhoneNoList::total);
	soap_default_int(soap, &this->ns1__PhoneNoList::totalPage);
	soap_default_int(soap, &this->ns1__PhoneNoList::pageSize);
	soap_default_int(soap, &this->ns1__PhoneNoList::currentPageIndex);
	this->ns1__PhoneNoList::listOfPhoneNo = NULL;
	/* transient soap skipped */
}

void ns1__PhoneNoList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPhoneNoItem(soap, &this->ns1__PhoneNoList::listOfPhoneNo);
	/* transient soap skipped */
}

int ns1__PhoneNoList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneNoList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneNoList(struct soap *soap, const char *tag, int id, const ns1__PhoneNoList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneNoList), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:total", -1, &(a->ns1__PhoneNoList::total), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:totalPage", -1, &(a->ns1__PhoneNoList::totalPage), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->ns1__PhoneNoList::pageSize), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:currentPageIndex", -1, &(a->ns1__PhoneNoList::currentPageIndex), "xsd:int"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:listOfPhoneNo", -1, &(a->ns1__PhoneNoList::listOfPhoneNo), "ns1:ArrayOfPhoneNoItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PhoneNoList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneNoList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneNoList * SOAP_FMAC4 soap_in_ns1__PhoneNoList(struct soap *soap, const char *tag, ns1__PhoneNoList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PhoneNoList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneNoList, sizeof(ns1__PhoneNoList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PhoneNoList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PhoneNoList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_total1 = 1;
	size_t soap_flag_totalPage1 = 1;
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_currentPageIndex1 = 1;
	size_t soap_flag_listOfPhoneNo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &(a->ns1__PhoneNoList::total), "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_totalPage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:totalPage", &(a->ns1__PhoneNoList::totalPage), "xsd:int"))
				{	soap_flag_totalPage1--;
					continue;
				}
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->ns1__PhoneNoList::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_currentPageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:currentPageIndex", &(a->ns1__PhoneNoList::currentPageIndex), "xsd:int"))
				{	soap_flag_currentPageIndex1--;
					continue;
				}
			if (soap_flag_listOfPhoneNo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPhoneNoItem(soap, "ns1:listOfPhoneNo", &(a->ns1__PhoneNoList::listOfPhoneNo), "ns1:ArrayOfPhoneNoItem"))
				{	soap_flag_listOfPhoneNo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PhoneNoList, 0, sizeof(ns1__PhoneNoList), 0, soap_copy_ns1__PhoneNoList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0 || soap_flag_totalPage1 > 0 || soap_flag_pageSize1 > 0 || soap_flag_currentPageIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PhoneNoList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PhoneNoList);
	if (this->soap_out(soap, tag?tag:"ns1:PhoneNoList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PhoneNoList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneNoList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneNoList * SOAP_FMAC4 soap_get_ns1__PhoneNoList(struct soap *soap, ns1__PhoneNoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneNoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PhoneNoList * SOAP_FMAC2 soap_instantiate_ns1__PhoneNoList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneNoList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneNoList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNoList);
		if (size)
			*size = sizeof(ns1__PhoneNoList);
		((ns1__PhoneNoList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNoList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PhoneNoList);
		for (int i = 0; i < n; i++)
			((ns1__PhoneNoList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PhoneNoList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PhoneNoList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PhoneNoList %p -> %p\n", q, p));
	*(ns1__PhoneNoList*)p = *(ns1__PhoneNoList*)q;
}

void ns1__Result::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Result::UserName);
	soap_default_string(soap, &this->ns1__Result::Balance);
	soap_default_string(soap, &this->ns1__Result::PhoneType);
	soap_default_string(soap, &this->ns1__Result::AccessNum);
	/* transient soap skipped */
}

void ns1__Result::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Result::UserName);
	soap_serialize_string(soap, &this->ns1__Result::Balance);
	soap_serialize_string(soap, &this->ns1__Result::PhoneType);
	soap_serialize_string(soap, &this->ns1__Result::AccessNum);
	/* transient soap skipped */
}

int ns1__Result::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Result(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Result(struct soap *soap, const char *tag, int id, const ns1__Result *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Result), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:UserName", -1, &(a->ns1__Result::UserName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Balance", -1, &(a->ns1__Result::Balance), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:PhoneType", -1, &(a->ns1__Result::PhoneType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:AccessNum", -1, &(a->ns1__Result::AccessNum), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Result::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Result(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Result * SOAP_FMAC4 soap_in_ns1__Result(struct soap *soap, const char *tag, ns1__Result *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Result *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Result, sizeof(ns1__Result), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Result)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Result *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Balance1 = 1;
	size_t soap_flag_PhoneType1 = 1;
	size_t soap_flag_AccessNum1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UserName", &(a->ns1__Result::UserName), "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			if (soap_flag_Balance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Balance", &(a->ns1__Result::Balance), "xsd:string"))
				{	soap_flag_Balance1--;
					continue;
				}
			if (soap_flag_PhoneType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PhoneType", &(a->ns1__Result::PhoneType), "xsd:string"))
				{	soap_flag_PhoneType1--;
					continue;
				}
			if (soap_flag_AccessNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AccessNum", &(a->ns1__Result::AccessNum), "xsd:string"))
				{	soap_flag_AccessNum1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Result, 0, sizeof(ns1__Result), 0, soap_copy_ns1__Result);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Result::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Result);
	if (this->soap_out(soap, tag?tag:"ns1:Result", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Result::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Result(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Result * SOAP_FMAC4 soap_get_ns1__Result(struct soap *soap, ns1__Result *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Result * SOAP_FMAC2 soap_instantiate_ns1__Result(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Result(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Result, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Result);
		if (size)
			*size = sizeof(ns1__Result);
		((ns1__Result*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Result[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Result);
		for (int i = 0; i < n; i++)
			((ns1__Result*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Result*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Result(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Result %p -> %p\n", q, p));
	*(ns1__Result*)p = *(ns1__Result*)q;
}

void ns1__CompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__CompanyAccount::Id);
	soap_default_string(soap, &this->ns1__CompanyAccount::AccountNo);
	soap_default_string(soap, &this->ns1__CompanyAccount::Bank);
	soap_default_string(soap, &this->ns1__CompanyAccount::userName);
	soap_default_string(soap, &this->ns1__CompanyAccount::clientType);
	/* transient soap skipped */
}

void ns1__CompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__CompanyAccount::Id);
	soap_serialize_string(soap, &this->ns1__CompanyAccount::AccountNo);
	soap_serialize_string(soap, &this->ns1__CompanyAccount::Bank);
	soap_serialize_string(soap, &this->ns1__CompanyAccount::userName);
	soap_serialize_string(soap, &this->ns1__CompanyAccount::clientType);
	/* transient soap skipped */
}

int ns1__CompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CompanyAccount(struct soap *soap, const char *tag, int id, const ns1__CompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CompanyAccount), type))
		return soap->error;
	if (a->ns1__CompanyAccount::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__CompanyAccount::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:AccountNo", -1, &(a->ns1__CompanyAccount::AccountNo), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Bank", -1, &(a->ns1__CompanyAccount::Bank), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__CompanyAccount::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__CompanyAccount::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CompanyAccount * SOAP_FMAC4 soap_in_ns1__CompanyAccount(struct soap *soap, const char *tag, ns1__CompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CompanyAccount, sizeof(ns1__CompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_AccountNo1 = 1;
	size_t soap_flag_Bank1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__CompanyAccount::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_AccountNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AccountNo", &(a->ns1__CompanyAccount::AccountNo), "xsd:string"))
				{	soap_flag_AccountNo1--;
					continue;
				}
			if (soap_flag_Bank1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Bank", &(a->ns1__CompanyAccount::Bank), "xsd:string"))
				{	soap_flag_Bank1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__CompanyAccount::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__CompanyAccount::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CompanyAccount, 0, sizeof(ns1__CompanyAccount), 0, soap_copy_ns1__CompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:CompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CompanyAccount * SOAP_FMAC4 soap_get_ns1__CompanyAccount(struct soap *soap, ns1__CompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CompanyAccount * SOAP_FMAC2 soap_instantiate_ns1__CompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CompanyAccount);
		if (size)
			*size = sizeof(ns1__CompanyAccount);
		((ns1__CompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CompanyAccount);
		for (int i = 0; i < n; i++)
			((ns1__CompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CompanyAccount %p -> %p\n", q, p));
	*(ns1__CompanyAccount*)p = *(ns1__CompanyAccount*)q;
}

void ns1__ArrayOfCompanyAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfCompanyAccount::__sizeCompanyAccount = 0;
	this->ns1__ArrayOfCompanyAccount::CompanyAccount = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfCompanyAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfCompanyAccount::CompanyAccount)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfCompanyAccount::__sizeCompanyAccount; i++)
		{
			soap_serialize_PointerTons1__CompanyAccount(soap, this->ns1__ArrayOfCompanyAccount::CompanyAccount + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfCompanyAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCompanyAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCompanyAccount(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCompanyAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfCompanyAccount), type))
		return soap->error;
	if (a->ns1__ArrayOfCompanyAccount::CompanyAccount)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfCompanyAccount::__sizeCompanyAccount; i++)
			if (soap_out_PointerTons1__CompanyAccount(soap, "ns1:CompanyAccount", -1, a->ns1__ArrayOfCompanyAccount::CompanyAccount + i, "ns1:CompanyAccount"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCompanyAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfCompanyAccount(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCompanyAccount * SOAP_FMAC4 soap_in_ns1__ArrayOfCompanyAccount(struct soap *soap, const char *tag, ns1__ArrayOfCompanyAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCompanyAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfCompanyAccount, sizeof(ns1__ArrayOfCompanyAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfCompanyAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfCompanyAccount *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CompanyAccount1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:CompanyAccount", 1, NULL))
			{	if (a->ns1__ArrayOfCompanyAccount::CompanyAccount == NULL)
				{	if (soap_blist_CompanyAccount1 == NULL)
						soap_blist_CompanyAccount1 = soap_new_block(soap);
					a->ns1__ArrayOfCompanyAccount::CompanyAccount = (ns1__CompanyAccount **)soap_push_block(soap, soap_blist_CompanyAccount1, sizeof(ns1__CompanyAccount *));
					if (a->ns1__ArrayOfCompanyAccount::CompanyAccount == NULL)
						return NULL;
					*a->ns1__ArrayOfCompanyAccount::CompanyAccount = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__CompanyAccount(soap, "ns1:CompanyAccount", a->ns1__ArrayOfCompanyAccount::CompanyAccount, "ns1:CompanyAccount"))
				{	a->ns1__ArrayOfCompanyAccount::__sizeCompanyAccount++;
					a->ns1__ArrayOfCompanyAccount::CompanyAccount = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfCompanyAccount::CompanyAccount)
			soap_pop_block(soap, soap_blist_CompanyAccount1);
		if (a->ns1__ArrayOfCompanyAccount::__sizeCompanyAccount)
			a->ns1__ArrayOfCompanyAccount::CompanyAccount = (ns1__CompanyAccount **)soap_save_block(soap, soap_blist_CompanyAccount1, NULL, 1);
		else
		{	a->ns1__ArrayOfCompanyAccount::CompanyAccount = NULL;
			if (soap_blist_CompanyAccount1)
				soap_end_block(soap, soap_blist_CompanyAccount1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCompanyAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfCompanyAccount, 0, sizeof(ns1__ArrayOfCompanyAccount), 0, soap_copy_ns1__ArrayOfCompanyAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfCompanyAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfCompanyAccount);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfCompanyAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfCompanyAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCompanyAccount(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCompanyAccount * SOAP_FMAC4 soap_get_ns1__ArrayOfCompanyAccount(struct soap *soap, ns1__ArrayOfCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfCompanyAccount * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfCompanyAccount);
		if (size)
			*size = sizeof(ns1__ArrayOfCompanyAccount);
		((ns1__ArrayOfCompanyAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfCompanyAccount);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfCompanyAccount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfCompanyAccount %p -> %p\n", q, p));
	*(ns1__ArrayOfCompanyAccount*)p = *(ns1__ArrayOfCompanyAccount*)q;
}

void ns1__CompanyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CompanyInfo::name);
	soap_default_string(soap, &this->ns1__CompanyInfo::address);
	soap_default_string(soap, &this->ns1__CompanyInfo::manager);
	soap_default_string(soap, &this->ns1__CompanyInfo::QQ);
	soap_default_string(soap, &this->ns1__CompanyInfo::tel_USCORE1);
	soap_default_string(soap, &this->ns1__CompanyInfo::tel_USCORE2);
	soap_default_string(soap, &this->ns1__CompanyInfo::clientType);
	/* transient soap skipped */
}

void ns1__CompanyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CompanyInfo::name);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::address);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::manager);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::QQ);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::tel_USCORE1);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::tel_USCORE2);
	soap_serialize_string(soap, &this->ns1__CompanyInfo::clientType);
	/* transient soap skipped */
}

int ns1__CompanyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CompanyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CompanyInfo(struct soap *soap, const char *tag, int id, const ns1__CompanyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CompanyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->ns1__CompanyInfo::name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:address", -1, &(a->ns1__CompanyInfo::address), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager", -1, &(a->ns1__CompanyInfo::manager), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:QQ", -1, &(a->ns1__CompanyInfo::QQ), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:tel_1", -1, &(a->ns1__CompanyInfo::tel_USCORE1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:tel_2", -1, &(a->ns1__CompanyInfo::tel_USCORE2), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__CompanyInfo::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CompanyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CompanyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CompanyInfo * SOAP_FMAC4 soap_in_ns1__CompanyInfo(struct soap *soap, const char *tag, ns1__CompanyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CompanyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CompanyInfo, sizeof(ns1__CompanyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CompanyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CompanyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_manager1 = 1;
	size_t soap_flag_QQ1 = 1;
	size_t soap_flag_tel_USCORE11 = 1;
	size_t soap_flag_tel_USCORE21 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->ns1__CompanyInfo::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:address", &(a->ns1__CompanyInfo::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_manager1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager", &(a->ns1__CompanyInfo::manager), "xsd:string"))
				{	soap_flag_manager1--;
					continue;
				}
			if (soap_flag_QQ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:QQ", &(a->ns1__CompanyInfo::QQ), "xsd:string"))
				{	soap_flag_QQ1--;
					continue;
				}
			if (soap_flag_tel_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:tel_1", &(a->ns1__CompanyInfo::tel_USCORE1), "xsd:string"))
				{	soap_flag_tel_USCORE11--;
					continue;
				}
			if (soap_flag_tel_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:tel_2", &(a->ns1__CompanyInfo::tel_USCORE2), "xsd:string"))
				{	soap_flag_tel_USCORE21--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__CompanyInfo::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CompanyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CompanyInfo, 0, sizeof(ns1__CompanyInfo), 0, soap_copy_ns1__CompanyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CompanyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CompanyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:CompanyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CompanyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CompanyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CompanyInfo * SOAP_FMAC4 soap_get_ns1__CompanyInfo(struct soap *soap, ns1__CompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CompanyInfo * SOAP_FMAC2 soap_instantiate_ns1__CompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CompanyInfo);
		if (size)
			*size = sizeof(ns1__CompanyInfo);
		((ns1__CompanyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CompanyInfo);
		for (int i = 0; i < n; i++)
			((ns1__CompanyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CompanyInfo %p -> %p\n", q, p));
	*(ns1__CompanyInfo*)p = *(ns1__CompanyInfo*)q;
}

void ns1__PhoneNumberBelong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PhoneNumberBelong::Id);
	soap_default_string(soap, &this->ns1__PhoneNumberBelong::HaoDuan);
	soap_default_string(soap, &this->ns1__PhoneNumberBelong::QuHao);
	soap_default_string(soap, &this->ns1__PhoneNumberBelong::ShengFen);
	soap_default_string(soap, &this->ns1__PhoneNumberBelong::City);
	soap_default_string(soap, &this->ns1__PhoneNumberBelong::Area);
	soap_default_time(soap, &this->ns1__PhoneNumberBelong::AddTime);
	/* transient soap skipped */
}

void ns1__PhoneNumberBelong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PhoneNumberBelong::Id);
	soap_serialize_string(soap, &this->ns1__PhoneNumberBelong::HaoDuan);
	soap_serialize_string(soap, &this->ns1__PhoneNumberBelong::QuHao);
	soap_serialize_string(soap, &this->ns1__PhoneNumberBelong::ShengFen);
	soap_serialize_string(soap, &this->ns1__PhoneNumberBelong::City);
	soap_serialize_string(soap, &this->ns1__PhoneNumberBelong::Area);
	/* transient soap skipped */
}

int ns1__PhoneNumberBelong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneNumberBelong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneNumberBelong(struct soap *soap, const char *tag, int id, const ns1__PhoneNumberBelong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneNumberBelong), type))
		return soap->error;
	if (a->ns1__PhoneNumberBelong::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PhoneNumberBelong::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:HaoDuan", -1, &(a->ns1__PhoneNumberBelong::HaoDuan), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:QuHao", -1, &(a->ns1__PhoneNumberBelong::QuHao), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:ShengFen", -1, &(a->ns1__PhoneNumberBelong::ShengFen), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:City", -1, &(a->ns1__PhoneNumberBelong::City), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Area", -1, &(a->ns1__PhoneNumberBelong::Area), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:AddTime", -1, &(a->ns1__PhoneNumberBelong::AddTime), "xsd:dateTime"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PhoneNumberBelong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneNumberBelong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneNumberBelong * SOAP_FMAC4 soap_in_ns1__PhoneNumberBelong(struct soap *soap, const char *tag, ns1__PhoneNumberBelong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PhoneNumberBelong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneNumberBelong, sizeof(ns1__PhoneNumberBelong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PhoneNumberBelong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PhoneNumberBelong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_HaoDuan1 = 1;
	size_t soap_flag_QuHao1 = 1;
	size_t soap_flag_ShengFen1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Area1 = 1;
	size_t soap_flag_AddTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PhoneNumberBelong::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_HaoDuan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:HaoDuan", &(a->ns1__PhoneNumberBelong::HaoDuan), "xsd:string"))
				{	soap_flag_HaoDuan1--;
					continue;
				}
			if (soap_flag_QuHao1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:QuHao", &(a->ns1__PhoneNumberBelong::QuHao), "xsd:string"))
				{	soap_flag_QuHao1--;
					continue;
				}
			if (soap_flag_ShengFen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ShengFen", &(a->ns1__PhoneNumberBelong::ShengFen), "xsd:string"))
				{	soap_flag_ShengFen1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:City", &(a->ns1__PhoneNumberBelong::City), "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Area", &(a->ns1__PhoneNumberBelong::Area), "xsd:string"))
				{	soap_flag_Area1--;
					continue;
				}
			if (soap_flag_AddTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:AddTime", &(a->ns1__PhoneNumberBelong::AddTime), "xsd:dateTime"))
				{	soap_flag_AddTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNumberBelong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PhoneNumberBelong, 0, sizeof(ns1__PhoneNumberBelong), 0, soap_copy_ns1__PhoneNumberBelong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_AddTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PhoneNumberBelong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PhoneNumberBelong);
	if (this->soap_out(soap, tag?tag:"ns1:PhoneNumberBelong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PhoneNumberBelong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneNumberBelong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneNumberBelong * SOAP_FMAC4 soap_get_ns1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PhoneNumberBelong * SOAP_FMAC2 soap_instantiate_ns1__PhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNumberBelong);
		if (size)
			*size = sizeof(ns1__PhoneNumberBelong);
		((ns1__PhoneNumberBelong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PhoneNumberBelong);
		for (int i = 0; i < n; i++)
			((ns1__PhoneNumberBelong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PhoneNumberBelong %p -> %p\n", q, p));
	*(ns1__PhoneNumberBelong*)p = *(ns1__PhoneNumberBelong*)q;
}

void ns1__ArrayOfPhoneNumberBelong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPhoneNumberBelong::__sizePhoneNumberBelong = 0;
	this->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPhoneNumberBelong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPhoneNumberBelong::__sizePhoneNumberBelong; i++)
		{
			soap_serialize_PointerTons1__PhoneNumberBelong(soap, this->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPhoneNumberBelong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPhoneNumberBelong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPhoneNumberBelong(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPhoneNumberBelong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong), type))
		return soap->error;
	if (a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPhoneNumberBelong::__sizePhoneNumberBelong; i++)
			if (soap_out_PointerTons1__PhoneNumberBelong(soap, "ns1:PhoneNumberBelong", -1, a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong + i, "ns1:PhoneNumberBelong"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPhoneNumberBelong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPhoneNumberBelong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNumberBelong * SOAP_FMAC4 soap_in_ns1__ArrayOfPhoneNumberBelong(struct soap *soap, const char *tag, ns1__ArrayOfPhoneNumberBelong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPhoneNumberBelong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong, sizeof(ns1__ArrayOfPhoneNumberBelong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPhoneNumberBelong *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PhoneNumberBelong1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PhoneNumberBelong", 1, NULL))
			{	if (a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong == NULL)
				{	if (soap_blist_PhoneNumberBelong1 == NULL)
						soap_blist_PhoneNumberBelong1 = soap_new_block(soap);
					a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = (ns1__PhoneNumberBelong **)soap_push_block(soap, soap_blist_PhoneNumberBelong1, sizeof(ns1__PhoneNumberBelong *));
					if (a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong == NULL)
						return NULL;
					*a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PhoneNumberBelong(soap, "ns1:PhoneNumberBelong", a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong, "ns1:PhoneNumberBelong"))
				{	a->ns1__ArrayOfPhoneNumberBelong::__sizePhoneNumberBelong++;
					a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong)
			soap_pop_block(soap, soap_blist_PhoneNumberBelong1);
		if (a->ns1__ArrayOfPhoneNumberBelong::__sizePhoneNumberBelong)
			a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = (ns1__PhoneNumberBelong **)soap_save_block(soap, soap_blist_PhoneNumberBelong1, NULL, 1);
		else
		{	a->ns1__ArrayOfPhoneNumberBelong::PhoneNumberBelong = NULL;
			if (soap_blist_PhoneNumberBelong1)
				soap_end_block(soap, soap_blist_PhoneNumberBelong1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPhoneNumberBelong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong, 0, sizeof(ns1__ArrayOfPhoneNumberBelong), 0, soap_copy_ns1__ArrayOfPhoneNumberBelong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPhoneNumberBelong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPhoneNumberBelong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPhoneNumberBelong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPhoneNumberBelong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNumberBelong * SOAP_FMAC4 soap_get_ns1__ArrayOfPhoneNumberBelong(struct soap *soap, ns1__ArrayOfPhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPhoneNumberBelong * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPhoneNumberBelong);
		if (size)
			*size = sizeof(ns1__ArrayOfPhoneNumberBelong);
		((ns1__ArrayOfPhoneNumberBelong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPhoneNumberBelong);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPhoneNumberBelong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPhoneNumberBelong %p -> %p\n", q, p));
	*(ns1__ArrayOfPhoneNumberBelong*)p = *(ns1__ArrayOfPhoneNumberBelong*)q;
}

void ns1__ReturnProportion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__ReturnProportion::Id);
	soap_default_string(soap, &this->ns1__ReturnProportion::ReturnClass);
	soap_default_string(soap, &this->ns1__ReturnProportion::ReturnName);
	soap_default_string(soap, &this->ns1__ReturnProportion::area);
	soap_default_string(soap, &this->ns1__ReturnProportion::level);
	soap_default_double(soap, &this->ns1__ReturnProportion::returnPoint);
	soap_default_string(soap, &this->ns1__ReturnProportion::content);
	/* transient soap skipped */
}

void ns1__ReturnProportion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__ReturnProportion::Id);
	soap_serialize_string(soap, &this->ns1__ReturnProportion::ReturnClass);
	soap_serialize_string(soap, &this->ns1__ReturnProportion::ReturnName);
	soap_serialize_string(soap, &this->ns1__ReturnProportion::area);
	soap_serialize_string(soap, &this->ns1__ReturnProportion::level);
	soap_serialize_string(soap, &this->ns1__ReturnProportion::content);
	/* transient soap skipped */
}

int ns1__ReturnProportion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnProportion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnProportion(struct soap *soap, const char *tag, int id, const ns1__ReturnProportion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnProportion), type))
		return soap->error;
	if (a->ns1__ReturnProportion::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__ReturnProportion::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:ReturnClass", -1, &(a->ns1__ReturnProportion::ReturnClass), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:ReturnName", -1, &(a->ns1__ReturnProportion::ReturnName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__ReturnProportion::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:level", -1, &(a->ns1__ReturnProportion::level), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnPoint", -1, &(a->ns1__ReturnProportion::returnPoint), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__ReturnProportion::content), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ReturnProportion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnProportion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnProportion * SOAP_FMAC4 soap_in_ns1__ReturnProportion(struct soap *soap, const char *tag, ns1__ReturnProportion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReturnProportion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnProportion, sizeof(ns1__ReturnProportion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReturnProportion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReturnProportion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_ReturnClass1 = 1;
	size_t soap_flag_ReturnName1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_returnPoint1 = 1;
	size_t soap_flag_content1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__ReturnProportion::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_ReturnClass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ReturnClass", &(a->ns1__ReturnProportion::ReturnClass), "xsd:string"))
				{	soap_flag_ReturnClass1--;
					continue;
				}
			if (soap_flag_ReturnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ReturnName", &(a->ns1__ReturnProportion::ReturnName), "xsd:string"))
				{	soap_flag_ReturnName1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__ReturnProportion::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_level1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:level", &(a->ns1__ReturnProportion::level), "xsd:string"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_returnPoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnPoint", &(a->ns1__ReturnProportion::returnPoint), "xsd:double"))
				{	soap_flag_returnPoint1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__ReturnProportion::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReturnProportion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnProportion, 0, sizeof(ns1__ReturnProportion), 0, soap_copy_ns1__ReturnProportion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_returnPoint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ReturnProportion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReturnProportion);
	if (this->soap_out(soap, tag?tag:"ns1:ReturnProportion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReturnProportion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnProportion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnProportion * SOAP_FMAC4 soap_get_ns1__ReturnProportion(struct soap *soap, ns1__ReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ReturnProportion * SOAP_FMAC2 soap_instantiate_ns1__ReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnProportion);
		if (size)
			*size = sizeof(ns1__ReturnProportion);
		((ns1__ReturnProportion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReturnProportion);
		for (int i = 0; i < n; i++)
			((ns1__ReturnProportion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReturnProportion %p -> %p\n", q, p));
	*(ns1__ReturnProportion*)p = *(ns1__ReturnProportion*)q;
}

void ns1__ArrayOfReturnProportion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfReturnProportion::__sizeReturnProportion = 0;
	this->ns1__ArrayOfReturnProportion::ReturnProportion = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfReturnProportion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfReturnProportion::ReturnProportion)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfReturnProportion::__sizeReturnProportion; i++)
		{
			soap_serialize_PointerTons1__ReturnProportion(soap, this->ns1__ArrayOfReturnProportion::ReturnProportion + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfReturnProportion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfReturnProportion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfReturnProportion(struct soap *soap, const char *tag, int id, const ns1__ArrayOfReturnProportion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfReturnProportion), type))
		return soap->error;
	if (a->ns1__ArrayOfReturnProportion::ReturnProportion)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfReturnProportion::__sizeReturnProportion; i++)
			if (soap_out_PointerTons1__ReturnProportion(soap, "ns1:ReturnProportion", -1, a->ns1__ArrayOfReturnProportion::ReturnProportion + i, "ns1:ReturnProportion"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfReturnProportion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfReturnProportion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnProportion * SOAP_FMAC4 soap_in_ns1__ArrayOfReturnProportion(struct soap *soap, const char *tag, ns1__ArrayOfReturnProportion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfReturnProportion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfReturnProportion, sizeof(ns1__ArrayOfReturnProportion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfReturnProportion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfReturnProportion *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ReturnProportion1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ReturnProportion", 1, NULL))
			{	if (a->ns1__ArrayOfReturnProportion::ReturnProportion == NULL)
				{	if (soap_blist_ReturnProportion1 == NULL)
						soap_blist_ReturnProportion1 = soap_new_block(soap);
					a->ns1__ArrayOfReturnProportion::ReturnProportion = (ns1__ReturnProportion **)soap_push_block(soap, soap_blist_ReturnProportion1, sizeof(ns1__ReturnProportion *));
					if (a->ns1__ArrayOfReturnProportion::ReturnProportion == NULL)
						return NULL;
					*a->ns1__ArrayOfReturnProportion::ReturnProportion = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ReturnProportion(soap, "ns1:ReturnProportion", a->ns1__ArrayOfReturnProportion::ReturnProportion, "ns1:ReturnProportion"))
				{	a->ns1__ArrayOfReturnProportion::__sizeReturnProportion++;
					a->ns1__ArrayOfReturnProportion::ReturnProportion = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfReturnProportion::ReturnProportion)
			soap_pop_block(soap, soap_blist_ReturnProportion1);
		if (a->ns1__ArrayOfReturnProportion::__sizeReturnProportion)
			a->ns1__ArrayOfReturnProportion::ReturnProportion = (ns1__ReturnProportion **)soap_save_block(soap, soap_blist_ReturnProportion1, NULL, 1);
		else
		{	a->ns1__ArrayOfReturnProportion::ReturnProportion = NULL;
			if (soap_blist_ReturnProportion1)
				soap_end_block(soap, soap_blist_ReturnProportion1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfReturnProportion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfReturnProportion, 0, sizeof(ns1__ArrayOfReturnProportion), 0, soap_copy_ns1__ArrayOfReturnProportion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfReturnProportion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfReturnProportion);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfReturnProportion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfReturnProportion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfReturnProportion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnProportion * SOAP_FMAC4 soap_get_ns1__ArrayOfReturnProportion(struct soap *soap, ns1__ArrayOfReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfReturnProportion * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnProportion);
		if (size)
			*size = sizeof(ns1__ArrayOfReturnProportion);
		((ns1__ArrayOfReturnProportion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfReturnProportion);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfReturnProportion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfReturnProportion %p -> %p\n", q, p));
	*(ns1__ArrayOfReturnProportion*)p = *(ns1__ArrayOfReturnProportion*)q;
}

void ns1__NoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__NoticeItem::Id);
	soap_default_string(soap, &this->ns1__NoticeItem::title);
	soap_default_string(soap, &this->ns1__NoticeItem::content);
	soap_default_time(soap, &this->ns1__NoticeItem::publishDatetime);
	soap_default_string(soap, &this->ns1__NoticeItem::type);
	soap_default_ns2__guid(soap, &this->ns1__NoticeItem::publisher_USCOREid);
	soap_default_bool(soap, &this->ns1__NoticeItem::isEnable);
	soap_default_int(soap, &this->ns1__NoticeItem::weight);
	soap_default_string(soap, &this->ns1__NoticeItem::clientType);
	/* transient soap skipped */
}

void ns1__NoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__NoticeItem::Id);
	soap_serialize_string(soap, &this->ns1__NoticeItem::title);
	soap_serialize_string(soap, &this->ns1__NoticeItem::content);
	soap_serialize_string(soap, &this->ns1__NoticeItem::type);
	soap_serialize_ns2__guid(soap, &this->ns1__NoticeItem::publisher_USCOREid);
	soap_serialize_string(soap, &this->ns1__NoticeItem::clientType);
	/* transient soap skipped */
}

int ns1__NoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoticeItem(struct soap *soap, const char *tag, int id, const ns1__NoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoticeItem), type))
		return soap->error;
	if (a->ns1__NoticeItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__NoticeItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:title", -1, &(a->ns1__NoticeItem::title), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__NoticeItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:publishDatetime", -1, &(a->ns1__NoticeItem::publishDatetime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->ns1__NoticeItem::type), "xsd:string"))
		return soap->error;
	if (a->ns1__NoticeItem::publisher_USCOREid)
	{	if (soap_out_ns2__guid(soap, "ns1:publisher_id", -1, &a->ns1__NoticeItem::publisher_USCOREid, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:publisher_id"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isEnable", -1, &(a->ns1__NoticeItem::isEnable), "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "ns1:weight", -1, &(a->ns1__NoticeItem::weight), "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__NoticeItem::clientType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__NoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoticeItem * SOAP_FMAC4 soap_in_ns1__NoticeItem(struct soap *soap, const char *tag, ns1__NoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoticeItem, sizeof(ns1__NoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_publishDatetime1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_publisher_USCOREid1 = 1;
	size_t soap_flag_isEnable1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_clientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__NoticeItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:title", &(a->ns1__NoticeItem::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__NoticeItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_publishDatetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:publishDatetime", &(a->ns1__NoticeItem::publishDatetime), "xsd:dateTime"))
				{	soap_flag_publishDatetime1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->ns1__NoticeItem::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_publisher_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:publisher_id", &(a->ns1__NoticeItem::publisher_USCOREid), "ns2:guid"))
				{	soap_flag_publisher_USCOREid1--;
					continue;
				}
			if (soap_flag_isEnable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isEnable", &(a->ns1__NoticeItem::isEnable), "xsd:boolean"))
				{	soap_flag_isEnable1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:weight", &(a->ns1__NoticeItem::weight), "xsd:int"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__NoticeItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoticeItem, 0, sizeof(ns1__NoticeItem), 0, soap_copy_ns1__NoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_publishDatetime1 > 0 || soap_flag_publisher_USCOREid1 > 0 || soap_flag_isEnable1 > 0 || soap_flag_weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__NoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:NoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoticeItem * SOAP_FMAC4 soap_get_ns1__NoticeItem(struct soap *soap, ns1__NoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoticeItem * SOAP_FMAC2 soap_instantiate_ns1__NoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoticeItem);
		if (size)
			*size = sizeof(ns1__NoticeItem);
		((ns1__NoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NoticeItem);
		for (int i = 0; i < n; i++)
			((ns1__NoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoticeItem %p -> %p\n", q, p));
	*(ns1__NoticeItem*)p = *(ns1__NoticeItem*)q;
}

void ns1__ArrayOfNoticeItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfNoticeItem::__sizeNoticeItem = 0;
	this->ns1__ArrayOfNoticeItem::NoticeItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfNoticeItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfNoticeItem::NoticeItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfNoticeItem::__sizeNoticeItem; i++)
		{
			soap_serialize_PointerTons1__NoticeItem(soap, this->ns1__ArrayOfNoticeItem::NoticeItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfNoticeItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfNoticeItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNoticeItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfNoticeItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfNoticeItem), type))
		return soap->error;
	if (a->ns1__ArrayOfNoticeItem::NoticeItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfNoticeItem::__sizeNoticeItem; i++)
			if (soap_out_PointerTons1__NoticeItem(soap, "ns1:NoticeItem", -1, a->ns1__ArrayOfNoticeItem::NoticeItem + i, "ns1:NoticeItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfNoticeItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfNoticeItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfNoticeItem * SOAP_FMAC4 soap_in_ns1__ArrayOfNoticeItem(struct soap *soap, const char *tag, ns1__ArrayOfNoticeItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfNoticeItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfNoticeItem, sizeof(ns1__ArrayOfNoticeItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfNoticeItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfNoticeItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NoticeItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:NoticeItem", 1, NULL))
			{	if (a->ns1__ArrayOfNoticeItem::NoticeItem == NULL)
				{	if (soap_blist_NoticeItem1 == NULL)
						soap_blist_NoticeItem1 = soap_new_block(soap);
					a->ns1__ArrayOfNoticeItem::NoticeItem = (ns1__NoticeItem **)soap_push_block(soap, soap_blist_NoticeItem1, sizeof(ns1__NoticeItem *));
					if (a->ns1__ArrayOfNoticeItem::NoticeItem == NULL)
						return NULL;
					*a->ns1__ArrayOfNoticeItem::NoticeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__NoticeItem(soap, "ns1:NoticeItem", a->ns1__ArrayOfNoticeItem::NoticeItem, "ns1:NoticeItem"))
				{	a->ns1__ArrayOfNoticeItem::__sizeNoticeItem++;
					a->ns1__ArrayOfNoticeItem::NoticeItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfNoticeItem::NoticeItem)
			soap_pop_block(soap, soap_blist_NoticeItem1);
		if (a->ns1__ArrayOfNoticeItem::__sizeNoticeItem)
			a->ns1__ArrayOfNoticeItem::NoticeItem = (ns1__NoticeItem **)soap_save_block(soap, soap_blist_NoticeItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfNoticeItem::NoticeItem = NULL;
			if (soap_blist_NoticeItem1)
				soap_end_block(soap, soap_blist_NoticeItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfNoticeItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfNoticeItem, 0, sizeof(ns1__ArrayOfNoticeItem), 0, soap_copy_ns1__ArrayOfNoticeItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfNoticeItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfNoticeItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfNoticeItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfNoticeItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfNoticeItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfNoticeItem * SOAP_FMAC4 soap_get_ns1__ArrayOfNoticeItem(struct soap *soap, ns1__ArrayOfNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfNoticeItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfNoticeItem);
		if (size)
			*size = sizeof(ns1__ArrayOfNoticeItem);
		((ns1__ArrayOfNoticeItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfNoticeItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfNoticeItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfNoticeItem %p -> %p\n", q, p));
	*(ns1__ArrayOfNoticeItem*)p = *(ns1__ArrayOfNoticeItem*)q;
}

void ns1__Notice::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Notice::total);
	soap_default_int(soap, &this->ns1__Notice::totalPage);
	soap_default_int(soap, &this->ns1__Notice::pageSize);
	soap_default_int(soap, &this->ns1__Notice::currentPageIndex);
	this->ns1__Notice::listOfNotice = NULL;
	/* transient soap skipped */
}

void ns1__Notice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfNoticeItem(soap, &this->ns1__Notice::listOfNotice);
	/* transient soap skipped */
}

int ns1__Notice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Notice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Notice(struct soap *soap, const char *tag, int id, const ns1__Notice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Notice), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:total", -1, &(a->ns1__Notice::total), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:totalPage", -1, &(a->ns1__Notice::totalPage), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->ns1__Notice::pageSize), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:currentPageIndex", -1, &(a->ns1__Notice::currentPageIndex), "xsd:int"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNoticeItem(soap, "ns1:listOfNotice", -1, &(a->ns1__Notice::listOfNotice), "ns1:ArrayOfNoticeItem"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Notice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Notice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Notice * SOAP_FMAC4 soap_in_ns1__Notice(struct soap *soap, const char *tag, ns1__Notice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Notice *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Notice, sizeof(ns1__Notice), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Notice)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Notice *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_total1 = 1;
	size_t soap_flag_totalPage1 = 1;
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_currentPageIndex1 = 1;
	size_t soap_flag_listOfNotice1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &(a->ns1__Notice::total), "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_totalPage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:totalPage", &(a->ns1__Notice::totalPage), "xsd:int"))
				{	soap_flag_totalPage1--;
					continue;
				}
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->ns1__Notice::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_currentPageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:currentPageIndex", &(a->ns1__Notice::currentPageIndex), "xsd:int"))
				{	soap_flag_currentPageIndex1--;
					continue;
				}
			if (soap_flag_listOfNotice1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNoticeItem(soap, "ns1:listOfNotice", &(a->ns1__Notice::listOfNotice), "ns1:ArrayOfNoticeItem"))
				{	soap_flag_listOfNotice1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Notice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Notice, 0, sizeof(ns1__Notice), 0, soap_copy_ns1__Notice);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0 || soap_flag_totalPage1 > 0 || soap_flag_pageSize1 > 0 || soap_flag_currentPageIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Notice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Notice);
	if (this->soap_out(soap, tag?tag:"ns1:Notice", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Notice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Notice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Notice * SOAP_FMAC4 soap_get_ns1__Notice(struct soap *soap, ns1__Notice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Notice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Notice * SOAP_FMAC2 soap_instantiate_ns1__Notice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Notice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Notice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Notice);
		if (size)
			*size = sizeof(ns1__Notice);
		((ns1__Notice*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Notice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Notice);
		for (int i = 0; i < n; i++)
			((ns1__Notice*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Notice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Notice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Notice %p -> %p\n", q, p));
	*(ns1__Notice*)p = *(ns1__Notice*)q;
}

void ns1__TableStatistics::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TableStatistics::total);
	soap_default_double(soap, &this->ns1__TableStatistics::sum1);
	soap_default_double(soap, &this->ns1__TableStatistics::sum2);
	/* transient soap skipped */
}

void ns1__TableStatistics::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__TableStatistics::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TableStatistics(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TableStatistics(struct soap *soap, const char *tag, int id, const ns1__TableStatistics *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TableStatistics), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:total", -1, &(a->ns1__TableStatistics::total), "xsd:int"))
		return soap->error;
	if (soap_out_double(soap, "ns1:sum1", -1, &(a->ns1__TableStatistics::sum1), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:sum2", -1, &(a->ns1__TableStatistics::sum2), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TableStatistics::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TableStatistics(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TableStatistics * SOAP_FMAC4 soap_in_ns1__TableStatistics(struct soap *soap, const char *tag, ns1__TableStatistics *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TableStatistics *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TableStatistics, sizeof(ns1__TableStatistics), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TableStatistics)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TableStatistics *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_total1 = 1;
	size_t soap_flag_sum11 = 1;
	size_t soap_flag_sum21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &(a->ns1__TableStatistics::total), "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_sum11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:sum1", &(a->ns1__TableStatistics::sum1), "xsd:double"))
				{	soap_flag_sum11--;
					continue;
				}
			if (soap_flag_sum21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:sum2", &(a->ns1__TableStatistics::sum2), "xsd:double"))
				{	soap_flag_sum21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TableStatistics *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TableStatistics, 0, sizeof(ns1__TableStatistics), 0, soap_copy_ns1__TableStatistics);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0 || soap_flag_sum11 > 0 || soap_flag_sum21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TableStatistics::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TableStatistics);
	if (this->soap_out(soap, tag?tag:"ns1:TableStatistics", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TableStatistics::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TableStatistics(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TableStatistics * SOAP_FMAC4 soap_get_ns1__TableStatistics(struct soap *soap, ns1__TableStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TableStatistics * SOAP_FMAC2 soap_instantiate_ns1__TableStatistics(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TableStatistics(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TableStatistics, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TableStatistics);
		if (size)
			*size = sizeof(ns1__TableStatistics);
		((ns1__TableStatistics*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TableStatistics[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TableStatistics);
		for (int i = 0; i < n; i++)
			((ns1__TableStatistics*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TableStatistics*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TableStatistics(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TableStatistics %p -> %p\n", q, p));
	*(ns1__TableStatistics*)p = *(ns1__TableStatistics*)q;
}

void ns1__DIC_USCORECategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__DIC_USCORECategory::Category);
	soap_default_bool(soap, &this->ns1__DIC_USCORECategory::Editable);
	/* transient soap skipped */
}

void ns1__DIC_USCORECategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__DIC_USCORECategory::Category);
	/* transient soap skipped */
}

int ns1__DIC_USCORECategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DIC_USCORECategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DIC_USCORECategory(struct soap *soap, const char *tag, int id, const ns1__DIC_USCORECategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DIC_USCORECategory), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Category", -1, &(a->ns1__DIC_USCORECategory::Category), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:Editable", -1, &(a->ns1__DIC_USCORECategory::Editable), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DIC_USCORECategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DIC_USCORECategory(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DIC_USCORECategory * SOAP_FMAC4 soap_in_ns1__DIC_USCORECategory(struct soap *soap, const char *tag, ns1__DIC_USCORECategory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DIC_USCORECategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DIC_USCORECategory, sizeof(ns1__DIC_USCORECategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DIC_USCORECategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DIC_USCORECategory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Category1 = 1;
	size_t soap_flag_Editable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Category", &(a->ns1__DIC_USCORECategory::Category), "xsd:string"))
				{	soap_flag_Category1--;
					continue;
				}
			if (soap_flag_Editable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:Editable", &(a->ns1__DIC_USCORECategory::Editable), "xsd:boolean"))
				{	soap_flag_Editable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DIC_USCORECategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DIC_USCORECategory, 0, sizeof(ns1__DIC_USCORECategory), 0, soap_copy_ns1__DIC_USCORECategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Editable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DIC_USCORECategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DIC_USCORECategory);
	if (this->soap_out(soap, tag?tag:"ns1:DIC_Category", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DIC_USCORECategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DIC_USCORECategory(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DIC_USCORECategory * SOAP_FMAC4 soap_get_ns1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DIC_USCORECategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DIC_USCORECategory * SOAP_FMAC2 soap_instantiate_ns1__DIC_USCORECategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DIC_USCORECategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DIC_USCORECategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DIC_USCORECategory);
		if (size)
			*size = sizeof(ns1__DIC_USCORECategory);
		((ns1__DIC_USCORECategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DIC_USCORECategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DIC_USCORECategory);
		for (int i = 0; i < n; i++)
			((ns1__DIC_USCORECategory*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DIC_USCORECategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DIC_USCORECategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DIC_USCORECategory %p -> %p\n", q, p));
	*(ns1__DIC_USCORECategory*)p = *(ns1__DIC_USCORECategory*)q;
}

void ns1__ArrayOfDIC_USCORECategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfDIC_USCORECategory::__sizeDIC_USCORECategory = 0;
	this->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfDIC_USCORECategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfDIC_USCORECategory::__sizeDIC_USCORECategory; i++)
		{
			soap_serialize_PointerTons1__DIC_USCORECategory(soap, this->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfDIC_USCORECategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDIC_USCORECategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDIC_USCORECategory(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDIC_USCORECategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory), type))
		return soap->error;
	if (a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfDIC_USCORECategory::__sizeDIC_USCORECategory; i++)
			if (soap_out_PointerTons1__DIC_USCORECategory(soap, "ns1:DIC_Category", -1, a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory + i, "ns1:DIC_Category"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDIC_USCORECategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDIC_USCORECategory(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCORECategory * SOAP_FMAC4 soap_in_ns1__ArrayOfDIC_USCORECategory(struct soap *soap, const char *tag, ns1__ArrayOfDIC_USCORECategory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDIC_USCORECategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory, sizeof(ns1__ArrayOfDIC_USCORECategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDIC_USCORECategory *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_DIC_USCORECategory1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DIC_Category", 1, NULL))
			{	if (a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory == NULL)
				{	if (soap_blist_DIC_USCORECategory1 == NULL)
						soap_blist_DIC_USCORECategory1 = soap_new_block(soap);
					a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = (ns1__DIC_USCORECategory **)soap_push_block(soap, soap_blist_DIC_USCORECategory1, sizeof(ns1__DIC_USCORECategory *));
					if (a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory == NULL)
						return NULL;
					*a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DIC_USCORECategory(soap, "ns1:DIC_Category", a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory, "ns1:DIC_Category"))
				{	a->ns1__ArrayOfDIC_USCORECategory::__sizeDIC_USCORECategory++;
					a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory)
			soap_pop_block(soap, soap_blist_DIC_USCORECategory1);
		if (a->ns1__ArrayOfDIC_USCORECategory::__sizeDIC_USCORECategory)
			a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = (ns1__DIC_USCORECategory **)soap_save_block(soap, soap_blist_DIC_USCORECategory1, NULL, 1);
		else
		{	a->ns1__ArrayOfDIC_USCORECategory::DIC_USCORECategory = NULL;
			if (soap_blist_DIC_USCORECategory1)
				soap_end_block(soap, soap_blist_DIC_USCORECategory1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDIC_USCORECategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory, 0, sizeof(ns1__ArrayOfDIC_USCORECategory), 0, soap_copy_ns1__ArrayOfDIC_USCORECategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfDIC_USCORECategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfDIC_Category", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDIC_USCORECategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDIC_USCORECategory(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCORECategory * SOAP_FMAC4 soap_get_ns1__ArrayOfDIC_USCORECategory(struct soap *soap, ns1__ArrayOfDIC_USCORECategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDIC_USCORECategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfDIC_USCORECategory * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDIC_USCORECategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDIC_USCORECategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfDIC_USCORECategory);
		if (size)
			*size = sizeof(ns1__ArrayOfDIC_USCORECategory);
		((ns1__ArrayOfDIC_USCORECategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfDIC_USCORECategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDIC_USCORECategory);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDIC_USCORECategory*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDIC_USCORECategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDIC_USCORECategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDIC_USCORECategory %p -> %p\n", q, p));
	*(ns1__ArrayOfDIC_USCORECategory*)p = *(ns1__ArrayOfDIC_USCORECategory*)q;
}

void ns1__DIC_USCOREContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::Name);
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::Code);
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::Category);
	soap_default_bool(soap, &this->ns1__DIC_USCOREContent::Enabled);
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::content);
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::val1);
	soap_default_string(soap, &this->ns1__DIC_USCOREContent::val2);
	/* transient soap skipped */
}

void ns1__DIC_USCOREContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::Name);
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::Code);
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::Category);
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::content);
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::val1);
	soap_serialize_string(soap, &this->ns1__DIC_USCOREContent::val2);
	/* transient soap skipped */
}

int ns1__DIC_USCOREContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DIC_USCOREContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DIC_USCOREContent(struct soap *soap, const char *tag, int id, const ns1__DIC_USCOREContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DIC_USCOREContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &(a->ns1__DIC_USCOREContent::Name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Code", -1, &(a->ns1__DIC_USCOREContent::Code), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Category", -1, &(a->ns1__DIC_USCOREContent::Category), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:Enabled", -1, &(a->ns1__DIC_USCOREContent::Enabled), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__DIC_USCOREContent::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val1", -1, &(a->ns1__DIC_USCOREContent::val1), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:val2", -1, &(a->ns1__DIC_USCOREContent::val2), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DIC_USCOREContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DIC_USCOREContent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DIC_USCOREContent * SOAP_FMAC4 soap_in_ns1__DIC_USCOREContent(struct soap *soap, const char *tag, ns1__DIC_USCOREContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DIC_USCOREContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DIC_USCOREContent, sizeof(ns1__DIC_USCOREContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DIC_USCOREContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DIC_USCOREContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Category1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_val11 = 1;
	size_t soap_flag_val21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &(a->ns1__DIC_USCOREContent::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Code", &(a->ns1__DIC_USCOREContent::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_Category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Category", &(a->ns1__DIC_USCOREContent::Category), "xsd:string"))
				{	soap_flag_Category1--;
					continue;
				}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:Enabled", &(a->ns1__DIC_USCOREContent::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__DIC_USCOREContent::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_val11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val1", &(a->ns1__DIC_USCOREContent::val1), "xsd:string"))
				{	soap_flag_val11--;
					continue;
				}
			if (soap_flag_val21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:val2", &(a->ns1__DIC_USCOREContent::val2), "xsd:string"))
				{	soap_flag_val21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DIC_USCOREContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DIC_USCOREContent, 0, sizeof(ns1__DIC_USCOREContent), 0, soap_copy_ns1__DIC_USCOREContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DIC_USCOREContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DIC_USCOREContent);
	if (this->soap_out(soap, tag?tag:"ns1:DIC_Content", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DIC_USCOREContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DIC_USCOREContent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DIC_USCOREContent * SOAP_FMAC4 soap_get_ns1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DIC_USCOREContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DIC_USCOREContent * SOAP_FMAC2 soap_instantiate_ns1__DIC_USCOREContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DIC_USCOREContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DIC_USCOREContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DIC_USCOREContent);
		if (size)
			*size = sizeof(ns1__DIC_USCOREContent);
		((ns1__DIC_USCOREContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DIC_USCOREContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DIC_USCOREContent);
		for (int i = 0; i < n; i++)
			((ns1__DIC_USCOREContent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DIC_USCOREContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DIC_USCOREContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DIC_USCOREContent %p -> %p\n", q, p));
	*(ns1__DIC_USCOREContent*)p = *(ns1__DIC_USCOREContent*)q;
}

void ns1__ArrayOfDIC_USCOREContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfDIC_USCOREContent::__sizeDIC_USCOREContent = 0;
	this->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfDIC_USCOREContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfDIC_USCOREContent::__sizeDIC_USCOREContent; i++)
		{
			soap_serialize_PointerTons1__DIC_USCOREContent(soap, this->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfDIC_USCOREContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDIC_USCOREContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDIC_USCOREContent(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDIC_USCOREContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent), type))
		return soap->error;
	if (a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfDIC_USCOREContent::__sizeDIC_USCOREContent; i++)
			if (soap_out_PointerTons1__DIC_USCOREContent(soap, "ns1:DIC_Content", -1, a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent + i, "ns1:DIC_Content"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDIC_USCOREContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDIC_USCOREContent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCOREContent * SOAP_FMAC4 soap_in_ns1__ArrayOfDIC_USCOREContent(struct soap *soap, const char *tag, ns1__ArrayOfDIC_USCOREContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDIC_USCOREContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent, sizeof(ns1__ArrayOfDIC_USCOREContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDIC_USCOREContent *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_DIC_USCOREContent1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DIC_Content", 1, NULL))
			{	if (a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent == NULL)
				{	if (soap_blist_DIC_USCOREContent1 == NULL)
						soap_blist_DIC_USCOREContent1 = soap_new_block(soap);
					a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = (ns1__DIC_USCOREContent **)soap_push_block(soap, soap_blist_DIC_USCOREContent1, sizeof(ns1__DIC_USCOREContent *));
					if (a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent == NULL)
						return NULL;
					*a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DIC_USCOREContent(soap, "ns1:DIC_Content", a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent, "ns1:DIC_Content"))
				{	a->ns1__ArrayOfDIC_USCOREContent::__sizeDIC_USCOREContent++;
					a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent)
			soap_pop_block(soap, soap_blist_DIC_USCOREContent1);
		if (a->ns1__ArrayOfDIC_USCOREContent::__sizeDIC_USCOREContent)
			a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = (ns1__DIC_USCOREContent **)soap_save_block(soap, soap_blist_DIC_USCOREContent1, NULL, 1);
		else
		{	a->ns1__ArrayOfDIC_USCOREContent::DIC_USCOREContent = NULL;
			if (soap_blist_DIC_USCOREContent1)
				soap_end_block(soap, soap_blist_DIC_USCOREContent1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDIC_USCOREContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent, 0, sizeof(ns1__ArrayOfDIC_USCOREContent), 0, soap_copy_ns1__ArrayOfDIC_USCOREContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfDIC_USCOREContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfDIC_Content", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDIC_USCOREContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDIC_USCOREContent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCOREContent * SOAP_FMAC4 soap_get_ns1__ArrayOfDIC_USCOREContent(struct soap *soap, ns1__ArrayOfDIC_USCOREContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDIC_USCOREContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfDIC_USCOREContent * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDIC_USCOREContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDIC_USCOREContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfDIC_USCOREContent);
		if (size)
			*size = sizeof(ns1__ArrayOfDIC_USCOREContent);
		((ns1__ArrayOfDIC_USCOREContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfDIC_USCOREContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDIC_USCOREContent);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDIC_USCOREContent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDIC_USCOREContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDIC_USCOREContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDIC_USCOREContent %p -> %p\n", q, p));
	*(ns1__ArrayOfDIC_USCOREContent*)p = *(ns1__ArrayOfDIC_USCOREContent*)q;
}

void ns1__AcountPaymentItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__AcountPaymentItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__AcountPaymentItem::userId);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::userName);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::acountName);
	soap_default_float(soap, &this->ns1__AcountPaymentItem::payMoney);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::payType);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::bankName);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::subBankName);
	soap_default_time(soap, &this->ns1__AcountPaymentItem::payTime);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::content);
	soap_default_bool(soap, &this->ns1__AcountPaymentItem::isCheck);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::state);
	soap_default_ns2__guid(soap, &this->ns1__AcountPaymentItem::workerId);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::workName);
	soap_default_string(soap, &this->ns1__AcountPaymentItem::userType);
	/* transient soap skipped */
}

void ns1__AcountPaymentItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__AcountPaymentItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__AcountPaymentItem::userId);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::userName);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::acountName);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::payType);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::bankName);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::subBankName);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::content);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__AcountPaymentItem::workerId);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::workName);
	soap_serialize_string(soap, &this->ns1__AcountPaymentItem::userType);
	/* transient soap skipped */
}

int ns1__AcountPaymentItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AcountPaymentItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcountPaymentItem(struct soap *soap, const char *tag, int id, const ns1__AcountPaymentItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcountPaymentItem), type))
		return soap->error;
	if (a->ns1__AcountPaymentItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__AcountPaymentItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__AcountPaymentItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__AcountPaymentItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__AcountPaymentItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:acountName", -1, &(a->ns1__AcountPaymentItem::acountName), "xsd:string"))
		return soap->error;
	if (soap_out_float(soap, "ns1:payMoney", -1, &(a->ns1__AcountPaymentItem::payMoney), "xsd:float"))
		return soap->error;
	if (soap_out_string(soap, "ns1:payType", -1, &(a->ns1__AcountPaymentItem::payType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:bankName", -1, &(a->ns1__AcountPaymentItem::bankName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:subBankName", -1, &(a->ns1__AcountPaymentItem::subBankName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:payTime", -1, &(a->ns1__AcountPaymentItem::payTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__AcountPaymentItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isCheck", -1, &(a->ns1__AcountPaymentItem::isCheck), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__AcountPaymentItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__AcountPaymentItem::workerId)
	{	if (soap_out_ns2__guid(soap, "ns1:workerId", -1, &a->ns1__AcountPaymentItem::workerId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workerId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:workName", -1, &(a->ns1__AcountPaymentItem::workName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userType", -1, &(a->ns1__AcountPaymentItem::userType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AcountPaymentItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AcountPaymentItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AcountPaymentItem * SOAP_FMAC4 soap_in_ns1__AcountPaymentItem(struct soap *soap, const char *tag, ns1__AcountPaymentItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AcountPaymentItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcountPaymentItem, sizeof(ns1__AcountPaymentItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AcountPaymentItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AcountPaymentItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_acountName1 = 1;
	size_t soap_flag_payMoney1 = 1;
	size_t soap_flag_payType1 = 1;
	size_t soap_flag_bankName1 = 1;
	size_t soap_flag_subBankName1 = 1;
	size_t soap_flag_payTime1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_isCheck1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workerId1 = 1;
	size_t soap_flag_workName1 = 1;
	size_t soap_flag_userType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__AcountPaymentItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__AcountPaymentItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__AcountPaymentItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_acountName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:acountName", &(a->ns1__AcountPaymentItem::acountName), "xsd:string"))
				{	soap_flag_acountName1--;
					continue;
				}
			if (soap_flag_payMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns1:payMoney", &(a->ns1__AcountPaymentItem::payMoney), "xsd:float"))
				{	soap_flag_payMoney1--;
					continue;
				}
			if (soap_flag_payType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:payType", &(a->ns1__AcountPaymentItem::payType), "xsd:string"))
				{	soap_flag_payType1--;
					continue;
				}
			if (soap_flag_bankName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:bankName", &(a->ns1__AcountPaymentItem::bankName), "xsd:string"))
				{	soap_flag_bankName1--;
					continue;
				}
			if (soap_flag_subBankName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:subBankName", &(a->ns1__AcountPaymentItem::subBankName), "xsd:string"))
				{	soap_flag_subBankName1--;
					continue;
				}
			if (soap_flag_payTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:payTime", &(a->ns1__AcountPaymentItem::payTime), "xsd:dateTime"))
				{	soap_flag_payTime1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__AcountPaymentItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_isCheck1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isCheck", &(a->ns1__AcountPaymentItem::isCheck), "xsd:boolean"))
				{	soap_flag_isCheck1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__AcountPaymentItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workerId", &(a->ns1__AcountPaymentItem::workerId), "ns2:guid"))
				{	soap_flag_workerId1--;
					continue;
				}
			if (soap_flag_workName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:workName", &(a->ns1__AcountPaymentItem::workName), "xsd:string"))
				{	soap_flag_workName1--;
					continue;
				}
			if (soap_flag_userType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userType", &(a->ns1__AcountPaymentItem::userType), "xsd:string"))
				{	soap_flag_userType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AcountPaymentItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AcountPaymentItem, 0, sizeof(ns1__AcountPaymentItem), 0, soap_copy_ns1__AcountPaymentItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_payMoney1 > 0 || soap_flag_payTime1 > 0 || soap_flag_isCheck1 > 0 || soap_flag_workerId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AcountPaymentItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AcountPaymentItem);
	if (this->soap_out(soap, tag?tag:"ns1:AcountPaymentItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AcountPaymentItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AcountPaymentItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AcountPaymentItem * SOAP_FMAC4 soap_get_ns1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcountPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AcountPaymentItem * SOAP_FMAC2 soap_instantiate_ns1__AcountPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AcountPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AcountPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AcountPaymentItem);
		if (size)
			*size = sizeof(ns1__AcountPaymentItem);
		((ns1__AcountPaymentItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AcountPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AcountPaymentItem);
		for (int i = 0; i < n; i++)
			((ns1__AcountPaymentItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AcountPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AcountPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AcountPaymentItem %p -> %p\n", q, p));
	*(ns1__AcountPaymentItem*)p = *(ns1__AcountPaymentItem*)q;
}

void ns1__ArrayOfAcountPaymentItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfAcountPaymentItem::__sizeAcountPaymentItem = 0;
	this->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfAcountPaymentItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfAcountPaymentItem::__sizeAcountPaymentItem; i++)
		{
			soap_serialize_PointerTons1__AcountPaymentItem(soap, this->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfAcountPaymentItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAcountPaymentItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAcountPaymentItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAcountPaymentItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem), type))
		return soap->error;
	if (a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfAcountPaymentItem::__sizeAcountPaymentItem; i++)
			if (soap_out_PointerTons1__AcountPaymentItem(soap, "ns1:AcountPaymentItem", -1, a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem + i, "ns1:AcountPaymentItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAcountPaymentItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAcountPaymentItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAcountPaymentItem * SOAP_FMAC4 soap_in_ns1__ArrayOfAcountPaymentItem(struct soap *soap, const char *tag, ns1__ArrayOfAcountPaymentItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAcountPaymentItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem, sizeof(ns1__ArrayOfAcountPaymentItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfAcountPaymentItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfAcountPaymentItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_AcountPaymentItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AcountPaymentItem", 1, NULL))
			{	if (a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem == NULL)
				{	if (soap_blist_AcountPaymentItem1 == NULL)
						soap_blist_AcountPaymentItem1 = soap_new_block(soap);
					a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = (ns1__AcountPaymentItem **)soap_push_block(soap, soap_blist_AcountPaymentItem1, sizeof(ns1__AcountPaymentItem *));
					if (a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem == NULL)
						return NULL;
					*a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__AcountPaymentItem(soap, "ns1:AcountPaymentItem", a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem, "ns1:AcountPaymentItem"))
				{	a->ns1__ArrayOfAcountPaymentItem::__sizeAcountPaymentItem++;
					a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem)
			soap_pop_block(soap, soap_blist_AcountPaymentItem1);
		if (a->ns1__ArrayOfAcountPaymentItem::__sizeAcountPaymentItem)
			a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = (ns1__AcountPaymentItem **)soap_save_block(soap, soap_blist_AcountPaymentItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfAcountPaymentItem::AcountPaymentItem = NULL;
			if (soap_blist_AcountPaymentItem1)
				soap_end_block(soap, soap_blist_AcountPaymentItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAcountPaymentItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem, 0, sizeof(ns1__ArrayOfAcountPaymentItem), 0, soap_copy_ns1__ArrayOfAcountPaymentItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfAcountPaymentItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfAcountPaymentItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAcountPaymentItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAcountPaymentItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAcountPaymentItem * SOAP_FMAC4 soap_get_ns1__ArrayOfAcountPaymentItem(struct soap *soap, ns1__ArrayOfAcountPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAcountPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfAcountPaymentItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAcountPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAcountPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAcountPaymentItem);
		if (size)
			*size = sizeof(ns1__ArrayOfAcountPaymentItem);
		((ns1__ArrayOfAcountPaymentItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAcountPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfAcountPaymentItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfAcountPaymentItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfAcountPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfAcountPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfAcountPaymentItem %p -> %p\n", q, p));
	*(ns1__ArrayOfAcountPaymentItem*)p = *(ns1__ArrayOfAcountPaymentItem*)q;
}

void ns1__ReturnedItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__ReturnedItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__ReturnedItem::userId);
	soap_default_time(soap, &this->ns1__ReturnedItem::datetime);
	soap_default_string(soap, &this->ns1__ReturnedItem::returnType);
	soap_default_ns2__guid(soap, &this->ns1__ReturnedItem::operationId);
	soap_default_double(soap, &this->ns1__ReturnedItem::money);
	soap_default_double(soap, &this->ns1__ReturnedItem::returnPoint);
	soap_default_double(soap, &this->ns1__ReturnedItem::returnMoney);
	/* transient soap skipped */
}

void ns1__ReturnedItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__ReturnedItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__ReturnedItem::userId);
	soap_serialize_string(soap, &this->ns1__ReturnedItem::returnType);
	soap_serialize_ns2__guid(soap, &this->ns1__ReturnedItem::operationId);
	/* transient soap skipped */
}

int ns1__ReturnedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnedItem(struct soap *soap, const char *tag, int id, const ns1__ReturnedItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnedItem), type))
		return soap->error;
	if (a->ns1__ReturnedItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__ReturnedItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__ReturnedItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__ReturnedItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_time(soap, "ns1:datetime", -1, &(a->ns1__ReturnedItem::datetime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:returnType", -1, &(a->ns1__ReturnedItem::returnType), "xsd:string"))
		return soap->error;
	if (a->ns1__ReturnedItem::operationId)
	{	if (soap_out_ns2__guid(soap, "ns1:operationId", -1, &a->ns1__ReturnedItem::operationId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:operationId"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__ReturnedItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnPoint", -1, &(a->ns1__ReturnedItem::returnPoint), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__ReturnedItem::returnMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ReturnedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnedItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnedItem * SOAP_FMAC4 soap_in_ns1__ReturnedItem(struct soap *soap, const char *tag, ns1__ReturnedItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReturnedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnedItem, sizeof(ns1__ReturnedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReturnedItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReturnedItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_datetime1 = 1;
	size_t soap_flag_returnType1 = 1;
	size_t soap_flag_operationId1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_returnPoint1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__ReturnedItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__ReturnedItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:datetime", &(a->ns1__ReturnedItem::datetime), "xsd:dateTime"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_returnType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:returnType", &(a->ns1__ReturnedItem::returnType), "xsd:string"))
				{	soap_flag_returnType1--;
					continue;
				}
			if (soap_flag_operationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:operationId", &(a->ns1__ReturnedItem::operationId), "ns2:guid"))
				{	soap_flag_operationId1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__ReturnedItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_returnPoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnPoint", &(a->ns1__ReturnedItem::returnPoint), "xsd:double"))
				{	soap_flag_returnPoint1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__ReturnedItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReturnedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnedItem, 0, sizeof(ns1__ReturnedItem), 0, soap_copy_ns1__ReturnedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_datetime1 > 0 || soap_flag_operationId1 > 0 || soap_flag_money1 > 0 || soap_flag_returnPoint1 > 0 || soap_flag_returnMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ReturnedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReturnedItem);
	if (this->soap_out(soap, tag?tag:"ns1:ReturnedItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReturnedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnedItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnedItem * SOAP_FMAC4 soap_get_ns1__ReturnedItem(struct soap *soap, ns1__ReturnedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ReturnedItem * SOAP_FMAC2 soap_instantiate_ns1__ReturnedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnedItem);
		if (size)
			*size = sizeof(ns1__ReturnedItem);
		((ns1__ReturnedItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnedItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReturnedItem);
		for (int i = 0; i < n; i++)
			((ns1__ReturnedItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReturnedItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReturnedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReturnedItem %p -> %p\n", q, p));
	*(ns1__ReturnedItem*)p = *(ns1__ReturnedItem*)q;
}

void ns1__ArrayOfReturnedItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfReturnedItem::__sizeReturnedItem = 0;
	this->ns1__ArrayOfReturnedItem::ReturnedItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfReturnedItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfReturnedItem::ReturnedItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfReturnedItem::__sizeReturnedItem; i++)
		{
			soap_serialize_PointerTons1__ReturnedItem(soap, this->ns1__ArrayOfReturnedItem::ReturnedItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfReturnedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfReturnedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfReturnedItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfReturnedItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfReturnedItem), type))
		return soap->error;
	if (a->ns1__ArrayOfReturnedItem::ReturnedItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfReturnedItem::__sizeReturnedItem; i++)
			if (soap_out_PointerTons1__ReturnedItem(soap, "ns1:ReturnedItem", -1, a->ns1__ArrayOfReturnedItem::ReturnedItem + i, "ns1:ReturnedItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfReturnedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfReturnedItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnedItem * SOAP_FMAC4 soap_in_ns1__ArrayOfReturnedItem(struct soap *soap, const char *tag, ns1__ArrayOfReturnedItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfReturnedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfReturnedItem, sizeof(ns1__ArrayOfReturnedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfReturnedItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfReturnedItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ReturnedItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ReturnedItem", 1, NULL))
			{	if (a->ns1__ArrayOfReturnedItem::ReturnedItem == NULL)
				{	if (soap_blist_ReturnedItem1 == NULL)
						soap_blist_ReturnedItem1 = soap_new_block(soap);
					a->ns1__ArrayOfReturnedItem::ReturnedItem = (ns1__ReturnedItem **)soap_push_block(soap, soap_blist_ReturnedItem1, sizeof(ns1__ReturnedItem *));
					if (a->ns1__ArrayOfReturnedItem::ReturnedItem == NULL)
						return NULL;
					*a->ns1__ArrayOfReturnedItem::ReturnedItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ReturnedItem(soap, "ns1:ReturnedItem", a->ns1__ArrayOfReturnedItem::ReturnedItem, "ns1:ReturnedItem"))
				{	a->ns1__ArrayOfReturnedItem::__sizeReturnedItem++;
					a->ns1__ArrayOfReturnedItem::ReturnedItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfReturnedItem::ReturnedItem)
			soap_pop_block(soap, soap_blist_ReturnedItem1);
		if (a->ns1__ArrayOfReturnedItem::__sizeReturnedItem)
			a->ns1__ArrayOfReturnedItem::ReturnedItem = (ns1__ReturnedItem **)soap_save_block(soap, soap_blist_ReturnedItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfReturnedItem::ReturnedItem = NULL;
			if (soap_blist_ReturnedItem1)
				soap_end_block(soap, soap_blist_ReturnedItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfReturnedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfReturnedItem, 0, sizeof(ns1__ArrayOfReturnedItem), 0, soap_copy_ns1__ArrayOfReturnedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfReturnedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfReturnedItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfReturnedItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfReturnedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfReturnedItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnedItem * SOAP_FMAC4 soap_get_ns1__ArrayOfReturnedItem(struct soap *soap, ns1__ArrayOfReturnedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfReturnedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfReturnedItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfReturnedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfReturnedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfReturnedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnedItem);
		if (size)
			*size = sizeof(ns1__ArrayOfReturnedItem);
		((ns1__ArrayOfReturnedItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnedItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfReturnedItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfReturnedItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfReturnedItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfReturnedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfReturnedItem %p -> %p\n", q, p));
	*(ns1__ArrayOfReturnedItem*)p = *(ns1__ArrayOfReturnedItem*)q;
}

void ns1__SystemFunction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__SystemFunction::Id);
	soap_default_string(soap, &this->ns1__SystemFunction::FunctionName);
	soap_default_string(soap, &this->ns1__SystemFunction::FunctionPictureName);
	soap_default_string(soap, &this->ns1__SystemFunction::FunctionNamespace);
	soap_default_string(soap, &this->ns1__SystemFunction::FunctionScope);
	soap_default_int(soap, &this->ns1__SystemFunction::Right);
	/* transient soap skipped */
}

void ns1__SystemFunction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__SystemFunction::Id);
	soap_serialize_string(soap, &this->ns1__SystemFunction::FunctionName);
	soap_serialize_string(soap, &this->ns1__SystemFunction::FunctionPictureName);
	soap_serialize_string(soap, &this->ns1__SystemFunction::FunctionNamespace);
	soap_serialize_string(soap, &this->ns1__SystemFunction::FunctionScope);
	/* transient soap skipped */
}

int ns1__SystemFunction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SystemFunction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SystemFunction(struct soap *soap, const char *tag, int id, const ns1__SystemFunction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SystemFunction), type))
		return soap->error;
	if (a->ns1__SystemFunction::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__SystemFunction::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:FunctionName", -1, &(a->ns1__SystemFunction::FunctionName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:FunctionPictureName", -1, &(a->ns1__SystemFunction::FunctionPictureName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:FunctionNamespace", -1, &(a->ns1__SystemFunction::FunctionNamespace), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:FunctionScope", -1, &(a->ns1__SystemFunction::FunctionScope), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:Right", -1, &(a->ns1__SystemFunction::Right), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SystemFunction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SystemFunction(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SystemFunction * SOAP_FMAC4 soap_in_ns1__SystemFunction(struct soap *soap, const char *tag, ns1__SystemFunction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SystemFunction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemFunction, sizeof(ns1__SystemFunction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SystemFunction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SystemFunction *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_FunctionName1 = 1;
	size_t soap_flag_FunctionPictureName1 = 1;
	size_t soap_flag_FunctionNamespace1 = 1;
	size_t soap_flag_FunctionScope1 = 1;
	size_t soap_flag_Right1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__SystemFunction::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_FunctionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FunctionName", &(a->ns1__SystemFunction::FunctionName), "xsd:string"))
				{	soap_flag_FunctionName1--;
					continue;
				}
			if (soap_flag_FunctionPictureName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FunctionPictureName", &(a->ns1__SystemFunction::FunctionPictureName), "xsd:string"))
				{	soap_flag_FunctionPictureName1--;
					continue;
				}
			if (soap_flag_FunctionNamespace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FunctionNamespace", &(a->ns1__SystemFunction::FunctionNamespace), "xsd:string"))
				{	soap_flag_FunctionNamespace1--;
					continue;
				}
			if (soap_flag_FunctionScope1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FunctionScope", &(a->ns1__SystemFunction::FunctionScope), "xsd:string"))
				{	soap_flag_FunctionScope1--;
					continue;
				}
			if (soap_flag_Right1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Right", &(a->ns1__SystemFunction::Right), "xsd:int"))
				{	soap_flag_Right1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SystemFunction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SystemFunction, 0, sizeof(ns1__SystemFunction), 0, soap_copy_ns1__SystemFunction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Right1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__SystemFunction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SystemFunction);
	if (this->soap_out(soap, tag?tag:"ns1:SystemFunction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SystemFunction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SystemFunction(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SystemFunction * SOAP_FMAC4 soap_get_ns1__SystemFunction(struct soap *soap, ns1__SystemFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SystemFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SystemFunction * SOAP_FMAC2 soap_instantiate_ns1__SystemFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SystemFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SystemFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SystemFunction);
		if (size)
			*size = sizeof(ns1__SystemFunction);
		((ns1__SystemFunction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SystemFunction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SystemFunction);
		for (int i = 0; i < n; i++)
			((ns1__SystemFunction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SystemFunction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SystemFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SystemFunction %p -> %p\n", q, p));
	*(ns1__SystemFunction*)p = *(ns1__SystemFunction*)q;
}

void ns1__ArrayOfSystemFunction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfSystemFunction::__sizeSystemFunction = 0;
	this->ns1__ArrayOfSystemFunction::SystemFunction = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfSystemFunction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfSystemFunction::SystemFunction)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfSystemFunction::__sizeSystemFunction; i++)
		{
			soap_serialize_PointerTons1__SystemFunction(soap, this->ns1__ArrayOfSystemFunction::SystemFunction + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfSystemFunction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSystemFunction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSystemFunction(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSystemFunction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSystemFunction), type))
		return soap->error;
	if (a->ns1__ArrayOfSystemFunction::SystemFunction)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfSystemFunction::__sizeSystemFunction; i++)
			if (soap_out_PointerTons1__SystemFunction(soap, "ns1:SystemFunction", -1, a->ns1__ArrayOfSystemFunction::SystemFunction + i, "ns1:SystemFunction"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSystemFunction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSystemFunction(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSystemFunction * SOAP_FMAC4 soap_in_ns1__ArrayOfSystemFunction(struct soap *soap, const char *tag, ns1__ArrayOfSystemFunction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSystemFunction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSystemFunction, sizeof(ns1__ArrayOfSystemFunction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSystemFunction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSystemFunction *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_SystemFunction1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:SystemFunction", 1, NULL))
			{	if (a->ns1__ArrayOfSystemFunction::SystemFunction == NULL)
				{	if (soap_blist_SystemFunction1 == NULL)
						soap_blist_SystemFunction1 = soap_new_block(soap);
					a->ns1__ArrayOfSystemFunction::SystemFunction = (ns1__SystemFunction **)soap_push_block(soap, soap_blist_SystemFunction1, sizeof(ns1__SystemFunction *));
					if (a->ns1__ArrayOfSystemFunction::SystemFunction == NULL)
						return NULL;
					*a->ns1__ArrayOfSystemFunction::SystemFunction = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__SystemFunction(soap, "ns1:SystemFunction", a->ns1__ArrayOfSystemFunction::SystemFunction, "ns1:SystemFunction"))
				{	a->ns1__ArrayOfSystemFunction::__sizeSystemFunction++;
					a->ns1__ArrayOfSystemFunction::SystemFunction = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfSystemFunction::SystemFunction)
			soap_pop_block(soap, soap_blist_SystemFunction1);
		if (a->ns1__ArrayOfSystemFunction::__sizeSystemFunction)
			a->ns1__ArrayOfSystemFunction::SystemFunction = (ns1__SystemFunction **)soap_save_block(soap, soap_blist_SystemFunction1, NULL, 1);
		else
		{	a->ns1__ArrayOfSystemFunction::SystemFunction = NULL;
			if (soap_blist_SystemFunction1)
				soap_end_block(soap, soap_blist_SystemFunction1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSystemFunction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSystemFunction, 0, sizeof(ns1__ArrayOfSystemFunction), 0, soap_copy_ns1__ArrayOfSystemFunction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSystemFunction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSystemFunction);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSystemFunction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSystemFunction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSystemFunction(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSystemFunction * SOAP_FMAC4 soap_get_ns1__ArrayOfSystemFunction(struct soap *soap, ns1__ArrayOfSystemFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSystemFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSystemFunction * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSystemFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSystemFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSystemFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSystemFunction);
		if (size)
			*size = sizeof(ns1__ArrayOfSystemFunction);
		((ns1__ArrayOfSystemFunction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSystemFunction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSystemFunction);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSystemFunction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSystemFunction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSystemFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSystemFunction %p -> %p\n", q, p));
	*(ns1__ArrayOfSystemFunction*)p = *(ns1__ArrayOfSystemFunction*)q;
}

void ns1__Worker::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__Worker::Id);
	soap_default_string(soap, &this->ns1__Worker::WorkerName);
	soap_default_string(soap, &this->ns1__Worker::Password);
	soap_default_string(soap, &this->ns1__Worker::MAC_USCOREAddress);
	soap_default_string(soap, &this->ns1__Worker::CPU_USCORECode);
	soap_default_string(soap, &this->ns1__Worker::Telephone);
	soap_default_string(soap, &this->ns1__Worker::RealName);
	soap_default_string(soap, &this->ns1__Worker::WorkerType);
	soap_default_ns2__guid(soap, &this->ns1__Worker::SessionId);
	/* transient soap skipped */
}

void ns1__Worker::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__Worker::Id);
	soap_serialize_string(soap, &this->ns1__Worker::WorkerName);
	soap_serialize_string(soap, &this->ns1__Worker::Password);
	soap_serialize_string(soap, &this->ns1__Worker::MAC_USCOREAddress);
	soap_serialize_string(soap, &this->ns1__Worker::CPU_USCORECode);
	soap_serialize_string(soap, &this->ns1__Worker::Telephone);
	soap_serialize_string(soap, &this->ns1__Worker::RealName);
	soap_serialize_string(soap, &this->ns1__Worker::WorkerType);
	soap_serialize_ns2__guid(soap, &this->ns1__Worker::SessionId);
	/* transient soap skipped */
}

int ns1__Worker::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Worker(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Worker(struct soap *soap, const char *tag, int id, const ns1__Worker *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Worker), type))
		return soap->error;
	if (a->ns1__Worker::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__Worker::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:WorkerName", -1, &(a->ns1__Worker::WorkerName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &(a->ns1__Worker::Password), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:MAC_Address", -1, &(a->ns1__Worker::MAC_USCOREAddress), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:CPU_Code", -1, &(a->ns1__Worker::CPU_USCORECode), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:Telephone", -1, &(a->ns1__Worker::Telephone), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:RealName", -1, &(a->ns1__Worker::RealName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:WorkerType", -1, &(a->ns1__Worker::WorkerType), "xsd:string"))
		return soap->error;
	if (a->ns1__Worker::SessionId)
	{	if (soap_out_ns2__guid(soap, "ns1:SessionId", -1, &a->ns1__Worker::SessionId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:SessionId"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Worker::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Worker(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Worker * SOAP_FMAC4 soap_in_ns1__Worker(struct soap *soap, const char *tag, ns1__Worker *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Worker *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Worker, sizeof(ns1__Worker), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Worker)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Worker *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_WorkerName1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_MAC_USCOREAddress1 = 1;
	size_t soap_flag_CPU_USCORECode1 = 1;
	size_t soap_flag_Telephone1 = 1;
	size_t soap_flag_RealName1 = 1;
	size_t soap_flag_WorkerType1 = 1;
	size_t soap_flag_SessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__Worker::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_WorkerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:WorkerName", &(a->ns1__Worker::WorkerName), "xsd:string"))
				{	soap_flag_WorkerName1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &(a->ns1__Worker::Password), "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap_flag_MAC_USCOREAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MAC_Address", &(a->ns1__Worker::MAC_USCOREAddress), "xsd:string"))
				{	soap_flag_MAC_USCOREAddress1--;
					continue;
				}
			if (soap_flag_CPU_USCORECode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:CPU_Code", &(a->ns1__Worker::CPU_USCORECode), "xsd:string"))
				{	soap_flag_CPU_USCORECode1--;
					continue;
				}
			if (soap_flag_Telephone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Telephone", &(a->ns1__Worker::Telephone), "xsd:string"))
				{	soap_flag_Telephone1--;
					continue;
				}
			if (soap_flag_RealName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:RealName", &(a->ns1__Worker::RealName), "xsd:string"))
				{	soap_flag_RealName1--;
					continue;
				}
			if (soap_flag_WorkerType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:WorkerType", &(a->ns1__Worker::WorkerType), "xsd:string"))
				{	soap_flag_WorkerType1--;
					continue;
				}
			if (soap_flag_SessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:SessionId", &(a->ns1__Worker::SessionId), "ns2:guid"))
				{	soap_flag_SessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Worker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Worker, 0, sizeof(ns1__Worker), 0, soap_copy_ns1__Worker);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_SessionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Worker::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Worker);
	if (this->soap_out(soap, tag?tag:"ns1:Worker", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Worker::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Worker(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Worker * SOAP_FMAC4 soap_get_ns1__Worker(struct soap *soap, ns1__Worker *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Worker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Worker * SOAP_FMAC2 soap_instantiate_ns1__Worker(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Worker(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Worker, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Worker);
		if (size)
			*size = sizeof(ns1__Worker);
		((ns1__Worker*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Worker[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Worker);
		for (int i = 0; i < n; i++)
			((ns1__Worker*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Worker*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Worker(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Worker %p -> %p\n", q, p));
	*(ns1__Worker*)p = *(ns1__Worker*)q;
}

void ns1__ArrayOfWorker::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfWorker::__sizeWorker = 0;
	this->ns1__ArrayOfWorker::Worker = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfWorker::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfWorker::Worker)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfWorker::__sizeWorker; i++)
		{
			soap_serialize_PointerTons1__Worker(soap, this->ns1__ArrayOfWorker::Worker + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfWorker::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfWorker(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfWorker(struct soap *soap, const char *tag, int id, const ns1__ArrayOfWorker *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfWorker), type))
		return soap->error;
	if (a->ns1__ArrayOfWorker::Worker)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfWorker::__sizeWorker; i++)
			if (soap_out_PointerTons1__Worker(soap, "ns1:Worker", -1, a->ns1__ArrayOfWorker::Worker + i, "ns1:Worker"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfWorker::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfWorker(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfWorker * SOAP_FMAC4 soap_in_ns1__ArrayOfWorker(struct soap *soap, const char *tag, ns1__ArrayOfWorker *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfWorker *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfWorker, sizeof(ns1__ArrayOfWorker), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfWorker)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfWorker *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Worker1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Worker", 1, NULL))
			{	if (a->ns1__ArrayOfWorker::Worker == NULL)
				{	if (soap_blist_Worker1 == NULL)
						soap_blist_Worker1 = soap_new_block(soap);
					a->ns1__ArrayOfWorker::Worker = (ns1__Worker **)soap_push_block(soap, soap_blist_Worker1, sizeof(ns1__Worker *));
					if (a->ns1__ArrayOfWorker::Worker == NULL)
						return NULL;
					*a->ns1__ArrayOfWorker::Worker = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Worker(soap, "ns1:Worker", a->ns1__ArrayOfWorker::Worker, "ns1:Worker"))
				{	a->ns1__ArrayOfWorker::__sizeWorker++;
					a->ns1__ArrayOfWorker::Worker = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfWorker::Worker)
			soap_pop_block(soap, soap_blist_Worker1);
		if (a->ns1__ArrayOfWorker::__sizeWorker)
			a->ns1__ArrayOfWorker::Worker = (ns1__Worker **)soap_save_block(soap, soap_blist_Worker1, NULL, 1);
		else
		{	a->ns1__ArrayOfWorker::Worker = NULL;
			if (soap_blist_Worker1)
				soap_end_block(soap, soap_blist_Worker1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfWorker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfWorker, 0, sizeof(ns1__ArrayOfWorker), 0, soap_copy_ns1__ArrayOfWorker);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfWorker::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfWorker);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfWorker", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfWorker::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfWorker(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfWorker * SOAP_FMAC4 soap_get_ns1__ArrayOfWorker(struct soap *soap, ns1__ArrayOfWorker *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfWorker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfWorker * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfWorker(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfWorker(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfWorker, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfWorker);
		if (size)
			*size = sizeof(ns1__ArrayOfWorker);
		((ns1__ArrayOfWorker*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfWorker[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfWorker);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfWorker*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfWorker*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfWorker(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfWorker %p -> %p\n", q, p));
	*(ns1__ArrayOfWorker*)p = *(ns1__ArrayOfWorker*)q;
}

void ns1__ReturnInfoItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__ReturnInfoItem::type);
	soap_default_double(soap, &this->ns1__ReturnInfoItem::totalMoney);
	soap_default_double(soap, &this->ns1__ReturnInfoItem::returnMoney);
	soap_default_int(soap, &this->ns1__ReturnInfoItem::count);
	/* transient soap skipped */
}

void ns1__ReturnInfoItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ReturnInfoItem::type);
	/* transient soap skipped */
}

int ns1__ReturnInfoItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnInfoItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnInfoItem(struct soap *soap, const char *tag, int id, const ns1__ReturnInfoItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnInfoItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->ns1__ReturnInfoItem::type), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:totalMoney", -1, &(a->ns1__ReturnInfoItem::totalMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__ReturnInfoItem::returnMoney), "xsd:double"))
		return soap->error;
	if (soap_out_int(soap, "ns1:count", -1, &(a->ns1__ReturnInfoItem::count), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ReturnInfoItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnInfoItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnInfoItem * SOAP_FMAC4 soap_in_ns1__ReturnInfoItem(struct soap *soap, const char *tag, ns1__ReturnInfoItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReturnInfoItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnInfoItem, sizeof(ns1__ReturnInfoItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReturnInfoItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReturnInfoItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_totalMoney1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->ns1__ReturnInfoItem::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_totalMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:totalMoney", &(a->ns1__ReturnInfoItem::totalMoney), "xsd:double"))
				{	soap_flag_totalMoney1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__ReturnInfoItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:count", &(a->ns1__ReturnInfoItem::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReturnInfoItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnInfoItem, 0, sizeof(ns1__ReturnInfoItem), 0, soap_copy_ns1__ReturnInfoItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalMoney1 > 0 || soap_flag_returnMoney1 > 0 || soap_flag_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ReturnInfoItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReturnInfoItem);
	if (this->soap_out(soap, tag?tag:"ns1:ReturnInfoItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReturnInfoItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnInfoItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnInfoItem * SOAP_FMAC4 soap_get_ns1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnInfoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ReturnInfoItem * SOAP_FMAC2 soap_instantiate_ns1__ReturnInfoItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnInfoItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnInfoItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnInfoItem);
		if (size)
			*size = sizeof(ns1__ReturnInfoItem);
		((ns1__ReturnInfoItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnInfoItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReturnInfoItem);
		for (int i = 0; i < n; i++)
			((ns1__ReturnInfoItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReturnInfoItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReturnInfoItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReturnInfoItem %p -> %p\n", q, p));
	*(ns1__ReturnInfoItem*)p = *(ns1__ReturnInfoItem*)q;
}

void ns1__ArrayOfReturnInfoItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfReturnInfoItem::__sizeReturnInfoItem = 0;
	this->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfReturnInfoItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfReturnInfoItem::ReturnInfoItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfReturnInfoItem::__sizeReturnInfoItem; i++)
		{
			soap_serialize_PointerTons1__ReturnInfoItem(soap, this->ns1__ArrayOfReturnInfoItem::ReturnInfoItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfReturnInfoItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfReturnInfoItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfReturnInfoItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfReturnInfoItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfReturnInfoItem), type))
		return soap->error;
	if (a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfReturnInfoItem::__sizeReturnInfoItem; i++)
			if (soap_out_PointerTons1__ReturnInfoItem(soap, "ns1:ReturnInfoItem", -1, a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem + i, "ns1:ReturnInfoItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfReturnInfoItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfReturnInfoItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnInfoItem * SOAP_FMAC4 soap_in_ns1__ArrayOfReturnInfoItem(struct soap *soap, const char *tag, ns1__ArrayOfReturnInfoItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfReturnInfoItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfReturnInfoItem, sizeof(ns1__ArrayOfReturnInfoItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfReturnInfoItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfReturnInfoItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ReturnInfoItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ReturnInfoItem", 1, NULL))
			{	if (a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem == NULL)
				{	if (soap_blist_ReturnInfoItem1 == NULL)
						soap_blist_ReturnInfoItem1 = soap_new_block(soap);
					a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = (ns1__ReturnInfoItem **)soap_push_block(soap, soap_blist_ReturnInfoItem1, sizeof(ns1__ReturnInfoItem *));
					if (a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem == NULL)
						return NULL;
					*a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ReturnInfoItem(soap, "ns1:ReturnInfoItem", a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem, "ns1:ReturnInfoItem"))
				{	a->ns1__ArrayOfReturnInfoItem::__sizeReturnInfoItem++;
					a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem)
			soap_pop_block(soap, soap_blist_ReturnInfoItem1);
		if (a->ns1__ArrayOfReturnInfoItem::__sizeReturnInfoItem)
			a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = (ns1__ReturnInfoItem **)soap_save_block(soap, soap_blist_ReturnInfoItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfReturnInfoItem::ReturnInfoItem = NULL;
			if (soap_blist_ReturnInfoItem1)
				soap_end_block(soap, soap_blist_ReturnInfoItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfReturnInfoItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfReturnInfoItem, 0, sizeof(ns1__ArrayOfReturnInfoItem), 0, soap_copy_ns1__ArrayOfReturnInfoItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfReturnInfoItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfReturnInfoItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfReturnInfoItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfReturnInfoItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfReturnInfoItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnInfoItem * SOAP_FMAC4 soap_get_ns1__ArrayOfReturnInfoItem(struct soap *soap, ns1__ArrayOfReturnInfoItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfReturnInfoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfReturnInfoItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfReturnInfoItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfReturnInfoItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfReturnInfoItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnInfoItem);
		if (size)
			*size = sizeof(ns1__ArrayOfReturnInfoItem);
		((ns1__ArrayOfReturnInfoItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfReturnInfoItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfReturnInfoItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfReturnInfoItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfReturnInfoItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfReturnInfoItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfReturnInfoItem %p -> %p\n", q, p));
	*(ns1__ArrayOfReturnInfoItem*)p = *(ns1__ArrayOfReturnInfoItem*)q;
}

void ns1__ReturnInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__ReturnInfo::lastChargeTime);
	soap_default_double(soap, &this->ns1__ReturnInfo::curMoney);
	this->ns1__ReturnInfo::list = NULL;
	soap_default_int(soap, &this->ns1__ReturnInfo::total);
	soap_default_double(soap, &this->ns1__ReturnInfo::processTotalMoney);
	soap_default_double(soap, &this->ns1__ReturnInfo::returnTotalMoney);
	soap_default_double(soap, &this->ns1__ReturnInfo::afterReturnTotalMoney);
	/* transient soap skipped */
}

void ns1__ReturnInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ReturnInfo::lastChargeTime);
	soap_serialize_PointerTons1__ArrayOfReturnInfoItem(soap, &this->ns1__ReturnInfo::list);
	/* transient soap skipped */
}

int ns1__ReturnInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnInfo(struct soap *soap, const char *tag, int id, const ns1__ReturnInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:lastChargeTime", -1, &(a->ns1__ReturnInfo::lastChargeTime), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:curMoney", -1, &(a->ns1__ReturnInfo::curMoney), "xsd:double"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfReturnInfoItem(soap, "ns1:list", -1, &(a->ns1__ReturnInfo::list), "ns1:ArrayOfReturnInfoItem"))
		return soap->error;
	if (soap_out_int(soap, "ns1:total", -1, &(a->ns1__ReturnInfo::total), "xsd:int"))
		return soap->error;
	if (soap_out_double(soap, "ns1:processTotalMoney", -1, &(a->ns1__ReturnInfo::processTotalMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnTotalMoney", -1, &(a->ns1__ReturnInfo::returnTotalMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:afterReturnTotalMoney", -1, &(a->ns1__ReturnInfo::afterReturnTotalMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ReturnInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnInfo * SOAP_FMAC4 soap_in_ns1__ReturnInfo(struct soap *soap, const char *tag, ns1__ReturnInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReturnInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnInfo, sizeof(ns1__ReturnInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReturnInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReturnInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lastChargeTime1 = 1;
	size_t soap_flag_curMoney1 = 1;
	size_t soap_flag_list1 = 1;
	size_t soap_flag_total1 = 1;
	size_t soap_flag_processTotalMoney1 = 1;
	size_t soap_flag_returnTotalMoney1 = 1;
	size_t soap_flag_afterReturnTotalMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lastChargeTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:lastChargeTime", &(a->ns1__ReturnInfo::lastChargeTime), "xsd:string"))
				{	soap_flag_lastChargeTime1--;
					continue;
				}
			if (soap_flag_curMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:curMoney", &(a->ns1__ReturnInfo::curMoney), "xsd:double"))
				{	soap_flag_curMoney1--;
					continue;
				}
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfReturnInfoItem(soap, "ns1:list", &(a->ns1__ReturnInfo::list), "ns1:ArrayOfReturnInfoItem"))
				{	soap_flag_list1--;
					continue;
				}
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &(a->ns1__ReturnInfo::total), "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_processTotalMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:processTotalMoney", &(a->ns1__ReturnInfo::processTotalMoney), "xsd:double"))
				{	soap_flag_processTotalMoney1--;
					continue;
				}
			if (soap_flag_returnTotalMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnTotalMoney", &(a->ns1__ReturnInfo::returnTotalMoney), "xsd:double"))
				{	soap_flag_returnTotalMoney1--;
					continue;
				}
			if (soap_flag_afterReturnTotalMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:afterReturnTotalMoney", &(a->ns1__ReturnInfo::afterReturnTotalMoney), "xsd:double"))
				{	soap_flag_afterReturnTotalMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReturnInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnInfo, 0, sizeof(ns1__ReturnInfo), 0, soap_copy_ns1__ReturnInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_curMoney1 > 0 || soap_flag_total1 > 0 || soap_flag_processTotalMoney1 > 0 || soap_flag_returnTotalMoney1 > 0 || soap_flag_afterReturnTotalMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ReturnInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReturnInfo);
	if (this->soap_out(soap, tag?tag:"ns1:ReturnInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReturnInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnInfo * SOAP_FMAC4 soap_get_ns1__ReturnInfo(struct soap *soap, ns1__ReturnInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ReturnInfo * SOAP_FMAC2 soap_instantiate_ns1__ReturnInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnInfo);
		if (size)
			*size = sizeof(ns1__ReturnInfo);
		((ns1__ReturnInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ReturnInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReturnInfo);
		for (int i = 0; i < n; i++)
			((ns1__ReturnInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReturnInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReturnInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReturnInfo %p -> %p\n", q, p));
	*(ns1__ReturnInfo*)p = *(ns1__ReturnInfo*)q;
}

void ns1__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__User::Id);
	soap_default_string(soap, &this->ns1__User::loggingName);
	soap_default_string(soap, &this->ns1__User::password);
	soap_default_float(soap, &this->ns1__User::money);
	soap_default_string(soap, &this->ns1__User::tel);
	soap_default_string(soap, &this->ns1__User::mac);
	soap_default_string(soap, &this->ns1__User::address);
	soap_default_string(soap, &this->ns1__User::shopName);
	soap_default_string(soap, &this->ns1__User::mobilePhone);
	soap_default_string(soap, &this->ns1__User::pingying);
	soap_default_string(soap, &this->ns1__User::realName);
	soap_default_string(soap, &this->ns1__User::indentityNo);
	soap_default_ns2__guid(soap, &this->ns1__User::manager_USCOREid);
	soap_default_string(soap, &this->ns1__User::managerName);
	soap_default_string(soap, &this->ns1__User::moneyTail);
	soap_default_string(soap, &this->ns1__User::level);
	soap_default_time(soap, &this->ns1__User::registerDatetime);
	soap_default_bool(soap, &this->ns1__User::isValidate);
	soap_default_string(soap, &this->ns1__User::btnList);
	soap_default_string(soap, &this->ns1__User::userType);
	/* transient soap skipped */
}

void ns1__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__User::Id);
	soap_serialize_string(soap, &this->ns1__User::loggingName);
	soap_serialize_string(soap, &this->ns1__User::password);
	soap_serialize_string(soap, &this->ns1__User::tel);
	soap_serialize_string(soap, &this->ns1__User::mac);
	soap_serialize_string(soap, &this->ns1__User::address);
	soap_serialize_string(soap, &this->ns1__User::shopName);
	soap_serialize_string(soap, &this->ns1__User::mobilePhone);
	soap_serialize_string(soap, &this->ns1__User::pingying);
	soap_serialize_string(soap, &this->ns1__User::realName);
	soap_serialize_string(soap, &this->ns1__User::indentityNo);
	soap_serialize_ns2__guid(soap, &this->ns1__User::manager_USCOREid);
	soap_serialize_string(soap, &this->ns1__User::managerName);
	soap_serialize_string(soap, &this->ns1__User::moneyTail);
	soap_serialize_string(soap, &this->ns1__User::level);
	soap_serialize_string(soap, &this->ns1__User::btnList);
	soap_serialize_string(soap, &this->ns1__User::userType);
	/* transient soap skipped */
}

int ns1__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__User(struct soap *soap, const char *tag, int id, const ns1__User *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__User), type))
		return soap->error;
	if (a->ns1__User::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__User::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:loggingName", -1, &(a->ns1__User::loggingName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:password", -1, &(a->ns1__User::password), "xsd:string"))
		return soap->error;
	if (soap_out_float(soap, "ns1:money", -1, &(a->ns1__User::money), "xsd:float"))
		return soap->error;
	if (soap_out_string(soap, "ns1:tel", -1, &(a->ns1__User::tel), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:mac", -1, &(a->ns1__User::mac), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:address", -1, &(a->ns1__User::address), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:shopName", -1, &(a->ns1__User::shopName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:mobilePhone", -1, &(a->ns1__User::mobilePhone), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:pingying", -1, &(a->ns1__User::pingying), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:realName", -1, &(a->ns1__User::realName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:indentityNo", -1, &(a->ns1__User::indentityNo), "xsd:string"))
		return soap->error;
	if (a->ns1__User::manager_USCOREid)
	{	if (soap_out_ns2__guid(soap, "ns1:manager_id", -1, &a->ns1__User::manager_USCOREid, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:manager_id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:managerName", -1, &(a->ns1__User::managerName), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:moneyTail", -1, &(a->ns1__User::moneyTail), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:level", -1, &(a->ns1__User::level), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:registerDatetime", -1, &(a->ns1__User::registerDatetime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isValidate", -1, &(a->ns1__User::isValidate), "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "ns1:btnList", -1, &(a->ns1__User::btnList), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userType", -1, &(a->ns1__User::userType), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__User(soap, tag, this, type);
}

SOAP_FMAC3 ns1__User * SOAP_FMAC4 soap_in_ns1__User(struct soap *soap, const char *tag, ns1__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__User, sizeof(ns1__User), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__User)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__User *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_loggingName1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_tel1 = 1;
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_shopName1 = 1;
	size_t soap_flag_mobilePhone1 = 1;
	size_t soap_flag_pingying1 = 1;
	size_t soap_flag_realName1 = 1;
	size_t soap_flag_indentityNo1 = 1;
	size_t soap_flag_manager_USCOREid1 = 1;
	size_t soap_flag_managerName1 = 1;
	size_t soap_flag_moneyTail1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_registerDatetime1 = 1;
	size_t soap_flag_isValidate1 = 1;
	size_t soap_flag_btnList1 = 1;
	size_t soap_flag_userType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__User::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_loggingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:loggingName", &(a->ns1__User::loggingName), "xsd:string"))
				{	soap_flag_loggingName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:password", &(a->ns1__User::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns1:money", &(a->ns1__User::money), "xsd:float"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_tel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:tel", &(a->ns1__User::tel), "xsd:string"))
				{	soap_flag_tel1--;
					continue;
				}
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mac", &(a->ns1__User::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:address", &(a->ns1__User::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_shopName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:shopName", &(a->ns1__User::shopName), "xsd:string"))
				{	soap_flag_shopName1--;
					continue;
				}
			if (soap_flag_mobilePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mobilePhone", &(a->ns1__User::mobilePhone), "xsd:string"))
				{	soap_flag_mobilePhone1--;
					continue;
				}
			if (soap_flag_pingying1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pingying", &(a->ns1__User::pingying), "xsd:string"))
				{	soap_flag_pingying1--;
					continue;
				}
			if (soap_flag_realName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:realName", &(a->ns1__User::realName), "xsd:string"))
				{	soap_flag_realName1--;
					continue;
				}
			if (soap_flag_indentityNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:indentityNo", &(a->ns1__User::indentityNo), "xsd:string"))
				{	soap_flag_indentityNo1--;
					continue;
				}
			if (soap_flag_manager_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:manager_id", &(a->ns1__User::manager_USCOREid), "ns2:guid"))
				{	soap_flag_manager_USCOREid1--;
					continue;
				}
			if (soap_flag_managerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:managerName", &(a->ns1__User::managerName), "xsd:string"))
				{	soap_flag_managerName1--;
					continue;
				}
			if (soap_flag_moneyTail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moneyTail", &(a->ns1__User::moneyTail), "xsd:string"))
				{	soap_flag_moneyTail1--;
					continue;
				}
			if (soap_flag_level1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:level", &(a->ns1__User::level), "xsd:string"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_registerDatetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:registerDatetime", &(a->ns1__User::registerDatetime), "xsd:dateTime"))
				{	soap_flag_registerDatetime1--;
					continue;
				}
			if (soap_flag_isValidate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isValidate", &(a->ns1__User::isValidate), "xsd:boolean"))
				{	soap_flag_isValidate1--;
					continue;
				}
			if (soap_flag_btnList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:btnList", &(a->ns1__User::btnList), "xsd:string"))
				{	soap_flag_btnList1--;
					continue;
				}
			if (soap_flag_userType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userType", &(a->ns1__User::userType), "xsd:string"))
				{	soap_flag_userType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__User, 0, sizeof(ns1__User), 0, soap_copy_ns1__User);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_money1 > 0 || soap_flag_manager_USCOREid1 > 0 || soap_flag_registerDatetime1 > 0 || soap_flag_isValidate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__User);
	if (this->soap_out(soap, tag?tag:"ns1:User", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__User(soap, this, tag, type);
}

SOAP_FMAC3 ns1__User * SOAP_FMAC4 soap_get_ns1__User(struct soap *soap, ns1__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__User * SOAP_FMAC2 soap_instantiate_ns1__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__User, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__User);
		if (size)
			*size = sizeof(ns1__User);
		((ns1__User*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__User[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__User);
		for (int i = 0; i < n; i++)
			((ns1__User*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__User %p -> %p\n", q, p));
	*(ns1__User*)p = *(ns1__User*)q;
}

void ns1__PayPublicTelItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PayPublicTelItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__PayPublicTelItem::userId);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::userName);
	soap_default_time(soap, &this->ns1__PayPublicTelItem::addDateTime);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::telType);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::telAccount);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::money);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::content);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::state);
	soap_default_ns2__guid(soap, &this->ns1__PayPublicTelItem::workId);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::work_USCOREname);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::manager_USCOREname);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::moneyBefore);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::moneyAfter);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::clientType);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::returnMoney);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::area);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::location);
	soap_default_string(soap, &this->ns1__PayPublicTelItem::customerName);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::customerBeforeMoney);
	soap_default_double(soap, &this->ns1__PayPublicTelItem::customerAfterMoney);
	/* transient soap skipped */
}

void ns1__PayPublicTelItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PayPublicTelItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__PayPublicTelItem::userId);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::userName);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::telType);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::telAccount);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::content);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__PayPublicTelItem::workId);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::work_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::manager_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::clientType);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::area);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::location);
	soap_serialize_string(soap, &this->ns1__PayPublicTelItem::customerName);
	/* transient soap skipped */
}

int ns1__PayPublicTelItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayPublicTelItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayPublicTelItem(struct soap *soap, const char *tag, int id, const ns1__PayPublicTelItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayPublicTelItem), type))
		return soap->error;
	if (a->ns1__PayPublicTelItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PayPublicTelItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__PayPublicTelItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__PayPublicTelItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__PayPublicTelItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:addDateTime", -1, &(a->ns1__PayPublicTelItem::addDateTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:telType", -1, &(a->ns1__PayPublicTelItem::telType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:telAccount", -1, &(a->ns1__PayPublicTelItem::telAccount), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__PayPublicTelItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__PayPublicTelItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PayPublicTelItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__PayPublicTelItem::workId)
	{	if (soap_out_ns2__guid(soap, "ns1:workId", -1, &a->ns1__PayPublicTelItem::workId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__PayPublicTelItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager_name", -1, &(a->ns1__PayPublicTelItem::manager_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__PayPublicTelItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__PayPublicTelItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__PayPublicTelItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__PayPublicTelItem::returnMoney), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__PayPublicTelItem::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:location", -1, &(a->ns1__PayPublicTelItem::location), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:customerName", -1, &(a->ns1__PayPublicTelItem::customerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerBeforeMoney", -1, &(a->ns1__PayPublicTelItem::customerBeforeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerAfterMoney", -1, &(a->ns1__PayPublicTelItem::customerAfterMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayPublicTelItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayPublicTelItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayPublicTelItem * SOAP_FMAC4 soap_in_ns1__PayPublicTelItem(struct soap *soap, const char *tag, ns1__PayPublicTelItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayPublicTelItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayPublicTelItem, sizeof(ns1__PayPublicTelItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayPublicTelItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayPublicTelItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_addDateTime1 = 1;
	size_t soap_flag_telType1 = 1;
	size_t soap_flag_telAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workId1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_manager_USCOREname1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_customerName1 = 1;
	size_t soap_flag_customerBeforeMoney1 = 1;
	size_t soap_flag_customerAfterMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PayPublicTelItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__PayPublicTelItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__PayPublicTelItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_addDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:addDateTime", &(a->ns1__PayPublicTelItem::addDateTime), "xsd:dateTime"))
				{	soap_flag_addDateTime1--;
					continue;
				}
			if (soap_flag_telType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telType", &(a->ns1__PayPublicTelItem::telType), "xsd:string"))
				{	soap_flag_telType1--;
					continue;
				}
			if (soap_flag_telAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telAccount", &(a->ns1__PayPublicTelItem::telAccount), "xsd:string"))
				{	soap_flag_telAccount1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__PayPublicTelItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__PayPublicTelItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PayPublicTelItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workId", &(a->ns1__PayPublicTelItem::workId), "ns2:guid"))
				{	soap_flag_workId1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__PayPublicTelItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_manager_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager_name", &(a->ns1__PayPublicTelItem::manager_USCOREname), "xsd:string"))
				{	soap_flag_manager_USCOREname1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__PayPublicTelItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__PayPublicTelItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__PayPublicTelItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__PayPublicTelItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__PayPublicTelItem::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:location", &(a->ns1__PayPublicTelItem::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_customerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:customerName", &(a->ns1__PayPublicTelItem::customerName), "xsd:string"))
				{	soap_flag_customerName1--;
					continue;
				}
			if (soap_flag_customerBeforeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerBeforeMoney", &(a->ns1__PayPublicTelItem::customerBeforeMoney), "xsd:double"))
				{	soap_flag_customerBeforeMoney1--;
					continue;
				}
			if (soap_flag_customerAfterMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerAfterMoney", &(a->ns1__PayPublicTelItem::customerAfterMoney), "xsd:double"))
				{	soap_flag_customerAfterMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayPublicTelItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayPublicTelItem, 0, sizeof(ns1__PayPublicTelItem), 0, soap_copy_ns1__PayPublicTelItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_addDateTime1 > 0 || soap_flag_money1 > 0 || soap_flag_workId1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0 || soap_flag_returnMoney1 > 0 || soap_flag_customerBeforeMoney1 > 0 || soap_flag_customerAfterMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayPublicTelItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayPublicTelItem);
	if (this->soap_out(soap, tag?tag:"ns1:PayPublicTelItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayPublicTelItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayPublicTelItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayPublicTelItem * SOAP_FMAC4 soap_get_ns1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayPublicTelItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayPublicTelItem * SOAP_FMAC2 soap_instantiate_ns1__PayPublicTelItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayPublicTelItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayPublicTelItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayPublicTelItem);
		if (size)
			*size = sizeof(ns1__PayPublicTelItem);
		((ns1__PayPublicTelItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayPublicTelItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayPublicTelItem);
		for (int i = 0; i < n; i++)
			((ns1__PayPublicTelItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayPublicTelItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayPublicTelItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayPublicTelItem %p -> %p\n", q, p));
	*(ns1__PayPublicTelItem*)p = *(ns1__PayPublicTelItem*)q;
}

void ns1__ArrayOfPayPublicTelItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPayPublicTelItem::__sizePayPublicTelItem = 0;
	this->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPayPublicTelItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPayPublicTelItem::__sizePayPublicTelItem; i++)
		{
			soap_serialize_PointerTons1__PayPublicTelItem(soap, this->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPayPublicTelItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPayPublicTelItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPayPublicTelItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPayPublicTelItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPayPublicTelItem::__sizePayPublicTelItem; i++)
			if (soap_out_PointerTons1__PayPublicTelItem(soap, "ns1:PayPublicTelItem", -1, a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem + i, "ns1:PayPublicTelItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPayPublicTelItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPayPublicTelItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPayPublicTelItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPayPublicTelItem(struct soap *soap, const char *tag, ns1__ArrayOfPayPublicTelItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPayPublicTelItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem, sizeof(ns1__ArrayOfPayPublicTelItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPayPublicTelItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPayPublicTelItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PayPublicTelItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PayPublicTelItem", 1, NULL))
			{	if (a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem == NULL)
				{	if (soap_blist_PayPublicTelItem1 == NULL)
						soap_blist_PayPublicTelItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = (ns1__PayPublicTelItem **)soap_push_block(soap, soap_blist_PayPublicTelItem1, sizeof(ns1__PayPublicTelItem *));
					if (a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PayPublicTelItem(soap, "ns1:PayPublicTelItem", a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem, "ns1:PayPublicTelItem"))
				{	a->ns1__ArrayOfPayPublicTelItem::__sizePayPublicTelItem++;
					a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem)
			soap_pop_block(soap, soap_blist_PayPublicTelItem1);
		if (a->ns1__ArrayOfPayPublicTelItem::__sizePayPublicTelItem)
			a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = (ns1__PayPublicTelItem **)soap_save_block(soap, soap_blist_PayPublicTelItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPayPublicTelItem::PayPublicTelItem = NULL;
			if (soap_blist_PayPublicTelItem1)
				soap_end_block(soap, soap_blist_PayPublicTelItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPayPublicTelItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem, 0, sizeof(ns1__ArrayOfPayPublicTelItem), 0, soap_copy_ns1__ArrayOfPayPublicTelItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPayPublicTelItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPayPublicTelItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPayPublicTelItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPayPublicTelItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPayPublicTelItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPayPublicTelItem(struct soap *soap, ns1__ArrayOfPayPublicTelItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPayPublicTelItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPayPublicTelItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPayPublicTelItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPayPublicTelItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayPublicTelItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPayPublicTelItem);
		((ns1__ArrayOfPayPublicTelItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayPublicTelItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPayPublicTelItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPayPublicTelItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPayPublicTelItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPayPublicTelItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPayPublicTelItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPayPublicTelItem*)p = *(ns1__ArrayOfPayPublicTelItem*)q;
}

void ns1__PayGameItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PayGameItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__PayGameItem::userId);
	soap_default_string(soap, &this->ns1__PayGameItem::userName);
	soap_default_time(soap, &this->ns1__PayGameItem::addDateTime);
	soap_default_string(soap, &this->ns1__PayGameItem::gameType);
	soap_default_string(soap, &this->ns1__PayGameItem::gameAccount);
	soap_default_double(soap, &this->ns1__PayGameItem::money);
	soap_default_string(soap, &this->ns1__PayGameItem::content);
	soap_default_string(soap, &this->ns1__PayGameItem::state);
	soap_default_ns2__guid(soap, &this->ns1__PayGameItem::workId);
	soap_default_string(soap, &this->ns1__PayGameItem::work_USCOREname);
	soap_default_string(soap, &this->ns1__PayGameItem::manager_USCOREname);
	soap_default_double(soap, &this->ns1__PayGameItem::moneyBefore);
	soap_default_double(soap, &this->ns1__PayGameItem::moneyAfter);
	soap_default_string(soap, &this->ns1__PayGameItem::clientType);
	soap_default_double(soap, &this->ns1__PayGameItem::returnMoney);
	soap_default_string(soap, &this->ns1__PayGameItem::customerName);
	soap_default_double(soap, &this->ns1__PayGameItem::customerBeforeMoney);
	soap_default_double(soap, &this->ns1__PayGameItem::customerAfterMoney);
	/* transient soap skipped */
}

void ns1__PayGameItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PayGameItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__PayGameItem::userId);
	soap_serialize_string(soap, &this->ns1__PayGameItem::userName);
	soap_serialize_string(soap, &this->ns1__PayGameItem::gameType);
	soap_serialize_string(soap, &this->ns1__PayGameItem::gameAccount);
	soap_serialize_string(soap, &this->ns1__PayGameItem::content);
	soap_serialize_string(soap, &this->ns1__PayGameItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__PayGameItem::workId);
	soap_serialize_string(soap, &this->ns1__PayGameItem::work_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayGameItem::manager_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayGameItem::clientType);
	soap_serialize_string(soap, &this->ns1__PayGameItem::customerName);
	/* transient soap skipped */
}

int ns1__PayGameItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayGameItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayGameItem(struct soap *soap, const char *tag, int id, const ns1__PayGameItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayGameItem), type))
		return soap->error;
	if (a->ns1__PayGameItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PayGameItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__PayGameItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__PayGameItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__PayGameItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:addDateTime", -1, &(a->ns1__PayGameItem::addDateTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:gameType", -1, &(a->ns1__PayGameItem::gameType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:gameAccount", -1, &(a->ns1__PayGameItem::gameAccount), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__PayGameItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__PayGameItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PayGameItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__PayGameItem::workId)
	{	if (soap_out_ns2__guid(soap, "ns1:workId", -1, &a->ns1__PayGameItem::workId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__PayGameItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager_name", -1, &(a->ns1__PayGameItem::manager_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__PayGameItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__PayGameItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__PayGameItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__PayGameItem::returnMoney), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:customerName", -1, &(a->ns1__PayGameItem::customerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerBeforeMoney", -1, &(a->ns1__PayGameItem::customerBeforeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerAfterMoney", -1, &(a->ns1__PayGameItem::customerAfterMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayGameItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayGameItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayGameItem * SOAP_FMAC4 soap_in_ns1__PayGameItem(struct soap *soap, const char *tag, ns1__PayGameItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayGameItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayGameItem, sizeof(ns1__PayGameItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayGameItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayGameItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_addDateTime1 = 1;
	size_t soap_flag_gameType1 = 1;
	size_t soap_flag_gameAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workId1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_manager_USCOREname1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	size_t soap_flag_customerName1 = 1;
	size_t soap_flag_customerBeforeMoney1 = 1;
	size_t soap_flag_customerAfterMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PayGameItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__PayGameItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__PayGameItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_addDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:addDateTime", &(a->ns1__PayGameItem::addDateTime), "xsd:dateTime"))
				{	soap_flag_addDateTime1--;
					continue;
				}
			if (soap_flag_gameType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gameType", &(a->ns1__PayGameItem::gameType), "xsd:string"))
				{	soap_flag_gameType1--;
					continue;
				}
			if (soap_flag_gameAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gameAccount", &(a->ns1__PayGameItem::gameAccount), "xsd:string"))
				{	soap_flag_gameAccount1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__PayGameItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__PayGameItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PayGameItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workId", &(a->ns1__PayGameItem::workId), "ns2:guid"))
				{	soap_flag_workId1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__PayGameItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_manager_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager_name", &(a->ns1__PayGameItem::manager_USCOREname), "xsd:string"))
				{	soap_flag_manager_USCOREname1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__PayGameItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__PayGameItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__PayGameItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__PayGameItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			if (soap_flag_customerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:customerName", &(a->ns1__PayGameItem::customerName), "xsd:string"))
				{	soap_flag_customerName1--;
					continue;
				}
			if (soap_flag_customerBeforeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerBeforeMoney", &(a->ns1__PayGameItem::customerBeforeMoney), "xsd:double"))
				{	soap_flag_customerBeforeMoney1--;
					continue;
				}
			if (soap_flag_customerAfterMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerAfterMoney", &(a->ns1__PayGameItem::customerAfterMoney), "xsd:double"))
				{	soap_flag_customerAfterMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayGameItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayGameItem, 0, sizeof(ns1__PayGameItem), 0, soap_copy_ns1__PayGameItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_addDateTime1 > 0 || soap_flag_money1 > 0 || soap_flag_workId1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0 || soap_flag_returnMoney1 > 0 || soap_flag_customerBeforeMoney1 > 0 || soap_flag_customerAfterMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayGameItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayGameItem);
	if (this->soap_out(soap, tag?tag:"ns1:PayGameItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayGameItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayGameItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayGameItem * SOAP_FMAC4 soap_get_ns1__PayGameItem(struct soap *soap, ns1__PayGameItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayGameItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayGameItem * SOAP_FMAC2 soap_instantiate_ns1__PayGameItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayGameItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayGameItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayGameItem);
		if (size)
			*size = sizeof(ns1__PayGameItem);
		((ns1__PayGameItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayGameItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayGameItem);
		for (int i = 0; i < n; i++)
			((ns1__PayGameItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayGameItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayGameItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayGameItem %p -> %p\n", q, p));
	*(ns1__PayGameItem*)p = *(ns1__PayGameItem*)q;
}

void ns1__ArrayOfPayGameItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPayGameItem::__sizePayGameItem = 0;
	this->ns1__ArrayOfPayGameItem::PayGameItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPayGameItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPayGameItem::PayGameItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPayGameItem::__sizePayGameItem; i++)
		{
			soap_serialize_PointerTons1__PayGameItem(soap, this->ns1__ArrayOfPayGameItem::PayGameItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPayGameItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPayGameItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPayGameItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPayGameItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPayGameItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPayGameItem::PayGameItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPayGameItem::__sizePayGameItem; i++)
			if (soap_out_PointerTons1__PayGameItem(soap, "ns1:PayGameItem", -1, a->ns1__ArrayOfPayGameItem::PayGameItem + i, "ns1:PayGameItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPayGameItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPayGameItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPayGameItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPayGameItem(struct soap *soap, const char *tag, ns1__ArrayOfPayGameItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPayGameItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPayGameItem, sizeof(ns1__ArrayOfPayGameItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPayGameItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPayGameItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PayGameItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PayGameItem", 1, NULL))
			{	if (a->ns1__ArrayOfPayGameItem::PayGameItem == NULL)
				{	if (soap_blist_PayGameItem1 == NULL)
						soap_blist_PayGameItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPayGameItem::PayGameItem = (ns1__PayGameItem **)soap_push_block(soap, soap_blist_PayGameItem1, sizeof(ns1__PayGameItem *));
					if (a->ns1__ArrayOfPayGameItem::PayGameItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPayGameItem::PayGameItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PayGameItem(soap, "ns1:PayGameItem", a->ns1__ArrayOfPayGameItem::PayGameItem, "ns1:PayGameItem"))
				{	a->ns1__ArrayOfPayGameItem::__sizePayGameItem++;
					a->ns1__ArrayOfPayGameItem::PayGameItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPayGameItem::PayGameItem)
			soap_pop_block(soap, soap_blist_PayGameItem1);
		if (a->ns1__ArrayOfPayGameItem::__sizePayGameItem)
			a->ns1__ArrayOfPayGameItem::PayGameItem = (ns1__PayGameItem **)soap_save_block(soap, soap_blist_PayGameItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPayGameItem::PayGameItem = NULL;
			if (soap_blist_PayGameItem1)
				soap_end_block(soap, soap_blist_PayGameItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPayGameItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPayGameItem, 0, sizeof(ns1__ArrayOfPayGameItem), 0, soap_copy_ns1__ArrayOfPayGameItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPayGameItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPayGameItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPayGameItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPayGameItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPayGameItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPayGameItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPayGameItem(struct soap *soap, ns1__ArrayOfPayGameItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPayGameItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPayGameItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPayGameItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPayGameItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPayGameItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayGameItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPayGameItem);
		((ns1__ArrayOfPayGameItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayGameItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPayGameItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPayGameItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPayGameItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPayGameItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPayGameItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPayGameItem*)p = *(ns1__ArrayOfPayGameItem*)q;
}

void ns1__PayInternetItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PayInternetItem::Id);
	soap_default_ns2__guid(soap, &this->ns1__PayInternetItem::userId);
	soap_default_string(soap, &this->ns1__PayInternetItem::userName);
	soap_default_time(soap, &this->ns1__PayInternetItem::addDateTime);
	soap_default_string(soap, &this->ns1__PayInternetItem::internentType);
	soap_default_string(soap, &this->ns1__PayInternetItem::internetAccount);
	soap_default_double(soap, &this->ns1__PayInternetItem::money);
	soap_default_string(soap, &this->ns1__PayInternetItem::content);
	soap_default_string(soap, &this->ns1__PayInternetItem::state);
	soap_default_ns2__guid(soap, &this->ns1__PayInternetItem::workId);
	soap_default_string(soap, &this->ns1__PayInternetItem::work_USCOREname);
	soap_default_string(soap, &this->ns1__PayInternetItem::manager_USCOREname);
	soap_default_double(soap, &this->ns1__PayInternetItem::moneyBefore);
	soap_default_double(soap, &this->ns1__PayInternetItem::moneyAfter);
	soap_default_string(soap, &this->ns1__PayInternetItem::clientType);
	soap_default_double(soap, &this->ns1__PayInternetItem::returnMoney);
	soap_default_string(soap, &this->ns1__PayInternetItem::area);
	soap_default_string(soap, &this->ns1__PayInternetItem::location);
	soap_default_string(soap, &this->ns1__PayInternetItem::customerName);
	soap_default_double(soap, &this->ns1__PayInternetItem::customerBeforeMoney);
	soap_default_double(soap, &this->ns1__PayInternetItem::customerAfterMoney);
	/* transient soap skipped */
}

void ns1__PayInternetItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PayInternetItem::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__PayInternetItem::userId);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::userName);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::internentType);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::internetAccount);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::content);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::state);
	soap_serialize_ns2__guid(soap, &this->ns1__PayInternetItem::workId);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::work_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::manager_USCOREname);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::clientType);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::area);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::location);
	soap_serialize_string(soap, &this->ns1__PayInternetItem::customerName);
	/* transient soap skipped */
}

int ns1__PayInternetItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayInternetItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayInternetItem(struct soap *soap, const char *tag, int id, const ns1__PayInternetItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayInternetItem), type))
		return soap->error;
	if (a->ns1__PayInternetItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PayInternetItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__PayInternetItem::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__PayInternetItem::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__PayInternetItem::userName), "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "ns1:addDateTime", -1, &(a->ns1__PayInternetItem::addDateTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:internentType", -1, &(a->ns1__PayInternetItem::internentType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:internetAccount", -1, &(a->ns1__PayInternetItem::internetAccount), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__PayInternetItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:content", -1, &(a->ns1__PayInternetItem::content), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PayInternetItem::state), "xsd:string"))
		return soap->error;
	if (a->ns1__PayInternetItem::workId)
	{	if (soap_out_ns2__guid(soap, "ns1:workId", -1, &a->ns1__PayInternetItem::workId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:workId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__PayInternetItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager_name", -1, &(a->ns1__PayInternetItem::manager_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__PayInternetItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__PayInternetItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__PayInternetItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__PayInternetItem::returnMoney), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__PayInternetItem::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:location", -1, &(a->ns1__PayInternetItem::location), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:customerName", -1, &(a->ns1__PayInternetItem::customerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerBeforeMoney", -1, &(a->ns1__PayInternetItem::customerBeforeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerAfterMoney", -1, &(a->ns1__PayInternetItem::customerAfterMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayInternetItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayInternetItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayInternetItem * SOAP_FMAC4 soap_in_ns1__PayInternetItem(struct soap *soap, const char *tag, ns1__PayInternetItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayInternetItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayInternetItem, sizeof(ns1__PayInternetItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayInternetItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayInternetItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_addDateTime1 = 1;
	size_t soap_flag_internentType1 = 1;
	size_t soap_flag_internetAccount1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_content1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_workId1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_manager_USCOREname1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_customerName1 = 1;
	size_t soap_flag_customerBeforeMoney1 = 1;
	size_t soap_flag_customerAfterMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PayInternetItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__PayInternetItem::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__PayInternetItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_addDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:addDateTime", &(a->ns1__PayInternetItem::addDateTime), "xsd:dateTime"))
				{	soap_flag_addDateTime1--;
					continue;
				}
			if (soap_flag_internentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:internentType", &(a->ns1__PayInternetItem::internentType), "xsd:string"))
				{	soap_flag_internentType1--;
					continue;
				}
			if (soap_flag_internetAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:internetAccount", &(a->ns1__PayInternetItem::internetAccount), "xsd:string"))
				{	soap_flag_internetAccount1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__PayInternetItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", &(a->ns1__PayInternetItem::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PayInternetItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_workId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:workId", &(a->ns1__PayInternetItem::workId), "ns2:guid"))
				{	soap_flag_workId1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__PayInternetItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_manager_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager_name", &(a->ns1__PayInternetItem::manager_USCOREname), "xsd:string"))
				{	soap_flag_manager_USCOREname1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__PayInternetItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__PayInternetItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__PayInternetItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__PayInternetItem::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__PayInternetItem::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:location", &(a->ns1__PayInternetItem::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_customerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:customerName", &(a->ns1__PayInternetItem::customerName), "xsd:string"))
				{	soap_flag_customerName1--;
					continue;
				}
			if (soap_flag_customerBeforeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerBeforeMoney", &(a->ns1__PayInternetItem::customerBeforeMoney), "xsd:double"))
				{	soap_flag_customerBeforeMoney1--;
					continue;
				}
			if (soap_flag_customerAfterMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerAfterMoney", &(a->ns1__PayInternetItem::customerAfterMoney), "xsd:double"))
				{	soap_flag_customerAfterMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayInternetItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayInternetItem, 0, sizeof(ns1__PayInternetItem), 0, soap_copy_ns1__PayInternetItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_addDateTime1 > 0 || soap_flag_money1 > 0 || soap_flag_workId1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0 || soap_flag_returnMoney1 > 0 || soap_flag_customerBeforeMoney1 > 0 || soap_flag_customerAfterMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayInternetItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayInternetItem);
	if (this->soap_out(soap, tag?tag:"ns1:PayInternetItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayInternetItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayInternetItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayInternetItem * SOAP_FMAC4 soap_get_ns1__PayInternetItem(struct soap *soap, ns1__PayInternetItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayInternetItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayInternetItem * SOAP_FMAC2 soap_instantiate_ns1__PayInternetItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayInternetItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayInternetItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayInternetItem);
		if (size)
			*size = sizeof(ns1__PayInternetItem);
		((ns1__PayInternetItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayInternetItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayInternetItem);
		for (int i = 0; i < n; i++)
			((ns1__PayInternetItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayInternetItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayInternetItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayInternetItem %p -> %p\n", q, p));
	*(ns1__PayInternetItem*)p = *(ns1__PayInternetItem*)q;
}

void ns1__ArrayOfPayInternetItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPayInternetItem::__sizePayInternetItem = 0;
	this->ns1__ArrayOfPayInternetItem::PayInternetItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPayInternetItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPayInternetItem::PayInternetItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPayInternetItem::__sizePayInternetItem; i++)
		{
			soap_serialize_PointerTons1__PayInternetItem(soap, this->ns1__ArrayOfPayInternetItem::PayInternetItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPayInternetItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPayInternetItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPayInternetItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPayInternetItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPayInternetItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPayInternetItem::PayInternetItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPayInternetItem::__sizePayInternetItem; i++)
			if (soap_out_PointerTons1__PayInternetItem(soap, "ns1:PayInternetItem", -1, a->ns1__ArrayOfPayInternetItem::PayInternetItem + i, "ns1:PayInternetItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPayInternetItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPayInternetItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPayInternetItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPayInternetItem(struct soap *soap, const char *tag, ns1__ArrayOfPayInternetItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPayInternetItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPayInternetItem, sizeof(ns1__ArrayOfPayInternetItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPayInternetItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPayInternetItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PayInternetItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PayInternetItem", 1, NULL))
			{	if (a->ns1__ArrayOfPayInternetItem::PayInternetItem == NULL)
				{	if (soap_blist_PayInternetItem1 == NULL)
						soap_blist_PayInternetItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPayInternetItem::PayInternetItem = (ns1__PayInternetItem **)soap_push_block(soap, soap_blist_PayInternetItem1, sizeof(ns1__PayInternetItem *));
					if (a->ns1__ArrayOfPayInternetItem::PayInternetItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPayInternetItem::PayInternetItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PayInternetItem(soap, "ns1:PayInternetItem", a->ns1__ArrayOfPayInternetItem::PayInternetItem, "ns1:PayInternetItem"))
				{	a->ns1__ArrayOfPayInternetItem::__sizePayInternetItem++;
					a->ns1__ArrayOfPayInternetItem::PayInternetItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPayInternetItem::PayInternetItem)
			soap_pop_block(soap, soap_blist_PayInternetItem1);
		if (a->ns1__ArrayOfPayInternetItem::__sizePayInternetItem)
			a->ns1__ArrayOfPayInternetItem::PayInternetItem = (ns1__PayInternetItem **)soap_save_block(soap, soap_blist_PayInternetItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPayInternetItem::PayInternetItem = NULL;
			if (soap_blist_PayInternetItem1)
				soap_end_block(soap, soap_blist_PayInternetItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPayInternetItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPayInternetItem, 0, sizeof(ns1__ArrayOfPayInternetItem), 0, soap_copy_ns1__ArrayOfPayInternetItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPayInternetItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPayInternetItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPayInternetItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPayInternetItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPayInternetItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPayInternetItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPayInternetItem(struct soap *soap, ns1__ArrayOfPayInternetItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPayInternetItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPayInternetItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPayInternetItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPayInternetItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPayInternetItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayInternetItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPayInternetItem);
		((ns1__ArrayOfPayInternetItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayInternetItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPayInternetItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPayInternetItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPayInternetItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPayInternetItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPayInternetItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPayInternetItem*)p = *(ns1__ArrayOfPayInternetItem*)q;
}

void ns1__TransStaticsItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__TransStaticsItem::transName);
	soap_default_int(soap, &this->ns1__TransStaticsItem::count);
	soap_default_double(soap, &this->ns1__TransStaticsItem::totalPay);
	soap_default_double(soap, &this->ns1__TransStaticsItem::totalCharge);
	soap_default_double(soap, &this->ns1__TransStaticsItem::totalReturn);
	/* transient soap skipped */
}

void ns1__TransStaticsItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__TransStaticsItem::transName);
	/* transient soap skipped */
}

int ns1__TransStaticsItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TransStaticsItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TransStaticsItem(struct soap *soap, const char *tag, int id, const ns1__TransStaticsItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TransStaticsItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:transName", -1, &(a->ns1__TransStaticsItem::transName), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:count", -1, &(a->ns1__TransStaticsItem::count), "xsd:int"))
		return soap->error;
	if (soap_out_double(soap, "ns1:totalPay", -1, &(a->ns1__TransStaticsItem::totalPay), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:totalCharge", -1, &(a->ns1__TransStaticsItem::totalCharge), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:totalReturn", -1, &(a->ns1__TransStaticsItem::totalReturn), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TransStaticsItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TransStaticsItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TransStaticsItem * SOAP_FMAC4 soap_in_ns1__TransStaticsItem(struct soap *soap, const char *tag, ns1__TransStaticsItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TransStaticsItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TransStaticsItem, sizeof(ns1__TransStaticsItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TransStaticsItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TransStaticsItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_transName1 = 1;
	size_t soap_flag_count1 = 1;
	size_t soap_flag_totalPay1 = 1;
	size_t soap_flag_totalCharge1 = 1;
	size_t soap_flag_totalReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:transName", &(a->ns1__TransStaticsItem::transName), "xsd:string"))
				{	soap_flag_transName1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:count", &(a->ns1__TransStaticsItem::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			if (soap_flag_totalPay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:totalPay", &(a->ns1__TransStaticsItem::totalPay), "xsd:double"))
				{	soap_flag_totalPay1--;
					continue;
				}
			if (soap_flag_totalCharge1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:totalCharge", &(a->ns1__TransStaticsItem::totalCharge), "xsd:double"))
				{	soap_flag_totalCharge1--;
					continue;
				}
			if (soap_flag_totalReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:totalReturn", &(a->ns1__TransStaticsItem::totalReturn), "xsd:double"))
				{	soap_flag_totalReturn1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TransStaticsItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TransStaticsItem, 0, sizeof(ns1__TransStaticsItem), 0, soap_copy_ns1__TransStaticsItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_count1 > 0 || soap_flag_totalPay1 > 0 || soap_flag_totalCharge1 > 0 || soap_flag_totalReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TransStaticsItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TransStaticsItem);
	if (this->soap_out(soap, tag?tag:"ns1:TransStaticsItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TransStaticsItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TransStaticsItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TransStaticsItem * SOAP_FMAC4 soap_get_ns1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TransStaticsItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TransStaticsItem * SOAP_FMAC2 soap_instantiate_ns1__TransStaticsItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TransStaticsItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TransStaticsItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TransStaticsItem);
		if (size)
			*size = sizeof(ns1__TransStaticsItem);
		((ns1__TransStaticsItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TransStaticsItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TransStaticsItem);
		for (int i = 0; i < n; i++)
			((ns1__TransStaticsItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TransStaticsItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TransStaticsItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TransStaticsItem %p -> %p\n", q, p));
	*(ns1__TransStaticsItem*)p = *(ns1__TransStaticsItem*)q;
}

void ns1__ArrayOfTransStaticsItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfTransStaticsItem::__sizeTransStaticsItem = 0;
	this->ns1__ArrayOfTransStaticsItem::TransStaticsItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfTransStaticsItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfTransStaticsItem::TransStaticsItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfTransStaticsItem::__sizeTransStaticsItem; i++)
		{
			soap_serialize_PointerTons1__TransStaticsItem(soap, this->ns1__ArrayOfTransStaticsItem::TransStaticsItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfTransStaticsItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfTransStaticsItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTransStaticsItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfTransStaticsItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTransStaticsItem), type))
		return soap->error;
	if (a->ns1__ArrayOfTransStaticsItem::TransStaticsItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfTransStaticsItem::__sizeTransStaticsItem; i++)
			if (soap_out_PointerTons1__TransStaticsItem(soap, "ns1:TransStaticsItem", -1, a->ns1__ArrayOfTransStaticsItem::TransStaticsItem + i, "ns1:TransStaticsItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfTransStaticsItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfTransStaticsItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfTransStaticsItem * SOAP_FMAC4 soap_in_ns1__ArrayOfTransStaticsItem(struct soap *soap, const char *tag, ns1__ArrayOfTransStaticsItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfTransStaticsItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTransStaticsItem, sizeof(ns1__ArrayOfTransStaticsItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfTransStaticsItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfTransStaticsItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_TransStaticsItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:TransStaticsItem", 1, NULL))
			{	if (a->ns1__ArrayOfTransStaticsItem::TransStaticsItem == NULL)
				{	if (soap_blist_TransStaticsItem1 == NULL)
						soap_blist_TransStaticsItem1 = soap_new_block(soap);
					a->ns1__ArrayOfTransStaticsItem::TransStaticsItem = (ns1__TransStaticsItem **)soap_push_block(soap, soap_blist_TransStaticsItem1, sizeof(ns1__TransStaticsItem *));
					if (a->ns1__ArrayOfTransStaticsItem::TransStaticsItem == NULL)
						return NULL;
					*a->ns1__ArrayOfTransStaticsItem::TransStaticsItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__TransStaticsItem(soap, "ns1:TransStaticsItem", a->ns1__ArrayOfTransStaticsItem::TransStaticsItem, "ns1:TransStaticsItem"))
				{	a->ns1__ArrayOfTransStaticsItem::__sizeTransStaticsItem++;
					a->ns1__ArrayOfTransStaticsItem::TransStaticsItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfTransStaticsItem::TransStaticsItem)
			soap_pop_block(soap, soap_blist_TransStaticsItem1);
		if (a->ns1__ArrayOfTransStaticsItem::__sizeTransStaticsItem)
			a->ns1__ArrayOfTransStaticsItem::TransStaticsItem = (ns1__TransStaticsItem **)soap_save_block(soap, soap_blist_TransStaticsItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfTransStaticsItem::TransStaticsItem = NULL;
			if (soap_blist_TransStaticsItem1)
				soap_end_block(soap, soap_blist_TransStaticsItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfTransStaticsItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTransStaticsItem, 0, sizeof(ns1__ArrayOfTransStaticsItem), 0, soap_copy_ns1__ArrayOfTransStaticsItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfTransStaticsItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTransStaticsItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfTransStaticsItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfTransStaticsItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfTransStaticsItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfTransStaticsItem * SOAP_FMAC4 soap_get_ns1__ArrayOfTransStaticsItem(struct soap *soap, ns1__ArrayOfTransStaticsItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTransStaticsItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfTransStaticsItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfTransStaticsItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfTransStaticsItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfTransStaticsItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfTransStaticsItem);
		if (size)
			*size = sizeof(ns1__ArrayOfTransStaticsItem);
		((ns1__ArrayOfTransStaticsItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfTransStaticsItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfTransStaticsItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfTransStaticsItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfTransStaticsItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfTransStaticsItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfTransStaticsItem %p -> %p\n", q, p));
	*(ns1__ArrayOfTransStaticsItem*)p = *(ns1__ArrayOfTransStaticsItem*)q;
}

void ns1__Transaction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__Transaction::Id);
	soap_default_ns2__guid(soap, &this->ns1__Transaction::userId);
	soap_default_string(soap, &this->ns1__Transaction::name);
	soap_default_string(soap, &this->ns1__Transaction::type);
	soap_default_string(soap, &this->ns1__Transaction::phoneNo);
	soap_default_double(soap, &this->ns1__Transaction::accountBefore);
	soap_default_double(soap, &this->ns1__Transaction::processMoney);
	soap_default_double(soap, &this->ns1__Transaction::returnMoney);
	soap_default_double(soap, &this->ns1__Transaction::accountAfter);
	soap_default_time(soap, &this->ns1__Transaction::processTime);
	soap_default_string(soap, &this->ns1__Transaction::state);
	/* transient soap skipped */
}

void ns1__Transaction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__Transaction::Id);
	soap_serialize_ns2__guid(soap, &this->ns1__Transaction::userId);
	soap_serialize_string(soap, &this->ns1__Transaction::name);
	soap_serialize_string(soap, &this->ns1__Transaction::type);
	soap_serialize_string(soap, &this->ns1__Transaction::phoneNo);
	soap_serialize_string(soap, &this->ns1__Transaction::state);
	/* transient soap skipped */
}

int ns1__Transaction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Transaction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Transaction(struct soap *soap, const char *tag, int id, const ns1__Transaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Transaction), type))
		return soap->error;
	if (a->ns1__Transaction::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__Transaction::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (a->ns1__Transaction::userId)
	{	if (soap_out_ns2__guid(soap, "ns1:userId", -1, &a->ns1__Transaction::userId, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:userId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->ns1__Transaction::name), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->ns1__Transaction::type), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:phoneNo", -1, &(a->ns1__Transaction::phoneNo), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:accountBefore", -1, &(a->ns1__Transaction::accountBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:processMoney", -1, &(a->ns1__Transaction::processMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:returnMoney", -1, &(a->ns1__Transaction::returnMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:accountAfter", -1, &(a->ns1__Transaction::accountAfter), "xsd:double"))
		return soap->error;
	if (soap_out_time(soap, "ns1:processTime", -1, &(a->ns1__Transaction::processTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__Transaction::state), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Transaction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Transaction(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Transaction * SOAP_FMAC4 soap_in_ns1__Transaction(struct soap *soap, const char *tag, ns1__Transaction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Transaction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Transaction, sizeof(ns1__Transaction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Transaction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Transaction *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_phoneNo1 = 1;
	size_t soap_flag_accountBefore1 = 1;
	size_t soap_flag_processMoney1 = 1;
	size_t soap_flag_returnMoney1 = 1;
	size_t soap_flag_accountAfter1 = 1;
	size_t soap_flag_processTime1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__Transaction::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:userId", &(a->ns1__Transaction::userId), "ns2:guid"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->ns1__Transaction::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->ns1__Transaction::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_phoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:phoneNo", &(a->ns1__Transaction::phoneNo), "xsd:string"))
				{	soap_flag_phoneNo1--;
					continue;
				}
			if (soap_flag_accountBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:accountBefore", &(a->ns1__Transaction::accountBefore), "xsd:double"))
				{	soap_flag_accountBefore1--;
					continue;
				}
			if (soap_flag_processMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:processMoney", &(a->ns1__Transaction::processMoney), "xsd:double"))
				{	soap_flag_processMoney1--;
					continue;
				}
			if (soap_flag_returnMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:returnMoney", &(a->ns1__Transaction::returnMoney), "xsd:double"))
				{	soap_flag_returnMoney1--;
					continue;
				}
			if (soap_flag_accountAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:accountAfter", &(a->ns1__Transaction::accountAfter), "xsd:double"))
				{	soap_flag_accountAfter1--;
					continue;
				}
			if (soap_flag_processTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:processTime", &(a->ns1__Transaction::processTime), "xsd:dateTime"))
				{	soap_flag_processTime1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__Transaction::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Transaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Transaction, 0, sizeof(ns1__Transaction), 0, soap_copy_ns1__Transaction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_userId1 > 0 || soap_flag_accountBefore1 > 0 || soap_flag_processMoney1 > 0 || soap_flag_returnMoney1 > 0 || soap_flag_accountAfter1 > 0 || soap_flag_processTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Transaction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Transaction);
	if (this->soap_out(soap, tag?tag:"ns1:Transaction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Transaction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Transaction(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Transaction * SOAP_FMAC4 soap_get_ns1__Transaction(struct soap *soap, ns1__Transaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Transaction * SOAP_FMAC2 soap_instantiate_ns1__Transaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Transaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Transaction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Transaction);
		if (size)
			*size = sizeof(ns1__Transaction);
		((ns1__Transaction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Transaction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Transaction);
		for (int i = 0; i < n; i++)
			((ns1__Transaction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Transaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Transaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Transaction %p -> %p\n", q, p));
	*(ns1__Transaction*)p = *(ns1__Transaction*)q;
}

void ns1__ArrayOfTransaction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfTransaction::__sizeTransaction = 0;
	this->ns1__ArrayOfTransaction::Transaction = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfTransaction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfTransaction::Transaction)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfTransaction::__sizeTransaction; i++)
		{
			soap_serialize_PointerTons1__Transaction(soap, this->ns1__ArrayOfTransaction::Transaction + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfTransaction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfTransaction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTransaction(struct soap *soap, const char *tag, int id, const ns1__ArrayOfTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTransaction), type))
		return soap->error;
	if (a->ns1__ArrayOfTransaction::Transaction)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfTransaction::__sizeTransaction; i++)
			if (soap_out_PointerTons1__Transaction(soap, "ns1:Transaction", -1, a->ns1__ArrayOfTransaction::Transaction + i, "ns1:Transaction"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfTransaction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfTransaction(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfTransaction * SOAP_FMAC4 soap_in_ns1__ArrayOfTransaction(struct soap *soap, const char *tag, ns1__ArrayOfTransaction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfTransaction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTransaction, sizeof(ns1__ArrayOfTransaction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfTransaction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfTransaction *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Transaction1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Transaction", 1, NULL))
			{	if (a->ns1__ArrayOfTransaction::Transaction == NULL)
				{	if (soap_blist_Transaction1 == NULL)
						soap_blist_Transaction1 = soap_new_block(soap);
					a->ns1__ArrayOfTransaction::Transaction = (ns1__Transaction **)soap_push_block(soap, soap_blist_Transaction1, sizeof(ns1__Transaction *));
					if (a->ns1__ArrayOfTransaction::Transaction == NULL)
						return NULL;
					*a->ns1__ArrayOfTransaction::Transaction = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Transaction(soap, "ns1:Transaction", a->ns1__ArrayOfTransaction::Transaction, "ns1:Transaction"))
				{	a->ns1__ArrayOfTransaction::__sizeTransaction++;
					a->ns1__ArrayOfTransaction::Transaction = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfTransaction::Transaction)
			soap_pop_block(soap, soap_blist_Transaction1);
		if (a->ns1__ArrayOfTransaction::__sizeTransaction)
			a->ns1__ArrayOfTransaction::Transaction = (ns1__Transaction **)soap_save_block(soap, soap_blist_Transaction1, NULL, 1);
		else
		{	a->ns1__ArrayOfTransaction::Transaction = NULL;
			if (soap_blist_Transaction1)
				soap_end_block(soap, soap_blist_Transaction1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTransaction, 0, sizeof(ns1__ArrayOfTransaction), 0, soap_copy_ns1__ArrayOfTransaction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfTransaction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTransaction);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfTransaction", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfTransaction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfTransaction(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfTransaction * SOAP_FMAC4 soap_get_ns1__ArrayOfTransaction(struct soap *soap, ns1__ArrayOfTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfTransaction * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfTransaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfTransaction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfTransaction);
		if (size)
			*size = sizeof(ns1__ArrayOfTransaction);
		((ns1__ArrayOfTransaction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfTransaction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfTransaction);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfTransaction*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfTransaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfTransaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfTransaction %p -> %p\n", q, p));
	*(ns1__ArrayOfTransaction*)p = *(ns1__ArrayOfTransaction*)q;
}

void ns1__PaymentItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__guid(soap, &this->ns1__PaymentItem::Id);
	soap_default_string(soap, &this->ns1__PaymentItem::customerName);
	soap_default_double(soap, &this->ns1__PaymentItem::customerBeforeMoney);
	soap_default_double(soap, &this->ns1__PaymentItem::customerAfterMoney);
	soap_default_string(soap, &this->ns1__PaymentItem::clientType);
	soap_default_string(soap, &this->ns1__PaymentItem::telNo);
	soap_default_double(soap, &this->ns1__PaymentItem::chargeMoney);
	soap_default_time(soap, &this->ns1__PaymentItem::chargeTime);
	soap_default_string(soap, &this->ns1__PaymentItem::NoLocation);
	soap_default_double(soap, &this->ns1__PaymentItem::moneyBefore);
	soap_default_double(soap, &this->ns1__PaymentItem::moneyAfter);
	soap_default_string(soap, &this->ns1__PaymentItem::state);
	soap_default_string(soap, &this->ns1__PaymentItem::brand);
	soap_default_string(soap, &this->ns1__PaymentItem::area);
	soap_default_string(soap, &this->ns1__PaymentItem::user_USCOREid);
	soap_default_string(soap, &this->ns1__PaymentItem::user_USCOREname);
	soap_default_string(soap, &this->ns1__PaymentItem::work_USCOREid);
	soap_default_string(soap, &this->ns1__PaymentItem::work_USCOREname);
	soap_default_string(soap, &this->ns1__PaymentItem::manager_USCOREname);
	soap_default_double(soap, &this->ns1__PaymentItem::repay);
	soap_default_string(soap, &this->ns1__PaymentItem::SP);
	/* transient soap skipped */
}

void ns1__PaymentItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__guid(soap, &this->ns1__PaymentItem::Id);
	soap_serialize_string(soap, &this->ns1__PaymentItem::customerName);
	soap_serialize_string(soap, &this->ns1__PaymentItem::clientType);
	soap_serialize_string(soap, &this->ns1__PaymentItem::telNo);
	soap_serialize_string(soap, &this->ns1__PaymentItem::NoLocation);
	soap_serialize_string(soap, &this->ns1__PaymentItem::state);
	soap_serialize_string(soap, &this->ns1__PaymentItem::brand);
	soap_serialize_string(soap, &this->ns1__PaymentItem::area);
	soap_serialize_string(soap, &this->ns1__PaymentItem::user_USCOREid);
	soap_serialize_string(soap, &this->ns1__PaymentItem::user_USCOREname);
	soap_serialize_string(soap, &this->ns1__PaymentItem::work_USCOREid);
	soap_serialize_string(soap, &this->ns1__PaymentItem::work_USCOREname);
	soap_serialize_string(soap, &this->ns1__PaymentItem::manager_USCOREname);
	soap_serialize_string(soap, &this->ns1__PaymentItem::SP);
	/* transient soap skipped */
}

int ns1__PaymentItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PaymentItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PaymentItem(struct soap *soap, const char *tag, int id, const ns1__PaymentItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PaymentItem), type))
		return soap->error;
	if (a->ns1__PaymentItem::Id)
	{	if (soap_out_ns2__guid(soap, "ns1:Id", -1, &a->ns1__PaymentItem::Id, "ns2:guid"))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Id"))
		return soap->error;
	if (soap_out_string(soap, "ns1:customerName", -1, &(a->ns1__PaymentItem::customerName), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerBeforeMoney", -1, &(a->ns1__PaymentItem::customerBeforeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:customerAfterMoney", -1, &(a->ns1__PaymentItem::customerAfterMoney), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, &(a->ns1__PaymentItem::clientType), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:telNo", -1, &(a->ns1__PaymentItem::telNo), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:chargeMoney", -1, &(a->ns1__PaymentItem::chargeMoney), "xsd:double"))
		return soap->error;
	if (soap_out_time(soap, "ns1:chargeTime", -1, &(a->ns1__PaymentItem::chargeTime), "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "ns1:NoLocation", -1, &(a->ns1__PaymentItem::NoLocation), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyBefore", -1, &(a->ns1__PaymentItem::moneyBefore), "xsd:double"))
		return soap->error;
	if (soap_out_double(soap, "ns1:moneyAfter", -1, &(a->ns1__PaymentItem::moneyAfter), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:state", -1, &(a->ns1__PaymentItem::state), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:brand", -1, &(a->ns1__PaymentItem::brand), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:area", -1, &(a->ns1__PaymentItem::area), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:user_id", -1, &(a->ns1__PaymentItem::user_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:user_name", -1, &(a->ns1__PaymentItem::user_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_id", -1, &(a->ns1__PaymentItem::work_USCOREid), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:work_name", -1, &(a->ns1__PaymentItem::work_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ns1:manager_name", -1, &(a->ns1__PaymentItem::manager_USCOREname), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:repay", -1, &(a->ns1__PaymentItem::repay), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:SP", -1, &(a->ns1__PaymentItem::SP), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PaymentItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PaymentItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PaymentItem * SOAP_FMAC4 soap_in_ns1__PaymentItem(struct soap *soap, const char *tag, ns1__PaymentItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PaymentItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PaymentItem, sizeof(ns1__PaymentItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PaymentItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PaymentItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_customerName1 = 1;
	size_t soap_flag_customerBeforeMoney1 = 1;
	size_t soap_flag_customerAfterMoney1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_telNo1 = 1;
	size_t soap_flag_chargeMoney1 = 1;
	size_t soap_flag_chargeTime1 = 1;
	size_t soap_flag_NoLocation1 = 1;
	size_t soap_flag_moneyBefore1 = 1;
	size_t soap_flag_moneyAfter1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_brand1 = 1;
	size_t soap_flag_area1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	size_t soap_flag_user_USCOREname1 = 1;
	size_t soap_flag_work_USCOREid1 = 1;
	size_t soap_flag_work_USCOREname1 = 1;
	size_t soap_flag_manager_USCOREname1 = 1;
	size_t soap_flag_repay1 = 1;
	size_t soap_flag_SP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__guid(soap, "ns1:Id", &(a->ns1__PaymentItem::Id), "ns2:guid"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_customerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:customerName", &(a->ns1__PaymentItem::customerName), "xsd:string"))
				{	soap_flag_customerName1--;
					continue;
				}
			if (soap_flag_customerBeforeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerBeforeMoney", &(a->ns1__PaymentItem::customerBeforeMoney), "xsd:double"))
				{	soap_flag_customerBeforeMoney1--;
					continue;
				}
			if (soap_flag_customerAfterMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:customerAfterMoney", &(a->ns1__PaymentItem::customerAfterMoney), "xsd:double"))
				{	soap_flag_customerAfterMoney1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", &(a->ns1__PaymentItem::clientType), "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_telNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:telNo", &(a->ns1__PaymentItem::telNo), "xsd:string"))
				{	soap_flag_telNo1--;
					continue;
				}
			if (soap_flag_chargeMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:chargeMoney", &(a->ns1__PaymentItem::chargeMoney), "xsd:double"))
				{	soap_flag_chargeMoney1--;
					continue;
				}
			if (soap_flag_chargeTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:chargeTime", &(a->ns1__PaymentItem::chargeTime), "xsd:dateTime"))
				{	soap_flag_chargeTime1--;
					continue;
				}
			if (soap_flag_NoLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NoLocation", &(a->ns1__PaymentItem::NoLocation), "xsd:string"))
				{	soap_flag_NoLocation1--;
					continue;
				}
			if (soap_flag_moneyBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyBefore", &(a->ns1__PaymentItem::moneyBefore), "xsd:double"))
				{	soap_flag_moneyBefore1--;
					continue;
				}
			if (soap_flag_moneyAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:moneyAfter", &(a->ns1__PaymentItem::moneyAfter), "xsd:double"))
				{	soap_flag_moneyAfter1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:state", &(a->ns1__PaymentItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_brand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:brand", &(a->ns1__PaymentItem::brand), "xsd:string"))
				{	soap_flag_brand1--;
					continue;
				}
			if (soap_flag_area1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:area", &(a->ns1__PaymentItem::area), "xsd:string"))
				{	soap_flag_area1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:user_id", &(a->ns1__PaymentItem::user_USCOREid), "xsd:string"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			if (soap_flag_user_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:user_name", &(a->ns1__PaymentItem::user_USCOREname), "xsd:string"))
				{	soap_flag_user_USCOREname1--;
					continue;
				}
			if (soap_flag_work_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_id", &(a->ns1__PaymentItem::work_USCOREid), "xsd:string"))
				{	soap_flag_work_USCOREid1--;
					continue;
				}
			if (soap_flag_work_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:work_name", &(a->ns1__PaymentItem::work_USCOREname), "xsd:string"))
				{	soap_flag_work_USCOREname1--;
					continue;
				}
			if (soap_flag_manager_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:manager_name", &(a->ns1__PaymentItem::manager_USCOREname), "xsd:string"))
				{	soap_flag_manager_USCOREname1--;
					continue;
				}
			if (soap_flag_repay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:repay", &(a->ns1__PaymentItem::repay), "xsd:double"))
				{	soap_flag_repay1--;
					continue;
				}
			if (soap_flag_SP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SP", &(a->ns1__PaymentItem::SP), "xsd:string"))
				{	soap_flag_SP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PaymentItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PaymentItem, 0, sizeof(ns1__PaymentItem), 0, soap_copy_ns1__PaymentItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_customerBeforeMoney1 > 0 || soap_flag_customerAfterMoney1 > 0 || soap_flag_chargeMoney1 > 0 || soap_flag_chargeTime1 > 0 || soap_flag_moneyBefore1 > 0 || soap_flag_moneyAfter1 > 0 || soap_flag_repay1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PaymentItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PaymentItem);
	if (this->soap_out(soap, tag?tag:"ns1:PaymentItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PaymentItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PaymentItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PaymentItem * SOAP_FMAC4 soap_get_ns1__PaymentItem(struct soap *soap, ns1__PaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PaymentItem * SOAP_FMAC2 soap_instantiate_ns1__PaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PaymentItem);
		if (size)
			*size = sizeof(ns1__PaymentItem);
		((ns1__PaymentItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PaymentItem);
		for (int i = 0; i < n; i++)
			((ns1__PaymentItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PaymentItem %p -> %p\n", q, p));
	*(ns1__PaymentItem*)p = *(ns1__PaymentItem*)q;
}

void ns1__ArrayOfPaymentItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPaymentItem::__sizePaymentItem = 0;
	this->ns1__ArrayOfPaymentItem::PaymentItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPaymentItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPaymentItem::PaymentItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPaymentItem::__sizePaymentItem; i++)
		{
			soap_serialize_PointerTons1__PaymentItem(soap, this->ns1__ArrayOfPaymentItem::PaymentItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPaymentItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPaymentItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPaymentItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPaymentItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPaymentItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPaymentItem::PaymentItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPaymentItem::__sizePaymentItem; i++)
			if (soap_out_PointerTons1__PaymentItem(soap, "ns1:PaymentItem", -1, a->ns1__ArrayOfPaymentItem::PaymentItem + i, "ns1:PaymentItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPaymentItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPaymentItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPaymentItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPaymentItem(struct soap *soap, const char *tag, ns1__ArrayOfPaymentItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPaymentItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPaymentItem, sizeof(ns1__ArrayOfPaymentItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPaymentItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPaymentItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PaymentItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PaymentItem", 1, NULL))
			{	if (a->ns1__ArrayOfPaymentItem::PaymentItem == NULL)
				{	if (soap_blist_PaymentItem1 == NULL)
						soap_blist_PaymentItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPaymentItem::PaymentItem = (ns1__PaymentItem **)soap_push_block(soap, soap_blist_PaymentItem1, sizeof(ns1__PaymentItem *));
					if (a->ns1__ArrayOfPaymentItem::PaymentItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPaymentItem::PaymentItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PaymentItem(soap, "ns1:PaymentItem", a->ns1__ArrayOfPaymentItem::PaymentItem, "ns1:PaymentItem"))
				{	a->ns1__ArrayOfPaymentItem::__sizePaymentItem++;
					a->ns1__ArrayOfPaymentItem::PaymentItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPaymentItem::PaymentItem)
			soap_pop_block(soap, soap_blist_PaymentItem1);
		if (a->ns1__ArrayOfPaymentItem::__sizePaymentItem)
			a->ns1__ArrayOfPaymentItem::PaymentItem = (ns1__PaymentItem **)soap_save_block(soap, soap_blist_PaymentItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPaymentItem::PaymentItem = NULL;
			if (soap_blist_PaymentItem1)
				soap_end_block(soap, soap_blist_PaymentItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPaymentItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPaymentItem, 0, sizeof(ns1__ArrayOfPaymentItem), 0, soap_copy_ns1__ArrayOfPaymentItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPaymentItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPaymentItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPaymentItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPaymentItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPaymentItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPaymentItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPaymentItem(struct soap *soap, ns1__ArrayOfPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPaymentItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPaymentItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPaymentItem);
		((ns1__ArrayOfPaymentItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPaymentItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPaymentItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPaymentItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPaymentItem*)p = *(ns1__ArrayOfPaymentItem*)q;
}

void ns1__PayWithListItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__PayWithListItem::phoneNo);
	soap_default_double(soap, &this->ns1__PayWithListItem::money);
	soap_default_string(soap, &this->ns1__PayWithListItem::type);
	/* transient soap skipped */
}

void ns1__PayWithListItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__PayWithListItem::phoneNo);
	soap_serialize_string(soap, &this->ns1__PayWithListItem::type);
	/* transient soap skipped */
}

int ns1__PayWithListItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayWithListItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayWithListItem(struct soap *soap, const char *tag, int id, const ns1__PayWithListItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayWithListItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:phoneNo", -1, &(a->ns1__PayWithListItem::phoneNo), "xsd:string"))
		return soap->error;
	if (soap_out_double(soap, "ns1:money", -1, &(a->ns1__PayWithListItem::money), "xsd:double"))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, &(a->ns1__PayWithListItem::type), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayWithListItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayWithListItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayWithListItem * SOAP_FMAC4 soap_in_ns1__PayWithListItem(struct soap *soap, const char *tag, ns1__PayWithListItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayWithListItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayWithListItem, sizeof(ns1__PayWithListItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayWithListItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayWithListItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_phoneNo1 = 1;
	size_t soap_flag_money1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_phoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:phoneNo", &(a->ns1__PayWithListItem::phoneNo), "xsd:string"))
				{	soap_flag_phoneNo1--;
					continue;
				}
			if (soap_flag_money1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:money", &(a->ns1__PayWithListItem::money), "xsd:double"))
				{	soap_flag_money1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &(a->ns1__PayWithListItem::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayWithListItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayWithListItem, 0, sizeof(ns1__PayWithListItem), 0, soap_copy_ns1__PayWithListItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_money1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayWithListItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayWithListItem);
	if (this->soap_out(soap, tag?tag:"ns1:PayWithListItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayWithListItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayWithListItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayWithListItem * SOAP_FMAC4 soap_get_ns1__PayWithListItem(struct soap *soap, ns1__PayWithListItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayWithListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayWithListItem * SOAP_FMAC2 soap_instantiate_ns1__PayWithListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayWithListItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayWithListItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayWithListItem);
		if (size)
			*size = sizeof(ns1__PayWithListItem);
		((ns1__PayWithListItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayWithListItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayWithListItem);
		for (int i = 0; i < n; i++)
			((ns1__PayWithListItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayWithListItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayWithListItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayWithListItem %p -> %p\n", q, p));
	*(ns1__PayWithListItem*)p = *(ns1__PayWithListItem*)q;
}

void ns1__ArrayOfPayWithListItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPayWithListItem::__sizePayWithListItem = 0;
	this->ns1__ArrayOfPayWithListItem::PayWithListItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPayWithListItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPayWithListItem::PayWithListItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPayWithListItem::__sizePayWithListItem; i++)
		{
			soap_serialize_PointerTons1__PayWithListItem(soap, this->ns1__ArrayOfPayWithListItem::PayWithListItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPayWithListItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPayWithListItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPayWithListItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPayWithListItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPayWithListItem), type))
		return soap->error;
	if (a->ns1__ArrayOfPayWithListItem::PayWithListItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPayWithListItem::__sizePayWithListItem; i++)
			if (soap_out_PointerTons1__PayWithListItem(soap, "ns1:PayWithListItem", -1, a->ns1__ArrayOfPayWithListItem::PayWithListItem + i, "ns1:PayWithListItem"))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPayWithListItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPayWithListItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPayWithListItem * SOAP_FMAC4 soap_in_ns1__ArrayOfPayWithListItem(struct soap *soap, const char *tag, ns1__ArrayOfPayWithListItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPayWithListItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPayWithListItem, sizeof(ns1__ArrayOfPayWithListItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPayWithListItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPayWithListItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_PayWithListItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PayWithListItem", 1, NULL))
			{	if (a->ns1__ArrayOfPayWithListItem::PayWithListItem == NULL)
				{	if (soap_blist_PayWithListItem1 == NULL)
						soap_blist_PayWithListItem1 = soap_new_block(soap);
					a->ns1__ArrayOfPayWithListItem::PayWithListItem = (ns1__PayWithListItem **)soap_push_block(soap, soap_blist_PayWithListItem1, sizeof(ns1__PayWithListItem *));
					if (a->ns1__ArrayOfPayWithListItem::PayWithListItem == NULL)
						return NULL;
					*a->ns1__ArrayOfPayWithListItem::PayWithListItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PayWithListItem(soap, "ns1:PayWithListItem", a->ns1__ArrayOfPayWithListItem::PayWithListItem, "ns1:PayWithListItem"))
				{	a->ns1__ArrayOfPayWithListItem::__sizePayWithListItem++;
					a->ns1__ArrayOfPayWithListItem::PayWithListItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPayWithListItem::PayWithListItem)
			soap_pop_block(soap, soap_blist_PayWithListItem1);
		if (a->ns1__ArrayOfPayWithListItem::__sizePayWithListItem)
			a->ns1__ArrayOfPayWithListItem::PayWithListItem = (ns1__PayWithListItem **)soap_save_block(soap, soap_blist_PayWithListItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfPayWithListItem::PayWithListItem = NULL;
			if (soap_blist_PayWithListItem1)
				soap_end_block(soap, soap_blist_PayWithListItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPayWithListItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPayWithListItem, 0, sizeof(ns1__ArrayOfPayWithListItem), 0, soap_copy_ns1__ArrayOfPayWithListItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPayWithListItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPayWithListItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPayWithListItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPayWithListItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPayWithListItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPayWithListItem * SOAP_FMAC4 soap_get_ns1__ArrayOfPayWithListItem(struct soap *soap, ns1__ArrayOfPayWithListItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPayWithListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPayWithListItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPayWithListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPayWithListItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPayWithListItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayWithListItem);
		if (size)
			*size = sizeof(ns1__ArrayOfPayWithListItem);
		((ns1__ArrayOfPayWithListItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPayWithListItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPayWithListItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPayWithListItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPayWithListItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPayWithListItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPayWithListItem %p -> %p\n", q, p));
	*(ns1__ArrayOfPayWithListItem*)p = *(ns1__ArrayOfPayWithListItem*)q;
}

void ns1__PayWithListResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__PayWithListResult::result);
	soap_default_int(soap, &this->ns1__PayWithListResult::count);
	soap_default_int(soap, &this->ns1__PayWithListResult::successCount);
	soap_default_int(soap, &this->ns1__PayWithListResult::failedCount);
	this->ns1__PayWithListResult::list = NULL;
	soap_default_double(soap, &this->ns1__PayWithListResult::totalMoney);
	/* transient soap skipped */
}

void ns1__PayWithListResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__PayWithListResult::result);
	soap_serialize_PointerTons1__ArrayOfPayWithListItem(soap, &this->ns1__PayWithListResult::list);
	/* transient soap skipped */
}

int ns1__PayWithListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PayWithListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PayWithListResult(struct soap *soap, const char *tag, int id, const ns1__PayWithListResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PayWithListResult), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:result", -1, &(a->ns1__PayWithListResult::result), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "ns1:count", -1, &(a->ns1__PayWithListResult::count), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:successCount", -1, &(a->ns1__PayWithListResult::successCount), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "ns1:failedCount", -1, &(a->ns1__PayWithListResult::failedCount), "xsd:int"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPayWithListItem(soap, "ns1:list", -1, &(a->ns1__PayWithListResult::list), "ns1:ArrayOfPayWithListItem"))
		return soap->error;
	if (soap_out_double(soap, "ns1:totalMoney", -1, &(a->ns1__PayWithListResult::totalMoney), "xsd:double"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PayWithListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PayWithListResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PayWithListResult * SOAP_FMAC4 soap_in_ns1__PayWithListResult(struct soap *soap, const char *tag, ns1__PayWithListResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PayWithListResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PayWithListResult, sizeof(ns1__PayWithListResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PayWithListResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PayWithListResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_count1 = 1;
	size_t soap_flag_successCount1 = 1;
	size_t soap_flag_failedCount1 = 1;
	size_t soap_flag_list1 = 1;
	size_t soap_flag_totalMoney1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:result", &(a->ns1__PayWithListResult::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:count", &(a->ns1__PayWithListResult::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			if (soap_flag_successCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:successCount", &(a->ns1__PayWithListResult::successCount), "xsd:int"))
				{	soap_flag_successCount1--;
					continue;
				}
			if (soap_flag_failedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:failedCount", &(a->ns1__PayWithListResult::failedCount), "xsd:int"))
				{	soap_flag_failedCount1--;
					continue;
				}
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPayWithListItem(soap, "ns1:list", &(a->ns1__PayWithListResult::list), "ns1:ArrayOfPayWithListItem"))
				{	soap_flag_list1--;
					continue;
				}
			if (soap_flag_totalMoney1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:totalMoney", &(a->ns1__PayWithListResult::totalMoney), "xsd:double"))
				{	soap_flag_totalMoney1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PayWithListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PayWithListResult, 0, sizeof(ns1__PayWithListResult), 0, soap_copy_ns1__PayWithListResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_count1 > 0 || soap_flag_successCount1 > 0 || soap_flag_failedCount1 > 0 || soap_flag_totalMoney1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PayWithListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PayWithListResult);
	if (this->soap_out(soap, tag?tag:"ns1:PayWithListResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PayWithListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PayWithListResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PayWithListResult * SOAP_FMAC4 soap_get_ns1__PayWithListResult(struct soap *soap, ns1__PayWithListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PayWithListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PayWithListResult * SOAP_FMAC2 soap_instantiate_ns1__PayWithListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PayWithListResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PayWithListResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayWithListResult);
		if (size)
			*size = sizeof(ns1__PayWithListResult);
		((ns1__PayWithListResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PayWithListResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PayWithListResult);
		for (int i = 0; i < n; i++)
			((ns1__PayWithListResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PayWithListResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PayWithListResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PayWithListResult %p -> %p\n", q, p));
	*(ns1__PayWithListResult*)p = *(ns1__PayWithListResult*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__queryPhoneNOInfo(struct soap *soap, struct __ns9__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPhoneNOInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__queryPhoneNOInfo(struct soap *soap, const struct __ns9__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPhoneNOInfo(soap, &a->ns1__queryPhoneNOInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns9__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, const struct __ns9__queryPhoneNOInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", -1, &a->ns1__queryPhoneNOInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__queryPhoneNOInfo * SOAP_FMAC4 soap_in___ns9__queryPhoneNOInfo(struct soap *soap, const char *tag, struct __ns9__queryPhoneNOInfo *a, const char *type)
{
	size_t soap_flag_ns1__queryPhoneNOInfo = 1;
	short soap_flag;
	a = (struct __ns9__queryPhoneNOInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__queryPhoneNOInfo, sizeof(struct __ns9__queryPhoneNOInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns9__queryPhoneNOInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPhoneNOInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", &a->ns1__queryPhoneNOInfo, ""))
				{	soap_flag_ns1__queryPhoneNOInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__queryPhoneNOInfo(struct soap *soap, const struct __ns9__queryPhoneNOInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns9__queryPhoneNOInfo(soap, tag?tag:"-ns9:queryPhoneNOInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__queryPhoneNOInfo * SOAP_FMAC4 soap_get___ns9__queryPhoneNOInfo(struct soap *soap, struct __ns9__queryPhoneNOInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns9__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__queryPhoneNOInfo * SOAP_FMAC2 soap_instantiate___ns9__queryPhoneNOInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__queryPhoneNOInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__queryPhoneNOInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns9__queryPhoneNOInfo);
		if (size)
			*size = sizeof(struct __ns9__queryPhoneNOInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns9__queryPhoneNOInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns9__queryPhoneNOInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__queryPhoneNOInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__queryPhoneNOInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__queryPhoneNOInfo %p -> %p\n", q, p));
	*(struct __ns9__queryPhoneNOInfo*)p = *(struct __ns9__queryPhoneNOInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetClientVersion(struct soap *soap, struct __ns8__GetClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetClientVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetClientVersion(struct soap *soap, const struct __ns8__GetClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetClientVersion(soap, &a->ns1__GetClientVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetClientVersion(struct soap *soap, const char *tag, int id, const struct __ns8__GetClientVersion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetClientVersion(soap, "ns1:GetClientVersion", -1, &a->ns1__GetClientVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetClientVersion * SOAP_FMAC4 soap_in___ns8__GetClientVersion(struct soap *soap, const char *tag, struct __ns8__GetClientVersion *a, const char *type)
{
	size_t soap_flag_ns1__GetClientVersion = 1;
	short soap_flag;
	a = (struct __ns8__GetClientVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetClientVersion, sizeof(struct __ns8__GetClientVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetClientVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetClientVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetClientVersion(soap, "ns1:GetClientVersion", &a->ns1__GetClientVersion, ""))
				{	soap_flag_ns1__GetClientVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetClientVersion(struct soap *soap, const struct __ns8__GetClientVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetClientVersion(soap, tag?tag:"-ns8:GetClientVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetClientVersion * SOAP_FMAC4 soap_get___ns8__GetClientVersion(struct soap *soap, struct __ns8__GetClientVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetClientVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetClientVersion * SOAP_FMAC2 soap_instantiate___ns8__GetClientVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetClientVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetClientVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetClientVersion);
		if (size)
			*size = sizeof(struct __ns8__GetClientVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetClientVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetClientVersion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetClientVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetClientVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetClientVersion %p -> %p\n", q, p));
	*(struct __ns8__GetClientVersion*)p = *(struct __ns8__GetClientVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__DeleteCompanyAccount(struct soap *soap, struct __ns8__DeleteCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__DeleteCompanyAccount(struct soap *soap, const struct __ns8__DeleteCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteCompanyAccount(soap, &a->ns1__DeleteCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__DeleteCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns8__DeleteCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteCompanyAccount(soap, "ns1:DeleteCompanyAccount", -1, &a->ns1__DeleteCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteCompanyAccount * SOAP_FMAC4 soap_in___ns8__DeleteCompanyAccount(struct soap *soap, const char *tag, struct __ns8__DeleteCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__DeleteCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns8__DeleteCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__DeleteCompanyAccount, sizeof(struct __ns8__DeleteCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__DeleteCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteCompanyAccount(soap, "ns1:DeleteCompanyAccount", &a->ns1__DeleteCompanyAccount, ""))
				{	soap_flag_ns1__DeleteCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__DeleteCompanyAccount(struct soap *soap, const struct __ns8__DeleteCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__DeleteCompanyAccount(soap, tag?tag:"-ns8:DeleteCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteCompanyAccount * SOAP_FMAC4 soap_get___ns8__DeleteCompanyAccount(struct soap *soap, struct __ns8__DeleteCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__DeleteCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__DeleteCompanyAccount * SOAP_FMAC2 soap_instantiate___ns8__DeleteCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__DeleteCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__DeleteCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteCompanyAccount);
		if (size)
			*size = sizeof(struct __ns8__DeleteCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__DeleteCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__DeleteCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__DeleteCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__DeleteCompanyAccount %p -> %p\n", q, p));
	*(struct __ns8__DeleteCompanyAccount*)p = *(struct __ns8__DeleteCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateCompanyAccount(struct soap *soap, struct __ns8__UpdateCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateCompanyAccount(struct soap *soap, const struct __ns8__UpdateCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateCompanyAccount(soap, &a->ns1__UpdateCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateCompanyAccount(soap, "ns1:UpdateCompanyAccount", -1, &a->ns1__UpdateCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateCompanyAccount * SOAP_FMAC4 soap_in___ns8__UpdateCompanyAccount(struct soap *soap, const char *tag, struct __ns8__UpdateCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__UpdateCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns8__UpdateCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateCompanyAccount, sizeof(struct __ns8__UpdateCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateCompanyAccount(soap, "ns1:UpdateCompanyAccount", &a->ns1__UpdateCompanyAccount, ""))
				{	soap_flag_ns1__UpdateCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateCompanyAccount(struct soap *soap, const struct __ns8__UpdateCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateCompanyAccount(soap, tag?tag:"-ns8:UpdateCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateCompanyAccount * SOAP_FMAC4 soap_get___ns8__UpdateCompanyAccount(struct soap *soap, struct __ns8__UpdateCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateCompanyAccount * SOAP_FMAC2 soap_instantiate___ns8__UpdateCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateCompanyAccount);
		if (size)
			*size = sizeof(struct __ns8__UpdateCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateCompanyAccount %p -> %p\n", q, p));
	*(struct __ns8__UpdateCompanyAccount*)p = *(struct __ns8__UpdateCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AddCompanyAccount(struct soap *soap, struct __ns8__AddCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AddCompanyAccount(struct soap *soap, const struct __ns8__AddCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddCompanyAccount(soap, &a->ns1__AddCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AddCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns8__AddCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddCompanyAccount(soap, "ns1:AddCompanyAccount", -1, &a->ns1__AddCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddCompanyAccount * SOAP_FMAC4 soap_in___ns8__AddCompanyAccount(struct soap *soap, const char *tag, struct __ns8__AddCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__AddCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns8__AddCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AddCompanyAccount, sizeof(struct __ns8__AddCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AddCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddCompanyAccount(soap, "ns1:AddCompanyAccount", &a->ns1__AddCompanyAccount, ""))
				{	soap_flag_ns1__AddCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AddCompanyAccount(struct soap *soap, const struct __ns8__AddCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__AddCompanyAccount(soap, tag?tag:"-ns8:AddCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddCompanyAccount * SOAP_FMAC4 soap_get___ns8__AddCompanyAccount(struct soap *soap, struct __ns8__AddCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AddCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__AddCompanyAccount * SOAP_FMAC2 soap_instantiate___ns8__AddCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__AddCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__AddCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddCompanyAccount);
		if (size)
			*size = sizeof(struct __ns8__AddCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__AddCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__AddCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__AddCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__AddCompanyAccount %p -> %p\n", q, p));
	*(struct __ns8__AddCompanyAccount*)p = *(struct __ns8__AddCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetCompanyAccount(struct soap *soap, struct __ns8__GetCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetCompanyAccount(struct soap *soap, const struct __ns8__GetCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCompanyAccount(soap, &a->ns1__GetCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns8__GetCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCompanyAccount(soap, "ns1:GetCompanyAccount", -1, &a->ns1__GetCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetCompanyAccount * SOAP_FMAC4 soap_in___ns8__GetCompanyAccount(struct soap *soap, const char *tag, struct __ns8__GetCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__GetCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns8__GetCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetCompanyAccount, sizeof(struct __ns8__GetCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCompanyAccount(soap, "ns1:GetCompanyAccount", &a->ns1__GetCompanyAccount, ""))
				{	soap_flag_ns1__GetCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetCompanyAccount(struct soap *soap, const struct __ns8__GetCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetCompanyAccount(soap, tag?tag:"-ns8:GetCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetCompanyAccount * SOAP_FMAC4 soap_get___ns8__GetCompanyAccount(struct soap *soap, struct __ns8__GetCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetCompanyAccount * SOAP_FMAC2 soap_instantiate___ns8__GetCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetCompanyAccount);
		if (size)
			*size = sizeof(struct __ns8__GetCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetCompanyAccount %p -> %p\n", q, p));
	*(struct __ns8__GetCompanyAccount*)p = *(struct __ns8__GetCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateCompanyInfo(struct soap *soap, struct __ns8__UpdateCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateCompanyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateCompanyInfo(struct soap *soap, const struct __ns8__UpdateCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateCompanyInfo(soap, &a->ns1__UpdateCompanyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateCompanyInfo(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateCompanyInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateCompanyInfo(soap, "ns1:UpdateCompanyInfo", -1, &a->ns1__UpdateCompanyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateCompanyInfo * SOAP_FMAC4 soap_in___ns8__UpdateCompanyInfo(struct soap *soap, const char *tag, struct __ns8__UpdateCompanyInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdateCompanyInfo = 1;
	short soap_flag;
	a = (struct __ns8__UpdateCompanyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateCompanyInfo, sizeof(struct __ns8__UpdateCompanyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateCompanyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateCompanyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateCompanyInfo(soap, "ns1:UpdateCompanyInfo", &a->ns1__UpdateCompanyInfo, ""))
				{	soap_flag_ns1__UpdateCompanyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateCompanyInfo(struct soap *soap, const struct __ns8__UpdateCompanyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateCompanyInfo(soap, tag?tag:"-ns8:UpdateCompanyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateCompanyInfo * SOAP_FMAC4 soap_get___ns8__UpdateCompanyInfo(struct soap *soap, struct __ns8__UpdateCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateCompanyInfo * SOAP_FMAC2 soap_instantiate___ns8__UpdateCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateCompanyInfo);
		if (size)
			*size = sizeof(struct __ns8__UpdateCompanyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateCompanyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateCompanyInfo %p -> %p\n", q, p));
	*(struct __ns8__UpdateCompanyInfo*)p = *(struct __ns8__UpdateCompanyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetCompanyInfo(struct soap *soap, struct __ns8__GetCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCompanyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetCompanyInfo(struct soap *soap, const struct __ns8__GetCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCompanyInfo(soap, &a->ns1__GetCompanyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetCompanyInfo(struct soap *soap, const char *tag, int id, const struct __ns8__GetCompanyInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCompanyInfo(soap, "ns1:GetCompanyInfo", -1, &a->ns1__GetCompanyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetCompanyInfo * SOAP_FMAC4 soap_in___ns8__GetCompanyInfo(struct soap *soap, const char *tag, struct __ns8__GetCompanyInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetCompanyInfo = 1;
	short soap_flag;
	a = (struct __ns8__GetCompanyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetCompanyInfo, sizeof(struct __ns8__GetCompanyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetCompanyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCompanyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCompanyInfo(soap, "ns1:GetCompanyInfo", &a->ns1__GetCompanyInfo, ""))
				{	soap_flag_ns1__GetCompanyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetCompanyInfo(struct soap *soap, const struct __ns8__GetCompanyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetCompanyInfo(soap, tag?tag:"-ns8:GetCompanyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetCompanyInfo * SOAP_FMAC4 soap_get___ns8__GetCompanyInfo(struct soap *soap, struct __ns8__GetCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetCompanyInfo * SOAP_FMAC2 soap_instantiate___ns8__GetCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetCompanyInfo);
		if (size)
			*size = sizeof(struct __ns8__GetCompanyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetCompanyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetCompanyInfo %p -> %p\n", q, p));
	*(struct __ns8__GetCompanyInfo*)p = *(struct __ns8__GetCompanyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__DeletePhoneNumberBelong(struct soap *soap, struct __ns8__DeletePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeletePhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__DeletePhoneNumberBelong(struct soap *soap, const struct __ns8__DeletePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeletePhoneNumberBelong(soap, &a->ns1__DeletePhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__DeletePhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns8__DeletePhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeletePhoneNumberBelong(soap, "ns1:DeletePhoneNumberBelong", -1, &a->ns1__DeletePhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeletePhoneNumberBelong * SOAP_FMAC4 soap_in___ns8__DeletePhoneNumberBelong(struct soap *soap, const char *tag, struct __ns8__DeletePhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__DeletePhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns8__DeletePhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__DeletePhoneNumberBelong, sizeof(struct __ns8__DeletePhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__DeletePhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeletePhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeletePhoneNumberBelong(soap, "ns1:DeletePhoneNumberBelong", &a->ns1__DeletePhoneNumberBelong, ""))
				{	soap_flag_ns1__DeletePhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__DeletePhoneNumberBelong(struct soap *soap, const struct __ns8__DeletePhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__DeletePhoneNumberBelong(soap, tag?tag:"-ns8:DeletePhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeletePhoneNumberBelong * SOAP_FMAC4 soap_get___ns8__DeletePhoneNumberBelong(struct soap *soap, struct __ns8__DeletePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__DeletePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__DeletePhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns8__DeletePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__DeletePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__DeletePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeletePhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns8__DeletePhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeletePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__DeletePhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__DeletePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__DeletePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__DeletePhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns8__DeletePhoneNumberBelong*)p = *(struct __ns8__DeletePhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AddPhoneNumberBelong(struct soap *soap, struct __ns8__AddPhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AddPhoneNumberBelong(struct soap *soap, const struct __ns8__AddPhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPhoneNumberBelong(soap, &a->ns1__AddPhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AddPhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns8__AddPhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPhoneNumberBelong(soap, "ns1:AddPhoneNumberBelong", -1, &a->ns1__AddPhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddPhoneNumberBelong * SOAP_FMAC4 soap_in___ns8__AddPhoneNumberBelong(struct soap *soap, const char *tag, struct __ns8__AddPhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__AddPhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns8__AddPhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AddPhoneNumberBelong, sizeof(struct __ns8__AddPhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AddPhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPhoneNumberBelong(soap, "ns1:AddPhoneNumberBelong", &a->ns1__AddPhoneNumberBelong, ""))
				{	soap_flag_ns1__AddPhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AddPhoneNumberBelong(struct soap *soap, const struct __ns8__AddPhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__AddPhoneNumberBelong(soap, tag?tag:"-ns8:AddPhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddPhoneNumberBelong * SOAP_FMAC4 soap_get___ns8__AddPhoneNumberBelong(struct soap *soap, struct __ns8__AddPhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AddPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__AddPhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns8__AddPhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__AddPhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__AddPhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddPhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns8__AddPhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddPhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__AddPhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__AddPhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__AddPhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__AddPhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns8__AddPhoneNumberBelong*)p = *(struct __ns8__AddPhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdatePhoneNumberBelong(struct soap *soap, struct __ns8__UpdatePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdatePhoneNumberBelong(struct soap *soap, const struct __ns8__UpdatePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelong(soap, &a->ns1__UpdatePhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns8__UpdatePhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdatePhoneNumberBelong(soap, "ns1:UpdatePhoneNumberBelong", -1, &a->ns1__UpdatePhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_in___ns8__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, struct __ns8__UpdatePhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns8__UpdatePhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdatePhoneNumberBelong, sizeof(struct __ns8__UpdatePhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdatePhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePhoneNumberBelong(soap, "ns1:UpdatePhoneNumberBelong", &a->ns1__UpdatePhoneNumberBelong, ""))
				{	soap_flag_ns1__UpdatePhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdatePhoneNumberBelong(struct soap *soap, const struct __ns8__UpdatePhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdatePhoneNumberBelong(soap, tag?tag:"-ns8:UpdatePhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_get___ns8__UpdatePhoneNumberBelong(struct soap *soap, struct __ns8__UpdatePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdatePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdatePhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns8__UpdatePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdatePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdatePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdatePhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns8__UpdatePhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdatePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdatePhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdatePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdatePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdatePhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns8__UpdatePhoneNumberBelong*)p = *(struct __ns8__UpdatePhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, struct __ns8__GetPhoneNumberBelongByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNumberBelongByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, const struct __ns8__GetPhoneNumberBelongByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, &a->ns1__GetPhoneNumberBelongByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, int id, const struct __ns8__GetPhoneNumberBelongByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, "ns1:GetPhoneNumberBelongByCondition", -1, &a->ns1__GetPhoneNumberBelongByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_in___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, struct __ns8__GetPhoneNumberBelongByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNumberBelongByCondition = 1;
	short soap_flag;
	a = (struct __ns8__GetPhoneNumberBelongByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetPhoneNumberBelongByCondition, sizeof(struct __ns8__GetPhoneNumberBelongByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetPhoneNumberBelongByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNumberBelongByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, "ns1:GetPhoneNumberBelongByCondition", &a->ns1__GetPhoneNumberBelongByCondition, ""))
				{	soap_flag_ns1__GetPhoneNumberBelongByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, const struct __ns8__GetPhoneNumberBelongByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetPhoneNumberBelongByCondition(soap, tag?tag:"-ns8:GetPhoneNumberBelongByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_get___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, struct __ns8__GetPhoneNumberBelongByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetPhoneNumberBelongByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetPhoneNumberBelongByCondition * SOAP_FMAC2 soap_instantiate___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetPhoneNumberBelongByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetPhoneNumberBelongByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetPhoneNumberBelongByCondition);
		if (size)
			*size = sizeof(struct __ns8__GetPhoneNumberBelongByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetPhoneNumberBelongByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetPhoneNumberBelongByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetPhoneNumberBelongByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetPhoneNumberBelongByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetPhoneNumberBelongByCondition %p -> %p\n", q, p));
	*(struct __ns8__GetPhoneNumberBelongByCondition*)p = *(struct __ns8__GetPhoneNumberBelongByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__DeletetReturnProportion(struct soap *soap, struct __ns8__DeletetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeletetReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__DeletetReturnProportion(struct soap *soap, const struct __ns8__DeletetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeletetReturnProportion(soap, &a->ns1__DeletetReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__DeletetReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns8__DeletetReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeletetReturnProportion(soap, "ns1:DeletetReturnProportion", -1, &a->ns1__DeletetReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeletetReturnProportion * SOAP_FMAC4 soap_in___ns8__DeletetReturnProportion(struct soap *soap, const char *tag, struct __ns8__DeletetReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__DeletetReturnProportion = 1;
	short soap_flag;
	a = (struct __ns8__DeletetReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__DeletetReturnProportion, sizeof(struct __ns8__DeletetReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__DeletetReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeletetReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeletetReturnProportion(soap, "ns1:DeletetReturnProportion", &a->ns1__DeletetReturnProportion, ""))
				{	soap_flag_ns1__DeletetReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__DeletetReturnProportion(struct soap *soap, const struct __ns8__DeletetReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__DeletetReturnProportion(soap, tag?tag:"-ns8:DeletetReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeletetReturnProportion * SOAP_FMAC4 soap_get___ns8__DeletetReturnProportion(struct soap *soap, struct __ns8__DeletetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__DeletetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__DeletetReturnProportion * SOAP_FMAC2 soap_instantiate___ns8__DeletetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__DeletetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__DeletetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeletetReturnProportion);
		if (size)
			*size = sizeof(struct __ns8__DeletetReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeletetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__DeletetReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__DeletetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__DeletetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__DeletetReturnProportion %p -> %p\n", q, p));
	*(struct __ns8__DeletetReturnProportion*)p = *(struct __ns8__DeletetReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdatetReturnProportion(struct soap *soap, struct __ns8__UpdatetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatetReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdatetReturnProportion(struct soap *soap, const struct __ns8__UpdatetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatetReturnProportion(soap, &a->ns1__UpdatetReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdatetReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns8__UpdatetReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdatetReturnProportion(soap, "ns1:UpdatetReturnProportion", -1, &a->ns1__UpdatetReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdatetReturnProportion * SOAP_FMAC4 soap_in___ns8__UpdatetReturnProportion(struct soap *soap, const char *tag, struct __ns8__UpdatetReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__UpdatetReturnProportion = 1;
	short soap_flag;
	a = (struct __ns8__UpdatetReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdatetReturnProportion, sizeof(struct __ns8__UpdatetReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdatetReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatetReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatetReturnProportion(soap, "ns1:UpdatetReturnProportion", &a->ns1__UpdatetReturnProportion, ""))
				{	soap_flag_ns1__UpdatetReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdatetReturnProportion(struct soap *soap, const struct __ns8__UpdatetReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdatetReturnProportion(soap, tag?tag:"-ns8:UpdatetReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdatetReturnProportion * SOAP_FMAC4 soap_get___ns8__UpdatetReturnProportion(struct soap *soap, struct __ns8__UpdatetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdatetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdatetReturnProportion * SOAP_FMAC2 soap_instantiate___ns8__UpdatetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdatetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdatetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdatetReturnProportion);
		if (size)
			*size = sizeof(struct __ns8__UpdatetReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdatetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdatetReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdatetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdatetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdatetReturnProportion %p -> %p\n", q, p));
	*(struct __ns8__UpdatetReturnProportion*)p = *(struct __ns8__UpdatetReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AddtReturnProportion(struct soap *soap, struct __ns8__AddtReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddtReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AddtReturnProportion(struct soap *soap, const struct __ns8__AddtReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddtReturnProportion(soap, &a->ns1__AddtReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AddtReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns8__AddtReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddtReturnProportion(soap, "ns1:AddtReturnProportion", -1, &a->ns1__AddtReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddtReturnProportion * SOAP_FMAC4 soap_in___ns8__AddtReturnProportion(struct soap *soap, const char *tag, struct __ns8__AddtReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__AddtReturnProportion = 1;
	short soap_flag;
	a = (struct __ns8__AddtReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AddtReturnProportion, sizeof(struct __ns8__AddtReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AddtReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddtReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddtReturnProportion(soap, "ns1:AddtReturnProportion", &a->ns1__AddtReturnProportion, ""))
				{	soap_flag_ns1__AddtReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AddtReturnProportion(struct soap *soap, const struct __ns8__AddtReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__AddtReturnProportion(soap, tag?tag:"-ns8:AddtReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddtReturnProportion * SOAP_FMAC4 soap_get___ns8__AddtReturnProportion(struct soap *soap, struct __ns8__AddtReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AddtReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__AddtReturnProportion * SOAP_FMAC2 soap_instantiate___ns8__AddtReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__AddtReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__AddtReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddtReturnProportion);
		if (size)
			*size = sizeof(struct __ns8__AddtReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddtReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__AddtReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__AddtReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__AddtReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__AddtReturnProportion %p -> %p\n", q, p));
	*(struct __ns8__AddtReturnProportion*)p = *(struct __ns8__AddtReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetReturnProportionRecord(struct soap *soap, struct __ns8__GetReturnProportionRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnProportionRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetReturnProportionRecord(struct soap *soap, const struct __ns8__GetReturnProportionRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnProportionRecord(soap, &a->ns1__GetReturnProportionRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetReturnProportionRecord(struct soap *soap, const char *tag, int id, const struct __ns8__GetReturnProportionRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnProportionRecord(soap, "ns1:GetReturnProportionRecord", -1, &a->ns1__GetReturnProportionRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetReturnProportionRecord * SOAP_FMAC4 soap_in___ns8__GetReturnProportionRecord(struct soap *soap, const char *tag, struct __ns8__GetReturnProportionRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnProportionRecord = 1;
	short soap_flag;
	a = (struct __ns8__GetReturnProportionRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetReturnProportionRecord, sizeof(struct __ns8__GetReturnProportionRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetReturnProportionRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnProportionRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnProportionRecord(soap, "ns1:GetReturnProportionRecord", &a->ns1__GetReturnProportionRecord, ""))
				{	soap_flag_ns1__GetReturnProportionRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetReturnProportionRecord(struct soap *soap, const struct __ns8__GetReturnProportionRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetReturnProportionRecord(soap, tag?tag:"-ns8:GetReturnProportionRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetReturnProportionRecord * SOAP_FMAC4 soap_get___ns8__GetReturnProportionRecord(struct soap *soap, struct __ns8__GetReturnProportionRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetReturnProportionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetReturnProportionRecord * SOAP_FMAC2 soap_instantiate___ns8__GetReturnProportionRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetReturnProportionRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetReturnProportionRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetReturnProportionRecord);
		if (size)
			*size = sizeof(struct __ns8__GetReturnProportionRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetReturnProportionRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetReturnProportionRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetReturnProportionRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetReturnProportionRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetReturnProportionRecord %p -> %p\n", q, p));
	*(struct __ns8__GetReturnProportionRecord*)p = *(struct __ns8__GetReturnProportionRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__InserNoticeToSomeOne(struct soap *soap, struct __ns8__InserNoticeToSomeOne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InserNoticeToSomeOne = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__InserNoticeToSomeOne(struct soap *soap, const struct __ns8__InserNoticeToSomeOne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InserNoticeToSomeOne(soap, &a->ns1__InserNoticeToSomeOne);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__InserNoticeToSomeOne(struct soap *soap, const char *tag, int id, const struct __ns8__InserNoticeToSomeOne *a, const char *type)
{
	if (soap_out_PointerTo_ns1__InserNoticeToSomeOne(soap, "ns1:InserNoticeToSomeOne", -1, &a->ns1__InserNoticeToSomeOne, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__InserNoticeToSomeOne * SOAP_FMAC4 soap_in___ns8__InserNoticeToSomeOne(struct soap *soap, const char *tag, struct __ns8__InserNoticeToSomeOne *a, const char *type)
{
	size_t soap_flag_ns1__InserNoticeToSomeOne = 1;
	short soap_flag;
	a = (struct __ns8__InserNoticeToSomeOne *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__InserNoticeToSomeOne, sizeof(struct __ns8__InserNoticeToSomeOne), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__InserNoticeToSomeOne(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InserNoticeToSomeOne && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InserNoticeToSomeOne(soap, "ns1:InserNoticeToSomeOne", &a->ns1__InserNoticeToSomeOne, ""))
				{	soap_flag_ns1__InserNoticeToSomeOne--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__InserNoticeToSomeOne(struct soap *soap, const struct __ns8__InserNoticeToSomeOne *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__InserNoticeToSomeOne(soap, tag?tag:"-ns8:InserNoticeToSomeOne", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__InserNoticeToSomeOne * SOAP_FMAC4 soap_get___ns8__InserNoticeToSomeOne(struct soap *soap, struct __ns8__InserNoticeToSomeOne *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__InserNoticeToSomeOne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__InserNoticeToSomeOne * SOAP_FMAC2 soap_instantiate___ns8__InserNoticeToSomeOne(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__InserNoticeToSomeOne(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__InserNoticeToSomeOne, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__InserNoticeToSomeOne);
		if (size)
			*size = sizeof(struct __ns8__InserNoticeToSomeOne);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__InserNoticeToSomeOne[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__InserNoticeToSomeOne);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__InserNoticeToSomeOne*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__InserNoticeToSomeOne(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__InserNoticeToSomeOne %p -> %p\n", q, p));
	*(struct __ns8__InserNoticeToSomeOne*)p = *(struct __ns8__InserNoticeToSomeOne*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__DeleteNoticeItem(struct soap *soap, struct __ns8__DeleteNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__DeleteNoticeItem(struct soap *soap, const struct __ns8__DeleteNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteNoticeItem(soap, &a->ns1__DeleteNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__DeleteNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns8__DeleteNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteNoticeItem(soap, "ns1:DeleteNoticeItem", -1, &a->ns1__DeleteNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteNoticeItem * SOAP_FMAC4 soap_in___ns8__DeleteNoticeItem(struct soap *soap, const char *tag, struct __ns8__DeleteNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__DeleteNoticeItem = 1;
	short soap_flag;
	a = (struct __ns8__DeleteNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__DeleteNoticeItem, sizeof(struct __ns8__DeleteNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__DeleteNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteNoticeItem(soap, "ns1:DeleteNoticeItem", &a->ns1__DeleteNoticeItem, ""))
				{	soap_flag_ns1__DeleteNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__DeleteNoticeItem(struct soap *soap, const struct __ns8__DeleteNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__DeleteNoticeItem(soap, tag?tag:"-ns8:DeleteNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteNoticeItem * SOAP_FMAC4 soap_get___ns8__DeleteNoticeItem(struct soap *soap, struct __ns8__DeleteNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__DeleteNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__DeleteNoticeItem * SOAP_FMAC2 soap_instantiate___ns8__DeleteNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__DeleteNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__DeleteNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteNoticeItem);
		if (size)
			*size = sizeof(struct __ns8__DeleteNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__DeleteNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__DeleteNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__DeleteNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__DeleteNoticeItem %p -> %p\n", q, p));
	*(struct __ns8__DeleteNoticeItem*)p = *(struct __ns8__DeleteNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateNoticeItem(struct soap *soap, struct __ns8__UpdateNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateNoticeItem(struct soap *soap, const struct __ns8__UpdateNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateNoticeItem(soap, &a->ns1__UpdateNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateNoticeItem(soap, "ns1:UpdateNoticeItem", -1, &a->ns1__UpdateNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateNoticeItem * SOAP_FMAC4 soap_in___ns8__UpdateNoticeItem(struct soap *soap, const char *tag, struct __ns8__UpdateNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__UpdateNoticeItem = 1;
	short soap_flag;
	a = (struct __ns8__UpdateNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateNoticeItem, sizeof(struct __ns8__UpdateNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateNoticeItem(soap, "ns1:UpdateNoticeItem", &a->ns1__UpdateNoticeItem, ""))
				{	soap_flag_ns1__UpdateNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateNoticeItem(struct soap *soap, const struct __ns8__UpdateNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateNoticeItem(soap, tag?tag:"-ns8:UpdateNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateNoticeItem * SOAP_FMAC4 soap_get___ns8__UpdateNoticeItem(struct soap *soap, struct __ns8__UpdateNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateNoticeItem * SOAP_FMAC2 soap_instantiate___ns8__UpdateNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateNoticeItem);
		if (size)
			*size = sizeof(struct __ns8__UpdateNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateNoticeItem %p -> %p\n", q, p));
	*(struct __ns8__UpdateNoticeItem*)p = *(struct __ns8__UpdateNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AddNoticeItemToSomeone(struct soap *soap, struct __ns8__AddNoticeItemToSomeone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddNoticeItemToSomeone = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AddNoticeItemToSomeone(struct soap *soap, const struct __ns8__AddNoticeItemToSomeone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddNoticeItemToSomeone(soap, &a->ns1__AddNoticeItemToSomeone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AddNoticeItemToSomeone(struct soap *soap, const char *tag, int id, const struct __ns8__AddNoticeItemToSomeone *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddNoticeItemToSomeone(soap, "ns1:AddNoticeItemToSomeone", -1, &a->ns1__AddNoticeItemToSomeone, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddNoticeItemToSomeone * SOAP_FMAC4 soap_in___ns8__AddNoticeItemToSomeone(struct soap *soap, const char *tag, struct __ns8__AddNoticeItemToSomeone *a, const char *type)
{
	size_t soap_flag_ns1__AddNoticeItemToSomeone = 1;
	short soap_flag;
	a = (struct __ns8__AddNoticeItemToSomeone *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AddNoticeItemToSomeone, sizeof(struct __ns8__AddNoticeItemToSomeone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AddNoticeItemToSomeone(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddNoticeItemToSomeone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddNoticeItemToSomeone(soap, "ns1:AddNoticeItemToSomeone", &a->ns1__AddNoticeItemToSomeone, ""))
				{	soap_flag_ns1__AddNoticeItemToSomeone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AddNoticeItemToSomeone(struct soap *soap, const struct __ns8__AddNoticeItemToSomeone *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__AddNoticeItemToSomeone(soap, tag?tag:"-ns8:AddNoticeItemToSomeone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddNoticeItemToSomeone * SOAP_FMAC4 soap_get___ns8__AddNoticeItemToSomeone(struct soap *soap, struct __ns8__AddNoticeItemToSomeone *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AddNoticeItemToSomeone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__AddNoticeItemToSomeone * SOAP_FMAC2 soap_instantiate___ns8__AddNoticeItemToSomeone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__AddNoticeItemToSomeone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__AddNoticeItemToSomeone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddNoticeItemToSomeone);
		if (size)
			*size = sizeof(struct __ns8__AddNoticeItemToSomeone);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddNoticeItemToSomeone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__AddNoticeItemToSomeone);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__AddNoticeItemToSomeone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__AddNoticeItemToSomeone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__AddNoticeItemToSomeone %p -> %p\n", q, p));
	*(struct __ns8__AddNoticeItemToSomeone*)p = *(struct __ns8__AddNoticeItemToSomeone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AddNoticeItem(struct soap *soap, struct __ns8__AddNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AddNoticeItem(struct soap *soap, const struct __ns8__AddNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddNoticeItem(soap, &a->ns1__AddNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AddNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns8__AddNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddNoticeItem(soap, "ns1:AddNoticeItem", -1, &a->ns1__AddNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddNoticeItem * SOAP_FMAC4 soap_in___ns8__AddNoticeItem(struct soap *soap, const char *tag, struct __ns8__AddNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__AddNoticeItem = 1;
	short soap_flag;
	a = (struct __ns8__AddNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AddNoticeItem, sizeof(struct __ns8__AddNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AddNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddNoticeItem(soap, "ns1:AddNoticeItem", &a->ns1__AddNoticeItem, ""))
				{	soap_flag_ns1__AddNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AddNoticeItem(struct soap *soap, const struct __ns8__AddNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__AddNoticeItem(soap, tag?tag:"-ns8:AddNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AddNoticeItem * SOAP_FMAC4 soap_get___ns8__AddNoticeItem(struct soap *soap, struct __ns8__AddNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AddNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__AddNoticeItem * SOAP_FMAC2 soap_instantiate___ns8__AddNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__AddNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__AddNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddNoticeItem);
		if (size)
			*size = sizeof(struct __ns8__AddNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__AddNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__AddNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__AddNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__AddNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__AddNoticeItem %p -> %p\n", q, p));
	*(struct __ns8__AddNoticeItem*)p = *(struct __ns8__AddNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetAlertNoticeList(struct soap *soap, struct __ns8__GetAlertNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlertNoticeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetAlertNoticeList(struct soap *soap, const struct __ns8__GetAlertNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlertNoticeList(soap, &a->ns1__GetAlertNoticeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetAlertNoticeList(struct soap *soap, const char *tag, int id, const struct __ns8__GetAlertNoticeList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAlertNoticeList(soap, "ns1:GetAlertNoticeList", -1, &a->ns1__GetAlertNoticeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetAlertNoticeList * SOAP_FMAC4 soap_in___ns8__GetAlertNoticeList(struct soap *soap, const char *tag, struct __ns8__GetAlertNoticeList *a, const char *type)
{
	size_t soap_flag_ns1__GetAlertNoticeList = 1;
	short soap_flag;
	a = (struct __ns8__GetAlertNoticeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetAlertNoticeList, sizeof(struct __ns8__GetAlertNoticeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetAlertNoticeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlertNoticeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlertNoticeList(soap, "ns1:GetAlertNoticeList", &a->ns1__GetAlertNoticeList, ""))
				{	soap_flag_ns1__GetAlertNoticeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetAlertNoticeList(struct soap *soap, const struct __ns8__GetAlertNoticeList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetAlertNoticeList(soap, tag?tag:"-ns8:GetAlertNoticeList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetAlertNoticeList * SOAP_FMAC4 soap_get___ns8__GetAlertNoticeList(struct soap *soap, struct __ns8__GetAlertNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetAlertNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetAlertNoticeList * SOAP_FMAC2 soap_instantiate___ns8__GetAlertNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetAlertNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetAlertNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetAlertNoticeList);
		if (size)
			*size = sizeof(struct __ns8__GetAlertNoticeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetAlertNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetAlertNoticeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetAlertNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetAlertNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetAlertNoticeList %p -> %p\n", q, p));
	*(struct __ns8__GetAlertNoticeList*)p = *(struct __ns8__GetAlertNoticeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetNoticeItem(struct soap *soap, struct __ns8__GetNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetNoticeItem(struct soap *soap, const struct __ns8__GetNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeItem(soap, &a->ns1__GetNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns8__GetNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeItem(soap, "ns1:GetNoticeItem", -1, &a->ns1__GetNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeItem * SOAP_FMAC4 soap_in___ns8__GetNoticeItem(struct soap *soap, const char *tag, struct __ns8__GetNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeItem = 1;
	short soap_flag;
	a = (struct __ns8__GetNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetNoticeItem, sizeof(struct __ns8__GetNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeItem(soap, "ns1:GetNoticeItem", &a->ns1__GetNoticeItem, ""))
				{	soap_flag_ns1__GetNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetNoticeItem(struct soap *soap, const struct __ns8__GetNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetNoticeItem(soap, tag?tag:"-ns8:GetNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeItem * SOAP_FMAC4 soap_get___ns8__GetNoticeItem(struct soap *soap, struct __ns8__GetNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetNoticeItem * SOAP_FMAC2 soap_instantiate___ns8__GetNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeItem);
		if (size)
			*size = sizeof(struct __ns8__GetNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetNoticeItem %p -> %p\n", q, p));
	*(struct __ns8__GetNoticeItem*)p = *(struct __ns8__GetNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetNoticeListByCondition(struct soap *soap, struct __ns8__GetNoticeListByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeListByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetNoticeListByCondition(struct soap *soap, const struct __ns8__GetNoticeListByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeListByCondition(soap, &a->ns1__GetNoticeListByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetNoticeListByCondition(struct soap *soap, const char *tag, int id, const struct __ns8__GetNoticeListByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeListByCondition(soap, "ns1:GetNoticeListByCondition", -1, &a->ns1__GetNoticeListByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeListByCondition * SOAP_FMAC4 soap_in___ns8__GetNoticeListByCondition(struct soap *soap, const char *tag, struct __ns8__GetNoticeListByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeListByCondition = 1;
	short soap_flag;
	a = (struct __ns8__GetNoticeListByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetNoticeListByCondition, sizeof(struct __ns8__GetNoticeListByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetNoticeListByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeListByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeListByCondition(soap, "ns1:GetNoticeListByCondition", &a->ns1__GetNoticeListByCondition, ""))
				{	soap_flag_ns1__GetNoticeListByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetNoticeListByCondition(struct soap *soap, const struct __ns8__GetNoticeListByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetNoticeListByCondition(soap, tag?tag:"-ns8:GetNoticeListByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeListByCondition * SOAP_FMAC4 soap_get___ns8__GetNoticeListByCondition(struct soap *soap, struct __ns8__GetNoticeListByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetNoticeListByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetNoticeListByCondition * SOAP_FMAC2 soap_instantiate___ns8__GetNoticeListByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetNoticeListByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetNoticeListByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeListByCondition);
		if (size)
			*size = sizeof(struct __ns8__GetNoticeListByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeListByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetNoticeListByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetNoticeListByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetNoticeListByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetNoticeListByCondition %p -> %p\n", q, p));
	*(struct __ns8__GetNoticeListByCondition*)p = *(struct __ns8__GetNoticeListByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetNoticeList(struct soap *soap, struct __ns8__GetNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetNoticeList(struct soap *soap, const struct __ns8__GetNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeList(soap, &a->ns1__GetNoticeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetNoticeList(struct soap *soap, const char *tag, int id, const struct __ns8__GetNoticeList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeList(soap, "ns1:GetNoticeList", -1, &a->ns1__GetNoticeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeList * SOAP_FMAC4 soap_in___ns8__GetNoticeList(struct soap *soap, const char *tag, struct __ns8__GetNoticeList *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeList = 1;
	short soap_flag;
	a = (struct __ns8__GetNoticeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetNoticeList, sizeof(struct __ns8__GetNoticeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetNoticeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeList(soap, "ns1:GetNoticeList", &a->ns1__GetNoticeList, ""))
				{	soap_flag_ns1__GetNoticeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetNoticeList(struct soap *soap, const struct __ns8__GetNoticeList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetNoticeList(soap, tag?tag:"-ns8:GetNoticeList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetNoticeList * SOAP_FMAC4 soap_get___ns8__GetNoticeList(struct soap *soap, struct __ns8__GetNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetNoticeList * SOAP_FMAC2 soap_instantiate___ns8__GetNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeList);
		if (size)
			*size = sizeof(struct __ns8__GetNoticeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetNoticeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetNoticeList %p -> %p\n", q, p));
	*(struct __ns8__GetNoticeList*)p = *(struct __ns8__GetNoticeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetTableStatistics(struct soap *soap, struct __ns8__GetTableStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTableStatistics = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetTableStatistics(struct soap *soap, const struct __ns8__GetTableStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTableStatistics(soap, &a->ns1__GetTableStatistics);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetTableStatistics(struct soap *soap, const char *tag, int id, const struct __ns8__GetTableStatistics *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTableStatistics(soap, "ns1:GetTableStatistics", -1, &a->ns1__GetTableStatistics, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetTableStatistics * SOAP_FMAC4 soap_in___ns8__GetTableStatistics(struct soap *soap, const char *tag, struct __ns8__GetTableStatistics *a, const char *type)
{
	size_t soap_flag_ns1__GetTableStatistics = 1;
	short soap_flag;
	a = (struct __ns8__GetTableStatistics *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetTableStatistics, sizeof(struct __ns8__GetTableStatistics), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetTableStatistics(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTableStatistics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTableStatistics(soap, "ns1:GetTableStatistics", &a->ns1__GetTableStatistics, ""))
				{	soap_flag_ns1__GetTableStatistics--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetTableStatistics(struct soap *soap, const struct __ns8__GetTableStatistics *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetTableStatistics(soap, tag?tag:"-ns8:GetTableStatistics", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetTableStatistics * SOAP_FMAC4 soap_get___ns8__GetTableStatistics(struct soap *soap, struct __ns8__GetTableStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetTableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetTableStatistics * SOAP_FMAC2 soap_instantiate___ns8__GetTableStatistics(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetTableStatistics(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetTableStatistics, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetTableStatistics);
		if (size)
			*size = sizeof(struct __ns8__GetTableStatistics);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetTableStatistics[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetTableStatistics);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetTableStatistics*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetTableStatistics(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetTableStatistics %p -> %p\n", q, p));
	*(struct __ns8__GetTableStatistics*)p = *(struct __ns8__GetTableStatistics*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateFunctionRight(struct soap *soap, struct __ns8__UpdateFunctionRight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateFunctionRight = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateFunctionRight(struct soap *soap, const struct __ns8__UpdateFunctionRight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateFunctionRight(soap, &a->ns1__UpdateFunctionRight);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateFunctionRight(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateFunctionRight *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateFunctionRight(soap, "ns1:UpdateFunctionRight", -1, &a->ns1__UpdateFunctionRight, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateFunctionRight * SOAP_FMAC4 soap_in___ns8__UpdateFunctionRight(struct soap *soap, const char *tag, struct __ns8__UpdateFunctionRight *a, const char *type)
{
	size_t soap_flag_ns1__UpdateFunctionRight = 1;
	short soap_flag;
	a = (struct __ns8__UpdateFunctionRight *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateFunctionRight, sizeof(struct __ns8__UpdateFunctionRight), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateFunctionRight(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateFunctionRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateFunctionRight(soap, "ns1:UpdateFunctionRight", &a->ns1__UpdateFunctionRight, ""))
				{	soap_flag_ns1__UpdateFunctionRight--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateFunctionRight(struct soap *soap, const struct __ns8__UpdateFunctionRight *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateFunctionRight(soap, tag?tag:"-ns8:UpdateFunctionRight", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateFunctionRight * SOAP_FMAC4 soap_get___ns8__UpdateFunctionRight(struct soap *soap, struct __ns8__UpdateFunctionRight *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateFunctionRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateFunctionRight * SOAP_FMAC2 soap_instantiate___ns8__UpdateFunctionRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateFunctionRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateFunctionRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateFunctionRight);
		if (size)
			*size = sizeof(struct __ns8__UpdateFunctionRight);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateFunctionRight[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateFunctionRight);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateFunctionRight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateFunctionRight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateFunctionRight %p -> %p\n", q, p));
	*(struct __ns8__UpdateFunctionRight*)p = *(struct __ns8__UpdateFunctionRight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateUserFunctionList(struct soap *soap, struct __ns8__UpdateUserFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateUserFunctionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateUserFunctionList(struct soap *soap, const struct __ns8__UpdateUserFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateUserFunctionList(soap, &a->ns1__UpdateUserFunctionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateUserFunctionList(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateUserFunctionList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateUserFunctionList(soap, "ns1:UpdateUserFunctionList", -1, &a->ns1__UpdateUserFunctionList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateUserFunctionList * SOAP_FMAC4 soap_in___ns8__UpdateUserFunctionList(struct soap *soap, const char *tag, struct __ns8__UpdateUserFunctionList *a, const char *type)
{
	size_t soap_flag_ns1__UpdateUserFunctionList = 1;
	short soap_flag;
	a = (struct __ns8__UpdateUserFunctionList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateUserFunctionList, sizeof(struct __ns8__UpdateUserFunctionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateUserFunctionList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateUserFunctionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateUserFunctionList(soap, "ns1:UpdateUserFunctionList", &a->ns1__UpdateUserFunctionList, ""))
				{	soap_flag_ns1__UpdateUserFunctionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateUserFunctionList(struct soap *soap, const struct __ns8__UpdateUserFunctionList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateUserFunctionList(soap, tag?tag:"-ns8:UpdateUserFunctionList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateUserFunctionList * SOAP_FMAC4 soap_get___ns8__UpdateUserFunctionList(struct soap *soap, struct __ns8__UpdateUserFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateUserFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateUserFunctionList * SOAP_FMAC2 soap_instantiate___ns8__UpdateUserFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateUserFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateUserFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateUserFunctionList);
		if (size)
			*size = sizeof(struct __ns8__UpdateUserFunctionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateUserFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateUserFunctionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateUserFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateUserFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateUserFunctionList %p -> %p\n", q, p));
	*(struct __ns8__UpdateUserFunctionList*)p = *(struct __ns8__UpdateUserFunctionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetFunctionList(struct soap *soap, struct __ns8__GetFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFunctionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetFunctionList(struct soap *soap, const struct __ns8__GetFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetFunctionList(soap, &a->ns1__GetFunctionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetFunctionList(struct soap *soap, const char *tag, int id, const struct __ns8__GetFunctionList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFunctionList(soap, "ns1:GetFunctionList", -1, &a->ns1__GetFunctionList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetFunctionList * SOAP_FMAC4 soap_in___ns8__GetFunctionList(struct soap *soap, const char *tag, struct __ns8__GetFunctionList *a, const char *type)
{
	size_t soap_flag_ns1__GetFunctionList = 1;
	short soap_flag;
	a = (struct __ns8__GetFunctionList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetFunctionList, sizeof(struct __ns8__GetFunctionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetFunctionList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFunctionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetFunctionList(soap, "ns1:GetFunctionList", &a->ns1__GetFunctionList, ""))
				{	soap_flag_ns1__GetFunctionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetFunctionList(struct soap *soap, const struct __ns8__GetFunctionList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetFunctionList(soap, tag?tag:"-ns8:GetFunctionList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetFunctionList * SOAP_FMAC4 soap_get___ns8__GetFunctionList(struct soap *soap, struct __ns8__GetFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetFunctionList * SOAP_FMAC2 soap_instantiate___ns8__GetFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetFunctionList);
		if (size)
			*size = sizeof(struct __ns8__GetFunctionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetFunctionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetFunctionList %p -> %p\n", q, p));
	*(struct __ns8__GetFunctionList*)p = *(struct __ns8__GetFunctionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateDicContentByCategory(struct soap *soap, struct __ns8__UpdateDicContentByCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDicContentByCategory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateDicContentByCategory(struct soap *soap, const struct __ns8__UpdateDicContentByCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateDicContentByCategory(soap, &a->ns1__UpdateDicContentByCategory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateDicContentByCategory(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateDicContentByCategory *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateDicContentByCategory(soap, "ns1:UpdateDicContentByCategory", -1, &a->ns1__UpdateDicContentByCategory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateDicContentByCategory * SOAP_FMAC4 soap_in___ns8__UpdateDicContentByCategory(struct soap *soap, const char *tag, struct __ns8__UpdateDicContentByCategory *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDicContentByCategory = 1;
	short soap_flag;
	a = (struct __ns8__UpdateDicContentByCategory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateDicContentByCategory, sizeof(struct __ns8__UpdateDicContentByCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateDicContentByCategory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDicContentByCategory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDicContentByCategory(soap, "ns1:UpdateDicContentByCategory", &a->ns1__UpdateDicContentByCategory, ""))
				{	soap_flag_ns1__UpdateDicContentByCategory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateDicContentByCategory(struct soap *soap, const struct __ns8__UpdateDicContentByCategory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateDicContentByCategory(soap, tag?tag:"-ns8:UpdateDicContentByCategory", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateDicContentByCategory * SOAP_FMAC4 soap_get___ns8__UpdateDicContentByCategory(struct soap *soap, struct __ns8__UpdateDicContentByCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateDicContentByCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateDicContentByCategory * SOAP_FMAC2 soap_instantiate___ns8__UpdateDicContentByCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateDicContentByCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateDicContentByCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateDicContentByCategory);
		if (size)
			*size = sizeof(struct __ns8__UpdateDicContentByCategory);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateDicContentByCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateDicContentByCategory);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateDicContentByCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateDicContentByCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateDicContentByCategory %p -> %p\n", q, p));
	*(struct __ns8__UpdateDicContentByCategory*)p = *(struct __ns8__UpdateDicContentByCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__DeleteDicContent(struct soap *soap, struct __ns8__DeleteDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__DeleteDicContent(struct soap *soap, const struct __ns8__DeleteDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteDicContent(soap, &a->ns1__DeleteDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__DeleteDicContent(struct soap *soap, const char *tag, int id, const struct __ns8__DeleteDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteDicContent(soap, "ns1:DeleteDicContent", -1, &a->ns1__DeleteDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteDicContent * SOAP_FMAC4 soap_in___ns8__DeleteDicContent(struct soap *soap, const char *tag, struct __ns8__DeleteDicContent *a, const char *type)
{
	size_t soap_flag_ns1__DeleteDicContent = 1;
	short soap_flag;
	a = (struct __ns8__DeleteDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__DeleteDicContent, sizeof(struct __ns8__DeleteDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__DeleteDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteDicContent(soap, "ns1:DeleteDicContent", &a->ns1__DeleteDicContent, ""))
				{	soap_flag_ns1__DeleteDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__DeleteDicContent(struct soap *soap, const struct __ns8__DeleteDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__DeleteDicContent(soap, tag?tag:"-ns8:DeleteDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__DeleteDicContent * SOAP_FMAC4 soap_get___ns8__DeleteDicContent(struct soap *soap, struct __ns8__DeleteDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__DeleteDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__DeleteDicContent * SOAP_FMAC2 soap_instantiate___ns8__DeleteDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__DeleteDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__DeleteDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteDicContent);
		if (size)
			*size = sizeof(struct __ns8__DeleteDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__DeleteDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__DeleteDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__DeleteDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__DeleteDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__DeleteDicContent %p -> %p\n", q, p));
	*(struct __ns8__DeleteDicContent*)p = *(struct __ns8__DeleteDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__UpdateDicContent(struct soap *soap, struct __ns8__UpdateDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__UpdateDicContent(struct soap *soap, const struct __ns8__UpdateDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateDicContent(soap, &a->ns1__UpdateDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__UpdateDicContent(struct soap *soap, const char *tag, int id, const struct __ns8__UpdateDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateDicContent(soap, "ns1:UpdateDicContent", -1, &a->ns1__UpdateDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateDicContent * SOAP_FMAC4 soap_in___ns8__UpdateDicContent(struct soap *soap, const char *tag, struct __ns8__UpdateDicContent *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDicContent = 1;
	short soap_flag;
	a = (struct __ns8__UpdateDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__UpdateDicContent, sizeof(struct __ns8__UpdateDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__UpdateDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDicContent(soap, "ns1:UpdateDicContent", &a->ns1__UpdateDicContent, ""))
				{	soap_flag_ns1__UpdateDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__UpdateDicContent(struct soap *soap, const struct __ns8__UpdateDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__UpdateDicContent(soap, tag?tag:"-ns8:UpdateDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__UpdateDicContent * SOAP_FMAC4 soap_get___ns8__UpdateDicContent(struct soap *soap, struct __ns8__UpdateDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__UpdateDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__UpdateDicContent * SOAP_FMAC2 soap_instantiate___ns8__UpdateDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__UpdateDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__UpdateDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateDicContent);
		if (size)
			*size = sizeof(struct __ns8__UpdateDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__UpdateDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__UpdateDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__UpdateDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__UpdateDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__UpdateDicContent %p -> %p\n", q, p));
	*(struct __ns8__UpdateDicContent*)p = *(struct __ns8__UpdateDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__InsertDicContent(struct soap *soap, struct __ns8__InsertDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsertDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__InsertDicContent(struct soap *soap, const struct __ns8__InsertDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InsertDicContent(soap, &a->ns1__InsertDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__InsertDicContent(struct soap *soap, const char *tag, int id, const struct __ns8__InsertDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__InsertDicContent(soap, "ns1:InsertDicContent", -1, &a->ns1__InsertDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__InsertDicContent * SOAP_FMAC4 soap_in___ns8__InsertDicContent(struct soap *soap, const char *tag, struct __ns8__InsertDicContent *a, const char *type)
{
	size_t soap_flag_ns1__InsertDicContent = 1;
	short soap_flag;
	a = (struct __ns8__InsertDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__InsertDicContent, sizeof(struct __ns8__InsertDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__InsertDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsertDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InsertDicContent(soap, "ns1:InsertDicContent", &a->ns1__InsertDicContent, ""))
				{	soap_flag_ns1__InsertDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__InsertDicContent(struct soap *soap, const struct __ns8__InsertDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__InsertDicContent(soap, tag?tag:"-ns8:InsertDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__InsertDicContent * SOAP_FMAC4 soap_get___ns8__InsertDicContent(struct soap *soap, struct __ns8__InsertDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__InsertDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__InsertDicContent * SOAP_FMAC2 soap_instantiate___ns8__InsertDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__InsertDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__InsertDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__InsertDicContent);
		if (size)
			*size = sizeof(struct __ns8__InsertDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__InsertDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__InsertDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__InsertDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__InsertDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__InsertDicContent %p -> %p\n", q, p));
	*(struct __ns8__InsertDicContent*)p = *(struct __ns8__InsertDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetAllCategory(struct soap *soap, struct __ns8__GetAllCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCategory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetAllCategory(struct soap *soap, const struct __ns8__GetAllCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCategory(soap, &a->ns1__GetAllCategory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetAllCategory(struct soap *soap, const char *tag, int id, const struct __ns8__GetAllCategory *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAllCategory(soap, "ns1:GetAllCategory", -1, &a->ns1__GetAllCategory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetAllCategory * SOAP_FMAC4 soap_in___ns8__GetAllCategory(struct soap *soap, const char *tag, struct __ns8__GetAllCategory *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCategory = 1;
	short soap_flag;
	a = (struct __ns8__GetAllCategory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetAllCategory, sizeof(struct __ns8__GetAllCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetAllCategory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCategory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCategory(soap, "ns1:GetAllCategory", &a->ns1__GetAllCategory, ""))
				{	soap_flag_ns1__GetAllCategory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetAllCategory(struct soap *soap, const struct __ns8__GetAllCategory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetAllCategory(soap, tag?tag:"-ns8:GetAllCategory", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetAllCategory * SOAP_FMAC4 soap_get___ns8__GetAllCategory(struct soap *soap, struct __ns8__GetAllCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetAllCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetAllCategory * SOAP_FMAC2 soap_instantiate___ns8__GetAllCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetAllCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetAllCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetAllCategory);
		if (size)
			*size = sizeof(struct __ns8__GetAllCategory);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetAllCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetAllCategory);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetAllCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetAllCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetAllCategory %p -> %p\n", q, p));
	*(struct __ns8__GetAllCategory*)p = *(struct __ns8__GetAllCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__GetDicContentByCondition(struct soap *soap, struct __ns8__GetDicContentByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDicContentByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__GetDicContentByCondition(struct soap *soap, const struct __ns8__GetDicContentByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDicContentByCondition(soap, &a->ns1__GetDicContentByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__GetDicContentByCondition(struct soap *soap, const char *tag, int id, const struct __ns8__GetDicContentByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDicContentByCondition(soap, "ns1:GetDicContentByCondition", -1, &a->ns1__GetDicContentByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetDicContentByCondition * SOAP_FMAC4 soap_in___ns8__GetDicContentByCondition(struct soap *soap, const char *tag, struct __ns8__GetDicContentByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetDicContentByCondition = 1;
	short soap_flag;
	a = (struct __ns8__GetDicContentByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__GetDicContentByCondition, sizeof(struct __ns8__GetDicContentByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__GetDicContentByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDicContentByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDicContentByCondition(soap, "ns1:GetDicContentByCondition", &a->ns1__GetDicContentByCondition, ""))
				{	soap_flag_ns1__GetDicContentByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__GetDicContentByCondition(struct soap *soap, const struct __ns8__GetDicContentByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__GetDicContentByCondition(soap, tag?tag:"-ns8:GetDicContentByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__GetDicContentByCondition * SOAP_FMAC4 soap_get___ns8__GetDicContentByCondition(struct soap *soap, struct __ns8__GetDicContentByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__GetDicContentByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns8__GetDicContentByCondition * SOAP_FMAC2 soap_instantiate___ns8__GetDicContentByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__GetDicContentByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__GetDicContentByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetDicContentByCondition);
		if (size)
			*size = sizeof(struct __ns8__GetDicContentByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns8__GetDicContentByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns8__GetDicContentByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__GetDicContentByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__GetDicContentByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__GetDicContentByCondition %p -> %p\n", q, p));
	*(struct __ns8__GetDicContentByCondition*)p = *(struct __ns8__GetDicContentByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetClientVersion(struct soap *soap, struct __ns7__GetClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetClientVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetClientVersion(struct soap *soap, const struct __ns7__GetClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetClientVersion(soap, &a->ns1__GetClientVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetClientVersion(struct soap *soap, const char *tag, int id, const struct __ns7__GetClientVersion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetClientVersion(soap, "ns1:GetClientVersion", -1, &a->ns1__GetClientVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetClientVersion * SOAP_FMAC4 soap_in___ns7__GetClientVersion(struct soap *soap, const char *tag, struct __ns7__GetClientVersion *a, const char *type)
{
	size_t soap_flag_ns1__GetClientVersion = 1;
	short soap_flag;
	a = (struct __ns7__GetClientVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetClientVersion, sizeof(struct __ns7__GetClientVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetClientVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetClientVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetClientVersion(soap, "ns1:GetClientVersion", &a->ns1__GetClientVersion, ""))
				{	soap_flag_ns1__GetClientVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetClientVersion(struct soap *soap, const struct __ns7__GetClientVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetClientVersion(soap, tag?tag:"-ns7:GetClientVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetClientVersion * SOAP_FMAC4 soap_get___ns7__GetClientVersion(struct soap *soap, struct __ns7__GetClientVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetClientVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetClientVersion * SOAP_FMAC2 soap_instantiate___ns7__GetClientVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetClientVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetClientVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetClientVersion);
		if (size)
			*size = sizeof(struct __ns7__GetClientVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetClientVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetClientVersion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetClientVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetClientVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetClientVersion %p -> %p\n", q, p));
	*(struct __ns7__GetClientVersion*)p = *(struct __ns7__GetClientVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__DeleteCompanyAccount(struct soap *soap, struct __ns7__DeleteCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__DeleteCompanyAccount(struct soap *soap, const struct __ns7__DeleteCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteCompanyAccount(soap, &a->ns1__DeleteCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__DeleteCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns7__DeleteCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteCompanyAccount(soap, "ns1:DeleteCompanyAccount", -1, &a->ns1__DeleteCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteCompanyAccount * SOAP_FMAC4 soap_in___ns7__DeleteCompanyAccount(struct soap *soap, const char *tag, struct __ns7__DeleteCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__DeleteCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns7__DeleteCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__DeleteCompanyAccount, sizeof(struct __ns7__DeleteCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__DeleteCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteCompanyAccount(soap, "ns1:DeleteCompanyAccount", &a->ns1__DeleteCompanyAccount, ""))
				{	soap_flag_ns1__DeleteCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__DeleteCompanyAccount(struct soap *soap, const struct __ns7__DeleteCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__DeleteCompanyAccount(soap, tag?tag:"-ns7:DeleteCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteCompanyAccount * SOAP_FMAC4 soap_get___ns7__DeleteCompanyAccount(struct soap *soap, struct __ns7__DeleteCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__DeleteCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__DeleteCompanyAccount * SOAP_FMAC2 soap_instantiate___ns7__DeleteCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__DeleteCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__DeleteCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteCompanyAccount);
		if (size)
			*size = sizeof(struct __ns7__DeleteCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__DeleteCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__DeleteCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__DeleteCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__DeleteCompanyAccount %p -> %p\n", q, p));
	*(struct __ns7__DeleteCompanyAccount*)p = *(struct __ns7__DeleteCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateCompanyAccount(struct soap *soap, struct __ns7__UpdateCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateCompanyAccount(struct soap *soap, const struct __ns7__UpdateCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateCompanyAccount(soap, &a->ns1__UpdateCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateCompanyAccount(soap, "ns1:UpdateCompanyAccount", -1, &a->ns1__UpdateCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateCompanyAccount * SOAP_FMAC4 soap_in___ns7__UpdateCompanyAccount(struct soap *soap, const char *tag, struct __ns7__UpdateCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__UpdateCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns7__UpdateCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateCompanyAccount, sizeof(struct __ns7__UpdateCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateCompanyAccount(soap, "ns1:UpdateCompanyAccount", &a->ns1__UpdateCompanyAccount, ""))
				{	soap_flag_ns1__UpdateCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateCompanyAccount(struct soap *soap, const struct __ns7__UpdateCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateCompanyAccount(soap, tag?tag:"-ns7:UpdateCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateCompanyAccount * SOAP_FMAC4 soap_get___ns7__UpdateCompanyAccount(struct soap *soap, struct __ns7__UpdateCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateCompanyAccount * SOAP_FMAC2 soap_instantiate___ns7__UpdateCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateCompanyAccount);
		if (size)
			*size = sizeof(struct __ns7__UpdateCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateCompanyAccount %p -> %p\n", q, p));
	*(struct __ns7__UpdateCompanyAccount*)p = *(struct __ns7__UpdateCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AddCompanyAccount(struct soap *soap, struct __ns7__AddCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AddCompanyAccount(struct soap *soap, const struct __ns7__AddCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddCompanyAccount(soap, &a->ns1__AddCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AddCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns7__AddCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddCompanyAccount(soap, "ns1:AddCompanyAccount", -1, &a->ns1__AddCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddCompanyAccount * SOAP_FMAC4 soap_in___ns7__AddCompanyAccount(struct soap *soap, const char *tag, struct __ns7__AddCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__AddCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns7__AddCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AddCompanyAccount, sizeof(struct __ns7__AddCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AddCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddCompanyAccount(soap, "ns1:AddCompanyAccount", &a->ns1__AddCompanyAccount, ""))
				{	soap_flag_ns1__AddCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AddCompanyAccount(struct soap *soap, const struct __ns7__AddCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AddCompanyAccount(soap, tag?tag:"-ns7:AddCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddCompanyAccount * SOAP_FMAC4 soap_get___ns7__AddCompanyAccount(struct soap *soap, struct __ns7__AddCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AddCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AddCompanyAccount * SOAP_FMAC2 soap_instantiate___ns7__AddCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AddCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AddCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddCompanyAccount);
		if (size)
			*size = sizeof(struct __ns7__AddCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AddCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AddCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AddCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AddCompanyAccount %p -> %p\n", q, p));
	*(struct __ns7__AddCompanyAccount*)p = *(struct __ns7__AddCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetCompanyAccount(struct soap *soap, struct __ns7__GetCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCompanyAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetCompanyAccount(struct soap *soap, const struct __ns7__GetCompanyAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCompanyAccount(soap, &a->ns1__GetCompanyAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetCompanyAccount(struct soap *soap, const char *tag, int id, const struct __ns7__GetCompanyAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCompanyAccount(soap, "ns1:GetCompanyAccount", -1, &a->ns1__GetCompanyAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetCompanyAccount * SOAP_FMAC4 soap_in___ns7__GetCompanyAccount(struct soap *soap, const char *tag, struct __ns7__GetCompanyAccount *a, const char *type)
{
	size_t soap_flag_ns1__GetCompanyAccount = 1;
	short soap_flag;
	a = (struct __ns7__GetCompanyAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetCompanyAccount, sizeof(struct __ns7__GetCompanyAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetCompanyAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCompanyAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCompanyAccount(soap, "ns1:GetCompanyAccount", &a->ns1__GetCompanyAccount, ""))
				{	soap_flag_ns1__GetCompanyAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetCompanyAccount(struct soap *soap, const struct __ns7__GetCompanyAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetCompanyAccount(soap, tag?tag:"-ns7:GetCompanyAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetCompanyAccount * SOAP_FMAC4 soap_get___ns7__GetCompanyAccount(struct soap *soap, struct __ns7__GetCompanyAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetCompanyAccount * SOAP_FMAC2 soap_instantiate___ns7__GetCompanyAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetCompanyAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetCompanyAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetCompanyAccount);
		if (size)
			*size = sizeof(struct __ns7__GetCompanyAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetCompanyAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetCompanyAccount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetCompanyAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetCompanyAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetCompanyAccount %p -> %p\n", q, p));
	*(struct __ns7__GetCompanyAccount*)p = *(struct __ns7__GetCompanyAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateCompanyInfo(struct soap *soap, struct __ns7__UpdateCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateCompanyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateCompanyInfo(struct soap *soap, const struct __ns7__UpdateCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateCompanyInfo(soap, &a->ns1__UpdateCompanyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateCompanyInfo(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateCompanyInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateCompanyInfo(soap, "ns1:UpdateCompanyInfo", -1, &a->ns1__UpdateCompanyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateCompanyInfo * SOAP_FMAC4 soap_in___ns7__UpdateCompanyInfo(struct soap *soap, const char *tag, struct __ns7__UpdateCompanyInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdateCompanyInfo = 1;
	short soap_flag;
	a = (struct __ns7__UpdateCompanyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateCompanyInfo, sizeof(struct __ns7__UpdateCompanyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateCompanyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateCompanyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateCompanyInfo(soap, "ns1:UpdateCompanyInfo", &a->ns1__UpdateCompanyInfo, ""))
				{	soap_flag_ns1__UpdateCompanyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateCompanyInfo(struct soap *soap, const struct __ns7__UpdateCompanyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateCompanyInfo(soap, tag?tag:"-ns7:UpdateCompanyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateCompanyInfo * SOAP_FMAC4 soap_get___ns7__UpdateCompanyInfo(struct soap *soap, struct __ns7__UpdateCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateCompanyInfo * SOAP_FMAC2 soap_instantiate___ns7__UpdateCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateCompanyInfo);
		if (size)
			*size = sizeof(struct __ns7__UpdateCompanyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateCompanyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateCompanyInfo %p -> %p\n", q, p));
	*(struct __ns7__UpdateCompanyInfo*)p = *(struct __ns7__UpdateCompanyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetCompanyInfo(struct soap *soap, struct __ns7__GetCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCompanyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetCompanyInfo(struct soap *soap, const struct __ns7__GetCompanyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCompanyInfo(soap, &a->ns1__GetCompanyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetCompanyInfo(struct soap *soap, const char *tag, int id, const struct __ns7__GetCompanyInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCompanyInfo(soap, "ns1:GetCompanyInfo", -1, &a->ns1__GetCompanyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetCompanyInfo * SOAP_FMAC4 soap_in___ns7__GetCompanyInfo(struct soap *soap, const char *tag, struct __ns7__GetCompanyInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetCompanyInfo = 1;
	short soap_flag;
	a = (struct __ns7__GetCompanyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetCompanyInfo, sizeof(struct __ns7__GetCompanyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetCompanyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCompanyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCompanyInfo(soap, "ns1:GetCompanyInfo", &a->ns1__GetCompanyInfo, ""))
				{	soap_flag_ns1__GetCompanyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetCompanyInfo(struct soap *soap, const struct __ns7__GetCompanyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetCompanyInfo(soap, tag?tag:"-ns7:GetCompanyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetCompanyInfo * SOAP_FMAC4 soap_get___ns7__GetCompanyInfo(struct soap *soap, struct __ns7__GetCompanyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetCompanyInfo * SOAP_FMAC2 soap_instantiate___ns7__GetCompanyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetCompanyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetCompanyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetCompanyInfo);
		if (size)
			*size = sizeof(struct __ns7__GetCompanyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetCompanyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetCompanyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetCompanyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetCompanyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetCompanyInfo %p -> %p\n", q, p));
	*(struct __ns7__GetCompanyInfo*)p = *(struct __ns7__GetCompanyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__DeletePhoneNumberBelong(struct soap *soap, struct __ns7__DeletePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeletePhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__DeletePhoneNumberBelong(struct soap *soap, const struct __ns7__DeletePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeletePhoneNumberBelong(soap, &a->ns1__DeletePhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__DeletePhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns7__DeletePhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeletePhoneNumberBelong(soap, "ns1:DeletePhoneNumberBelong", -1, &a->ns1__DeletePhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeletePhoneNumberBelong * SOAP_FMAC4 soap_in___ns7__DeletePhoneNumberBelong(struct soap *soap, const char *tag, struct __ns7__DeletePhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__DeletePhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns7__DeletePhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__DeletePhoneNumberBelong, sizeof(struct __ns7__DeletePhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__DeletePhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeletePhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeletePhoneNumberBelong(soap, "ns1:DeletePhoneNumberBelong", &a->ns1__DeletePhoneNumberBelong, ""))
				{	soap_flag_ns1__DeletePhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__DeletePhoneNumberBelong(struct soap *soap, const struct __ns7__DeletePhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__DeletePhoneNumberBelong(soap, tag?tag:"-ns7:DeletePhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeletePhoneNumberBelong * SOAP_FMAC4 soap_get___ns7__DeletePhoneNumberBelong(struct soap *soap, struct __ns7__DeletePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__DeletePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__DeletePhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns7__DeletePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__DeletePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__DeletePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeletePhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns7__DeletePhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeletePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__DeletePhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__DeletePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__DeletePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__DeletePhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns7__DeletePhoneNumberBelong*)p = *(struct __ns7__DeletePhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AddPhoneNumberBelong(struct soap *soap, struct __ns7__AddPhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AddPhoneNumberBelong(struct soap *soap, const struct __ns7__AddPhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPhoneNumberBelong(soap, &a->ns1__AddPhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AddPhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns7__AddPhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPhoneNumberBelong(soap, "ns1:AddPhoneNumberBelong", -1, &a->ns1__AddPhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddPhoneNumberBelong * SOAP_FMAC4 soap_in___ns7__AddPhoneNumberBelong(struct soap *soap, const char *tag, struct __ns7__AddPhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__AddPhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns7__AddPhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AddPhoneNumberBelong, sizeof(struct __ns7__AddPhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AddPhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPhoneNumberBelong(soap, "ns1:AddPhoneNumberBelong", &a->ns1__AddPhoneNumberBelong, ""))
				{	soap_flag_ns1__AddPhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AddPhoneNumberBelong(struct soap *soap, const struct __ns7__AddPhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AddPhoneNumberBelong(soap, tag?tag:"-ns7:AddPhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddPhoneNumberBelong * SOAP_FMAC4 soap_get___ns7__AddPhoneNumberBelong(struct soap *soap, struct __ns7__AddPhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AddPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AddPhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns7__AddPhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AddPhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AddPhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddPhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns7__AddPhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddPhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AddPhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AddPhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AddPhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AddPhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns7__AddPhoneNumberBelong*)p = *(struct __ns7__AddPhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdatePhoneNumberBelong(struct soap *soap, struct __ns7__UpdatePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePhoneNumberBelong = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdatePhoneNumberBelong(struct soap *soap, const struct __ns7__UpdatePhoneNumberBelong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelong(soap, &a->ns1__UpdatePhoneNumberBelong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, int id, const struct __ns7__UpdatePhoneNumberBelong *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdatePhoneNumberBelong(soap, "ns1:UpdatePhoneNumberBelong", -1, &a->ns1__UpdatePhoneNumberBelong, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_in___ns7__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, struct __ns7__UpdatePhoneNumberBelong *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePhoneNumberBelong = 1;
	short soap_flag;
	a = (struct __ns7__UpdatePhoneNumberBelong *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdatePhoneNumberBelong, sizeof(struct __ns7__UpdatePhoneNumberBelong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdatePhoneNumberBelong(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePhoneNumberBelong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePhoneNumberBelong(soap, "ns1:UpdatePhoneNumberBelong", &a->ns1__UpdatePhoneNumberBelong, ""))
				{	soap_flag_ns1__UpdatePhoneNumberBelong--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdatePhoneNumberBelong(struct soap *soap, const struct __ns7__UpdatePhoneNumberBelong *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdatePhoneNumberBelong(soap, tag?tag:"-ns7:UpdatePhoneNumberBelong", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdatePhoneNumberBelong * SOAP_FMAC4 soap_get___ns7__UpdatePhoneNumberBelong(struct soap *soap, struct __ns7__UpdatePhoneNumberBelong *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdatePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdatePhoneNumberBelong * SOAP_FMAC2 soap_instantiate___ns7__UpdatePhoneNumberBelong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdatePhoneNumberBelong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdatePhoneNumberBelong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdatePhoneNumberBelong);
		if (size)
			*size = sizeof(struct __ns7__UpdatePhoneNumberBelong);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdatePhoneNumberBelong[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdatePhoneNumberBelong);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdatePhoneNumberBelong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdatePhoneNumberBelong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdatePhoneNumberBelong %p -> %p\n", q, p));
	*(struct __ns7__UpdatePhoneNumberBelong*)p = *(struct __ns7__UpdatePhoneNumberBelong*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, struct __ns7__GetPhoneNumberBelongByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNumberBelongByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, const struct __ns7__GetPhoneNumberBelongByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, &a->ns1__GetPhoneNumberBelongByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, int id, const struct __ns7__GetPhoneNumberBelongByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, "ns1:GetPhoneNumberBelongByCondition", -1, &a->ns1__GetPhoneNumberBelongByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_in___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, struct __ns7__GetPhoneNumberBelongByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNumberBelongByCondition = 1;
	short soap_flag;
	a = (struct __ns7__GetPhoneNumberBelongByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetPhoneNumberBelongByCondition, sizeof(struct __ns7__GetPhoneNumberBelongByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetPhoneNumberBelongByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNumberBelongByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, "ns1:GetPhoneNumberBelongByCondition", &a->ns1__GetPhoneNumberBelongByCondition, ""))
				{	soap_flag_ns1__GetPhoneNumberBelongByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, const struct __ns7__GetPhoneNumberBelongByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetPhoneNumberBelongByCondition(soap, tag?tag:"-ns7:GetPhoneNumberBelongByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetPhoneNumberBelongByCondition * SOAP_FMAC4 soap_get___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, struct __ns7__GetPhoneNumberBelongByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetPhoneNumberBelongByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetPhoneNumberBelongByCondition * SOAP_FMAC2 soap_instantiate___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetPhoneNumberBelongByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetPhoneNumberBelongByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetPhoneNumberBelongByCondition);
		if (size)
			*size = sizeof(struct __ns7__GetPhoneNumberBelongByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetPhoneNumberBelongByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetPhoneNumberBelongByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetPhoneNumberBelongByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetPhoneNumberBelongByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetPhoneNumberBelongByCondition %p -> %p\n", q, p));
	*(struct __ns7__GetPhoneNumberBelongByCondition*)p = *(struct __ns7__GetPhoneNumberBelongByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__DeletetReturnProportion(struct soap *soap, struct __ns7__DeletetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeletetReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__DeletetReturnProportion(struct soap *soap, const struct __ns7__DeletetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeletetReturnProportion(soap, &a->ns1__DeletetReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__DeletetReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns7__DeletetReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeletetReturnProportion(soap, "ns1:DeletetReturnProportion", -1, &a->ns1__DeletetReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeletetReturnProportion * SOAP_FMAC4 soap_in___ns7__DeletetReturnProportion(struct soap *soap, const char *tag, struct __ns7__DeletetReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__DeletetReturnProportion = 1;
	short soap_flag;
	a = (struct __ns7__DeletetReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__DeletetReturnProportion, sizeof(struct __ns7__DeletetReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__DeletetReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeletetReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeletetReturnProportion(soap, "ns1:DeletetReturnProportion", &a->ns1__DeletetReturnProportion, ""))
				{	soap_flag_ns1__DeletetReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__DeletetReturnProportion(struct soap *soap, const struct __ns7__DeletetReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__DeletetReturnProportion(soap, tag?tag:"-ns7:DeletetReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeletetReturnProportion * SOAP_FMAC4 soap_get___ns7__DeletetReturnProportion(struct soap *soap, struct __ns7__DeletetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__DeletetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__DeletetReturnProportion * SOAP_FMAC2 soap_instantiate___ns7__DeletetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__DeletetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__DeletetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeletetReturnProportion);
		if (size)
			*size = sizeof(struct __ns7__DeletetReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeletetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__DeletetReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__DeletetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__DeletetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__DeletetReturnProportion %p -> %p\n", q, p));
	*(struct __ns7__DeletetReturnProportion*)p = *(struct __ns7__DeletetReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdatetReturnProportion(struct soap *soap, struct __ns7__UpdatetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatetReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdatetReturnProportion(struct soap *soap, const struct __ns7__UpdatetReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatetReturnProportion(soap, &a->ns1__UpdatetReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdatetReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns7__UpdatetReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdatetReturnProportion(soap, "ns1:UpdatetReturnProportion", -1, &a->ns1__UpdatetReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdatetReturnProportion * SOAP_FMAC4 soap_in___ns7__UpdatetReturnProportion(struct soap *soap, const char *tag, struct __ns7__UpdatetReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__UpdatetReturnProportion = 1;
	short soap_flag;
	a = (struct __ns7__UpdatetReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdatetReturnProportion, sizeof(struct __ns7__UpdatetReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdatetReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatetReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatetReturnProportion(soap, "ns1:UpdatetReturnProportion", &a->ns1__UpdatetReturnProportion, ""))
				{	soap_flag_ns1__UpdatetReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdatetReturnProportion(struct soap *soap, const struct __ns7__UpdatetReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdatetReturnProportion(soap, tag?tag:"-ns7:UpdatetReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdatetReturnProportion * SOAP_FMAC4 soap_get___ns7__UpdatetReturnProportion(struct soap *soap, struct __ns7__UpdatetReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdatetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdatetReturnProportion * SOAP_FMAC2 soap_instantiate___ns7__UpdatetReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdatetReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdatetReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdatetReturnProportion);
		if (size)
			*size = sizeof(struct __ns7__UpdatetReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdatetReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdatetReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdatetReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdatetReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdatetReturnProportion %p -> %p\n", q, p));
	*(struct __ns7__UpdatetReturnProportion*)p = *(struct __ns7__UpdatetReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AddtReturnProportion(struct soap *soap, struct __ns7__AddtReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddtReturnProportion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AddtReturnProportion(struct soap *soap, const struct __ns7__AddtReturnProportion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddtReturnProportion(soap, &a->ns1__AddtReturnProportion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AddtReturnProportion(struct soap *soap, const char *tag, int id, const struct __ns7__AddtReturnProportion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddtReturnProportion(soap, "ns1:AddtReturnProportion", -1, &a->ns1__AddtReturnProportion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddtReturnProportion * SOAP_FMAC4 soap_in___ns7__AddtReturnProportion(struct soap *soap, const char *tag, struct __ns7__AddtReturnProportion *a, const char *type)
{
	size_t soap_flag_ns1__AddtReturnProportion = 1;
	short soap_flag;
	a = (struct __ns7__AddtReturnProportion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AddtReturnProportion, sizeof(struct __ns7__AddtReturnProportion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AddtReturnProportion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddtReturnProportion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddtReturnProportion(soap, "ns1:AddtReturnProportion", &a->ns1__AddtReturnProportion, ""))
				{	soap_flag_ns1__AddtReturnProportion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AddtReturnProportion(struct soap *soap, const struct __ns7__AddtReturnProportion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AddtReturnProportion(soap, tag?tag:"-ns7:AddtReturnProportion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddtReturnProportion * SOAP_FMAC4 soap_get___ns7__AddtReturnProportion(struct soap *soap, struct __ns7__AddtReturnProportion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AddtReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AddtReturnProportion * SOAP_FMAC2 soap_instantiate___ns7__AddtReturnProportion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AddtReturnProportion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AddtReturnProportion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddtReturnProportion);
		if (size)
			*size = sizeof(struct __ns7__AddtReturnProportion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddtReturnProportion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AddtReturnProportion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AddtReturnProportion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AddtReturnProportion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AddtReturnProportion %p -> %p\n", q, p));
	*(struct __ns7__AddtReturnProportion*)p = *(struct __ns7__AddtReturnProportion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetReturnProportionRecord(struct soap *soap, struct __ns7__GetReturnProportionRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnProportionRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetReturnProportionRecord(struct soap *soap, const struct __ns7__GetReturnProportionRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnProportionRecord(soap, &a->ns1__GetReturnProportionRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetReturnProportionRecord(struct soap *soap, const char *tag, int id, const struct __ns7__GetReturnProportionRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnProportionRecord(soap, "ns1:GetReturnProportionRecord", -1, &a->ns1__GetReturnProportionRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetReturnProportionRecord * SOAP_FMAC4 soap_in___ns7__GetReturnProportionRecord(struct soap *soap, const char *tag, struct __ns7__GetReturnProportionRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnProportionRecord = 1;
	short soap_flag;
	a = (struct __ns7__GetReturnProportionRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetReturnProportionRecord, sizeof(struct __ns7__GetReturnProportionRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetReturnProportionRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnProportionRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnProportionRecord(soap, "ns1:GetReturnProportionRecord", &a->ns1__GetReturnProportionRecord, ""))
				{	soap_flag_ns1__GetReturnProportionRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetReturnProportionRecord(struct soap *soap, const struct __ns7__GetReturnProportionRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetReturnProportionRecord(soap, tag?tag:"-ns7:GetReturnProportionRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetReturnProportionRecord * SOAP_FMAC4 soap_get___ns7__GetReturnProportionRecord(struct soap *soap, struct __ns7__GetReturnProportionRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetReturnProportionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetReturnProportionRecord * SOAP_FMAC2 soap_instantiate___ns7__GetReturnProportionRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetReturnProportionRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetReturnProportionRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetReturnProportionRecord);
		if (size)
			*size = sizeof(struct __ns7__GetReturnProportionRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetReturnProportionRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetReturnProportionRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetReturnProportionRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetReturnProportionRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetReturnProportionRecord %p -> %p\n", q, p));
	*(struct __ns7__GetReturnProportionRecord*)p = *(struct __ns7__GetReturnProportionRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__InserNoticeToSomeOne(struct soap *soap, struct __ns7__InserNoticeToSomeOne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InserNoticeToSomeOne = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__InserNoticeToSomeOne(struct soap *soap, const struct __ns7__InserNoticeToSomeOne *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InserNoticeToSomeOne(soap, &a->ns1__InserNoticeToSomeOne);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__InserNoticeToSomeOne(struct soap *soap, const char *tag, int id, const struct __ns7__InserNoticeToSomeOne *a, const char *type)
{
	if (soap_out_PointerTo_ns1__InserNoticeToSomeOne(soap, "ns1:InserNoticeToSomeOne", -1, &a->ns1__InserNoticeToSomeOne, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__InserNoticeToSomeOne * SOAP_FMAC4 soap_in___ns7__InserNoticeToSomeOne(struct soap *soap, const char *tag, struct __ns7__InserNoticeToSomeOne *a, const char *type)
{
	size_t soap_flag_ns1__InserNoticeToSomeOne = 1;
	short soap_flag;
	a = (struct __ns7__InserNoticeToSomeOne *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__InserNoticeToSomeOne, sizeof(struct __ns7__InserNoticeToSomeOne), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__InserNoticeToSomeOne(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InserNoticeToSomeOne && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InserNoticeToSomeOne(soap, "ns1:InserNoticeToSomeOne", &a->ns1__InserNoticeToSomeOne, ""))
				{	soap_flag_ns1__InserNoticeToSomeOne--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__InserNoticeToSomeOne(struct soap *soap, const struct __ns7__InserNoticeToSomeOne *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__InserNoticeToSomeOne(soap, tag?tag:"-ns7:InserNoticeToSomeOne", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__InserNoticeToSomeOne * SOAP_FMAC4 soap_get___ns7__InserNoticeToSomeOne(struct soap *soap, struct __ns7__InserNoticeToSomeOne *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__InserNoticeToSomeOne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__InserNoticeToSomeOne * SOAP_FMAC2 soap_instantiate___ns7__InserNoticeToSomeOne(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__InserNoticeToSomeOne(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__InserNoticeToSomeOne, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__InserNoticeToSomeOne);
		if (size)
			*size = sizeof(struct __ns7__InserNoticeToSomeOne);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__InserNoticeToSomeOne[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__InserNoticeToSomeOne);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__InserNoticeToSomeOne*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__InserNoticeToSomeOne(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__InserNoticeToSomeOne %p -> %p\n", q, p));
	*(struct __ns7__InserNoticeToSomeOne*)p = *(struct __ns7__InserNoticeToSomeOne*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__DeleteNoticeItem(struct soap *soap, struct __ns7__DeleteNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__DeleteNoticeItem(struct soap *soap, const struct __ns7__DeleteNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteNoticeItem(soap, &a->ns1__DeleteNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__DeleteNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns7__DeleteNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteNoticeItem(soap, "ns1:DeleteNoticeItem", -1, &a->ns1__DeleteNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteNoticeItem * SOAP_FMAC4 soap_in___ns7__DeleteNoticeItem(struct soap *soap, const char *tag, struct __ns7__DeleteNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__DeleteNoticeItem = 1;
	short soap_flag;
	a = (struct __ns7__DeleteNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__DeleteNoticeItem, sizeof(struct __ns7__DeleteNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__DeleteNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteNoticeItem(soap, "ns1:DeleteNoticeItem", &a->ns1__DeleteNoticeItem, ""))
				{	soap_flag_ns1__DeleteNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__DeleteNoticeItem(struct soap *soap, const struct __ns7__DeleteNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__DeleteNoticeItem(soap, tag?tag:"-ns7:DeleteNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteNoticeItem * SOAP_FMAC4 soap_get___ns7__DeleteNoticeItem(struct soap *soap, struct __ns7__DeleteNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__DeleteNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__DeleteNoticeItem * SOAP_FMAC2 soap_instantiate___ns7__DeleteNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__DeleteNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__DeleteNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteNoticeItem);
		if (size)
			*size = sizeof(struct __ns7__DeleteNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__DeleteNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__DeleteNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__DeleteNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__DeleteNoticeItem %p -> %p\n", q, p));
	*(struct __ns7__DeleteNoticeItem*)p = *(struct __ns7__DeleteNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateNoticeItem(struct soap *soap, struct __ns7__UpdateNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateNoticeItem(struct soap *soap, const struct __ns7__UpdateNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateNoticeItem(soap, &a->ns1__UpdateNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateNoticeItem(soap, "ns1:UpdateNoticeItem", -1, &a->ns1__UpdateNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateNoticeItem * SOAP_FMAC4 soap_in___ns7__UpdateNoticeItem(struct soap *soap, const char *tag, struct __ns7__UpdateNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__UpdateNoticeItem = 1;
	short soap_flag;
	a = (struct __ns7__UpdateNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateNoticeItem, sizeof(struct __ns7__UpdateNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateNoticeItem(soap, "ns1:UpdateNoticeItem", &a->ns1__UpdateNoticeItem, ""))
				{	soap_flag_ns1__UpdateNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateNoticeItem(struct soap *soap, const struct __ns7__UpdateNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateNoticeItem(soap, tag?tag:"-ns7:UpdateNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateNoticeItem * SOAP_FMAC4 soap_get___ns7__UpdateNoticeItem(struct soap *soap, struct __ns7__UpdateNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateNoticeItem * SOAP_FMAC2 soap_instantiate___ns7__UpdateNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateNoticeItem);
		if (size)
			*size = sizeof(struct __ns7__UpdateNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateNoticeItem %p -> %p\n", q, p));
	*(struct __ns7__UpdateNoticeItem*)p = *(struct __ns7__UpdateNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AddNoticeItemToSomeone(struct soap *soap, struct __ns7__AddNoticeItemToSomeone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddNoticeItemToSomeone = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AddNoticeItemToSomeone(struct soap *soap, const struct __ns7__AddNoticeItemToSomeone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddNoticeItemToSomeone(soap, &a->ns1__AddNoticeItemToSomeone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AddNoticeItemToSomeone(struct soap *soap, const char *tag, int id, const struct __ns7__AddNoticeItemToSomeone *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddNoticeItemToSomeone(soap, "ns1:AddNoticeItemToSomeone", -1, &a->ns1__AddNoticeItemToSomeone, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddNoticeItemToSomeone * SOAP_FMAC4 soap_in___ns7__AddNoticeItemToSomeone(struct soap *soap, const char *tag, struct __ns7__AddNoticeItemToSomeone *a, const char *type)
{
	size_t soap_flag_ns1__AddNoticeItemToSomeone = 1;
	short soap_flag;
	a = (struct __ns7__AddNoticeItemToSomeone *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AddNoticeItemToSomeone, sizeof(struct __ns7__AddNoticeItemToSomeone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AddNoticeItemToSomeone(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddNoticeItemToSomeone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddNoticeItemToSomeone(soap, "ns1:AddNoticeItemToSomeone", &a->ns1__AddNoticeItemToSomeone, ""))
				{	soap_flag_ns1__AddNoticeItemToSomeone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AddNoticeItemToSomeone(struct soap *soap, const struct __ns7__AddNoticeItemToSomeone *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AddNoticeItemToSomeone(soap, tag?tag:"-ns7:AddNoticeItemToSomeone", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddNoticeItemToSomeone * SOAP_FMAC4 soap_get___ns7__AddNoticeItemToSomeone(struct soap *soap, struct __ns7__AddNoticeItemToSomeone *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AddNoticeItemToSomeone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AddNoticeItemToSomeone * SOAP_FMAC2 soap_instantiate___ns7__AddNoticeItemToSomeone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AddNoticeItemToSomeone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AddNoticeItemToSomeone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddNoticeItemToSomeone);
		if (size)
			*size = sizeof(struct __ns7__AddNoticeItemToSomeone);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddNoticeItemToSomeone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AddNoticeItemToSomeone);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AddNoticeItemToSomeone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AddNoticeItemToSomeone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AddNoticeItemToSomeone %p -> %p\n", q, p));
	*(struct __ns7__AddNoticeItemToSomeone*)p = *(struct __ns7__AddNoticeItemToSomeone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AddNoticeItem(struct soap *soap, struct __ns7__AddNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AddNoticeItem(struct soap *soap, const struct __ns7__AddNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddNoticeItem(soap, &a->ns1__AddNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AddNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns7__AddNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddNoticeItem(soap, "ns1:AddNoticeItem", -1, &a->ns1__AddNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddNoticeItem * SOAP_FMAC4 soap_in___ns7__AddNoticeItem(struct soap *soap, const char *tag, struct __ns7__AddNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__AddNoticeItem = 1;
	short soap_flag;
	a = (struct __ns7__AddNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AddNoticeItem, sizeof(struct __ns7__AddNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AddNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddNoticeItem(soap, "ns1:AddNoticeItem", &a->ns1__AddNoticeItem, ""))
				{	soap_flag_ns1__AddNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AddNoticeItem(struct soap *soap, const struct __ns7__AddNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AddNoticeItem(soap, tag?tag:"-ns7:AddNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AddNoticeItem * SOAP_FMAC4 soap_get___ns7__AddNoticeItem(struct soap *soap, struct __ns7__AddNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AddNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AddNoticeItem * SOAP_FMAC2 soap_instantiate___ns7__AddNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AddNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AddNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddNoticeItem);
		if (size)
			*size = sizeof(struct __ns7__AddNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AddNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AddNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AddNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AddNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AddNoticeItem %p -> %p\n", q, p));
	*(struct __ns7__AddNoticeItem*)p = *(struct __ns7__AddNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetAlertNoticeList(struct soap *soap, struct __ns7__GetAlertNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlertNoticeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetAlertNoticeList(struct soap *soap, const struct __ns7__GetAlertNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlertNoticeList(soap, &a->ns1__GetAlertNoticeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetAlertNoticeList(struct soap *soap, const char *tag, int id, const struct __ns7__GetAlertNoticeList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAlertNoticeList(soap, "ns1:GetAlertNoticeList", -1, &a->ns1__GetAlertNoticeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetAlertNoticeList * SOAP_FMAC4 soap_in___ns7__GetAlertNoticeList(struct soap *soap, const char *tag, struct __ns7__GetAlertNoticeList *a, const char *type)
{
	size_t soap_flag_ns1__GetAlertNoticeList = 1;
	short soap_flag;
	a = (struct __ns7__GetAlertNoticeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetAlertNoticeList, sizeof(struct __ns7__GetAlertNoticeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetAlertNoticeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlertNoticeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlertNoticeList(soap, "ns1:GetAlertNoticeList", &a->ns1__GetAlertNoticeList, ""))
				{	soap_flag_ns1__GetAlertNoticeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetAlertNoticeList(struct soap *soap, const struct __ns7__GetAlertNoticeList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetAlertNoticeList(soap, tag?tag:"-ns7:GetAlertNoticeList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetAlertNoticeList * SOAP_FMAC4 soap_get___ns7__GetAlertNoticeList(struct soap *soap, struct __ns7__GetAlertNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetAlertNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetAlertNoticeList * SOAP_FMAC2 soap_instantiate___ns7__GetAlertNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetAlertNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetAlertNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetAlertNoticeList);
		if (size)
			*size = sizeof(struct __ns7__GetAlertNoticeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetAlertNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetAlertNoticeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetAlertNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetAlertNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetAlertNoticeList %p -> %p\n", q, p));
	*(struct __ns7__GetAlertNoticeList*)p = *(struct __ns7__GetAlertNoticeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetNoticeItem(struct soap *soap, struct __ns7__GetNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetNoticeItem(struct soap *soap, const struct __ns7__GetNoticeItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeItem(soap, &a->ns1__GetNoticeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetNoticeItem(struct soap *soap, const char *tag, int id, const struct __ns7__GetNoticeItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeItem(soap, "ns1:GetNoticeItem", -1, &a->ns1__GetNoticeItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeItem * SOAP_FMAC4 soap_in___ns7__GetNoticeItem(struct soap *soap, const char *tag, struct __ns7__GetNoticeItem *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeItem = 1;
	short soap_flag;
	a = (struct __ns7__GetNoticeItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetNoticeItem, sizeof(struct __ns7__GetNoticeItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetNoticeItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeItem(soap, "ns1:GetNoticeItem", &a->ns1__GetNoticeItem, ""))
				{	soap_flag_ns1__GetNoticeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetNoticeItem(struct soap *soap, const struct __ns7__GetNoticeItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetNoticeItem(soap, tag?tag:"-ns7:GetNoticeItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeItem * SOAP_FMAC4 soap_get___ns7__GetNoticeItem(struct soap *soap, struct __ns7__GetNoticeItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetNoticeItem * SOAP_FMAC2 soap_instantiate___ns7__GetNoticeItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetNoticeItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetNoticeItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeItem);
		if (size)
			*size = sizeof(struct __ns7__GetNoticeItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetNoticeItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetNoticeItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetNoticeItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetNoticeItem %p -> %p\n", q, p));
	*(struct __ns7__GetNoticeItem*)p = *(struct __ns7__GetNoticeItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetNoticeListByCondition(struct soap *soap, struct __ns7__GetNoticeListByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeListByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetNoticeListByCondition(struct soap *soap, const struct __ns7__GetNoticeListByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeListByCondition(soap, &a->ns1__GetNoticeListByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetNoticeListByCondition(struct soap *soap, const char *tag, int id, const struct __ns7__GetNoticeListByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeListByCondition(soap, "ns1:GetNoticeListByCondition", -1, &a->ns1__GetNoticeListByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeListByCondition * SOAP_FMAC4 soap_in___ns7__GetNoticeListByCondition(struct soap *soap, const char *tag, struct __ns7__GetNoticeListByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeListByCondition = 1;
	short soap_flag;
	a = (struct __ns7__GetNoticeListByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetNoticeListByCondition, sizeof(struct __ns7__GetNoticeListByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetNoticeListByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeListByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeListByCondition(soap, "ns1:GetNoticeListByCondition", &a->ns1__GetNoticeListByCondition, ""))
				{	soap_flag_ns1__GetNoticeListByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetNoticeListByCondition(struct soap *soap, const struct __ns7__GetNoticeListByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetNoticeListByCondition(soap, tag?tag:"-ns7:GetNoticeListByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeListByCondition * SOAP_FMAC4 soap_get___ns7__GetNoticeListByCondition(struct soap *soap, struct __ns7__GetNoticeListByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetNoticeListByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetNoticeListByCondition * SOAP_FMAC2 soap_instantiate___ns7__GetNoticeListByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetNoticeListByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetNoticeListByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeListByCondition);
		if (size)
			*size = sizeof(struct __ns7__GetNoticeListByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeListByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetNoticeListByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetNoticeListByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetNoticeListByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetNoticeListByCondition %p -> %p\n", q, p));
	*(struct __ns7__GetNoticeListByCondition*)p = *(struct __ns7__GetNoticeListByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetNoticeList(struct soap *soap, struct __ns7__GetNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetNoticeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetNoticeList(struct soap *soap, const struct __ns7__GetNoticeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetNoticeList(soap, &a->ns1__GetNoticeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetNoticeList(struct soap *soap, const char *tag, int id, const struct __ns7__GetNoticeList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetNoticeList(soap, "ns1:GetNoticeList", -1, &a->ns1__GetNoticeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeList * SOAP_FMAC4 soap_in___ns7__GetNoticeList(struct soap *soap, const char *tag, struct __ns7__GetNoticeList *a, const char *type)
{
	size_t soap_flag_ns1__GetNoticeList = 1;
	short soap_flag;
	a = (struct __ns7__GetNoticeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetNoticeList, sizeof(struct __ns7__GetNoticeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetNoticeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetNoticeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetNoticeList(soap, "ns1:GetNoticeList", &a->ns1__GetNoticeList, ""))
				{	soap_flag_ns1__GetNoticeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetNoticeList(struct soap *soap, const struct __ns7__GetNoticeList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetNoticeList(soap, tag?tag:"-ns7:GetNoticeList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetNoticeList * SOAP_FMAC4 soap_get___ns7__GetNoticeList(struct soap *soap, struct __ns7__GetNoticeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetNoticeList * SOAP_FMAC2 soap_instantiate___ns7__GetNoticeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetNoticeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetNoticeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeList);
		if (size)
			*size = sizeof(struct __ns7__GetNoticeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetNoticeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetNoticeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetNoticeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetNoticeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetNoticeList %p -> %p\n", q, p));
	*(struct __ns7__GetNoticeList*)p = *(struct __ns7__GetNoticeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetTableStatistics(struct soap *soap, struct __ns7__GetTableStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTableStatistics = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetTableStatistics(struct soap *soap, const struct __ns7__GetTableStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTableStatistics(soap, &a->ns1__GetTableStatistics);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetTableStatistics(struct soap *soap, const char *tag, int id, const struct __ns7__GetTableStatistics *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTableStatistics(soap, "ns1:GetTableStatistics", -1, &a->ns1__GetTableStatistics, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetTableStatistics * SOAP_FMAC4 soap_in___ns7__GetTableStatistics(struct soap *soap, const char *tag, struct __ns7__GetTableStatistics *a, const char *type)
{
	size_t soap_flag_ns1__GetTableStatistics = 1;
	short soap_flag;
	a = (struct __ns7__GetTableStatistics *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetTableStatistics, sizeof(struct __ns7__GetTableStatistics), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetTableStatistics(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTableStatistics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTableStatistics(soap, "ns1:GetTableStatistics", &a->ns1__GetTableStatistics, ""))
				{	soap_flag_ns1__GetTableStatistics--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetTableStatistics(struct soap *soap, const struct __ns7__GetTableStatistics *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetTableStatistics(soap, tag?tag:"-ns7:GetTableStatistics", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetTableStatistics * SOAP_FMAC4 soap_get___ns7__GetTableStatistics(struct soap *soap, struct __ns7__GetTableStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetTableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetTableStatistics * SOAP_FMAC2 soap_instantiate___ns7__GetTableStatistics(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetTableStatistics(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetTableStatistics, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetTableStatistics);
		if (size)
			*size = sizeof(struct __ns7__GetTableStatistics);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetTableStatistics[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetTableStatistics);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetTableStatistics*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetTableStatistics(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetTableStatistics %p -> %p\n", q, p));
	*(struct __ns7__GetTableStatistics*)p = *(struct __ns7__GetTableStatistics*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateFunctionRight(struct soap *soap, struct __ns7__UpdateFunctionRight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateFunctionRight = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateFunctionRight(struct soap *soap, const struct __ns7__UpdateFunctionRight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateFunctionRight(soap, &a->ns1__UpdateFunctionRight);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateFunctionRight(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateFunctionRight *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateFunctionRight(soap, "ns1:UpdateFunctionRight", -1, &a->ns1__UpdateFunctionRight, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateFunctionRight * SOAP_FMAC4 soap_in___ns7__UpdateFunctionRight(struct soap *soap, const char *tag, struct __ns7__UpdateFunctionRight *a, const char *type)
{
	size_t soap_flag_ns1__UpdateFunctionRight = 1;
	short soap_flag;
	a = (struct __ns7__UpdateFunctionRight *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateFunctionRight, sizeof(struct __ns7__UpdateFunctionRight), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateFunctionRight(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateFunctionRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateFunctionRight(soap, "ns1:UpdateFunctionRight", &a->ns1__UpdateFunctionRight, ""))
				{	soap_flag_ns1__UpdateFunctionRight--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateFunctionRight(struct soap *soap, const struct __ns7__UpdateFunctionRight *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateFunctionRight(soap, tag?tag:"-ns7:UpdateFunctionRight", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateFunctionRight * SOAP_FMAC4 soap_get___ns7__UpdateFunctionRight(struct soap *soap, struct __ns7__UpdateFunctionRight *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateFunctionRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateFunctionRight * SOAP_FMAC2 soap_instantiate___ns7__UpdateFunctionRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateFunctionRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateFunctionRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateFunctionRight);
		if (size)
			*size = sizeof(struct __ns7__UpdateFunctionRight);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateFunctionRight[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateFunctionRight);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateFunctionRight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateFunctionRight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateFunctionRight %p -> %p\n", q, p));
	*(struct __ns7__UpdateFunctionRight*)p = *(struct __ns7__UpdateFunctionRight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateUserFunctionList(struct soap *soap, struct __ns7__UpdateUserFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateUserFunctionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateUserFunctionList(struct soap *soap, const struct __ns7__UpdateUserFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateUserFunctionList(soap, &a->ns1__UpdateUserFunctionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateUserFunctionList(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateUserFunctionList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateUserFunctionList(soap, "ns1:UpdateUserFunctionList", -1, &a->ns1__UpdateUserFunctionList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateUserFunctionList * SOAP_FMAC4 soap_in___ns7__UpdateUserFunctionList(struct soap *soap, const char *tag, struct __ns7__UpdateUserFunctionList *a, const char *type)
{
	size_t soap_flag_ns1__UpdateUserFunctionList = 1;
	short soap_flag;
	a = (struct __ns7__UpdateUserFunctionList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateUserFunctionList, sizeof(struct __ns7__UpdateUserFunctionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateUserFunctionList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateUserFunctionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateUserFunctionList(soap, "ns1:UpdateUserFunctionList", &a->ns1__UpdateUserFunctionList, ""))
				{	soap_flag_ns1__UpdateUserFunctionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateUserFunctionList(struct soap *soap, const struct __ns7__UpdateUserFunctionList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateUserFunctionList(soap, tag?tag:"-ns7:UpdateUserFunctionList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateUserFunctionList * SOAP_FMAC4 soap_get___ns7__UpdateUserFunctionList(struct soap *soap, struct __ns7__UpdateUserFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateUserFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateUserFunctionList * SOAP_FMAC2 soap_instantiate___ns7__UpdateUserFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateUserFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateUserFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateUserFunctionList);
		if (size)
			*size = sizeof(struct __ns7__UpdateUserFunctionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateUserFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateUserFunctionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateUserFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateUserFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateUserFunctionList %p -> %p\n", q, p));
	*(struct __ns7__UpdateUserFunctionList*)p = *(struct __ns7__UpdateUserFunctionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetFunctionList(struct soap *soap, struct __ns7__GetFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFunctionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetFunctionList(struct soap *soap, const struct __ns7__GetFunctionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetFunctionList(soap, &a->ns1__GetFunctionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetFunctionList(struct soap *soap, const char *tag, int id, const struct __ns7__GetFunctionList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFunctionList(soap, "ns1:GetFunctionList", -1, &a->ns1__GetFunctionList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetFunctionList * SOAP_FMAC4 soap_in___ns7__GetFunctionList(struct soap *soap, const char *tag, struct __ns7__GetFunctionList *a, const char *type)
{
	size_t soap_flag_ns1__GetFunctionList = 1;
	short soap_flag;
	a = (struct __ns7__GetFunctionList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetFunctionList, sizeof(struct __ns7__GetFunctionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetFunctionList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFunctionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetFunctionList(soap, "ns1:GetFunctionList", &a->ns1__GetFunctionList, ""))
				{	soap_flag_ns1__GetFunctionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetFunctionList(struct soap *soap, const struct __ns7__GetFunctionList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetFunctionList(soap, tag?tag:"-ns7:GetFunctionList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetFunctionList * SOAP_FMAC4 soap_get___ns7__GetFunctionList(struct soap *soap, struct __ns7__GetFunctionList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetFunctionList * SOAP_FMAC2 soap_instantiate___ns7__GetFunctionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetFunctionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetFunctionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetFunctionList);
		if (size)
			*size = sizeof(struct __ns7__GetFunctionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetFunctionList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetFunctionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetFunctionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetFunctionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetFunctionList %p -> %p\n", q, p));
	*(struct __ns7__GetFunctionList*)p = *(struct __ns7__GetFunctionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateDicContentByCategory(struct soap *soap, struct __ns7__UpdateDicContentByCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDicContentByCategory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateDicContentByCategory(struct soap *soap, const struct __ns7__UpdateDicContentByCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateDicContentByCategory(soap, &a->ns1__UpdateDicContentByCategory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateDicContentByCategory(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateDicContentByCategory *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateDicContentByCategory(soap, "ns1:UpdateDicContentByCategory", -1, &a->ns1__UpdateDicContentByCategory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateDicContentByCategory * SOAP_FMAC4 soap_in___ns7__UpdateDicContentByCategory(struct soap *soap, const char *tag, struct __ns7__UpdateDicContentByCategory *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDicContentByCategory = 1;
	short soap_flag;
	a = (struct __ns7__UpdateDicContentByCategory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateDicContentByCategory, sizeof(struct __ns7__UpdateDicContentByCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateDicContentByCategory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDicContentByCategory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDicContentByCategory(soap, "ns1:UpdateDicContentByCategory", &a->ns1__UpdateDicContentByCategory, ""))
				{	soap_flag_ns1__UpdateDicContentByCategory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateDicContentByCategory(struct soap *soap, const struct __ns7__UpdateDicContentByCategory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateDicContentByCategory(soap, tag?tag:"-ns7:UpdateDicContentByCategory", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateDicContentByCategory * SOAP_FMAC4 soap_get___ns7__UpdateDicContentByCategory(struct soap *soap, struct __ns7__UpdateDicContentByCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateDicContentByCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateDicContentByCategory * SOAP_FMAC2 soap_instantiate___ns7__UpdateDicContentByCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateDicContentByCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateDicContentByCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateDicContentByCategory);
		if (size)
			*size = sizeof(struct __ns7__UpdateDicContentByCategory);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateDicContentByCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateDicContentByCategory);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateDicContentByCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateDicContentByCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateDicContentByCategory %p -> %p\n", q, p));
	*(struct __ns7__UpdateDicContentByCategory*)p = *(struct __ns7__UpdateDicContentByCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__DeleteDicContent(struct soap *soap, struct __ns7__DeleteDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__DeleteDicContent(struct soap *soap, const struct __ns7__DeleteDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteDicContent(soap, &a->ns1__DeleteDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__DeleteDicContent(struct soap *soap, const char *tag, int id, const struct __ns7__DeleteDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteDicContent(soap, "ns1:DeleteDicContent", -1, &a->ns1__DeleteDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteDicContent * SOAP_FMAC4 soap_in___ns7__DeleteDicContent(struct soap *soap, const char *tag, struct __ns7__DeleteDicContent *a, const char *type)
{
	size_t soap_flag_ns1__DeleteDicContent = 1;
	short soap_flag;
	a = (struct __ns7__DeleteDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__DeleteDicContent, sizeof(struct __ns7__DeleteDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__DeleteDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteDicContent(soap, "ns1:DeleteDicContent", &a->ns1__DeleteDicContent, ""))
				{	soap_flag_ns1__DeleteDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__DeleteDicContent(struct soap *soap, const struct __ns7__DeleteDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__DeleteDicContent(soap, tag?tag:"-ns7:DeleteDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__DeleteDicContent * SOAP_FMAC4 soap_get___ns7__DeleteDicContent(struct soap *soap, struct __ns7__DeleteDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__DeleteDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__DeleteDicContent * SOAP_FMAC2 soap_instantiate___ns7__DeleteDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__DeleteDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__DeleteDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteDicContent);
		if (size)
			*size = sizeof(struct __ns7__DeleteDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__DeleteDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__DeleteDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__DeleteDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__DeleteDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__DeleteDicContent %p -> %p\n", q, p));
	*(struct __ns7__DeleteDicContent*)p = *(struct __ns7__DeleteDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UpdateDicContent(struct soap *soap, struct __ns7__UpdateDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UpdateDicContent(struct soap *soap, const struct __ns7__UpdateDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateDicContent(soap, &a->ns1__UpdateDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UpdateDicContent(struct soap *soap, const char *tag, int id, const struct __ns7__UpdateDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateDicContent(soap, "ns1:UpdateDicContent", -1, &a->ns1__UpdateDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateDicContent * SOAP_FMAC4 soap_in___ns7__UpdateDicContent(struct soap *soap, const char *tag, struct __ns7__UpdateDicContent *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDicContent = 1;
	short soap_flag;
	a = (struct __ns7__UpdateDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UpdateDicContent, sizeof(struct __ns7__UpdateDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UpdateDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDicContent(soap, "ns1:UpdateDicContent", &a->ns1__UpdateDicContent, ""))
				{	soap_flag_ns1__UpdateDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UpdateDicContent(struct soap *soap, const struct __ns7__UpdateDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UpdateDicContent(soap, tag?tag:"-ns7:UpdateDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UpdateDicContent * SOAP_FMAC4 soap_get___ns7__UpdateDicContent(struct soap *soap, struct __ns7__UpdateDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UpdateDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UpdateDicContent * SOAP_FMAC2 soap_instantiate___ns7__UpdateDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UpdateDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UpdateDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateDicContent);
		if (size)
			*size = sizeof(struct __ns7__UpdateDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UpdateDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UpdateDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UpdateDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UpdateDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UpdateDicContent %p -> %p\n", q, p));
	*(struct __ns7__UpdateDicContent*)p = *(struct __ns7__UpdateDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__InsertDicContent(struct soap *soap, struct __ns7__InsertDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsertDicContent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__InsertDicContent(struct soap *soap, const struct __ns7__InsertDicContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InsertDicContent(soap, &a->ns1__InsertDicContent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__InsertDicContent(struct soap *soap, const char *tag, int id, const struct __ns7__InsertDicContent *a, const char *type)
{
	if (soap_out_PointerTo_ns1__InsertDicContent(soap, "ns1:InsertDicContent", -1, &a->ns1__InsertDicContent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__InsertDicContent * SOAP_FMAC4 soap_in___ns7__InsertDicContent(struct soap *soap, const char *tag, struct __ns7__InsertDicContent *a, const char *type)
{
	size_t soap_flag_ns1__InsertDicContent = 1;
	short soap_flag;
	a = (struct __ns7__InsertDicContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__InsertDicContent, sizeof(struct __ns7__InsertDicContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__InsertDicContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsertDicContent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InsertDicContent(soap, "ns1:InsertDicContent", &a->ns1__InsertDicContent, ""))
				{	soap_flag_ns1__InsertDicContent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__InsertDicContent(struct soap *soap, const struct __ns7__InsertDicContent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__InsertDicContent(soap, tag?tag:"-ns7:InsertDicContent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__InsertDicContent * SOAP_FMAC4 soap_get___ns7__InsertDicContent(struct soap *soap, struct __ns7__InsertDicContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__InsertDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__InsertDicContent * SOAP_FMAC2 soap_instantiate___ns7__InsertDicContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__InsertDicContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__InsertDicContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__InsertDicContent);
		if (size)
			*size = sizeof(struct __ns7__InsertDicContent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__InsertDicContent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__InsertDicContent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__InsertDicContent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__InsertDicContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__InsertDicContent %p -> %p\n", q, p));
	*(struct __ns7__InsertDicContent*)p = *(struct __ns7__InsertDicContent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetAllCategory(struct soap *soap, struct __ns7__GetAllCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCategory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetAllCategory(struct soap *soap, const struct __ns7__GetAllCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCategory(soap, &a->ns1__GetAllCategory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetAllCategory(struct soap *soap, const char *tag, int id, const struct __ns7__GetAllCategory *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAllCategory(soap, "ns1:GetAllCategory", -1, &a->ns1__GetAllCategory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetAllCategory * SOAP_FMAC4 soap_in___ns7__GetAllCategory(struct soap *soap, const char *tag, struct __ns7__GetAllCategory *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCategory = 1;
	short soap_flag;
	a = (struct __ns7__GetAllCategory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetAllCategory, sizeof(struct __ns7__GetAllCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetAllCategory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCategory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCategory(soap, "ns1:GetAllCategory", &a->ns1__GetAllCategory, ""))
				{	soap_flag_ns1__GetAllCategory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetAllCategory(struct soap *soap, const struct __ns7__GetAllCategory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetAllCategory(soap, tag?tag:"-ns7:GetAllCategory", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetAllCategory * SOAP_FMAC4 soap_get___ns7__GetAllCategory(struct soap *soap, struct __ns7__GetAllCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetAllCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetAllCategory * SOAP_FMAC2 soap_instantiate___ns7__GetAllCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetAllCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetAllCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetAllCategory);
		if (size)
			*size = sizeof(struct __ns7__GetAllCategory);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetAllCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetAllCategory);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetAllCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetAllCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetAllCategory %p -> %p\n", q, p));
	*(struct __ns7__GetAllCategory*)p = *(struct __ns7__GetAllCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__GetDicContentByCondition(struct soap *soap, struct __ns7__GetDicContentByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDicContentByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__GetDicContentByCondition(struct soap *soap, const struct __ns7__GetDicContentByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDicContentByCondition(soap, &a->ns1__GetDicContentByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__GetDicContentByCondition(struct soap *soap, const char *tag, int id, const struct __ns7__GetDicContentByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDicContentByCondition(soap, "ns1:GetDicContentByCondition", -1, &a->ns1__GetDicContentByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetDicContentByCondition * SOAP_FMAC4 soap_in___ns7__GetDicContentByCondition(struct soap *soap, const char *tag, struct __ns7__GetDicContentByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetDicContentByCondition = 1;
	short soap_flag;
	a = (struct __ns7__GetDicContentByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__GetDicContentByCondition, sizeof(struct __ns7__GetDicContentByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__GetDicContentByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDicContentByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDicContentByCondition(soap, "ns1:GetDicContentByCondition", &a->ns1__GetDicContentByCondition, ""))
				{	soap_flag_ns1__GetDicContentByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__GetDicContentByCondition(struct soap *soap, const struct __ns7__GetDicContentByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__GetDicContentByCondition(soap, tag?tag:"-ns7:GetDicContentByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__GetDicContentByCondition * SOAP_FMAC4 soap_get___ns7__GetDicContentByCondition(struct soap *soap, struct __ns7__GetDicContentByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__GetDicContentByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__GetDicContentByCondition * SOAP_FMAC2 soap_instantiate___ns7__GetDicContentByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__GetDicContentByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__GetDicContentByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetDicContentByCondition);
		if (size)
			*size = sizeof(struct __ns7__GetDicContentByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__GetDicContentByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__GetDicContentByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__GetDicContentByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__GetDicContentByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__GetDicContentByCondition %p -> %p\n", q, p));
	*(struct __ns7__GetDicContentByCondition*)p = *(struct __ns7__GetDicContentByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetAcountPaymentRecord(struct soap *soap, struct __ns6__GetAcountPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAcountPaymentRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetAcountPaymentRecord(struct soap *soap, const struct __ns6__GetAcountPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAcountPaymentRecord(soap, &a->ns1__GetAcountPaymentRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetAcountPaymentRecord(struct soap *soap, const char *tag, int id, const struct __ns6__GetAcountPaymentRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAcountPaymentRecord(soap, "ns1:GetAcountPaymentRecord", -1, &a->ns1__GetAcountPaymentRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetAcountPaymentRecord * SOAP_FMAC4 soap_in___ns6__GetAcountPaymentRecord(struct soap *soap, const char *tag, struct __ns6__GetAcountPaymentRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetAcountPaymentRecord = 1;
	short soap_flag;
	a = (struct __ns6__GetAcountPaymentRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetAcountPaymentRecord, sizeof(struct __ns6__GetAcountPaymentRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetAcountPaymentRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAcountPaymentRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAcountPaymentRecord(soap, "ns1:GetAcountPaymentRecord", &a->ns1__GetAcountPaymentRecord, ""))
				{	soap_flag_ns1__GetAcountPaymentRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetAcountPaymentRecord(struct soap *soap, const struct __ns6__GetAcountPaymentRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetAcountPaymentRecord(soap, tag?tag:"-ns6:GetAcountPaymentRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetAcountPaymentRecord * SOAP_FMAC4 soap_get___ns6__GetAcountPaymentRecord(struct soap *soap, struct __ns6__GetAcountPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetAcountPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetAcountPaymentRecord * SOAP_FMAC2 soap_instantiate___ns6__GetAcountPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetAcountPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetAcountPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetAcountPaymentRecord);
		if (size)
			*size = sizeof(struct __ns6__GetAcountPaymentRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetAcountPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetAcountPaymentRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetAcountPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetAcountPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetAcountPaymentRecord %p -> %p\n", q, p));
	*(struct __ns6__GetAcountPaymentRecord*)p = *(struct __ns6__GetAcountPaymentRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetReturnRecordDeal(struct soap *soap, struct __ns6__GetReturnRecordDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnRecordDeal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetReturnRecordDeal(struct soap *soap, const struct __ns6__GetReturnRecordDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnRecordDeal(soap, &a->ns1__GetReturnRecordDeal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetReturnRecordDeal(struct soap *soap, const char *tag, int id, const struct __ns6__GetReturnRecordDeal *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnRecordDeal(soap, "ns1:GetReturnRecordDeal", -1, &a->ns1__GetReturnRecordDeal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnRecordDeal * SOAP_FMAC4 soap_in___ns6__GetReturnRecordDeal(struct soap *soap, const char *tag, struct __ns6__GetReturnRecordDeal *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnRecordDeal = 1;
	short soap_flag;
	a = (struct __ns6__GetReturnRecordDeal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetReturnRecordDeal, sizeof(struct __ns6__GetReturnRecordDeal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetReturnRecordDeal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnRecordDeal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnRecordDeal(soap, "ns1:GetReturnRecordDeal", &a->ns1__GetReturnRecordDeal, ""))
				{	soap_flag_ns1__GetReturnRecordDeal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetReturnRecordDeal(struct soap *soap, const struct __ns6__GetReturnRecordDeal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetReturnRecordDeal(soap, tag?tag:"-ns6:GetReturnRecordDeal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnRecordDeal * SOAP_FMAC4 soap_get___ns6__GetReturnRecordDeal(struct soap *soap, struct __ns6__GetReturnRecordDeal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetReturnRecordDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetReturnRecordDeal * SOAP_FMAC2 soap_instantiate___ns6__GetReturnRecordDeal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetReturnRecordDeal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetReturnRecordDeal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnRecordDeal);
		if (size)
			*size = sizeof(struct __ns6__GetReturnRecordDeal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnRecordDeal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetReturnRecordDeal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetReturnRecordDeal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetReturnRecordDeal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetReturnRecordDeal %p -> %p\n", q, p));
	*(struct __ns6__GetReturnRecordDeal*)p = *(struct __ns6__GetReturnRecordDeal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetReturnRecord(struct soap *soap, struct __ns6__GetReturnRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetReturnRecord(struct soap *soap, const struct __ns6__GetReturnRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnRecord(soap, &a->ns1__GetReturnRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetReturnRecord(struct soap *soap, const char *tag, int id, const struct __ns6__GetReturnRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnRecord(soap, "ns1:GetReturnRecord", -1, &a->ns1__GetReturnRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnRecord * SOAP_FMAC4 soap_in___ns6__GetReturnRecord(struct soap *soap, const char *tag, struct __ns6__GetReturnRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnRecord = 1;
	short soap_flag;
	a = (struct __ns6__GetReturnRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetReturnRecord, sizeof(struct __ns6__GetReturnRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetReturnRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnRecord(soap, "ns1:GetReturnRecord", &a->ns1__GetReturnRecord, ""))
				{	soap_flag_ns1__GetReturnRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetReturnRecord(struct soap *soap, const struct __ns6__GetReturnRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetReturnRecord(soap, tag?tag:"-ns6:GetReturnRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnRecord * SOAP_FMAC4 soap_get___ns6__GetReturnRecord(struct soap *soap, struct __ns6__GetReturnRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetReturnRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetReturnRecord * SOAP_FMAC2 soap_instantiate___ns6__GetReturnRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetReturnRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetReturnRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnRecord);
		if (size)
			*size = sizeof(struct __ns6__GetReturnRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetReturnRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetReturnRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetReturnRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetReturnRecord %p -> %p\n", q, p));
	*(struct __ns6__GetReturnRecord*)p = *(struct __ns6__GetReturnRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetUserFunction(struct soap *soap, struct __ns6__GetUserFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetUserFunction(struct soap *soap, const struct __ns6__GetUserFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserFunction(soap, &a->ns1__GetUserFunction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetUserFunction(struct soap *soap, const char *tag, int id, const struct __ns6__GetUserFunction *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUserFunction(soap, "ns1:GetUserFunction", -1, &a->ns1__GetUserFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetUserFunction * SOAP_FMAC4 soap_in___ns6__GetUserFunction(struct soap *soap, const char *tag, struct __ns6__GetUserFunction *a, const char *type)
{
	size_t soap_flag_ns1__GetUserFunction = 1;
	short soap_flag;
	a = (struct __ns6__GetUserFunction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetUserFunction, sizeof(struct __ns6__GetUserFunction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetUserFunction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserFunction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserFunction(soap, "ns1:GetUserFunction", &a->ns1__GetUserFunction, ""))
				{	soap_flag_ns1__GetUserFunction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetUserFunction(struct soap *soap, const struct __ns6__GetUserFunction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetUserFunction(soap, tag?tag:"-ns6:GetUserFunction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetUserFunction * SOAP_FMAC4 soap_get___ns6__GetUserFunction(struct soap *soap, struct __ns6__GetUserFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetUserFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetUserFunction * SOAP_FMAC2 soap_instantiate___ns6__GetUserFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetUserFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetUserFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetUserFunction);
		if (size)
			*size = sizeof(struct __ns6__GetUserFunction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetUserFunction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetUserFunction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetUserFunction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetUserFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetUserFunction %p -> %p\n", q, p));
	*(struct __ns6__GetUserFunction*)p = *(struct __ns6__GetUserFunction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetWorkNameList(struct soap *soap, struct __ns6__GetWorkNameList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWorkNameList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetWorkNameList(struct soap *soap, const struct __ns6__GetWorkNameList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetWorkNameList(soap, &a->ns1__GetWorkNameList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetWorkNameList(struct soap *soap, const char *tag, int id, const struct __ns6__GetWorkNameList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetWorkNameList(soap, "ns1:GetWorkNameList", -1, &a->ns1__GetWorkNameList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetWorkNameList * SOAP_FMAC4 soap_in___ns6__GetWorkNameList(struct soap *soap, const char *tag, struct __ns6__GetWorkNameList *a, const char *type)
{
	size_t soap_flag_ns1__GetWorkNameList = 1;
	short soap_flag;
	a = (struct __ns6__GetWorkNameList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetWorkNameList, sizeof(struct __ns6__GetWorkNameList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetWorkNameList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWorkNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetWorkNameList(soap, "ns1:GetWorkNameList", &a->ns1__GetWorkNameList, ""))
				{	soap_flag_ns1__GetWorkNameList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetWorkNameList(struct soap *soap, const struct __ns6__GetWorkNameList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetWorkNameList(soap, tag?tag:"-ns6:GetWorkNameList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetWorkNameList * SOAP_FMAC4 soap_get___ns6__GetWorkNameList(struct soap *soap, struct __ns6__GetWorkNameList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetWorkNameList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetWorkNameList * SOAP_FMAC2 soap_instantiate___ns6__GetWorkNameList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetWorkNameList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetWorkNameList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetWorkNameList);
		if (size)
			*size = sizeof(struct __ns6__GetWorkNameList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetWorkNameList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetWorkNameList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetWorkNameList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetWorkNameList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetWorkNameList %p -> %p\n", q, p));
	*(struct __ns6__GetWorkNameList*)p = *(struct __ns6__GetWorkNameList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__CharegeReturnedMoney(struct soap *soap, struct __ns6__CharegeReturnedMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CharegeReturnedMoney = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__CharegeReturnedMoney(struct soap *soap, const struct __ns6__CharegeReturnedMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CharegeReturnedMoney(soap, &a->ns1__CharegeReturnedMoney);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__CharegeReturnedMoney(struct soap *soap, const char *tag, int id, const struct __ns6__CharegeReturnedMoney *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CharegeReturnedMoney(soap, "ns1:CharegeReturnedMoney", -1, &a->ns1__CharegeReturnedMoney, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__CharegeReturnedMoney * SOAP_FMAC4 soap_in___ns6__CharegeReturnedMoney(struct soap *soap, const char *tag, struct __ns6__CharegeReturnedMoney *a, const char *type)
{
	size_t soap_flag_ns1__CharegeReturnedMoney = 1;
	short soap_flag;
	a = (struct __ns6__CharegeReturnedMoney *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__CharegeReturnedMoney, sizeof(struct __ns6__CharegeReturnedMoney), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__CharegeReturnedMoney(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CharegeReturnedMoney && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CharegeReturnedMoney(soap, "ns1:CharegeReturnedMoney", &a->ns1__CharegeReturnedMoney, ""))
				{	soap_flag_ns1__CharegeReturnedMoney--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__CharegeReturnedMoney(struct soap *soap, const struct __ns6__CharegeReturnedMoney *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__CharegeReturnedMoney(soap, tag?tag:"-ns6:CharegeReturnedMoney", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__CharegeReturnedMoney * SOAP_FMAC4 soap_get___ns6__CharegeReturnedMoney(struct soap *soap, struct __ns6__CharegeReturnedMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__CharegeReturnedMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__CharegeReturnedMoney * SOAP_FMAC2 soap_instantiate___ns6__CharegeReturnedMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__CharegeReturnedMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__CharegeReturnedMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__CharegeReturnedMoney);
		if (size)
			*size = sizeof(struct __ns6__CharegeReturnedMoney);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__CharegeReturnedMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__CharegeReturnedMoney);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__CharegeReturnedMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__CharegeReturnedMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__CharegeReturnedMoney %p -> %p\n", q, p));
	*(struct __ns6__CharegeReturnedMoney*)p = *(struct __ns6__CharegeReturnedMoney*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetReturnInfo(struct soap *soap, struct __ns6__GetReturnInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetReturnInfo(struct soap *soap, const struct __ns6__GetReturnInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnInfo(soap, &a->ns1__GetReturnInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetReturnInfo(struct soap *soap, const char *tag, int id, const struct __ns6__GetReturnInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnInfo(soap, "ns1:GetReturnInfo", -1, &a->ns1__GetReturnInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnInfo * SOAP_FMAC4 soap_in___ns6__GetReturnInfo(struct soap *soap, const char *tag, struct __ns6__GetReturnInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnInfo = 1;
	short soap_flag;
	a = (struct __ns6__GetReturnInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetReturnInfo, sizeof(struct __ns6__GetReturnInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetReturnInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnInfo(soap, "ns1:GetReturnInfo", &a->ns1__GetReturnInfo, ""))
				{	soap_flag_ns1__GetReturnInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetReturnInfo(struct soap *soap, const struct __ns6__GetReturnInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetReturnInfo(soap, tag?tag:"-ns6:GetReturnInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetReturnInfo * SOAP_FMAC4 soap_get___ns6__GetReturnInfo(struct soap *soap, struct __ns6__GetReturnInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetReturnInfo * SOAP_FMAC2 soap_instantiate___ns6__GetReturnInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetReturnInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetReturnInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnInfo);
		if (size)
			*size = sizeof(struct __ns6__GetReturnInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetReturnInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetReturnInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetReturnInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetReturnInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetReturnInfo %p -> %p\n", q, p));
	*(struct __ns6__GetReturnInfo*)p = *(struct __ns6__GetReturnInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__AddAcountPayment(struct soap *soap, struct __ns6__AddAcountPayment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddAcountPayment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__AddAcountPayment(struct soap *soap, const struct __ns6__AddAcountPayment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddAcountPayment(soap, &a->ns1__AddAcountPayment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__AddAcountPayment(struct soap *soap, const char *tag, int id, const struct __ns6__AddAcountPayment *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddAcountPayment(soap, "ns1:AddAcountPayment", -1, &a->ns1__AddAcountPayment, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AddAcountPayment * SOAP_FMAC4 soap_in___ns6__AddAcountPayment(struct soap *soap, const char *tag, struct __ns6__AddAcountPayment *a, const char *type)
{
	size_t soap_flag_ns1__AddAcountPayment = 1;
	short soap_flag;
	a = (struct __ns6__AddAcountPayment *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__AddAcountPayment, sizeof(struct __ns6__AddAcountPayment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__AddAcountPayment(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddAcountPayment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddAcountPayment(soap, "ns1:AddAcountPayment", &a->ns1__AddAcountPayment, ""))
				{	soap_flag_ns1__AddAcountPayment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__AddAcountPayment(struct soap *soap, const struct __ns6__AddAcountPayment *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__AddAcountPayment(soap, tag?tag:"-ns6:AddAcountPayment", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AddAcountPayment * SOAP_FMAC4 soap_get___ns6__AddAcountPayment(struct soap *soap, struct __ns6__AddAcountPayment *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__AddAcountPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__AddAcountPayment * SOAP_FMAC2 soap_instantiate___ns6__AddAcountPayment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__AddAcountPayment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__AddAcountPayment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AddAcountPayment);
		if (size)
			*size = sizeof(struct __ns6__AddAcountPayment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AddAcountPayment[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__AddAcountPayment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__AddAcountPayment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__AddAcountPayment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__AddAcountPayment %p -> %p\n", q, p));
	*(struct __ns6__AddAcountPayment*)p = *(struct __ns6__AddAcountPayment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__AlterUserInfo(struct soap *soap, struct __ns6__AlterUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__AlterUserInfo(struct soap *soap, const struct __ns6__AlterUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AlterUserInfo(soap, &a->ns1__AlterUserInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__AlterUserInfo(struct soap *soap, const char *tag, int id, const struct __ns6__AlterUserInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AlterUserInfo(soap, "ns1:AlterUserInfo", -1, &a->ns1__AlterUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AlterUserInfo * SOAP_FMAC4 soap_in___ns6__AlterUserInfo(struct soap *soap, const char *tag, struct __ns6__AlterUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__AlterUserInfo = 1;
	short soap_flag;
	a = (struct __ns6__AlterUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__AlterUserInfo, sizeof(struct __ns6__AlterUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__AlterUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AlterUserInfo(soap, "ns1:AlterUserInfo", &a->ns1__AlterUserInfo, ""))
				{	soap_flag_ns1__AlterUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__AlterUserInfo(struct soap *soap, const struct __ns6__AlterUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__AlterUserInfo(soap, tag?tag:"-ns6:AlterUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AlterUserInfo * SOAP_FMAC4 soap_get___ns6__AlterUserInfo(struct soap *soap, struct __ns6__AlterUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__AlterUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__AlterUserInfo * SOAP_FMAC2 soap_instantiate___ns6__AlterUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__AlterUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__AlterUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AlterUserInfo);
		if (size)
			*size = sizeof(struct __ns6__AlterUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AlterUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__AlterUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__AlterUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__AlterUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__AlterUserInfo %p -> %p\n", q, p));
	*(struct __ns6__AlterUserInfo*)p = *(struct __ns6__AlterUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__AlterPsw(struct soap *soap, struct __ns6__AlterPsw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterPsw = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__AlterPsw(struct soap *soap, const struct __ns6__AlterPsw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AlterPsw(soap, &a->ns1__AlterPsw);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__AlterPsw(struct soap *soap, const char *tag, int id, const struct __ns6__AlterPsw *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AlterPsw(soap, "ns1:AlterPsw", -1, &a->ns1__AlterPsw, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AlterPsw * SOAP_FMAC4 soap_in___ns6__AlterPsw(struct soap *soap, const char *tag, struct __ns6__AlterPsw *a, const char *type)
{
	size_t soap_flag_ns1__AlterPsw = 1;
	short soap_flag;
	a = (struct __ns6__AlterPsw *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__AlterPsw, sizeof(struct __ns6__AlterPsw), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__AlterPsw(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterPsw && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AlterPsw(soap, "ns1:AlterPsw", &a->ns1__AlterPsw, ""))
				{	soap_flag_ns1__AlterPsw--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__AlterPsw(struct soap *soap, const struct __ns6__AlterPsw *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__AlterPsw(soap, tag?tag:"-ns6:AlterPsw", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__AlterPsw * SOAP_FMAC4 soap_get___ns6__AlterPsw(struct soap *soap, struct __ns6__AlterPsw *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__AlterPsw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__AlterPsw * SOAP_FMAC2 soap_instantiate___ns6__AlterPsw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__AlterPsw(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__AlterPsw, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AlterPsw);
		if (size)
			*size = sizeof(struct __ns6__AlterPsw);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__AlterPsw[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__AlterPsw);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__AlterPsw*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__AlterPsw(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__AlterPsw %p -> %p\n", q, p));
	*(struct __ns6__AlterPsw*)p = *(struct __ns6__AlterPsw*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__RegisterUser(struct soap *soap, struct __ns6__RegisterUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RegisterUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__RegisterUser(struct soap *soap, const struct __ns6__RegisterUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RegisterUser(soap, &a->ns1__RegisterUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__RegisterUser(struct soap *soap, const char *tag, int id, const struct __ns6__RegisterUser *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RegisterUser(soap, "ns1:RegisterUser", -1, &a->ns1__RegisterUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__RegisterUser * SOAP_FMAC4 soap_in___ns6__RegisterUser(struct soap *soap, const char *tag, struct __ns6__RegisterUser *a, const char *type)
{
	size_t soap_flag_ns1__RegisterUser = 1;
	short soap_flag;
	a = (struct __ns6__RegisterUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__RegisterUser, sizeof(struct __ns6__RegisterUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__RegisterUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RegisterUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RegisterUser(soap, "ns1:RegisterUser", &a->ns1__RegisterUser, ""))
				{	soap_flag_ns1__RegisterUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__RegisterUser(struct soap *soap, const struct __ns6__RegisterUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__RegisterUser(soap, tag?tag:"-ns6:RegisterUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__RegisterUser * SOAP_FMAC4 soap_get___ns6__RegisterUser(struct soap *soap, struct __ns6__RegisterUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__RegisterUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__RegisterUser * SOAP_FMAC2 soap_instantiate___ns6__RegisterUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__RegisterUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__RegisterUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__RegisterUser);
		if (size)
			*size = sizeof(struct __ns6__RegisterUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__RegisterUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__RegisterUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__RegisterUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__RegisterUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__RegisterUser %p -> %p\n", q, p));
	*(struct __ns6__RegisterUser*)p = *(struct __ns6__RegisterUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__GetUserInfo(struct soap *soap, struct __ns6__GetUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__GetUserInfo(struct soap *soap, const struct __ns6__GetUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserInfo(soap, &a->ns1__GetUserInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__GetUserInfo(struct soap *soap, const char *tag, int id, const struct __ns6__GetUserInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUserInfo(soap, "ns1:GetUserInfo", -1, &a->ns1__GetUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetUserInfo * SOAP_FMAC4 soap_in___ns6__GetUserInfo(struct soap *soap, const char *tag, struct __ns6__GetUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetUserInfo = 1;
	short soap_flag;
	a = (struct __ns6__GetUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__GetUserInfo, sizeof(struct __ns6__GetUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__GetUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserInfo(soap, "ns1:GetUserInfo", &a->ns1__GetUserInfo, ""))
				{	soap_flag_ns1__GetUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__GetUserInfo(struct soap *soap, const struct __ns6__GetUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__GetUserInfo(soap, tag?tag:"-ns6:GetUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__GetUserInfo * SOAP_FMAC4 soap_get___ns6__GetUserInfo(struct soap *soap, struct __ns6__GetUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__GetUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__GetUserInfo * SOAP_FMAC2 soap_instantiate___ns6__GetUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__GetUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__GetUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetUserInfo);
		if (size)
			*size = sizeof(struct __ns6__GetUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__GetUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__GetUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__GetUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__GetUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__GetUserInfo %p -> %p\n", q, p));
	*(struct __ns6__GetUserInfo*)p = *(struct __ns6__GetUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__TestLogin(struct soap *soap, struct __ns6__TestLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TestLogin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__TestLogin(struct soap *soap, const struct __ns6__TestLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TestLogin(soap, &a->ns1__TestLogin);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__TestLogin(struct soap *soap, const char *tag, int id, const struct __ns6__TestLogin *a, const char *type)
{
	if (soap_out_PointerTo_ns1__TestLogin(soap, "ns1:TestLogin", -1, &a->ns1__TestLogin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__TestLogin * SOAP_FMAC4 soap_in___ns6__TestLogin(struct soap *soap, const char *tag, struct __ns6__TestLogin *a, const char *type)
{
	size_t soap_flag_ns1__TestLogin = 1;
	short soap_flag;
	a = (struct __ns6__TestLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__TestLogin, sizeof(struct __ns6__TestLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__TestLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TestLogin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TestLogin(soap, "ns1:TestLogin", &a->ns1__TestLogin, ""))
				{	soap_flag_ns1__TestLogin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__TestLogin(struct soap *soap, const struct __ns6__TestLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__TestLogin(soap, tag?tag:"-ns6:TestLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__TestLogin * SOAP_FMAC4 soap_get___ns6__TestLogin(struct soap *soap, struct __ns6__TestLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__TestLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__TestLogin * SOAP_FMAC2 soap_instantiate___ns6__TestLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__TestLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__TestLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__TestLogin);
		if (size)
			*size = sizeof(struct __ns6__TestLogin);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__TestLogin[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__TestLogin);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__TestLogin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__TestLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__TestLogin %p -> %p\n", q, p));
	*(struct __ns6__TestLogin*)p = *(struct __ns6__TestLogin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__loggout(struct soap *soap, struct __ns6__loggout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loggout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__loggout(struct soap *soap, const struct __ns6__loggout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__loggout(soap, &a->ns1__loggout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__loggout(struct soap *soap, const char *tag, int id, const struct __ns6__loggout *a, const char *type)
{
	if (soap_out_PointerTo_ns1__loggout(soap, "ns1:loggout", -1, &a->ns1__loggout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__loggout * SOAP_FMAC4 soap_in___ns6__loggout(struct soap *soap, const char *tag, struct __ns6__loggout *a, const char *type)
{
	size_t soap_flag_ns1__loggout = 1;
	short soap_flag;
	a = (struct __ns6__loggout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__loggout, sizeof(struct __ns6__loggout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__loggout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loggout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__loggout(soap, "ns1:loggout", &a->ns1__loggout, ""))
				{	soap_flag_ns1__loggout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__loggout(struct soap *soap, const struct __ns6__loggout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__loggout(soap, tag?tag:"-ns6:loggout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__loggout * SOAP_FMAC4 soap_get___ns6__loggout(struct soap *soap, struct __ns6__loggout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__loggout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__loggout * SOAP_FMAC2 soap_instantiate___ns6__loggout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__loggout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__loggout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__loggout);
		if (size)
			*size = sizeof(struct __ns6__loggout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__loggout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__loggout);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__loggout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__loggout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__loggout %p -> %p\n", q, p));
	*(struct __ns6__loggout*)p = *(struct __ns6__loggout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__HelloWorld(struct soap *soap, struct __ns6__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__HelloWorld(struct soap *soap, const struct __ns6__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__HelloWorld(struct soap *soap, const char *tag, int id, const struct __ns6__HelloWorld *a, const char *type)
{
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__HelloWorld * SOAP_FMAC4 soap_in___ns6__HelloWorld(struct soap *soap, const char *tag, struct __ns6__HelloWorld *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	a = (struct __ns6__HelloWorld *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__HelloWorld, sizeof(struct __ns6__HelloWorld), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__HelloWorld(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__HelloWorld(struct soap *soap, const struct __ns6__HelloWorld *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__HelloWorld(soap, tag?tag:"-ns6:HelloWorld", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__HelloWorld * SOAP_FMAC4 soap_get___ns6__HelloWorld(struct soap *soap, struct __ns6__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns6__HelloWorld * SOAP_FMAC2 soap_instantiate___ns6__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__HelloWorld(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__HelloWorld, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__HelloWorld);
		if (size)
			*size = sizeof(struct __ns6__HelloWorld);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns6__HelloWorld[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__HelloWorld);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__HelloWorld*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__HelloWorld(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__HelloWorld %p -> %p\n", q, p));
	*(struct __ns6__HelloWorld*)p = *(struct __ns6__HelloWorld*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetAcountPaymentRecord(struct soap *soap, struct __ns5__GetAcountPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAcountPaymentRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetAcountPaymentRecord(struct soap *soap, const struct __ns5__GetAcountPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAcountPaymentRecord(soap, &a->ns1__GetAcountPaymentRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetAcountPaymentRecord(struct soap *soap, const char *tag, int id, const struct __ns5__GetAcountPaymentRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAcountPaymentRecord(soap, "ns1:GetAcountPaymentRecord", -1, &a->ns1__GetAcountPaymentRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetAcountPaymentRecord * SOAP_FMAC4 soap_in___ns5__GetAcountPaymentRecord(struct soap *soap, const char *tag, struct __ns5__GetAcountPaymentRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetAcountPaymentRecord = 1;
	short soap_flag;
	a = (struct __ns5__GetAcountPaymentRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetAcountPaymentRecord, sizeof(struct __ns5__GetAcountPaymentRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetAcountPaymentRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAcountPaymentRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAcountPaymentRecord(soap, "ns1:GetAcountPaymentRecord", &a->ns1__GetAcountPaymentRecord, ""))
				{	soap_flag_ns1__GetAcountPaymentRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetAcountPaymentRecord(struct soap *soap, const struct __ns5__GetAcountPaymentRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetAcountPaymentRecord(soap, tag?tag:"-ns5:GetAcountPaymentRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetAcountPaymentRecord * SOAP_FMAC4 soap_get___ns5__GetAcountPaymentRecord(struct soap *soap, struct __ns5__GetAcountPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetAcountPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetAcountPaymentRecord * SOAP_FMAC2 soap_instantiate___ns5__GetAcountPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetAcountPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetAcountPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetAcountPaymentRecord);
		if (size)
			*size = sizeof(struct __ns5__GetAcountPaymentRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetAcountPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetAcountPaymentRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetAcountPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetAcountPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetAcountPaymentRecord %p -> %p\n", q, p));
	*(struct __ns5__GetAcountPaymentRecord*)p = *(struct __ns5__GetAcountPaymentRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetReturnRecordDeal(struct soap *soap, struct __ns5__GetReturnRecordDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnRecordDeal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetReturnRecordDeal(struct soap *soap, const struct __ns5__GetReturnRecordDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnRecordDeal(soap, &a->ns1__GetReturnRecordDeal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetReturnRecordDeal(struct soap *soap, const char *tag, int id, const struct __ns5__GetReturnRecordDeal *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnRecordDeal(soap, "ns1:GetReturnRecordDeal", -1, &a->ns1__GetReturnRecordDeal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnRecordDeal * SOAP_FMAC4 soap_in___ns5__GetReturnRecordDeal(struct soap *soap, const char *tag, struct __ns5__GetReturnRecordDeal *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnRecordDeal = 1;
	short soap_flag;
	a = (struct __ns5__GetReturnRecordDeal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetReturnRecordDeal, sizeof(struct __ns5__GetReturnRecordDeal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetReturnRecordDeal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnRecordDeal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnRecordDeal(soap, "ns1:GetReturnRecordDeal", &a->ns1__GetReturnRecordDeal, ""))
				{	soap_flag_ns1__GetReturnRecordDeal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetReturnRecordDeal(struct soap *soap, const struct __ns5__GetReturnRecordDeal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetReturnRecordDeal(soap, tag?tag:"-ns5:GetReturnRecordDeal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnRecordDeal * SOAP_FMAC4 soap_get___ns5__GetReturnRecordDeal(struct soap *soap, struct __ns5__GetReturnRecordDeal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetReturnRecordDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetReturnRecordDeal * SOAP_FMAC2 soap_instantiate___ns5__GetReturnRecordDeal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetReturnRecordDeal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetReturnRecordDeal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnRecordDeal);
		if (size)
			*size = sizeof(struct __ns5__GetReturnRecordDeal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnRecordDeal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetReturnRecordDeal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetReturnRecordDeal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetReturnRecordDeal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetReturnRecordDeal %p -> %p\n", q, p));
	*(struct __ns5__GetReturnRecordDeal*)p = *(struct __ns5__GetReturnRecordDeal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetReturnRecord(struct soap *soap, struct __ns5__GetReturnRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetReturnRecord(struct soap *soap, const struct __ns5__GetReturnRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnRecord(soap, &a->ns1__GetReturnRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetReturnRecord(struct soap *soap, const char *tag, int id, const struct __ns5__GetReturnRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnRecord(soap, "ns1:GetReturnRecord", -1, &a->ns1__GetReturnRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnRecord * SOAP_FMAC4 soap_in___ns5__GetReturnRecord(struct soap *soap, const char *tag, struct __ns5__GetReturnRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnRecord = 1;
	short soap_flag;
	a = (struct __ns5__GetReturnRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetReturnRecord, sizeof(struct __ns5__GetReturnRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetReturnRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnRecord(soap, "ns1:GetReturnRecord", &a->ns1__GetReturnRecord, ""))
				{	soap_flag_ns1__GetReturnRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetReturnRecord(struct soap *soap, const struct __ns5__GetReturnRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetReturnRecord(soap, tag?tag:"-ns5:GetReturnRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnRecord * SOAP_FMAC4 soap_get___ns5__GetReturnRecord(struct soap *soap, struct __ns5__GetReturnRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetReturnRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetReturnRecord * SOAP_FMAC2 soap_instantiate___ns5__GetReturnRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetReturnRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetReturnRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnRecord);
		if (size)
			*size = sizeof(struct __ns5__GetReturnRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetReturnRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetReturnRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetReturnRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetReturnRecord %p -> %p\n", q, p));
	*(struct __ns5__GetReturnRecord*)p = *(struct __ns5__GetReturnRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetUserFunction(struct soap *soap, struct __ns5__GetUserFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetUserFunction(struct soap *soap, const struct __ns5__GetUserFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserFunction(soap, &a->ns1__GetUserFunction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetUserFunction(struct soap *soap, const char *tag, int id, const struct __ns5__GetUserFunction *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUserFunction(soap, "ns1:GetUserFunction", -1, &a->ns1__GetUserFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetUserFunction * SOAP_FMAC4 soap_in___ns5__GetUserFunction(struct soap *soap, const char *tag, struct __ns5__GetUserFunction *a, const char *type)
{
	size_t soap_flag_ns1__GetUserFunction = 1;
	short soap_flag;
	a = (struct __ns5__GetUserFunction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetUserFunction, sizeof(struct __ns5__GetUserFunction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetUserFunction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserFunction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserFunction(soap, "ns1:GetUserFunction", &a->ns1__GetUserFunction, ""))
				{	soap_flag_ns1__GetUserFunction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetUserFunction(struct soap *soap, const struct __ns5__GetUserFunction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetUserFunction(soap, tag?tag:"-ns5:GetUserFunction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetUserFunction * SOAP_FMAC4 soap_get___ns5__GetUserFunction(struct soap *soap, struct __ns5__GetUserFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetUserFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetUserFunction * SOAP_FMAC2 soap_instantiate___ns5__GetUserFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetUserFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetUserFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetUserFunction);
		if (size)
			*size = sizeof(struct __ns5__GetUserFunction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetUserFunction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetUserFunction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetUserFunction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetUserFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetUserFunction %p -> %p\n", q, p));
	*(struct __ns5__GetUserFunction*)p = *(struct __ns5__GetUserFunction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetWorkNameList(struct soap *soap, struct __ns5__GetWorkNameList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWorkNameList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetWorkNameList(struct soap *soap, const struct __ns5__GetWorkNameList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetWorkNameList(soap, &a->ns1__GetWorkNameList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetWorkNameList(struct soap *soap, const char *tag, int id, const struct __ns5__GetWorkNameList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetWorkNameList(soap, "ns1:GetWorkNameList", -1, &a->ns1__GetWorkNameList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetWorkNameList * SOAP_FMAC4 soap_in___ns5__GetWorkNameList(struct soap *soap, const char *tag, struct __ns5__GetWorkNameList *a, const char *type)
{
	size_t soap_flag_ns1__GetWorkNameList = 1;
	short soap_flag;
	a = (struct __ns5__GetWorkNameList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetWorkNameList, sizeof(struct __ns5__GetWorkNameList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetWorkNameList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWorkNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetWorkNameList(soap, "ns1:GetWorkNameList", &a->ns1__GetWorkNameList, ""))
				{	soap_flag_ns1__GetWorkNameList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetWorkNameList(struct soap *soap, const struct __ns5__GetWorkNameList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetWorkNameList(soap, tag?tag:"-ns5:GetWorkNameList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetWorkNameList * SOAP_FMAC4 soap_get___ns5__GetWorkNameList(struct soap *soap, struct __ns5__GetWorkNameList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetWorkNameList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetWorkNameList * SOAP_FMAC2 soap_instantiate___ns5__GetWorkNameList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetWorkNameList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetWorkNameList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetWorkNameList);
		if (size)
			*size = sizeof(struct __ns5__GetWorkNameList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetWorkNameList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetWorkNameList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetWorkNameList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetWorkNameList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetWorkNameList %p -> %p\n", q, p));
	*(struct __ns5__GetWorkNameList*)p = *(struct __ns5__GetWorkNameList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__CharegeReturnedMoney(struct soap *soap, struct __ns5__CharegeReturnedMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CharegeReturnedMoney = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__CharegeReturnedMoney(struct soap *soap, const struct __ns5__CharegeReturnedMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CharegeReturnedMoney(soap, &a->ns1__CharegeReturnedMoney);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__CharegeReturnedMoney(struct soap *soap, const char *tag, int id, const struct __ns5__CharegeReturnedMoney *a, const char *type)
{
	if (soap_out_PointerTo_ns1__CharegeReturnedMoney(soap, "ns1:CharegeReturnedMoney", -1, &a->ns1__CharegeReturnedMoney, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__CharegeReturnedMoney * SOAP_FMAC4 soap_in___ns5__CharegeReturnedMoney(struct soap *soap, const char *tag, struct __ns5__CharegeReturnedMoney *a, const char *type)
{
	size_t soap_flag_ns1__CharegeReturnedMoney = 1;
	short soap_flag;
	a = (struct __ns5__CharegeReturnedMoney *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__CharegeReturnedMoney, sizeof(struct __ns5__CharegeReturnedMoney), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__CharegeReturnedMoney(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CharegeReturnedMoney && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CharegeReturnedMoney(soap, "ns1:CharegeReturnedMoney", &a->ns1__CharegeReturnedMoney, ""))
				{	soap_flag_ns1__CharegeReturnedMoney--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__CharegeReturnedMoney(struct soap *soap, const struct __ns5__CharegeReturnedMoney *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__CharegeReturnedMoney(soap, tag?tag:"-ns5:CharegeReturnedMoney", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__CharegeReturnedMoney * SOAP_FMAC4 soap_get___ns5__CharegeReturnedMoney(struct soap *soap, struct __ns5__CharegeReturnedMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__CharegeReturnedMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__CharegeReturnedMoney * SOAP_FMAC2 soap_instantiate___ns5__CharegeReturnedMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__CharegeReturnedMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__CharegeReturnedMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__CharegeReturnedMoney);
		if (size)
			*size = sizeof(struct __ns5__CharegeReturnedMoney);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__CharegeReturnedMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__CharegeReturnedMoney);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__CharegeReturnedMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__CharegeReturnedMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__CharegeReturnedMoney %p -> %p\n", q, p));
	*(struct __ns5__CharegeReturnedMoney*)p = *(struct __ns5__CharegeReturnedMoney*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetReturnInfo(struct soap *soap, struct __ns5__GetReturnInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReturnInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetReturnInfo(struct soap *soap, const struct __ns5__GetReturnInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetReturnInfo(soap, &a->ns1__GetReturnInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetReturnInfo(struct soap *soap, const char *tag, int id, const struct __ns5__GetReturnInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetReturnInfo(soap, "ns1:GetReturnInfo", -1, &a->ns1__GetReturnInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnInfo * SOAP_FMAC4 soap_in___ns5__GetReturnInfo(struct soap *soap, const char *tag, struct __ns5__GetReturnInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetReturnInfo = 1;
	short soap_flag;
	a = (struct __ns5__GetReturnInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetReturnInfo, sizeof(struct __ns5__GetReturnInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetReturnInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReturnInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReturnInfo(soap, "ns1:GetReturnInfo", &a->ns1__GetReturnInfo, ""))
				{	soap_flag_ns1__GetReturnInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetReturnInfo(struct soap *soap, const struct __ns5__GetReturnInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetReturnInfo(soap, tag?tag:"-ns5:GetReturnInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetReturnInfo * SOAP_FMAC4 soap_get___ns5__GetReturnInfo(struct soap *soap, struct __ns5__GetReturnInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetReturnInfo * SOAP_FMAC2 soap_instantiate___ns5__GetReturnInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetReturnInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetReturnInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnInfo);
		if (size)
			*size = sizeof(struct __ns5__GetReturnInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetReturnInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetReturnInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetReturnInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetReturnInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetReturnInfo %p -> %p\n", q, p));
	*(struct __ns5__GetReturnInfo*)p = *(struct __ns5__GetReturnInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AddAcountPayment(struct soap *soap, struct __ns5__AddAcountPayment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddAcountPayment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AddAcountPayment(struct soap *soap, const struct __ns5__AddAcountPayment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddAcountPayment(soap, &a->ns1__AddAcountPayment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AddAcountPayment(struct soap *soap, const char *tag, int id, const struct __ns5__AddAcountPayment *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddAcountPayment(soap, "ns1:AddAcountPayment", -1, &a->ns1__AddAcountPayment, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddAcountPayment * SOAP_FMAC4 soap_in___ns5__AddAcountPayment(struct soap *soap, const char *tag, struct __ns5__AddAcountPayment *a, const char *type)
{
	size_t soap_flag_ns1__AddAcountPayment = 1;
	short soap_flag;
	a = (struct __ns5__AddAcountPayment *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AddAcountPayment, sizeof(struct __ns5__AddAcountPayment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AddAcountPayment(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddAcountPayment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddAcountPayment(soap, "ns1:AddAcountPayment", &a->ns1__AddAcountPayment, ""))
				{	soap_flag_ns1__AddAcountPayment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AddAcountPayment(struct soap *soap, const struct __ns5__AddAcountPayment *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__AddAcountPayment(soap, tag?tag:"-ns5:AddAcountPayment", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddAcountPayment * SOAP_FMAC4 soap_get___ns5__AddAcountPayment(struct soap *soap, struct __ns5__AddAcountPayment *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AddAcountPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__AddAcountPayment * SOAP_FMAC2 soap_instantiate___ns5__AddAcountPayment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AddAcountPayment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__AddAcountPayment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AddAcountPayment);
		if (size)
			*size = sizeof(struct __ns5__AddAcountPayment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AddAcountPayment[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__AddAcountPayment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__AddAcountPayment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__AddAcountPayment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__AddAcountPayment %p -> %p\n", q, p));
	*(struct __ns5__AddAcountPayment*)p = *(struct __ns5__AddAcountPayment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AlterUserInfo(struct soap *soap, struct __ns5__AlterUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AlterUserInfo(struct soap *soap, const struct __ns5__AlterUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AlterUserInfo(soap, &a->ns1__AlterUserInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AlterUserInfo(struct soap *soap, const char *tag, int id, const struct __ns5__AlterUserInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AlterUserInfo(soap, "ns1:AlterUserInfo", -1, &a->ns1__AlterUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AlterUserInfo * SOAP_FMAC4 soap_in___ns5__AlterUserInfo(struct soap *soap, const char *tag, struct __ns5__AlterUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__AlterUserInfo = 1;
	short soap_flag;
	a = (struct __ns5__AlterUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AlterUserInfo, sizeof(struct __ns5__AlterUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AlterUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AlterUserInfo(soap, "ns1:AlterUserInfo", &a->ns1__AlterUserInfo, ""))
				{	soap_flag_ns1__AlterUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AlterUserInfo(struct soap *soap, const struct __ns5__AlterUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__AlterUserInfo(soap, tag?tag:"-ns5:AlterUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AlterUserInfo * SOAP_FMAC4 soap_get___ns5__AlterUserInfo(struct soap *soap, struct __ns5__AlterUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AlterUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__AlterUserInfo * SOAP_FMAC2 soap_instantiate___ns5__AlterUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AlterUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__AlterUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AlterUserInfo);
		if (size)
			*size = sizeof(struct __ns5__AlterUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AlterUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__AlterUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__AlterUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__AlterUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__AlterUserInfo %p -> %p\n", q, p));
	*(struct __ns5__AlterUserInfo*)p = *(struct __ns5__AlterUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AlterPsw(struct soap *soap, struct __ns5__AlterPsw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterPsw = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AlterPsw(struct soap *soap, const struct __ns5__AlterPsw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AlterPsw(soap, &a->ns1__AlterPsw);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AlterPsw(struct soap *soap, const char *tag, int id, const struct __ns5__AlterPsw *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AlterPsw(soap, "ns1:AlterPsw", -1, &a->ns1__AlterPsw, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AlterPsw * SOAP_FMAC4 soap_in___ns5__AlterPsw(struct soap *soap, const char *tag, struct __ns5__AlterPsw *a, const char *type)
{
	size_t soap_flag_ns1__AlterPsw = 1;
	short soap_flag;
	a = (struct __ns5__AlterPsw *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AlterPsw, sizeof(struct __ns5__AlterPsw), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AlterPsw(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterPsw && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AlterPsw(soap, "ns1:AlterPsw", &a->ns1__AlterPsw, ""))
				{	soap_flag_ns1__AlterPsw--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AlterPsw(struct soap *soap, const struct __ns5__AlterPsw *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__AlterPsw(soap, tag?tag:"-ns5:AlterPsw", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AlterPsw * SOAP_FMAC4 soap_get___ns5__AlterPsw(struct soap *soap, struct __ns5__AlterPsw *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AlterPsw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__AlterPsw * SOAP_FMAC2 soap_instantiate___ns5__AlterPsw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AlterPsw(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__AlterPsw, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AlterPsw);
		if (size)
			*size = sizeof(struct __ns5__AlterPsw);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__AlterPsw[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__AlterPsw);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__AlterPsw*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__AlterPsw(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__AlterPsw %p -> %p\n", q, p));
	*(struct __ns5__AlterPsw*)p = *(struct __ns5__AlterPsw*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__RegisterUser(struct soap *soap, struct __ns5__RegisterUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RegisterUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__RegisterUser(struct soap *soap, const struct __ns5__RegisterUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RegisterUser(soap, &a->ns1__RegisterUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__RegisterUser(struct soap *soap, const char *tag, int id, const struct __ns5__RegisterUser *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RegisterUser(soap, "ns1:RegisterUser", -1, &a->ns1__RegisterUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RegisterUser * SOAP_FMAC4 soap_in___ns5__RegisterUser(struct soap *soap, const char *tag, struct __ns5__RegisterUser *a, const char *type)
{
	size_t soap_flag_ns1__RegisterUser = 1;
	short soap_flag;
	a = (struct __ns5__RegisterUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__RegisterUser, sizeof(struct __ns5__RegisterUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__RegisterUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RegisterUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RegisterUser(soap, "ns1:RegisterUser", &a->ns1__RegisterUser, ""))
				{	soap_flag_ns1__RegisterUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__RegisterUser(struct soap *soap, const struct __ns5__RegisterUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__RegisterUser(soap, tag?tag:"-ns5:RegisterUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RegisterUser * SOAP_FMAC4 soap_get___ns5__RegisterUser(struct soap *soap, struct __ns5__RegisterUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__RegisterUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__RegisterUser * SOAP_FMAC2 soap_instantiate___ns5__RegisterUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__RegisterUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__RegisterUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__RegisterUser);
		if (size)
			*size = sizeof(struct __ns5__RegisterUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__RegisterUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__RegisterUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__RegisterUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__RegisterUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__RegisterUser %p -> %p\n", q, p));
	*(struct __ns5__RegisterUser*)p = *(struct __ns5__RegisterUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetUserInfo(struct soap *soap, struct __ns5__GetUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetUserInfo(struct soap *soap, const struct __ns5__GetUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserInfo(soap, &a->ns1__GetUserInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetUserInfo(struct soap *soap, const char *tag, int id, const struct __ns5__GetUserInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUserInfo(soap, "ns1:GetUserInfo", -1, &a->ns1__GetUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetUserInfo * SOAP_FMAC4 soap_in___ns5__GetUserInfo(struct soap *soap, const char *tag, struct __ns5__GetUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetUserInfo = 1;
	short soap_flag;
	a = (struct __ns5__GetUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetUserInfo, sizeof(struct __ns5__GetUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserInfo(soap, "ns1:GetUserInfo", &a->ns1__GetUserInfo, ""))
				{	soap_flag_ns1__GetUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetUserInfo(struct soap *soap, const struct __ns5__GetUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__GetUserInfo(soap, tag?tag:"-ns5:GetUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetUserInfo * SOAP_FMAC4 soap_get___ns5__GetUserInfo(struct soap *soap, struct __ns5__GetUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__GetUserInfo * SOAP_FMAC2 soap_instantiate___ns5__GetUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__GetUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetUserInfo);
		if (size)
			*size = sizeof(struct __ns5__GetUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__GetUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__GetUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__GetUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__GetUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__GetUserInfo %p -> %p\n", q, p));
	*(struct __ns5__GetUserInfo*)p = *(struct __ns5__GetUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__TestLogin(struct soap *soap, struct __ns5__TestLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TestLogin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__TestLogin(struct soap *soap, const struct __ns5__TestLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__TestLogin(soap, &a->ns1__TestLogin);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__TestLogin(struct soap *soap, const char *tag, int id, const struct __ns5__TestLogin *a, const char *type)
{
	if (soap_out_PointerTo_ns1__TestLogin(soap, "ns1:TestLogin", -1, &a->ns1__TestLogin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__TestLogin * SOAP_FMAC4 soap_in___ns5__TestLogin(struct soap *soap, const char *tag, struct __ns5__TestLogin *a, const char *type)
{
	size_t soap_flag_ns1__TestLogin = 1;
	short soap_flag;
	a = (struct __ns5__TestLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__TestLogin, sizeof(struct __ns5__TestLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__TestLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TestLogin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TestLogin(soap, "ns1:TestLogin", &a->ns1__TestLogin, ""))
				{	soap_flag_ns1__TestLogin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__TestLogin(struct soap *soap, const struct __ns5__TestLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__TestLogin(soap, tag?tag:"-ns5:TestLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__TestLogin * SOAP_FMAC4 soap_get___ns5__TestLogin(struct soap *soap, struct __ns5__TestLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__TestLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__TestLogin * SOAP_FMAC2 soap_instantiate___ns5__TestLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__TestLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__TestLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__TestLogin);
		if (size)
			*size = sizeof(struct __ns5__TestLogin);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__TestLogin[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__TestLogin);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__TestLogin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__TestLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__TestLogin %p -> %p\n", q, p));
	*(struct __ns5__TestLogin*)p = *(struct __ns5__TestLogin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__loggout(struct soap *soap, struct __ns5__loggout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loggout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__loggout(struct soap *soap, const struct __ns5__loggout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__loggout(soap, &a->ns1__loggout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__loggout(struct soap *soap, const char *tag, int id, const struct __ns5__loggout *a, const char *type)
{
	if (soap_out_PointerTo_ns1__loggout(soap, "ns1:loggout", -1, &a->ns1__loggout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__loggout * SOAP_FMAC4 soap_in___ns5__loggout(struct soap *soap, const char *tag, struct __ns5__loggout *a, const char *type)
{
	size_t soap_flag_ns1__loggout = 1;
	short soap_flag;
	a = (struct __ns5__loggout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__loggout, sizeof(struct __ns5__loggout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__loggout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loggout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__loggout(soap, "ns1:loggout", &a->ns1__loggout, ""))
				{	soap_flag_ns1__loggout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__loggout(struct soap *soap, const struct __ns5__loggout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__loggout(soap, tag?tag:"-ns5:loggout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__loggout * SOAP_FMAC4 soap_get___ns5__loggout(struct soap *soap, struct __ns5__loggout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__loggout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__loggout * SOAP_FMAC2 soap_instantiate___ns5__loggout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__loggout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__loggout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__loggout);
		if (size)
			*size = sizeof(struct __ns5__loggout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__loggout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__loggout);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__loggout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__loggout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__loggout %p -> %p\n", q, p));
	*(struct __ns5__loggout*)p = *(struct __ns5__loggout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__HelloWorld(struct soap *soap, struct __ns5__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__HelloWorld(struct soap *soap, const struct __ns5__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__HelloWorld(struct soap *soap, const char *tag, int id, const struct __ns5__HelloWorld *a, const char *type)
{
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__HelloWorld * SOAP_FMAC4 soap_in___ns5__HelloWorld(struct soap *soap, const char *tag, struct __ns5__HelloWorld *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	a = (struct __ns5__HelloWorld *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__HelloWorld, sizeof(struct __ns5__HelloWorld), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__HelloWorld(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__HelloWorld(struct soap *soap, const struct __ns5__HelloWorld *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__HelloWorld(soap, tag?tag:"-ns5:HelloWorld", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__HelloWorld * SOAP_FMAC4 soap_get___ns5__HelloWorld(struct soap *soap, struct __ns5__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__HelloWorld * SOAP_FMAC2 soap_instantiate___ns5__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__HelloWorld(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__HelloWorld, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__HelloWorld);
		if (size)
			*size = sizeof(struct __ns5__HelloWorld);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__HelloWorld[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns5__HelloWorld);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__HelloWorld*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__HelloWorld(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__HelloWorld %p -> %p\n", q, p));
	*(struct __ns5__HelloWorld*)p = *(struct __ns5__HelloWorld*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, struct __ns4__GetPayPublicTelHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayPublicTelHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, const struct __ns4__GetPayPublicTelHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, &a->ns1__GetPayPublicTelHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, "ns1:GetPayPublicTelHistoryByCondition", -1, &a->ns1__GetPayPublicTelHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_in___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayPublicTelHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayPublicTelHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayPublicTelHistoryByCondition, sizeof(struct __ns4__GetPayPublicTelHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayPublicTelHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayPublicTelHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, "ns1:GetPayPublicTelHistoryByCondition", &a->ns1__GetPayPublicTelHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayPublicTelHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, const struct __ns4__GetPayPublicTelHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayPublicTelHistoryByCondition(soap, tag?tag:"-ns4:GetPayPublicTelHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_get___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, struct __ns4__GetPayPublicTelHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayPublicTelHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayPublicTelHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayPublicTelHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayPublicTelHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayPublicTelHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayPublicTelHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayPublicTelHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayPublicTelHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayPublicTelHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayPublicTelHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayPublicTelHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayPublicTelHistoryByCondition*)p = *(struct __ns4__GetPayPublicTelHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayPublicTelByCondition(struct soap *soap, struct __ns4__GetPayPublicTelByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayPublicTelByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayPublicTelByCondition(struct soap *soap, const struct __ns4__GetPayPublicTelByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayPublicTelByCondition(soap, &a->ns1__GetPayPublicTelByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayPublicTelByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayPublicTelByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayPublicTelByCondition(soap, "ns1:GetPayPublicTelByCondition", -1, &a->ns1__GetPayPublicTelByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayPublicTelByCondition * SOAP_FMAC4 soap_in___ns4__GetPayPublicTelByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayPublicTelByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayPublicTelByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayPublicTelByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayPublicTelByCondition, sizeof(struct __ns4__GetPayPublicTelByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayPublicTelByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayPublicTelByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayPublicTelByCondition(soap, "ns1:GetPayPublicTelByCondition", &a->ns1__GetPayPublicTelByCondition, ""))
				{	soap_flag_ns1__GetPayPublicTelByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayPublicTelByCondition(struct soap *soap, const struct __ns4__GetPayPublicTelByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayPublicTelByCondition(soap, tag?tag:"-ns4:GetPayPublicTelByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayPublicTelByCondition * SOAP_FMAC4 soap_get___ns4__GetPayPublicTelByCondition(struct soap *soap, struct __ns4__GetPayPublicTelByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayPublicTelByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayPublicTelByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayPublicTelByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayPublicTelByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayPublicTelByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayPublicTelByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayPublicTelByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayPublicTelByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayPublicTelByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayPublicTelByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayPublicTelByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayPublicTelByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayPublicTelByCondition*)p = *(struct __ns4__GetPayPublicTelByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayGameHistoryByCondition(struct soap *soap, struct __ns4__GetPayGameHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayGameHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayGameHistoryByCondition(struct soap *soap, const struct __ns4__GetPayGameHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayGameHistoryByCondition(soap, &a->ns1__GetPayGameHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayGameHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayGameHistoryByCondition(soap, "ns1:GetPayGameHistoryByCondition", -1, &a->ns1__GetPayGameHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_in___ns4__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayGameHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayGameHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayGameHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayGameHistoryByCondition, sizeof(struct __ns4__GetPayGameHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayGameHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayGameHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayGameHistoryByCondition(soap, "ns1:GetPayGameHistoryByCondition", &a->ns1__GetPayGameHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayGameHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayGameHistoryByCondition(struct soap *soap, const struct __ns4__GetPayGameHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayGameHistoryByCondition(soap, tag?tag:"-ns4:GetPayGameHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_get___ns4__GetPayGameHistoryByCondition(struct soap *soap, struct __ns4__GetPayGameHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayGameHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayGameHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayGameHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayGameHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayGameHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayGameHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayGameHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayGameHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayGameHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayGameHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayGameHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayGameHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayGameHistoryByCondition*)p = *(struct __ns4__GetPayGameHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayGameByCondition(struct soap *soap, struct __ns4__GetPayGameByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayGameByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayGameByCondition(struct soap *soap, const struct __ns4__GetPayGameByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayGameByCondition(soap, &a->ns1__GetPayGameByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayGameByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayGameByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayGameByCondition(soap, "ns1:GetPayGameByCondition", -1, &a->ns1__GetPayGameByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayGameByCondition * SOAP_FMAC4 soap_in___ns4__GetPayGameByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayGameByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayGameByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayGameByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayGameByCondition, sizeof(struct __ns4__GetPayGameByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayGameByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayGameByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayGameByCondition(soap, "ns1:GetPayGameByCondition", &a->ns1__GetPayGameByCondition, ""))
				{	soap_flag_ns1__GetPayGameByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayGameByCondition(struct soap *soap, const struct __ns4__GetPayGameByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayGameByCondition(soap, tag?tag:"-ns4:GetPayGameByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayGameByCondition * SOAP_FMAC4 soap_get___ns4__GetPayGameByCondition(struct soap *soap, struct __ns4__GetPayGameByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayGameByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayGameByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayGameByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayGameByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayGameByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayGameByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayGameByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayGameByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayGameByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayGameByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayGameByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayGameByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayGameByCondition*)p = *(struct __ns4__GetPayGameByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayInternetHistoryByCondition(struct soap *soap, struct __ns4__GetPayInternetHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayInternetHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayInternetHistoryByCondition(struct soap *soap, const struct __ns4__GetPayInternetHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, &a->ns1__GetPayInternetHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayInternetHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, "ns1:GetPayInternetHistoryByCondition", -1, &a->ns1__GetPayInternetHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_in___ns4__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayInternetHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayInternetHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayInternetHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayInternetHistoryByCondition, sizeof(struct __ns4__GetPayInternetHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayInternetHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayInternetHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, "ns1:GetPayInternetHistoryByCondition", &a->ns1__GetPayInternetHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayInternetHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayInternetHistoryByCondition(struct soap *soap, const struct __ns4__GetPayInternetHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayInternetHistoryByCondition(soap, tag?tag:"-ns4:GetPayInternetHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_get___ns4__GetPayInternetHistoryByCondition(struct soap *soap, struct __ns4__GetPayInternetHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayInternetHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayInternetHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayInternetHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayInternetHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayInternetHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayInternetHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayInternetHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayInternetHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayInternetHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayInternetHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayInternetHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayInternetHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayInternetHistoryByCondition*)p = *(struct __ns4__GetPayInternetHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPayInternetByCondition(struct soap *soap, struct __ns4__GetPayInternetByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayInternetByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPayInternetByCondition(struct soap *soap, const struct __ns4__GetPayInternetByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayInternetByCondition(soap, &a->ns1__GetPayInternetByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPayInternetByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPayInternetByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayInternetByCondition(soap, "ns1:GetPayInternetByCondition", -1, &a->ns1__GetPayInternetByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayInternetByCondition * SOAP_FMAC4 soap_in___ns4__GetPayInternetByCondition(struct soap *soap, const char *tag, struct __ns4__GetPayInternetByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayInternetByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPayInternetByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPayInternetByCondition, sizeof(struct __ns4__GetPayInternetByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPayInternetByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayInternetByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayInternetByCondition(soap, "ns1:GetPayInternetByCondition", &a->ns1__GetPayInternetByCondition, ""))
				{	soap_flag_ns1__GetPayInternetByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPayInternetByCondition(struct soap *soap, const struct __ns4__GetPayInternetByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPayInternetByCondition(soap, tag?tag:"-ns4:GetPayInternetByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPayInternetByCondition * SOAP_FMAC4 soap_get___ns4__GetPayInternetByCondition(struct soap *soap, struct __ns4__GetPayInternetByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPayInternetByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPayInternetByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPayInternetByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPayInternetByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPayInternetByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayInternetByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPayInternetByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPayInternetByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPayInternetByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPayInternetByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPayInternetByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPayInternetByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPayInternetByCondition*)p = *(struct __ns4__GetPayInternetByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, struct __ns4__GetPaymentOrPaymentHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentOrPaymentHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const struct __ns4__GetPaymentOrPaymentHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, &a->ns1__GetPaymentOrPaymentHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, "ns1:GetPaymentOrPaymentHistoryByCondition", -1, &a->ns1__GetPaymentOrPaymentHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_in___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, struct __ns4__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetPaymentOrPaymentHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPaymentOrPaymentHistoryByCondition, sizeof(struct __ns4__GetPaymentOrPaymentHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPaymentOrPaymentHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, "ns1:GetPaymentOrPaymentHistoryByCondition", &a->ns1__GetPaymentOrPaymentHistoryByCondition, ""))
				{	soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const struct __ns4__GetPaymentOrPaymentHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPaymentOrPaymentHistoryByCondition(soap, tag?tag:"-ns4:GetPaymentOrPaymentHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_get___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, struct __ns4__GetPaymentOrPaymentHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPaymentOrPaymentHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPaymentOrPaymentHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPaymentOrPaymentHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentOrPaymentHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetPaymentOrPaymentHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentOrPaymentHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPaymentOrPaymentHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPaymentOrPaymentHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPaymentOrPaymentHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetPaymentOrPaymentHistoryByCondition*)p = *(struct __ns4__GetPaymentOrPaymentHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetTransactionStaticsByCondition(struct soap *soap, struct __ns4__GetTransactionStaticsByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTransactionStaticsByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetTransactionStaticsByCondition(struct soap *soap, const struct __ns4__GetTransactionStaticsByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTransactionStaticsByCondition(soap, &a->ns1__GetTransactionStaticsByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetTransactionStaticsByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTransactionStaticsByCondition(soap, "ns1:GetTransactionStaticsByCondition", -1, &a->ns1__GetTransactionStaticsByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_in___ns4__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, struct __ns4__GetTransactionStaticsByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetTransactionStaticsByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetTransactionStaticsByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetTransactionStaticsByCondition, sizeof(struct __ns4__GetTransactionStaticsByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetTransactionStaticsByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTransactionStaticsByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTransactionStaticsByCondition(soap, "ns1:GetTransactionStaticsByCondition", &a->ns1__GetTransactionStaticsByCondition, ""))
				{	soap_flag_ns1__GetTransactionStaticsByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetTransactionStaticsByCondition(struct soap *soap, const struct __ns4__GetTransactionStaticsByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetTransactionStaticsByCondition(soap, tag?tag:"-ns4:GetTransactionStaticsByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_get___ns4__GetTransactionStaticsByCondition(struct soap *soap, struct __ns4__GetTransactionStaticsByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetTransactionStaticsByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetTransactionStaticsByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetTransactionStaticsByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetTransactionStaticsByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetTransactionStaticsByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetTransactionStaticsByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetTransactionStaticsByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetTransactionStaticsByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetTransactionStaticsByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetTransactionStaticsByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetTransactionStaticsByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetTransactionStaticsByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetTransactionStaticsByCondition*)p = *(struct __ns4__GetTransactionStaticsByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetTransactionByCondition(struct soap *soap, struct __ns4__GetTransactionByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTransactionByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetTransactionByCondition(struct soap *soap, const struct __ns4__GetTransactionByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTransactionByCondition(soap, &a->ns1__GetTransactionByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetTransactionByCondition(struct soap *soap, const char *tag, int id, const struct __ns4__GetTransactionByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTransactionByCondition(soap, "ns1:GetTransactionByCondition", -1, &a->ns1__GetTransactionByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetTransactionByCondition * SOAP_FMAC4 soap_in___ns4__GetTransactionByCondition(struct soap *soap, const char *tag, struct __ns4__GetTransactionByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetTransactionByCondition = 1;
	short soap_flag;
	a = (struct __ns4__GetTransactionByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetTransactionByCondition, sizeof(struct __ns4__GetTransactionByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetTransactionByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTransactionByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTransactionByCondition(soap, "ns1:GetTransactionByCondition", &a->ns1__GetTransactionByCondition, ""))
				{	soap_flag_ns1__GetTransactionByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetTransactionByCondition(struct soap *soap, const struct __ns4__GetTransactionByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetTransactionByCondition(soap, tag?tag:"-ns4:GetTransactionByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetTransactionByCondition * SOAP_FMAC4 soap_get___ns4__GetTransactionByCondition(struct soap *soap, struct __ns4__GetTransactionByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetTransactionByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetTransactionByCondition * SOAP_FMAC2 soap_instantiate___ns4__GetTransactionByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetTransactionByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetTransactionByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetTransactionByCondition);
		if (size)
			*size = sizeof(struct __ns4__GetTransactionByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetTransactionByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetTransactionByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetTransactionByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetTransactionByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetTransactionByCondition %p -> %p\n", q, p));
	*(struct __ns4__GetTransactionByCondition*)p = *(struct __ns4__GetTransactionByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPaymentItem(struct soap *soap, struct __ns4__GetPaymentItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPaymentItem(struct soap *soap, const struct __ns4__GetPaymentItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentItem(soap, &a->ns1__GetPaymentItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPaymentItem(struct soap *soap, const char *tag, int id, const struct __ns4__GetPaymentItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentItem(soap, "ns1:GetPaymentItem", -1, &a->ns1__GetPaymentItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentItem * SOAP_FMAC4 soap_in___ns4__GetPaymentItem(struct soap *soap, const char *tag, struct __ns4__GetPaymentItem *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentItem = 1;
	short soap_flag;
	a = (struct __ns4__GetPaymentItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPaymentItem, sizeof(struct __ns4__GetPaymentItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPaymentItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentItem(soap, "ns1:GetPaymentItem", &a->ns1__GetPaymentItem, ""))
				{	soap_flag_ns1__GetPaymentItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPaymentItem(struct soap *soap, const struct __ns4__GetPaymentItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPaymentItem(soap, tag?tag:"-ns4:GetPaymentItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentItem * SOAP_FMAC4 soap_get___ns4__GetPaymentItem(struct soap *soap, struct __ns4__GetPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPaymentItem * SOAP_FMAC2 soap_instantiate___ns4__GetPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentItem);
		if (size)
			*size = sizeof(struct __ns4__GetPaymentItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPaymentItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPaymentItem %p -> %p\n", q, p));
	*(struct __ns4__GetPaymentItem*)p = *(struct __ns4__GetPaymentItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetPaymentRecord(struct soap *soap, struct __ns4__GetPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetPaymentRecord(struct soap *soap, const struct __ns4__GetPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentRecord(soap, &a->ns1__GetPaymentRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetPaymentRecord(struct soap *soap, const char *tag, int id, const struct __ns4__GetPaymentRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentRecord(soap, "ns1:GetPaymentRecord", -1, &a->ns1__GetPaymentRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentRecord * SOAP_FMAC4 soap_in___ns4__GetPaymentRecord(struct soap *soap, const char *tag, struct __ns4__GetPaymentRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentRecord = 1;
	short soap_flag;
	a = (struct __ns4__GetPaymentRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetPaymentRecord, sizeof(struct __ns4__GetPaymentRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetPaymentRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentRecord(soap, "ns1:GetPaymentRecord", &a->ns1__GetPaymentRecord, ""))
				{	soap_flag_ns1__GetPaymentRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetPaymentRecord(struct soap *soap, const struct __ns4__GetPaymentRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetPaymentRecord(soap, tag?tag:"-ns4:GetPaymentRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetPaymentRecord * SOAP_FMAC4 soap_get___ns4__GetPaymentRecord(struct soap *soap, struct __ns4__GetPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetPaymentRecord * SOAP_FMAC2 soap_instantiate___ns4__GetPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentRecord);
		if (size)
			*size = sizeof(struct __ns4__GetPaymentRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetPaymentRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetPaymentRecord %p -> %p\n", q, p));
	*(struct __ns4__GetPaymentRecord*)p = *(struct __ns4__GetPaymentRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayPublicTel(struct soap *soap, struct __ns4__PayPublicTel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayPublicTel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayPublicTel(struct soap *soap, const struct __ns4__PayPublicTel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayPublicTel(soap, &a->ns1__PayPublicTel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayPublicTel(struct soap *soap, const char *tag, int id, const struct __ns4__PayPublicTel *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayPublicTel(soap, "ns1:PayPublicTel", -1, &a->ns1__PayPublicTel, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayPublicTel * SOAP_FMAC4 soap_in___ns4__PayPublicTel(struct soap *soap, const char *tag, struct __ns4__PayPublicTel *a, const char *type)
{
	size_t soap_flag_ns1__PayPublicTel = 1;
	short soap_flag;
	a = (struct __ns4__PayPublicTel *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayPublicTel, sizeof(struct __ns4__PayPublicTel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayPublicTel(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayPublicTel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayPublicTel(soap, "ns1:PayPublicTel", &a->ns1__PayPublicTel, ""))
				{	soap_flag_ns1__PayPublicTel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayPublicTel(struct soap *soap, const struct __ns4__PayPublicTel *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayPublicTel(soap, tag?tag:"-ns4:PayPublicTel", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayPublicTel * SOAP_FMAC4 soap_get___ns4__PayPublicTel(struct soap *soap, struct __ns4__PayPublicTel *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayPublicTel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayPublicTel * SOAP_FMAC2 soap_instantiate___ns4__PayPublicTel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayPublicTel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayPublicTel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayPublicTel);
		if (size)
			*size = sizeof(struct __ns4__PayPublicTel);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayPublicTel[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayPublicTel);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayPublicTel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayPublicTel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayPublicTel %p -> %p\n", q, p));
	*(struct __ns4__PayPublicTel*)p = *(struct __ns4__PayPublicTel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayGame(struct soap *soap, struct __ns4__PayGame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayGame = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayGame(struct soap *soap, const struct __ns4__PayGame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayGame(soap, &a->ns1__PayGame);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayGame(struct soap *soap, const char *tag, int id, const struct __ns4__PayGame *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayGame(soap, "ns1:PayGame", -1, &a->ns1__PayGame, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayGame * SOAP_FMAC4 soap_in___ns4__PayGame(struct soap *soap, const char *tag, struct __ns4__PayGame *a, const char *type)
{
	size_t soap_flag_ns1__PayGame = 1;
	short soap_flag;
	a = (struct __ns4__PayGame *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayGame, sizeof(struct __ns4__PayGame), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayGame(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayGame && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayGame(soap, "ns1:PayGame", &a->ns1__PayGame, ""))
				{	soap_flag_ns1__PayGame--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayGame(struct soap *soap, const struct __ns4__PayGame *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayGame(soap, tag?tag:"-ns4:PayGame", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayGame * SOAP_FMAC4 soap_get___ns4__PayGame(struct soap *soap, struct __ns4__PayGame *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayGame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayGame * SOAP_FMAC2 soap_instantiate___ns4__PayGame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayGame(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayGame, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayGame);
		if (size)
			*size = sizeof(struct __ns4__PayGame);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayGame[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayGame);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayGame*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayGame(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayGame %p -> %p\n", q, p));
	*(struct __ns4__PayGame*)p = *(struct __ns4__PayGame*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__RequstInternetRollback(struct soap *soap, struct __ns4__RequstInternetRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequstInternetRollback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__RequstInternetRollback(struct soap *soap, const struct __ns4__RequstInternetRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RequstInternetRollback(soap, &a->ns1__RequstInternetRollback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__RequstInternetRollback(struct soap *soap, const char *tag, int id, const struct __ns4__RequstInternetRollback *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RequstInternetRollback(soap, "ns1:RequstInternetRollback", -1, &a->ns1__RequstInternetRollback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__RequstInternetRollback * SOAP_FMAC4 soap_in___ns4__RequstInternetRollback(struct soap *soap, const char *tag, struct __ns4__RequstInternetRollback *a, const char *type)
{
	size_t soap_flag_ns1__RequstInternetRollback = 1;
	short soap_flag;
	a = (struct __ns4__RequstInternetRollback *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__RequstInternetRollback, sizeof(struct __ns4__RequstInternetRollback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__RequstInternetRollback(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequstInternetRollback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RequstInternetRollback(soap, "ns1:RequstInternetRollback", &a->ns1__RequstInternetRollback, ""))
				{	soap_flag_ns1__RequstInternetRollback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__RequstInternetRollback(struct soap *soap, const struct __ns4__RequstInternetRollback *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__RequstInternetRollback(soap, tag?tag:"-ns4:RequstInternetRollback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__RequstInternetRollback * SOAP_FMAC4 soap_get___ns4__RequstInternetRollback(struct soap *soap, struct __ns4__RequstInternetRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__RequstInternetRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__RequstInternetRollback * SOAP_FMAC2 soap_instantiate___ns4__RequstInternetRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__RequstInternetRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__RequstInternetRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__RequstInternetRollback);
		if (size)
			*size = sizeof(struct __ns4__RequstInternetRollback);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__RequstInternetRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__RequstInternetRollback);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__RequstInternetRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__RequstInternetRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__RequstInternetRollback %p -> %p\n", q, p));
	*(struct __ns4__RequstInternetRollback*)p = *(struct __ns4__RequstInternetRollback*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayInternetWithList(struct soap *soap, struct __ns4__PayInternetWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayInternetWithList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayInternetWithList(struct soap *soap, const struct __ns4__PayInternetWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayInternetWithList(soap, &a->ns1__PayInternetWithList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayInternetWithList(struct soap *soap, const char *tag, int id, const struct __ns4__PayInternetWithList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayInternetWithList(soap, "ns1:PayInternetWithList", -1, &a->ns1__PayInternetWithList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayInternetWithList * SOAP_FMAC4 soap_in___ns4__PayInternetWithList(struct soap *soap, const char *tag, struct __ns4__PayInternetWithList *a, const char *type)
{
	size_t soap_flag_ns1__PayInternetWithList = 1;
	short soap_flag;
	a = (struct __ns4__PayInternetWithList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayInternetWithList, sizeof(struct __ns4__PayInternetWithList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayInternetWithList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayInternetWithList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayInternetWithList(soap, "ns1:PayInternetWithList", &a->ns1__PayInternetWithList, ""))
				{	soap_flag_ns1__PayInternetWithList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayInternetWithList(struct soap *soap, const struct __ns4__PayInternetWithList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayInternetWithList(soap, tag?tag:"-ns4:PayInternetWithList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayInternetWithList * SOAP_FMAC4 soap_get___ns4__PayInternetWithList(struct soap *soap, struct __ns4__PayInternetWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayInternetWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayInternetWithList * SOAP_FMAC2 soap_instantiate___ns4__PayInternetWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayInternetWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayInternetWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayInternetWithList);
		if (size)
			*size = sizeof(struct __ns4__PayInternetWithList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayInternetWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayInternetWithList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayInternetWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayInternetWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayInternetWithList %p -> %p\n", q, p));
	*(struct __ns4__PayInternetWithList*)p = *(struct __ns4__PayInternetWithList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayInternet(struct soap *soap, struct __ns4__PayInternet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayInternet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayInternet(struct soap *soap, const struct __ns4__PayInternet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayInternet(soap, &a->ns1__PayInternet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayInternet(struct soap *soap, const char *tag, int id, const struct __ns4__PayInternet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayInternet(soap, "ns1:PayInternet", -1, &a->ns1__PayInternet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayInternet * SOAP_FMAC4 soap_in___ns4__PayInternet(struct soap *soap, const char *tag, struct __ns4__PayInternet *a, const char *type)
{
	size_t soap_flag_ns1__PayInternet = 1;
	short soap_flag;
	a = (struct __ns4__PayInternet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayInternet, sizeof(struct __ns4__PayInternet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayInternet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayInternet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayInternet(soap, "ns1:PayInternet", &a->ns1__PayInternet, ""))
				{	soap_flag_ns1__PayInternet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayInternet(struct soap *soap, const struct __ns4__PayInternet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayInternet(soap, tag?tag:"-ns4:PayInternet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayInternet * SOAP_FMAC4 soap_get___ns4__PayInternet(struct soap *soap, struct __ns4__PayInternet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayInternet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayInternet * SOAP_FMAC2 soap_instantiate___ns4__PayInternet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayInternet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayInternet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayInternet);
		if (size)
			*size = sizeof(struct __ns4__PayInternet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayInternet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayInternet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayInternet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayInternet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayInternet %p -> %p\n", q, p));
	*(struct __ns4__PayInternet*)p = *(struct __ns4__PayInternet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__RequstRollback(struct soap *soap, struct __ns4__RequstRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequstRollback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__RequstRollback(struct soap *soap, const struct __ns4__RequstRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RequstRollback(soap, &a->ns1__RequstRollback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__RequstRollback(struct soap *soap, const char *tag, int id, const struct __ns4__RequstRollback *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RequstRollback(soap, "ns1:RequstRollback", -1, &a->ns1__RequstRollback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__RequstRollback * SOAP_FMAC4 soap_in___ns4__RequstRollback(struct soap *soap, const char *tag, struct __ns4__RequstRollback *a, const char *type)
{
	size_t soap_flag_ns1__RequstRollback = 1;
	short soap_flag;
	a = (struct __ns4__RequstRollback *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__RequstRollback, sizeof(struct __ns4__RequstRollback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__RequstRollback(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequstRollback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RequstRollback(soap, "ns1:RequstRollback", &a->ns1__RequstRollback, ""))
				{	soap_flag_ns1__RequstRollback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__RequstRollback(struct soap *soap, const struct __ns4__RequstRollback *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__RequstRollback(soap, tag?tag:"-ns4:RequstRollback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__RequstRollback * SOAP_FMAC4 soap_get___ns4__RequstRollback(struct soap *soap, struct __ns4__RequstRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__RequstRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__RequstRollback * SOAP_FMAC2 soap_instantiate___ns4__RequstRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__RequstRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__RequstRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__RequstRollback);
		if (size)
			*size = sizeof(struct __ns4__RequstRollback);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__RequstRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__RequstRollback);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__RequstRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__RequstRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__RequstRollback %p -> %p\n", q, p));
	*(struct __ns4__RequstRollback*)p = *(struct __ns4__RequstRollback*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayMoneyWithList(struct soap *soap, struct __ns4__PayMoneyWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayMoneyWithList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayMoneyWithList(struct soap *soap, const struct __ns4__PayMoneyWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayMoneyWithList(soap, &a->ns1__PayMoneyWithList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayMoneyWithList(struct soap *soap, const char *tag, int id, const struct __ns4__PayMoneyWithList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayMoneyWithList(soap, "ns1:PayMoneyWithList", -1, &a->ns1__PayMoneyWithList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayMoneyWithList * SOAP_FMAC4 soap_in___ns4__PayMoneyWithList(struct soap *soap, const char *tag, struct __ns4__PayMoneyWithList *a, const char *type)
{
	size_t soap_flag_ns1__PayMoneyWithList = 1;
	short soap_flag;
	a = (struct __ns4__PayMoneyWithList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayMoneyWithList, sizeof(struct __ns4__PayMoneyWithList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayMoneyWithList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayMoneyWithList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayMoneyWithList(soap, "ns1:PayMoneyWithList", &a->ns1__PayMoneyWithList, ""))
				{	soap_flag_ns1__PayMoneyWithList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayMoneyWithList(struct soap *soap, const struct __ns4__PayMoneyWithList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayMoneyWithList(soap, tag?tag:"-ns4:PayMoneyWithList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayMoneyWithList * SOAP_FMAC4 soap_get___ns4__PayMoneyWithList(struct soap *soap, struct __ns4__PayMoneyWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayMoneyWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayMoneyWithList * SOAP_FMAC2 soap_instantiate___ns4__PayMoneyWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayMoneyWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayMoneyWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayMoneyWithList);
		if (size)
			*size = sizeof(struct __ns4__PayMoneyWithList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayMoneyWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayMoneyWithList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayMoneyWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayMoneyWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayMoneyWithList %p -> %p\n", q, p));
	*(struct __ns4__PayMoneyWithList*)p = *(struct __ns4__PayMoneyWithList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__PayMoney(struct soap *soap, struct __ns4__PayMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayMoney = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__PayMoney(struct soap *soap, const struct __ns4__PayMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayMoney(soap, &a->ns1__PayMoney);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__PayMoney(struct soap *soap, const char *tag, int id, const struct __ns4__PayMoney *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayMoney(soap, "ns1:PayMoney", -1, &a->ns1__PayMoney, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayMoney * SOAP_FMAC4 soap_in___ns4__PayMoney(struct soap *soap, const char *tag, struct __ns4__PayMoney *a, const char *type)
{
	size_t soap_flag_ns1__PayMoney = 1;
	short soap_flag;
	a = (struct __ns4__PayMoney *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__PayMoney, sizeof(struct __ns4__PayMoney), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__PayMoney(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayMoney && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayMoney(soap, "ns1:PayMoney", &a->ns1__PayMoney, ""))
				{	soap_flag_ns1__PayMoney--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__PayMoney(struct soap *soap, const struct __ns4__PayMoney *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__PayMoney(soap, tag?tag:"-ns4:PayMoney", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__PayMoney * SOAP_FMAC4 soap_get___ns4__PayMoney(struct soap *soap, struct __ns4__PayMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__PayMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__PayMoney * SOAP_FMAC2 soap_instantiate___ns4__PayMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__PayMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__PayMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayMoney);
		if (size)
			*size = sizeof(struct __ns4__PayMoney);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__PayMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__PayMoney);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__PayMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__PayMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__PayMoney %p -> %p\n", q, p));
	*(struct __ns4__PayMoney*)p = *(struct __ns4__PayMoney*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetLocation(struct soap *soap, struct __ns4__GetLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetLocation(struct soap *soap, const struct __ns4__GetLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLocation(soap, &a->ns1__GetLocation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetLocation(struct soap *soap, const char *tag, int id, const struct __ns4__GetLocation *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLocation(soap, "ns1:GetLocation", -1, &a->ns1__GetLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetLocation * SOAP_FMAC4 soap_in___ns4__GetLocation(struct soap *soap, const char *tag, struct __ns4__GetLocation *a, const char *type)
{
	size_t soap_flag_ns1__GetLocation = 1;
	short soap_flag;
	a = (struct __ns4__GetLocation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetLocation, sizeof(struct __ns4__GetLocation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLocation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLocation(soap, "ns1:GetLocation", &a->ns1__GetLocation, ""))
				{	soap_flag_ns1__GetLocation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetLocation(struct soap *soap, const struct __ns4__GetLocation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetLocation(soap, tag?tag:"-ns4:GetLocation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetLocation * SOAP_FMAC4 soap_get___ns4__GetLocation(struct soap *soap, struct __ns4__GetLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetLocation * SOAP_FMAC2 soap_instantiate___ns4__GetLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetLocation);
		if (size)
			*size = sizeof(struct __ns4__GetLocation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetLocation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetLocation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetLocation %p -> %p\n", q, p));
	*(struct __ns4__GetLocation*)p = *(struct __ns4__GetLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, struct __ns3__GetPayPublicTelHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayPublicTelHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, const struct __ns3__GetPayPublicTelHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, &a->ns1__GetPayPublicTelHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, "ns1:GetPayPublicTelHistoryByCondition", -1, &a->ns1__GetPayPublicTelHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_in___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayPublicTelHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayPublicTelHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayPublicTelHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayPublicTelHistoryByCondition, sizeof(struct __ns3__GetPayPublicTelHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayPublicTelHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayPublicTelHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, "ns1:GetPayPublicTelHistoryByCondition", &a->ns1__GetPayPublicTelHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayPublicTelHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, const struct __ns3__GetPayPublicTelHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayPublicTelHistoryByCondition(soap, tag?tag:"-ns3:GetPayPublicTelHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayPublicTelHistoryByCondition * SOAP_FMAC4 soap_get___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, struct __ns3__GetPayPublicTelHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayPublicTelHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayPublicTelHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayPublicTelHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayPublicTelHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayPublicTelHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayPublicTelHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayPublicTelHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayPublicTelHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayPublicTelHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayPublicTelHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayPublicTelHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayPublicTelHistoryByCondition*)p = *(struct __ns3__GetPayPublicTelHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayPublicTelByCondition(struct soap *soap, struct __ns3__GetPayPublicTelByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayPublicTelByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayPublicTelByCondition(struct soap *soap, const struct __ns3__GetPayPublicTelByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayPublicTelByCondition(soap, &a->ns1__GetPayPublicTelByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayPublicTelByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayPublicTelByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayPublicTelByCondition(soap, "ns1:GetPayPublicTelByCondition", -1, &a->ns1__GetPayPublicTelByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayPublicTelByCondition * SOAP_FMAC4 soap_in___ns3__GetPayPublicTelByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayPublicTelByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayPublicTelByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayPublicTelByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayPublicTelByCondition, sizeof(struct __ns3__GetPayPublicTelByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayPublicTelByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayPublicTelByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayPublicTelByCondition(soap, "ns1:GetPayPublicTelByCondition", &a->ns1__GetPayPublicTelByCondition, ""))
				{	soap_flag_ns1__GetPayPublicTelByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayPublicTelByCondition(struct soap *soap, const struct __ns3__GetPayPublicTelByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayPublicTelByCondition(soap, tag?tag:"-ns3:GetPayPublicTelByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayPublicTelByCondition * SOAP_FMAC4 soap_get___ns3__GetPayPublicTelByCondition(struct soap *soap, struct __ns3__GetPayPublicTelByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayPublicTelByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayPublicTelByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayPublicTelByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayPublicTelByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayPublicTelByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayPublicTelByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayPublicTelByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayPublicTelByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayPublicTelByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayPublicTelByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayPublicTelByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayPublicTelByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayPublicTelByCondition*)p = *(struct __ns3__GetPayPublicTelByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayGameHistoryByCondition(struct soap *soap, struct __ns3__GetPayGameHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayGameHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayGameHistoryByCondition(struct soap *soap, const struct __ns3__GetPayGameHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayGameHistoryByCondition(soap, &a->ns1__GetPayGameHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayGameHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayGameHistoryByCondition(soap, "ns1:GetPayGameHistoryByCondition", -1, &a->ns1__GetPayGameHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_in___ns3__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayGameHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayGameHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayGameHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayGameHistoryByCondition, sizeof(struct __ns3__GetPayGameHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayGameHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayGameHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayGameHistoryByCondition(soap, "ns1:GetPayGameHistoryByCondition", &a->ns1__GetPayGameHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayGameHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayGameHistoryByCondition(struct soap *soap, const struct __ns3__GetPayGameHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayGameHistoryByCondition(soap, tag?tag:"-ns3:GetPayGameHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayGameHistoryByCondition * SOAP_FMAC4 soap_get___ns3__GetPayGameHistoryByCondition(struct soap *soap, struct __ns3__GetPayGameHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayGameHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayGameHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayGameHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayGameHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayGameHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayGameHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayGameHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayGameHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayGameHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayGameHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayGameHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayGameHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayGameHistoryByCondition*)p = *(struct __ns3__GetPayGameHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayGameByCondition(struct soap *soap, struct __ns3__GetPayGameByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayGameByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayGameByCondition(struct soap *soap, const struct __ns3__GetPayGameByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayGameByCondition(soap, &a->ns1__GetPayGameByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayGameByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayGameByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayGameByCondition(soap, "ns1:GetPayGameByCondition", -1, &a->ns1__GetPayGameByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayGameByCondition * SOAP_FMAC4 soap_in___ns3__GetPayGameByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayGameByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayGameByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayGameByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayGameByCondition, sizeof(struct __ns3__GetPayGameByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayGameByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayGameByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayGameByCondition(soap, "ns1:GetPayGameByCondition", &a->ns1__GetPayGameByCondition, ""))
				{	soap_flag_ns1__GetPayGameByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayGameByCondition(struct soap *soap, const struct __ns3__GetPayGameByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayGameByCondition(soap, tag?tag:"-ns3:GetPayGameByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayGameByCondition * SOAP_FMAC4 soap_get___ns3__GetPayGameByCondition(struct soap *soap, struct __ns3__GetPayGameByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayGameByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayGameByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayGameByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayGameByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayGameByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayGameByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayGameByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayGameByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayGameByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayGameByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayGameByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayGameByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayGameByCondition*)p = *(struct __ns3__GetPayGameByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayInternetHistoryByCondition(struct soap *soap, struct __ns3__GetPayInternetHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayInternetHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayInternetHistoryByCondition(struct soap *soap, const struct __ns3__GetPayInternetHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, &a->ns1__GetPayInternetHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayInternetHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, "ns1:GetPayInternetHistoryByCondition", -1, &a->ns1__GetPayInternetHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_in___ns3__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayInternetHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayInternetHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayInternetHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayInternetHistoryByCondition, sizeof(struct __ns3__GetPayInternetHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayInternetHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayInternetHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, "ns1:GetPayInternetHistoryByCondition", &a->ns1__GetPayInternetHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayInternetHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayInternetHistoryByCondition(struct soap *soap, const struct __ns3__GetPayInternetHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayInternetHistoryByCondition(soap, tag?tag:"-ns3:GetPayInternetHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayInternetHistoryByCondition * SOAP_FMAC4 soap_get___ns3__GetPayInternetHistoryByCondition(struct soap *soap, struct __ns3__GetPayInternetHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayInternetHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayInternetHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayInternetHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayInternetHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayInternetHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayInternetHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayInternetHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayInternetHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayInternetHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayInternetHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayInternetHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayInternetHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayInternetHistoryByCondition*)p = *(struct __ns3__GetPayInternetHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPayInternetByCondition(struct soap *soap, struct __ns3__GetPayInternetByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayInternetByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPayInternetByCondition(struct soap *soap, const struct __ns3__GetPayInternetByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayInternetByCondition(soap, &a->ns1__GetPayInternetByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPayInternetByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPayInternetByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayInternetByCondition(soap, "ns1:GetPayInternetByCondition", -1, &a->ns1__GetPayInternetByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayInternetByCondition * SOAP_FMAC4 soap_in___ns3__GetPayInternetByCondition(struct soap *soap, const char *tag, struct __ns3__GetPayInternetByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayInternetByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPayInternetByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPayInternetByCondition, sizeof(struct __ns3__GetPayInternetByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPayInternetByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayInternetByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayInternetByCondition(soap, "ns1:GetPayInternetByCondition", &a->ns1__GetPayInternetByCondition, ""))
				{	soap_flag_ns1__GetPayInternetByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPayInternetByCondition(struct soap *soap, const struct __ns3__GetPayInternetByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPayInternetByCondition(soap, tag?tag:"-ns3:GetPayInternetByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPayInternetByCondition * SOAP_FMAC4 soap_get___ns3__GetPayInternetByCondition(struct soap *soap, struct __ns3__GetPayInternetByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPayInternetByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPayInternetByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPayInternetByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPayInternetByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPayInternetByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayInternetByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPayInternetByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPayInternetByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPayInternetByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPayInternetByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPayInternetByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPayInternetByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPayInternetByCondition*)p = *(struct __ns3__GetPayInternetByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, struct __ns3__GetPaymentOrPaymentHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentOrPaymentHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const struct __ns3__GetPaymentOrPaymentHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, &a->ns1__GetPaymentOrPaymentHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, "ns1:GetPaymentOrPaymentHistoryByCondition", -1, &a->ns1__GetPaymentOrPaymentHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_in___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, struct __ns3__GetPaymentOrPaymentHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetPaymentOrPaymentHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPaymentOrPaymentHistoryByCondition, sizeof(struct __ns3__GetPaymentOrPaymentHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPaymentOrPaymentHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, "ns1:GetPaymentOrPaymentHistoryByCondition", &a->ns1__GetPaymentOrPaymentHistoryByCondition, ""))
				{	soap_flag_ns1__GetPaymentOrPaymentHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const struct __ns3__GetPaymentOrPaymentHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPaymentOrPaymentHistoryByCondition(soap, tag?tag:"-ns3:GetPaymentOrPaymentHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC4 soap_get___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, struct __ns3__GetPaymentOrPaymentHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPaymentOrPaymentHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPaymentOrPaymentHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPaymentOrPaymentHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPaymentOrPaymentHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentOrPaymentHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetPaymentOrPaymentHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentOrPaymentHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPaymentOrPaymentHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPaymentOrPaymentHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPaymentOrPaymentHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetPaymentOrPaymentHistoryByCondition*)p = *(struct __ns3__GetPaymentOrPaymentHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetTransactionStaticsByCondition(struct soap *soap, struct __ns3__GetTransactionStaticsByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTransactionStaticsByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetTransactionStaticsByCondition(struct soap *soap, const struct __ns3__GetTransactionStaticsByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTransactionStaticsByCondition(soap, &a->ns1__GetTransactionStaticsByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetTransactionStaticsByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTransactionStaticsByCondition(soap, "ns1:GetTransactionStaticsByCondition", -1, &a->ns1__GetTransactionStaticsByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_in___ns3__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, struct __ns3__GetTransactionStaticsByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetTransactionStaticsByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetTransactionStaticsByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetTransactionStaticsByCondition, sizeof(struct __ns3__GetTransactionStaticsByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetTransactionStaticsByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTransactionStaticsByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTransactionStaticsByCondition(soap, "ns1:GetTransactionStaticsByCondition", &a->ns1__GetTransactionStaticsByCondition, ""))
				{	soap_flag_ns1__GetTransactionStaticsByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetTransactionStaticsByCondition(struct soap *soap, const struct __ns3__GetTransactionStaticsByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetTransactionStaticsByCondition(soap, tag?tag:"-ns3:GetTransactionStaticsByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetTransactionStaticsByCondition * SOAP_FMAC4 soap_get___ns3__GetTransactionStaticsByCondition(struct soap *soap, struct __ns3__GetTransactionStaticsByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetTransactionStaticsByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetTransactionStaticsByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetTransactionStaticsByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetTransactionStaticsByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetTransactionStaticsByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetTransactionStaticsByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetTransactionStaticsByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetTransactionStaticsByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetTransactionStaticsByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetTransactionStaticsByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetTransactionStaticsByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetTransactionStaticsByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetTransactionStaticsByCondition*)p = *(struct __ns3__GetTransactionStaticsByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetTransactionByCondition(struct soap *soap, struct __ns3__GetTransactionByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTransactionByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetTransactionByCondition(struct soap *soap, const struct __ns3__GetTransactionByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetTransactionByCondition(soap, &a->ns1__GetTransactionByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetTransactionByCondition(struct soap *soap, const char *tag, int id, const struct __ns3__GetTransactionByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTransactionByCondition(soap, "ns1:GetTransactionByCondition", -1, &a->ns1__GetTransactionByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetTransactionByCondition * SOAP_FMAC4 soap_in___ns3__GetTransactionByCondition(struct soap *soap, const char *tag, struct __ns3__GetTransactionByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetTransactionByCondition = 1;
	short soap_flag;
	a = (struct __ns3__GetTransactionByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetTransactionByCondition, sizeof(struct __ns3__GetTransactionByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetTransactionByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTransactionByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetTransactionByCondition(soap, "ns1:GetTransactionByCondition", &a->ns1__GetTransactionByCondition, ""))
				{	soap_flag_ns1__GetTransactionByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetTransactionByCondition(struct soap *soap, const struct __ns3__GetTransactionByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetTransactionByCondition(soap, tag?tag:"-ns3:GetTransactionByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetTransactionByCondition * SOAP_FMAC4 soap_get___ns3__GetTransactionByCondition(struct soap *soap, struct __ns3__GetTransactionByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetTransactionByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetTransactionByCondition * SOAP_FMAC2 soap_instantiate___ns3__GetTransactionByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetTransactionByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetTransactionByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetTransactionByCondition);
		if (size)
			*size = sizeof(struct __ns3__GetTransactionByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetTransactionByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetTransactionByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetTransactionByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetTransactionByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetTransactionByCondition %p -> %p\n", q, p));
	*(struct __ns3__GetTransactionByCondition*)p = *(struct __ns3__GetTransactionByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPaymentItem(struct soap *soap, struct __ns3__GetPaymentItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPaymentItem(struct soap *soap, const struct __ns3__GetPaymentItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentItem(soap, &a->ns1__GetPaymentItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPaymentItem(struct soap *soap, const char *tag, int id, const struct __ns3__GetPaymentItem *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentItem(soap, "ns1:GetPaymentItem", -1, &a->ns1__GetPaymentItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentItem * SOAP_FMAC4 soap_in___ns3__GetPaymentItem(struct soap *soap, const char *tag, struct __ns3__GetPaymentItem *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentItem = 1;
	short soap_flag;
	a = (struct __ns3__GetPaymentItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPaymentItem, sizeof(struct __ns3__GetPaymentItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPaymentItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentItem(soap, "ns1:GetPaymentItem", &a->ns1__GetPaymentItem, ""))
				{	soap_flag_ns1__GetPaymentItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPaymentItem(struct soap *soap, const struct __ns3__GetPaymentItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPaymentItem(soap, tag?tag:"-ns3:GetPaymentItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentItem * SOAP_FMAC4 soap_get___ns3__GetPaymentItem(struct soap *soap, struct __ns3__GetPaymentItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPaymentItem * SOAP_FMAC2 soap_instantiate___ns3__GetPaymentItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPaymentItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPaymentItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentItem);
		if (size)
			*size = sizeof(struct __ns3__GetPaymentItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPaymentItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPaymentItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPaymentItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPaymentItem %p -> %p\n", q, p));
	*(struct __ns3__GetPaymentItem*)p = *(struct __ns3__GetPaymentItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPaymentRecord(struct soap *soap, struct __ns3__GetPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPaymentRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPaymentRecord(struct soap *soap, const struct __ns3__GetPaymentRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPaymentRecord(soap, &a->ns1__GetPaymentRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPaymentRecord(struct soap *soap, const char *tag, int id, const struct __ns3__GetPaymentRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPaymentRecord(soap, "ns1:GetPaymentRecord", -1, &a->ns1__GetPaymentRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentRecord * SOAP_FMAC4 soap_in___ns3__GetPaymentRecord(struct soap *soap, const char *tag, struct __ns3__GetPaymentRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetPaymentRecord = 1;
	short soap_flag;
	a = (struct __ns3__GetPaymentRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPaymentRecord, sizeof(struct __ns3__GetPaymentRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPaymentRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPaymentRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPaymentRecord(soap, "ns1:GetPaymentRecord", &a->ns1__GetPaymentRecord, ""))
				{	soap_flag_ns1__GetPaymentRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPaymentRecord(struct soap *soap, const struct __ns3__GetPaymentRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPaymentRecord(soap, tag?tag:"-ns3:GetPaymentRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPaymentRecord * SOAP_FMAC4 soap_get___ns3__GetPaymentRecord(struct soap *soap, struct __ns3__GetPaymentRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetPaymentRecord * SOAP_FMAC2 soap_instantiate___ns3__GetPaymentRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPaymentRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPaymentRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentRecord);
		if (size)
			*size = sizeof(struct __ns3__GetPaymentRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetPaymentRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPaymentRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPaymentRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPaymentRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPaymentRecord %p -> %p\n", q, p));
	*(struct __ns3__GetPaymentRecord*)p = *(struct __ns3__GetPaymentRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayPublicTel(struct soap *soap, struct __ns3__PayPublicTel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayPublicTel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayPublicTel(struct soap *soap, const struct __ns3__PayPublicTel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayPublicTel(soap, &a->ns1__PayPublicTel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayPublicTel(struct soap *soap, const char *tag, int id, const struct __ns3__PayPublicTel *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayPublicTel(soap, "ns1:PayPublicTel", -1, &a->ns1__PayPublicTel, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayPublicTel * SOAP_FMAC4 soap_in___ns3__PayPublicTel(struct soap *soap, const char *tag, struct __ns3__PayPublicTel *a, const char *type)
{
	size_t soap_flag_ns1__PayPublicTel = 1;
	short soap_flag;
	a = (struct __ns3__PayPublicTel *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayPublicTel, sizeof(struct __ns3__PayPublicTel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayPublicTel(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayPublicTel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayPublicTel(soap, "ns1:PayPublicTel", &a->ns1__PayPublicTel, ""))
				{	soap_flag_ns1__PayPublicTel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayPublicTel(struct soap *soap, const struct __ns3__PayPublicTel *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayPublicTel(soap, tag?tag:"-ns3:PayPublicTel", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayPublicTel * SOAP_FMAC4 soap_get___ns3__PayPublicTel(struct soap *soap, struct __ns3__PayPublicTel *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayPublicTel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayPublicTel * SOAP_FMAC2 soap_instantiate___ns3__PayPublicTel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayPublicTel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayPublicTel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayPublicTel);
		if (size)
			*size = sizeof(struct __ns3__PayPublicTel);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayPublicTel[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayPublicTel);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayPublicTel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayPublicTel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayPublicTel %p -> %p\n", q, p));
	*(struct __ns3__PayPublicTel*)p = *(struct __ns3__PayPublicTel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayGame(struct soap *soap, struct __ns3__PayGame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayGame = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayGame(struct soap *soap, const struct __ns3__PayGame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayGame(soap, &a->ns1__PayGame);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayGame(struct soap *soap, const char *tag, int id, const struct __ns3__PayGame *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayGame(soap, "ns1:PayGame", -1, &a->ns1__PayGame, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayGame * SOAP_FMAC4 soap_in___ns3__PayGame(struct soap *soap, const char *tag, struct __ns3__PayGame *a, const char *type)
{
	size_t soap_flag_ns1__PayGame = 1;
	short soap_flag;
	a = (struct __ns3__PayGame *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayGame, sizeof(struct __ns3__PayGame), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayGame(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayGame && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayGame(soap, "ns1:PayGame", &a->ns1__PayGame, ""))
				{	soap_flag_ns1__PayGame--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayGame(struct soap *soap, const struct __ns3__PayGame *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayGame(soap, tag?tag:"-ns3:PayGame", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayGame * SOAP_FMAC4 soap_get___ns3__PayGame(struct soap *soap, struct __ns3__PayGame *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayGame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayGame * SOAP_FMAC2 soap_instantiate___ns3__PayGame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayGame(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayGame, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayGame);
		if (size)
			*size = sizeof(struct __ns3__PayGame);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayGame[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayGame);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayGame*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayGame(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayGame %p -> %p\n", q, p));
	*(struct __ns3__PayGame*)p = *(struct __ns3__PayGame*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__RequstInternetRollback(struct soap *soap, struct __ns3__RequstInternetRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequstInternetRollback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__RequstInternetRollback(struct soap *soap, const struct __ns3__RequstInternetRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RequstInternetRollback(soap, &a->ns1__RequstInternetRollback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__RequstInternetRollback(struct soap *soap, const char *tag, int id, const struct __ns3__RequstInternetRollback *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RequstInternetRollback(soap, "ns1:RequstInternetRollback", -1, &a->ns1__RequstInternetRollback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RequstInternetRollback * SOAP_FMAC4 soap_in___ns3__RequstInternetRollback(struct soap *soap, const char *tag, struct __ns3__RequstInternetRollback *a, const char *type)
{
	size_t soap_flag_ns1__RequstInternetRollback = 1;
	short soap_flag;
	a = (struct __ns3__RequstInternetRollback *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__RequstInternetRollback, sizeof(struct __ns3__RequstInternetRollback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__RequstInternetRollback(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequstInternetRollback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RequstInternetRollback(soap, "ns1:RequstInternetRollback", &a->ns1__RequstInternetRollback, ""))
				{	soap_flag_ns1__RequstInternetRollback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__RequstInternetRollback(struct soap *soap, const struct __ns3__RequstInternetRollback *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__RequstInternetRollback(soap, tag?tag:"-ns3:RequstInternetRollback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RequstInternetRollback * SOAP_FMAC4 soap_get___ns3__RequstInternetRollback(struct soap *soap, struct __ns3__RequstInternetRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__RequstInternetRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__RequstInternetRollback * SOAP_FMAC2 soap_instantiate___ns3__RequstInternetRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__RequstInternetRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__RequstInternetRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__RequstInternetRollback);
		if (size)
			*size = sizeof(struct __ns3__RequstInternetRollback);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__RequstInternetRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__RequstInternetRollback);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__RequstInternetRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__RequstInternetRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__RequstInternetRollback %p -> %p\n", q, p));
	*(struct __ns3__RequstInternetRollback*)p = *(struct __ns3__RequstInternetRollback*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayInternetWithList(struct soap *soap, struct __ns3__PayInternetWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayInternetWithList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayInternetWithList(struct soap *soap, const struct __ns3__PayInternetWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayInternetWithList(soap, &a->ns1__PayInternetWithList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayInternetWithList(struct soap *soap, const char *tag, int id, const struct __ns3__PayInternetWithList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayInternetWithList(soap, "ns1:PayInternetWithList", -1, &a->ns1__PayInternetWithList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayInternetWithList * SOAP_FMAC4 soap_in___ns3__PayInternetWithList(struct soap *soap, const char *tag, struct __ns3__PayInternetWithList *a, const char *type)
{
	size_t soap_flag_ns1__PayInternetWithList = 1;
	short soap_flag;
	a = (struct __ns3__PayInternetWithList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayInternetWithList, sizeof(struct __ns3__PayInternetWithList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayInternetWithList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayInternetWithList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayInternetWithList(soap, "ns1:PayInternetWithList", &a->ns1__PayInternetWithList, ""))
				{	soap_flag_ns1__PayInternetWithList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayInternetWithList(struct soap *soap, const struct __ns3__PayInternetWithList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayInternetWithList(soap, tag?tag:"-ns3:PayInternetWithList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayInternetWithList * SOAP_FMAC4 soap_get___ns3__PayInternetWithList(struct soap *soap, struct __ns3__PayInternetWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayInternetWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayInternetWithList * SOAP_FMAC2 soap_instantiate___ns3__PayInternetWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayInternetWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayInternetWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayInternetWithList);
		if (size)
			*size = sizeof(struct __ns3__PayInternetWithList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayInternetWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayInternetWithList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayInternetWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayInternetWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayInternetWithList %p -> %p\n", q, p));
	*(struct __ns3__PayInternetWithList*)p = *(struct __ns3__PayInternetWithList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayInternet(struct soap *soap, struct __ns3__PayInternet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayInternet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayInternet(struct soap *soap, const struct __ns3__PayInternet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayInternet(soap, &a->ns1__PayInternet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayInternet(struct soap *soap, const char *tag, int id, const struct __ns3__PayInternet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayInternet(soap, "ns1:PayInternet", -1, &a->ns1__PayInternet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayInternet * SOAP_FMAC4 soap_in___ns3__PayInternet(struct soap *soap, const char *tag, struct __ns3__PayInternet *a, const char *type)
{
	size_t soap_flag_ns1__PayInternet = 1;
	short soap_flag;
	a = (struct __ns3__PayInternet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayInternet, sizeof(struct __ns3__PayInternet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayInternet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayInternet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayInternet(soap, "ns1:PayInternet", &a->ns1__PayInternet, ""))
				{	soap_flag_ns1__PayInternet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayInternet(struct soap *soap, const struct __ns3__PayInternet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayInternet(soap, tag?tag:"-ns3:PayInternet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayInternet * SOAP_FMAC4 soap_get___ns3__PayInternet(struct soap *soap, struct __ns3__PayInternet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayInternet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayInternet * SOAP_FMAC2 soap_instantiate___ns3__PayInternet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayInternet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayInternet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayInternet);
		if (size)
			*size = sizeof(struct __ns3__PayInternet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayInternet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayInternet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayInternet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayInternet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayInternet %p -> %p\n", q, p));
	*(struct __ns3__PayInternet*)p = *(struct __ns3__PayInternet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__RequstRollback(struct soap *soap, struct __ns3__RequstRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequstRollback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__RequstRollback(struct soap *soap, const struct __ns3__RequstRollback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RequstRollback(soap, &a->ns1__RequstRollback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__RequstRollback(struct soap *soap, const char *tag, int id, const struct __ns3__RequstRollback *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RequstRollback(soap, "ns1:RequstRollback", -1, &a->ns1__RequstRollback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RequstRollback * SOAP_FMAC4 soap_in___ns3__RequstRollback(struct soap *soap, const char *tag, struct __ns3__RequstRollback *a, const char *type)
{
	size_t soap_flag_ns1__RequstRollback = 1;
	short soap_flag;
	a = (struct __ns3__RequstRollback *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__RequstRollback, sizeof(struct __ns3__RequstRollback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__RequstRollback(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequstRollback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RequstRollback(soap, "ns1:RequstRollback", &a->ns1__RequstRollback, ""))
				{	soap_flag_ns1__RequstRollback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__RequstRollback(struct soap *soap, const struct __ns3__RequstRollback *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__RequstRollback(soap, tag?tag:"-ns3:RequstRollback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RequstRollback * SOAP_FMAC4 soap_get___ns3__RequstRollback(struct soap *soap, struct __ns3__RequstRollback *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__RequstRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__RequstRollback * SOAP_FMAC2 soap_instantiate___ns3__RequstRollback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__RequstRollback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__RequstRollback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__RequstRollback);
		if (size)
			*size = sizeof(struct __ns3__RequstRollback);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__RequstRollback[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__RequstRollback);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__RequstRollback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__RequstRollback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__RequstRollback %p -> %p\n", q, p));
	*(struct __ns3__RequstRollback*)p = *(struct __ns3__RequstRollback*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayMoneyWithList(struct soap *soap, struct __ns3__PayMoneyWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayMoneyWithList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayMoneyWithList(struct soap *soap, const struct __ns3__PayMoneyWithList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayMoneyWithList(soap, &a->ns1__PayMoneyWithList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayMoneyWithList(struct soap *soap, const char *tag, int id, const struct __ns3__PayMoneyWithList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayMoneyWithList(soap, "ns1:PayMoneyWithList", -1, &a->ns1__PayMoneyWithList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayMoneyWithList * SOAP_FMAC4 soap_in___ns3__PayMoneyWithList(struct soap *soap, const char *tag, struct __ns3__PayMoneyWithList *a, const char *type)
{
	size_t soap_flag_ns1__PayMoneyWithList = 1;
	short soap_flag;
	a = (struct __ns3__PayMoneyWithList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayMoneyWithList, sizeof(struct __ns3__PayMoneyWithList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayMoneyWithList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayMoneyWithList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayMoneyWithList(soap, "ns1:PayMoneyWithList", &a->ns1__PayMoneyWithList, ""))
				{	soap_flag_ns1__PayMoneyWithList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayMoneyWithList(struct soap *soap, const struct __ns3__PayMoneyWithList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayMoneyWithList(soap, tag?tag:"-ns3:PayMoneyWithList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayMoneyWithList * SOAP_FMAC4 soap_get___ns3__PayMoneyWithList(struct soap *soap, struct __ns3__PayMoneyWithList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayMoneyWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayMoneyWithList * SOAP_FMAC2 soap_instantiate___ns3__PayMoneyWithList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayMoneyWithList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayMoneyWithList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayMoneyWithList);
		if (size)
			*size = sizeof(struct __ns3__PayMoneyWithList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayMoneyWithList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayMoneyWithList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayMoneyWithList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayMoneyWithList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayMoneyWithList %p -> %p\n", q, p));
	*(struct __ns3__PayMoneyWithList*)p = *(struct __ns3__PayMoneyWithList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PayMoney(struct soap *soap, struct __ns3__PayMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PayMoney = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PayMoney(struct soap *soap, const struct __ns3__PayMoney *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PayMoney(soap, &a->ns1__PayMoney);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PayMoney(struct soap *soap, const char *tag, int id, const struct __ns3__PayMoney *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PayMoney(soap, "ns1:PayMoney", -1, &a->ns1__PayMoney, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayMoney * SOAP_FMAC4 soap_in___ns3__PayMoney(struct soap *soap, const char *tag, struct __ns3__PayMoney *a, const char *type)
{
	size_t soap_flag_ns1__PayMoney = 1;
	short soap_flag;
	a = (struct __ns3__PayMoney *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PayMoney, sizeof(struct __ns3__PayMoney), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PayMoney(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PayMoney && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PayMoney(soap, "ns1:PayMoney", &a->ns1__PayMoney, ""))
				{	soap_flag_ns1__PayMoney--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PayMoney(struct soap *soap, const struct __ns3__PayMoney *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PayMoney(soap, tag?tag:"-ns3:PayMoney", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PayMoney * SOAP_FMAC4 soap_get___ns3__PayMoney(struct soap *soap, struct __ns3__PayMoney *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PayMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__PayMoney * SOAP_FMAC2 soap_instantiate___ns3__PayMoney(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PayMoney(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PayMoney, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayMoney);
		if (size)
			*size = sizeof(struct __ns3__PayMoney);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__PayMoney[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PayMoney);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PayMoney*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PayMoney(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PayMoney %p -> %p\n", q, p));
	*(struct __ns3__PayMoney*)p = *(struct __ns3__PayMoney*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetLocation(struct soap *soap, struct __ns3__GetLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetLocation(struct soap *soap, const struct __ns3__GetLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLocation(soap, &a->ns1__GetLocation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetLocation(struct soap *soap, const char *tag, int id, const struct __ns3__GetLocation *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLocation(soap, "ns1:GetLocation", -1, &a->ns1__GetLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetLocation * SOAP_FMAC4 soap_in___ns3__GetLocation(struct soap *soap, const char *tag, struct __ns3__GetLocation *a, const char *type)
{
	size_t soap_flag_ns1__GetLocation = 1;
	short soap_flag;
	a = (struct __ns3__GetLocation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetLocation, sizeof(struct __ns3__GetLocation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLocation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLocation(soap, "ns1:GetLocation", &a->ns1__GetLocation, ""))
				{	soap_flag_ns1__GetLocation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetLocation(struct soap *soap, const struct __ns3__GetLocation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetLocation(soap, tag?tag:"-ns3:GetLocation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetLocation * SOAP_FMAC4 soap_get___ns3__GetLocation(struct soap *soap, struct __ns3__GetLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__GetLocation * SOAP_FMAC2 soap_instantiate___ns3__GetLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetLocation);
		if (size)
			*size = sizeof(struct __ns3__GetLocation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__GetLocation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetLocation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetLocation %p -> %p\n", q, p));
	*(struct __ns3__GetLocation*)p = *(struct __ns3__GetLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, struct __ns14__GetStockCardItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStockCardItemAndHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, const struct __ns14__GetStockCardItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, &a->ns1__GetStockCardItemAndHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, "ns1:GetStockCardItemAndHistoryByCondition", -1, &a->ns1__GetStockCardItemAndHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetStockCardItemAndHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetStockCardItemAndHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetStockCardItemAndHistoryByCondition, sizeof(struct __ns14__GetStockCardItemAndHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetStockCardItemAndHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStockCardItemAndHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, "ns1:GetStockCardItemAndHistoryByCondition", &a->ns1__GetStockCardItemAndHistoryByCondition, ""))
				{	soap_flag_ns1__GetStockCardItemAndHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, const struct __ns14__GetStockCardItemAndHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetStockCardItemAndHistoryByCondition(soap, tag?tag:"-ns14:GetStockCardItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, struct __ns14__GetStockCardItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetStockCardItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetStockCardItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetStockCardItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetStockCardItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetStockCardItemAndHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetStockCardItemAndHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetStockCardItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetStockCardItemAndHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetStockCardItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetStockCardItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetStockCardItemAndHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetStockCardItemAndHistoryByCondition*)p = *(struct __ns14__GetStockCardItemAndHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetStockCardItemByCondition(struct soap *soap, struct __ns14__GetStockCardItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStockCardItemByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetStockCardItemByCondition(struct soap *soap, const struct __ns14__GetStockCardItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStockCardItemByCondition(soap, &a->ns1__GetStockCardItemByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetStockCardItemByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetStockCardItemByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStockCardItemByCondition(soap, "ns1:GetStockCardItemByCondition", -1, &a->ns1__GetStockCardItemByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetStockCardItemByCondition * SOAP_FMAC4 soap_in___ns14__GetStockCardItemByCondition(struct soap *soap, const char *tag, struct __ns14__GetStockCardItemByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetStockCardItemByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetStockCardItemByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetStockCardItemByCondition, sizeof(struct __ns14__GetStockCardItemByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetStockCardItemByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStockCardItemByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStockCardItemByCondition(soap, "ns1:GetStockCardItemByCondition", &a->ns1__GetStockCardItemByCondition, ""))
				{	soap_flag_ns1__GetStockCardItemByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetStockCardItemByCondition(struct soap *soap, const struct __ns14__GetStockCardItemByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetStockCardItemByCondition(soap, tag?tag:"-ns14:GetStockCardItemByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetStockCardItemByCondition * SOAP_FMAC4 soap_get___ns14__GetStockCardItemByCondition(struct soap *soap, struct __ns14__GetStockCardItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetStockCardItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetStockCardItemByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetStockCardItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetStockCardItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetStockCardItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetStockCardItemByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetStockCardItemByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetStockCardItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetStockCardItemByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetStockCardItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetStockCardItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetStockCardItemByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetStockCardItemByCondition*)p = *(struct __ns14__GetStockCardItemByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetOtherCardList(struct soap *soap, struct __ns14__GetOtherCardList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherCardList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetOtherCardList(struct soap *soap, const struct __ns14__GetOtherCardList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetOtherCardList(soap, &a->ns1__GetOtherCardList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetOtherCardList(struct soap *soap, const char *tag, int id, const struct __ns14__GetOtherCardList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetOtherCardList(soap, "ns1:GetOtherCardList", -1, &a->ns1__GetOtherCardList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetOtherCardList * SOAP_FMAC4 soap_in___ns14__GetOtherCardList(struct soap *soap, const char *tag, struct __ns14__GetOtherCardList *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherCardList = 1;
	short soap_flag;
	a = (struct __ns14__GetOtherCardList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetOtherCardList, sizeof(struct __ns14__GetOtherCardList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetOtherCardList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherCardList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherCardList(soap, "ns1:GetOtherCardList", &a->ns1__GetOtherCardList, ""))
				{	soap_flag_ns1__GetOtherCardList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetOtherCardList(struct soap *soap, const struct __ns14__GetOtherCardList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetOtherCardList(soap, tag?tag:"-ns14:GetOtherCardList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetOtherCardList * SOAP_FMAC4 soap_get___ns14__GetOtherCardList(struct soap *soap, struct __ns14__GetOtherCardList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetOtherCardList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetOtherCardList * SOAP_FMAC2 soap_instantiate___ns14__GetOtherCardList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetOtherCardList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetOtherCardList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetOtherCardList);
		if (size)
			*size = sizeof(struct __ns14__GetOtherCardList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetOtherCardList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetOtherCardList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetOtherCardList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetOtherCardList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetOtherCardList %p -> %p\n", q, p));
	*(struct __ns14__GetOtherCardList*)p = *(struct __ns14__GetOtherCardList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, struct __ns14__GettSellOtherCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GettSellOtherCardRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const struct __ns14__GettSellOtherCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, &a->ns1__GettSellOtherCardRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, "ns1:GettSellOtherCardRecordHistoryByCondition", -1, &a->ns1__GettSellOtherCardRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GettSellOtherCardRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GettSellOtherCardRecordHistoryByCondition, sizeof(struct __ns14__GettSellOtherCardRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GettSellOtherCardRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, "ns1:GettSellOtherCardRecordHistoryByCondition", &a->ns1__GettSellOtherCardRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const struct __ns14__GettSellOtherCardRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GettSellOtherCardRecordHistoryByCondition(soap, tag?tag:"-ns14:GettSellOtherCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, struct __ns14__GettSellOtherCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GettSellOtherCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GettSellOtherCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GettSellOtherCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GettSellOtherCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GettSellOtherCardRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GettSellOtherCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GettSellOtherCardRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GettSellOtherCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GettSellOtherCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GettSellOtherCardRecordHistoryByCondition*)p = *(struct __ns14__GettSellOtherCardRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, struct __ns14__GetSellOtherCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellOtherCardRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, const struct __ns14__GetSellOtherCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, &a->ns1__GetSellOtherCardRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetSellOtherCardRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, "ns1:GetSellOtherCardRecordByCondition", -1, &a->ns1__GetSellOtherCardRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_in___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, struct __ns14__GetSellOtherCardRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellOtherCardRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetSellOtherCardRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetSellOtherCardRecordByCondition, sizeof(struct __ns14__GetSellOtherCardRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetSellOtherCardRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellOtherCardRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, "ns1:GetSellOtherCardRecordByCondition", &a->ns1__GetSellOtherCardRecordByCondition, ""))
				{	soap_flag_ns1__GetSellOtherCardRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, const struct __ns14__GetSellOtherCardRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetSellOtherCardRecordByCondition(soap, tag?tag:"-ns14:GetSellOtherCardRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_get___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, struct __ns14__GetSellOtherCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetSellOtherCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetSellOtherCardRecordByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetSellOtherCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetSellOtherCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellOtherCardRecordByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetSellOtherCardRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellOtherCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetSellOtherCardRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetSellOtherCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetSellOtherCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetSellOtherCardRecordByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetSellOtherCardRecordByCondition*)p = *(struct __ns14__GetSellOtherCardRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, struct __ns14__GettBusinessRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GettBusinessRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, const struct __ns14__GettBusinessRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, &a->ns1__GettBusinessRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, "ns1:GettBusinessRecordHistoryByCondition", -1, &a->ns1__GettBusinessRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GettBusinessRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GettBusinessRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GettBusinessRecordHistoryByCondition, sizeof(struct __ns14__GettBusinessRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GettBusinessRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GettBusinessRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, "ns1:GettBusinessRecordHistoryByCondition", &a->ns1__GettBusinessRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GettBusinessRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, const struct __ns14__GettBusinessRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GettBusinessRecordHistoryByCondition(soap, tag?tag:"-ns14:GettBusinessRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, struct __ns14__GettBusinessRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GettBusinessRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GettBusinessRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GettBusinessRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GettBusinessRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GettBusinessRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GettBusinessRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GettBusinessRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GettBusinessRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GettBusinessRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GettBusinessRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GettBusinessRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GettBusinessRecordHistoryByCondition*)p = *(struct __ns14__GettBusinessRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetBusinessRecordByCondition(struct soap *soap, struct __ns14__GetBusinessRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBusinessRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetBusinessRecordByCondition(struct soap *soap, const struct __ns14__GetBusinessRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetBusinessRecordByCondition(soap, &a->ns1__GetBusinessRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetBusinessRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetBusinessRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetBusinessRecordByCondition(soap, "ns1:GetBusinessRecordByCondition", -1, &a->ns1__GetBusinessRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetBusinessRecordByCondition * SOAP_FMAC4 soap_in___ns14__GetBusinessRecordByCondition(struct soap *soap, const char *tag, struct __ns14__GetBusinessRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetBusinessRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetBusinessRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetBusinessRecordByCondition, sizeof(struct __ns14__GetBusinessRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetBusinessRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBusinessRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetBusinessRecordByCondition(soap, "ns1:GetBusinessRecordByCondition", &a->ns1__GetBusinessRecordByCondition, ""))
				{	soap_flag_ns1__GetBusinessRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetBusinessRecordByCondition(struct soap *soap, const struct __ns14__GetBusinessRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetBusinessRecordByCondition(soap, tag?tag:"-ns14:GetBusinessRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetBusinessRecordByCondition * SOAP_FMAC4 soap_get___ns14__GetBusinessRecordByCondition(struct soap *soap, struct __ns14__GetBusinessRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetBusinessRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetBusinessRecordByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetBusinessRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetBusinessRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetBusinessRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetBusinessRecordByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetBusinessRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetBusinessRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetBusinessRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetBusinessRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetBusinessRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetBusinessRecordByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetBusinessRecordByCondition*)p = *(struct __ns14__GetBusinessRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, struct __ns14__GetSellCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellCardRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, const struct __ns14__GetSellCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, &a->ns1__GetSellCardRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, "ns1:GetSellCardRecordHistoryByCondition", -1, &a->ns1__GetSellCardRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellCardRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetSellCardRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetSellCardRecordHistoryByCondition, sizeof(struct __ns14__GetSellCardRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetSellCardRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellCardRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, "ns1:GetSellCardRecordHistoryByCondition", &a->ns1__GetSellCardRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GetSellCardRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, const struct __ns14__GetSellCardRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetSellCardRecordHistoryByCondition(soap, tag?tag:"-ns14:GetSellCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, struct __ns14__GetSellCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetSellCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetSellCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetSellCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetSellCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetSellCardRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetSellCardRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetSellCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetSellCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetSellCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetSellCardRecordHistoryByCondition*)p = *(struct __ns14__GetSellCardRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetSellCardRecordByCondition(struct soap *soap, struct __ns14__GetSellCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellCardRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetSellCardRecordByCondition(struct soap *soap, const struct __ns14__GetSellCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellCardRecordByCondition(soap, &a->ns1__GetSellCardRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetSellCardRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetSellCardRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellCardRecordByCondition(soap, "ns1:GetSellCardRecordByCondition", -1, &a->ns1__GetSellCardRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellCardRecordByCondition * SOAP_FMAC4 soap_in___ns14__GetSellCardRecordByCondition(struct soap *soap, const char *tag, struct __ns14__GetSellCardRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellCardRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetSellCardRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetSellCardRecordByCondition, sizeof(struct __ns14__GetSellCardRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetSellCardRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellCardRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellCardRecordByCondition(soap, "ns1:GetSellCardRecordByCondition", &a->ns1__GetSellCardRecordByCondition, ""))
				{	soap_flag_ns1__GetSellCardRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetSellCardRecordByCondition(struct soap *soap, const struct __ns14__GetSellCardRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetSellCardRecordByCondition(soap, tag?tag:"-ns14:GetSellCardRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetSellCardRecordByCondition * SOAP_FMAC4 soap_get___ns14__GetSellCardRecordByCondition(struct soap *soap, struct __ns14__GetSellCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetSellCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetSellCardRecordByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetSellCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetSellCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetSellCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellCardRecordByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetSellCardRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetSellCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetSellCardRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetSellCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetSellCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetSellCardRecordByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetSellCardRecordByCondition*)p = *(struct __ns14__GetSellCardRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetCardService(struct soap *soap, struct __ns14__GetCardService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCardService = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetCardService(struct soap *soap, const struct __ns14__GetCardService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCardService(soap, &a->ns1__GetCardService);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetCardService(struct soap *soap, const char *tag, int id, const struct __ns14__GetCardService *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCardService(soap, "ns1:GetCardService", -1, &a->ns1__GetCardService, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetCardService * SOAP_FMAC4 soap_in___ns14__GetCardService(struct soap *soap, const char *tag, struct __ns14__GetCardService *a, const char *type)
{
	size_t soap_flag_ns1__GetCardService = 1;
	short soap_flag;
	a = (struct __ns14__GetCardService *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetCardService, sizeof(struct __ns14__GetCardService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetCardService(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCardService && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCardService(soap, "ns1:GetCardService", &a->ns1__GetCardService, ""))
				{	soap_flag_ns1__GetCardService--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetCardService(struct soap *soap, const struct __ns14__GetCardService *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetCardService(soap, tag?tag:"-ns14:GetCardService", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetCardService * SOAP_FMAC4 soap_get___ns14__GetCardService(struct soap *soap, struct __ns14__GetCardService *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetCardService * SOAP_FMAC2 soap_instantiate___ns14__GetCardService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetCardService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetCardService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetCardService);
		if (size)
			*size = sizeof(struct __ns14__GetCardService);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetCardService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetCardService);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetCardService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetCardService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetCardService %p -> %p\n", q, p));
	*(struct __ns14__GetCardService*)p = *(struct __ns14__GetCardService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, struct __ns14__GetPhoneNoItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoItemAndHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const struct __ns14__GetPhoneNoItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, &a->ns1__GetPhoneNoItemAndHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, "ns1:GetPhoneNoItemAndHistoryByCondition", -1, &a->ns1__GetPhoneNoItemAndHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetPhoneNoItemAndHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetPhoneNoItemAndHistoryByCondition, sizeof(struct __ns14__GetPhoneNoItemAndHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetPhoneNoItemAndHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, "ns1:GetPhoneNoItemAndHistoryByCondition", &a->ns1__GetPhoneNoItemAndHistoryByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const struct __ns14__GetPhoneNoItemAndHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetPhoneNoItemAndHistoryByCondition(soap, tag?tag:"-ns14:GetPhoneNoItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, struct __ns14__GetPhoneNoItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetPhoneNoItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetPhoneNoItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetPhoneNoItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoItemAndHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetPhoneNoItemAndHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetPhoneNoItemAndHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetPhoneNoItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetPhoneNoItemAndHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetPhoneNoItemAndHistoryByCondition*)p = *(struct __ns14__GetPhoneNoItemAndHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetPhoneNoItemByCondition(struct soap *soap, struct __ns14__GetPhoneNoItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoItemByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetPhoneNoItemByCondition(struct soap *soap, const struct __ns14__GetPhoneNoItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoItemByCondition(soap, &a->ns1__GetPhoneNoItemByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetPhoneNoItemByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoItemByCondition(soap, "ns1:GetPhoneNoItemByCondition", -1, &a->ns1__GetPhoneNoItemByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_in___ns14__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, struct __ns14__GetPhoneNoItemByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoItemByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetPhoneNoItemByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetPhoneNoItemByCondition, sizeof(struct __ns14__GetPhoneNoItemByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetPhoneNoItemByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoItemByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoItemByCondition(soap, "ns1:GetPhoneNoItemByCondition", &a->ns1__GetPhoneNoItemByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoItemByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetPhoneNoItemByCondition(struct soap *soap, const struct __ns14__GetPhoneNoItemByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetPhoneNoItemByCondition(soap, tag?tag:"-ns14:GetPhoneNoItemByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_get___ns14__GetPhoneNoItemByCondition(struct soap *soap, struct __ns14__GetPhoneNoItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetPhoneNoItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetPhoneNoItemByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetPhoneNoItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetPhoneNoItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetPhoneNoItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoItemByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetPhoneNoItemByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetPhoneNoItemByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetPhoneNoItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetPhoneNoItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetPhoneNoItemByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetPhoneNoItemByCondition*)p = *(struct __ns14__GetPhoneNoItemByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, struct __ns14__GetPayMiniCardHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayMiniCardHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, const struct __ns14__GetPayMiniCardHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, &a->ns1__GetPayMiniCardHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, "ns1:GetPayMiniCardHistoryByCondition", -1, &a->ns1__GetPayMiniCardHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_in___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, struct __ns14__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayMiniCardHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetPayMiniCardHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetPayMiniCardHistoryByCondition, sizeof(struct __ns14__GetPayMiniCardHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetPayMiniCardHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayMiniCardHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, "ns1:GetPayMiniCardHistoryByCondition", &a->ns1__GetPayMiniCardHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayMiniCardHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, const struct __ns14__GetPayMiniCardHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetPayMiniCardHistoryByCondition(soap, tag?tag:"-ns14:GetPayMiniCardHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_get___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, struct __ns14__GetPayMiniCardHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetPayMiniCardHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetPayMiniCardHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetPayMiniCardHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetPayMiniCardHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPayMiniCardHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetPayMiniCardHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPayMiniCardHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetPayMiniCardHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetPayMiniCardHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetPayMiniCardHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetPayMiniCardHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetPayMiniCardHistoryByCondition*)p = *(struct __ns14__GetPayMiniCardHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetPayMiniCardByCondition(struct soap *soap, struct __ns14__GetPayMiniCardByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayMiniCardByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetPayMiniCardByCondition(struct soap *soap, const struct __ns14__GetPayMiniCardByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayMiniCardByCondition(soap, &a->ns1__GetPayMiniCardByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetPayMiniCardByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetPayMiniCardByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayMiniCardByCondition(soap, "ns1:GetPayMiniCardByCondition", -1, &a->ns1__GetPayMiniCardByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPayMiniCardByCondition * SOAP_FMAC4 soap_in___ns14__GetPayMiniCardByCondition(struct soap *soap, const char *tag, struct __ns14__GetPayMiniCardByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayMiniCardByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetPayMiniCardByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetPayMiniCardByCondition, sizeof(struct __ns14__GetPayMiniCardByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetPayMiniCardByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayMiniCardByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayMiniCardByCondition(soap, "ns1:GetPayMiniCardByCondition", &a->ns1__GetPayMiniCardByCondition, ""))
				{	soap_flag_ns1__GetPayMiniCardByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetPayMiniCardByCondition(struct soap *soap, const struct __ns14__GetPayMiniCardByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetPayMiniCardByCondition(soap, tag?tag:"-ns14:GetPayMiniCardByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPayMiniCardByCondition * SOAP_FMAC4 soap_get___ns14__GetPayMiniCardByCondition(struct soap *soap, struct __ns14__GetPayMiniCardByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetPayMiniCardByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetPayMiniCardByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetPayMiniCardByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetPayMiniCardByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetPayMiniCardByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPayMiniCardByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetPayMiniCardByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPayMiniCardByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetPayMiniCardByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetPayMiniCardByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetPayMiniCardByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetPayMiniCardByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetPayMiniCardByCondition*)p = *(struct __ns14__GetPayMiniCardByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetMiniCardRecord(struct soap *soap, struct __ns14__GetMiniCardRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMiniCardRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetMiniCardRecord(struct soap *soap, const struct __ns14__GetMiniCardRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetMiniCardRecord(soap, &a->ns1__GetMiniCardRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetMiniCardRecord(struct soap *soap, const char *tag, int id, const struct __ns14__GetMiniCardRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMiniCardRecord(soap, "ns1:GetMiniCardRecord", -1, &a->ns1__GetMiniCardRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetMiniCardRecord * SOAP_FMAC4 soap_in___ns14__GetMiniCardRecord(struct soap *soap, const char *tag, struct __ns14__GetMiniCardRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetMiniCardRecord = 1;
	short soap_flag;
	a = (struct __ns14__GetMiniCardRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetMiniCardRecord, sizeof(struct __ns14__GetMiniCardRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetMiniCardRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMiniCardRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetMiniCardRecord(soap, "ns1:GetMiniCardRecord", &a->ns1__GetMiniCardRecord, ""))
				{	soap_flag_ns1__GetMiniCardRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetMiniCardRecord(struct soap *soap, const struct __ns14__GetMiniCardRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetMiniCardRecord(soap, tag?tag:"-ns14:GetMiniCardRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetMiniCardRecord * SOAP_FMAC4 soap_get___ns14__GetMiniCardRecord(struct soap *soap, struct __ns14__GetMiniCardRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetMiniCardRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetMiniCardRecord * SOAP_FMAC2 soap_instantiate___ns14__GetMiniCardRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetMiniCardRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetMiniCardRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetMiniCardRecord);
		if (size)
			*size = sizeof(struct __ns14__GetMiniCardRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetMiniCardRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetMiniCardRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetMiniCardRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetMiniCardRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetMiniCardRecord %p -> %p\n", q, p));
	*(struct __ns14__GetMiniCardRecord*)p = *(struct __ns14__GetMiniCardRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__SellOhterCard(struct soap *soap, struct __ns14__SellOhterCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SellOhterCard = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__SellOhterCard(struct soap *soap, const struct __ns14__SellOhterCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SellOhterCard(soap, &a->ns1__SellOhterCard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__SellOhterCard(struct soap *soap, const char *tag, int id, const struct __ns14__SellOhterCard *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SellOhterCard(soap, "ns1:SellOhterCard", -1, &a->ns1__SellOhterCard, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SellOhterCard * SOAP_FMAC4 soap_in___ns14__SellOhterCard(struct soap *soap, const char *tag, struct __ns14__SellOhterCard *a, const char *type)
{
	size_t soap_flag_ns1__SellOhterCard = 1;
	short soap_flag;
	a = (struct __ns14__SellOhterCard *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__SellOhterCard, sizeof(struct __ns14__SellOhterCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__SellOhterCard(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SellOhterCard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SellOhterCard(soap, "ns1:SellOhterCard", &a->ns1__SellOhterCard, ""))
				{	soap_flag_ns1__SellOhterCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__SellOhterCard(struct soap *soap, const struct __ns14__SellOhterCard *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__SellOhterCard(soap, tag?tag:"-ns14:SellOhterCard", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SellOhterCard * SOAP_FMAC4 soap_get___ns14__SellOhterCard(struct soap *soap, struct __ns14__SellOhterCard *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__SellOhterCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__SellOhterCard * SOAP_FMAC2 soap_instantiate___ns14__SellOhterCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__SellOhterCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__SellOhterCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SellOhterCard);
		if (size)
			*size = sizeof(struct __ns14__SellOhterCard);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SellOhterCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__SellOhterCard);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__SellOhterCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__SellOhterCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__SellOhterCard %p -> %p\n", q, p));
	*(struct __ns14__SellOhterCard*)p = *(struct __ns14__SellOhterCard*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__SellNo(struct soap *soap, struct __ns14__SellNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SellNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__SellNo(struct soap *soap, const struct __ns14__SellNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SellNo(soap, &a->ns1__SellNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__SellNo(struct soap *soap, const char *tag, int id, const struct __ns14__SellNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SellNo(soap, "ns1:SellNo", -1, &a->ns1__SellNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SellNo * SOAP_FMAC4 soap_in___ns14__SellNo(struct soap *soap, const char *tag, struct __ns14__SellNo *a, const char *type)
{
	size_t soap_flag_ns1__SellNo = 1;
	short soap_flag;
	a = (struct __ns14__SellNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__SellNo, sizeof(struct __ns14__SellNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__SellNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SellNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SellNo(soap, "ns1:SellNo", &a->ns1__SellNo, ""))
				{	soap_flag_ns1__SellNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__SellNo(struct soap *soap, const struct __ns14__SellNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__SellNo(soap, tag?tag:"-ns14:SellNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SellNo * SOAP_FMAC4 soap_get___ns14__SellNo(struct soap *soap, struct __ns14__SellNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__SellNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__SellNo * SOAP_FMAC2 soap_instantiate___ns14__SellNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__SellNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__SellNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SellNo);
		if (size)
			*size = sizeof(struct __ns14__SellNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SellNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__SellNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__SellNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__SellNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__SellNo %p -> %p\n", q, p));
	*(struct __ns14__SellNo*)p = *(struct __ns14__SellNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__SubmitBusiness(struct soap *soap, struct __ns14__SubmitBusiness *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SubmitBusiness = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__SubmitBusiness(struct soap *soap, const struct __ns14__SubmitBusiness *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SubmitBusiness(soap, &a->ns1__SubmitBusiness);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__SubmitBusiness(struct soap *soap, const char *tag, int id, const struct __ns14__SubmitBusiness *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SubmitBusiness(soap, "ns1:SubmitBusiness", -1, &a->ns1__SubmitBusiness, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SubmitBusiness * SOAP_FMAC4 soap_in___ns14__SubmitBusiness(struct soap *soap, const char *tag, struct __ns14__SubmitBusiness *a, const char *type)
{
	size_t soap_flag_ns1__SubmitBusiness = 1;
	short soap_flag;
	a = (struct __ns14__SubmitBusiness *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__SubmitBusiness, sizeof(struct __ns14__SubmitBusiness), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__SubmitBusiness(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SubmitBusiness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SubmitBusiness(soap, "ns1:SubmitBusiness", &a->ns1__SubmitBusiness, ""))
				{	soap_flag_ns1__SubmitBusiness--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__SubmitBusiness(struct soap *soap, const struct __ns14__SubmitBusiness *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__SubmitBusiness(soap, tag?tag:"-ns14:SubmitBusiness", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__SubmitBusiness * SOAP_FMAC4 soap_get___ns14__SubmitBusiness(struct soap *soap, struct __ns14__SubmitBusiness *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__SubmitBusiness(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__SubmitBusiness * SOAP_FMAC2 soap_instantiate___ns14__SubmitBusiness(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__SubmitBusiness(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__SubmitBusiness, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SubmitBusiness);
		if (size)
			*size = sizeof(struct __ns14__SubmitBusiness);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__SubmitBusiness[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__SubmitBusiness);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__SubmitBusiness*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__SubmitBusiness(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__SubmitBusiness %p -> %p\n", q, p));
	*(struct __ns14__SubmitBusiness*)p = *(struct __ns14__SubmitBusiness*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__UnlockNo(struct soap *soap, struct __ns14__UnlockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnlockNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__UnlockNo(struct soap *soap, const struct __ns14__UnlockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UnlockNo(soap, &a->ns1__UnlockNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__UnlockNo(struct soap *soap, const char *tag, int id, const struct __ns14__UnlockNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UnlockNo(soap, "ns1:UnlockNo", -1, &a->ns1__UnlockNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__UnlockNo * SOAP_FMAC4 soap_in___ns14__UnlockNo(struct soap *soap, const char *tag, struct __ns14__UnlockNo *a, const char *type)
{
	size_t soap_flag_ns1__UnlockNo = 1;
	short soap_flag;
	a = (struct __ns14__UnlockNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__UnlockNo, sizeof(struct __ns14__UnlockNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__UnlockNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnlockNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UnlockNo(soap, "ns1:UnlockNo", &a->ns1__UnlockNo, ""))
				{	soap_flag_ns1__UnlockNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__UnlockNo(struct soap *soap, const struct __ns14__UnlockNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__UnlockNo(soap, tag?tag:"-ns14:UnlockNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__UnlockNo * SOAP_FMAC4 soap_get___ns14__UnlockNo(struct soap *soap, struct __ns14__UnlockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__UnlockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__UnlockNo * SOAP_FMAC2 soap_instantiate___ns14__UnlockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__UnlockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__UnlockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__UnlockNo);
		if (size)
			*size = sizeof(struct __ns14__UnlockNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__UnlockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__UnlockNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__UnlockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__UnlockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__UnlockNo %p -> %p\n", q, p));
	*(struct __ns14__UnlockNo*)p = *(struct __ns14__UnlockNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__LockNo(struct soap *soap, struct __ns14__LockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LockNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__LockNo(struct soap *soap, const struct __ns14__LockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__LockNo(soap, &a->ns1__LockNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__LockNo(struct soap *soap, const char *tag, int id, const struct __ns14__LockNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__LockNo(soap, "ns1:LockNo", -1, &a->ns1__LockNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__LockNo * SOAP_FMAC4 soap_in___ns14__LockNo(struct soap *soap, const char *tag, struct __ns14__LockNo *a, const char *type)
{
	size_t soap_flag_ns1__LockNo = 1;
	short soap_flag;
	a = (struct __ns14__LockNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__LockNo, sizeof(struct __ns14__LockNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__LockNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LockNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LockNo(soap, "ns1:LockNo", &a->ns1__LockNo, ""))
				{	soap_flag_ns1__LockNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__LockNo(struct soap *soap, const struct __ns14__LockNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__LockNo(soap, tag?tag:"-ns14:LockNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__LockNo * SOAP_FMAC4 soap_get___ns14__LockNo(struct soap *soap, struct __ns14__LockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__LockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__LockNo * SOAP_FMAC2 soap_instantiate___ns14__LockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__LockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__LockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__LockNo);
		if (size)
			*size = sizeof(struct __ns14__LockNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__LockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__LockNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__LockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__LockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__LockNo %p -> %p\n", q, p));
	*(struct __ns14__LockNo*)p = *(struct __ns14__LockNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetMyNoSection(struct soap *soap, struct __ns14__GetMyNoSection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMyNoSection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetMyNoSection(struct soap *soap, const struct __ns14__GetMyNoSection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetMyNoSection(soap, &a->ns1__GetMyNoSection);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetMyNoSection(struct soap *soap, const char *tag, int id, const struct __ns14__GetMyNoSection *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMyNoSection(soap, "ns1:GetMyNoSection", -1, &a->ns1__GetMyNoSection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetMyNoSection * SOAP_FMAC4 soap_in___ns14__GetMyNoSection(struct soap *soap, const char *tag, struct __ns14__GetMyNoSection *a, const char *type)
{
	size_t soap_flag_ns1__GetMyNoSection = 1;
	short soap_flag;
	a = (struct __ns14__GetMyNoSection *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetMyNoSection, sizeof(struct __ns14__GetMyNoSection), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetMyNoSection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMyNoSection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetMyNoSection(soap, "ns1:GetMyNoSection", &a->ns1__GetMyNoSection, ""))
				{	soap_flag_ns1__GetMyNoSection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetMyNoSection(struct soap *soap, const struct __ns14__GetMyNoSection *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetMyNoSection(soap, tag?tag:"-ns14:GetMyNoSection", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetMyNoSection * SOAP_FMAC4 soap_get___ns14__GetMyNoSection(struct soap *soap, struct __ns14__GetMyNoSection *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetMyNoSection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetMyNoSection * SOAP_FMAC2 soap_instantiate___ns14__GetMyNoSection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetMyNoSection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetMyNoSection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetMyNoSection);
		if (size)
			*size = sizeof(struct __ns14__GetMyNoSection);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetMyNoSection[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetMyNoSection);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetMyNoSection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetMyNoSection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetMyNoSection %p -> %p\n", q, p));
	*(struct __ns14__GetMyNoSection*)p = *(struct __ns14__GetMyNoSection*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__GetPhoneNoByCondition(struct soap *soap, struct __ns14__GetPhoneNoByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__GetPhoneNoByCondition(struct soap *soap, const struct __ns14__GetPhoneNoByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoByCondition(soap, &a->ns1__GetPhoneNoByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__GetPhoneNoByCondition(struct soap *soap, const char *tag, int id, const struct __ns14__GetPhoneNoByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoByCondition(soap, "ns1:GetPhoneNoByCondition", -1, &a->ns1__GetPhoneNoByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoByCondition * SOAP_FMAC4 soap_in___ns14__GetPhoneNoByCondition(struct soap *soap, const char *tag, struct __ns14__GetPhoneNoByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoByCondition = 1;
	short soap_flag;
	a = (struct __ns14__GetPhoneNoByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__GetPhoneNoByCondition, sizeof(struct __ns14__GetPhoneNoByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__GetPhoneNoByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoByCondition(soap, "ns1:GetPhoneNoByCondition", &a->ns1__GetPhoneNoByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__GetPhoneNoByCondition(struct soap *soap, const struct __ns14__GetPhoneNoByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__GetPhoneNoByCondition(soap, tag?tag:"-ns14:GetPhoneNoByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__GetPhoneNoByCondition * SOAP_FMAC4 soap_get___ns14__GetPhoneNoByCondition(struct soap *soap, struct __ns14__GetPhoneNoByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__GetPhoneNoByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__GetPhoneNoByCondition * SOAP_FMAC2 soap_instantiate___ns14__GetPhoneNoByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__GetPhoneNoByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__GetPhoneNoByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoByCondition);
		if (size)
			*size = sizeof(struct __ns14__GetPhoneNoByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__GetPhoneNoByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__GetPhoneNoByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__GetPhoneNoByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__GetPhoneNoByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__GetPhoneNoByCondition %p -> %p\n", q, p));
	*(struct __ns14__GetPhoneNoByCondition*)p = *(struct __ns14__GetPhoneNoByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__BuyMiniCard(struct soap *soap, struct __ns14__BuyMiniCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BuyMiniCard = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__BuyMiniCard(struct soap *soap, const struct __ns14__BuyMiniCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__BuyMiniCard(soap, &a->ns1__BuyMiniCard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__BuyMiniCard(struct soap *soap, const char *tag, int id, const struct __ns14__BuyMiniCard *a, const char *type)
{
	if (soap_out_PointerTo_ns1__BuyMiniCard(soap, "ns1:BuyMiniCard", -1, &a->ns1__BuyMiniCard, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__BuyMiniCard * SOAP_FMAC4 soap_in___ns14__BuyMiniCard(struct soap *soap, const char *tag, struct __ns14__BuyMiniCard *a, const char *type)
{
	size_t soap_flag_ns1__BuyMiniCard = 1;
	short soap_flag;
	a = (struct __ns14__BuyMiniCard *)soap_id_enter(soap, "", a, SOAP_TYPE___ns14__BuyMiniCard, sizeof(struct __ns14__BuyMiniCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns14__BuyMiniCard(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BuyMiniCard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BuyMiniCard(soap, "ns1:BuyMiniCard", &a->ns1__BuyMiniCard, ""))
				{	soap_flag_ns1__BuyMiniCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__BuyMiniCard(struct soap *soap, const struct __ns14__BuyMiniCard *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns14__BuyMiniCard(soap, tag?tag:"-ns14:BuyMiniCard", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__BuyMiniCard * SOAP_FMAC4 soap_get___ns14__BuyMiniCard(struct soap *soap, struct __ns14__BuyMiniCard *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__BuyMiniCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns14__BuyMiniCard * SOAP_FMAC2 soap_instantiate___ns14__BuyMiniCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns14__BuyMiniCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns14__BuyMiniCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__BuyMiniCard);
		if (size)
			*size = sizeof(struct __ns14__BuyMiniCard);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns14__BuyMiniCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns14__BuyMiniCard);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns14__BuyMiniCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns14__BuyMiniCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns14__BuyMiniCard %p -> %p\n", q, p));
	*(struct __ns14__BuyMiniCard*)p = *(struct __ns14__BuyMiniCard*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, struct __ns13__GetStockCardItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStockCardItemAndHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, const struct __ns13__GetStockCardItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, &a->ns1__GetStockCardItemAndHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, "ns1:GetStockCardItemAndHistoryByCondition", -1, &a->ns1__GetStockCardItemAndHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GetStockCardItemAndHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetStockCardItemAndHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetStockCardItemAndHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetStockCardItemAndHistoryByCondition, sizeof(struct __ns13__GetStockCardItemAndHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetStockCardItemAndHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStockCardItemAndHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, "ns1:GetStockCardItemAndHistoryByCondition", &a->ns1__GetStockCardItemAndHistoryByCondition, ""))
				{	soap_flag_ns1__GetStockCardItemAndHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, const struct __ns13__GetStockCardItemAndHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetStockCardItemAndHistoryByCondition(soap, tag?tag:"-ns13:GetStockCardItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetStockCardItemAndHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, struct __ns13__GetStockCardItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetStockCardItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetStockCardItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetStockCardItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetStockCardItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetStockCardItemAndHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetStockCardItemAndHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetStockCardItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetStockCardItemAndHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetStockCardItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetStockCardItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetStockCardItemAndHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetStockCardItemAndHistoryByCondition*)p = *(struct __ns13__GetStockCardItemAndHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetStockCardItemByCondition(struct soap *soap, struct __ns13__GetStockCardItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStockCardItemByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetStockCardItemByCondition(struct soap *soap, const struct __ns13__GetStockCardItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStockCardItemByCondition(soap, &a->ns1__GetStockCardItemByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetStockCardItemByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetStockCardItemByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStockCardItemByCondition(soap, "ns1:GetStockCardItemByCondition", -1, &a->ns1__GetStockCardItemByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetStockCardItemByCondition * SOAP_FMAC4 soap_in___ns13__GetStockCardItemByCondition(struct soap *soap, const char *tag, struct __ns13__GetStockCardItemByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetStockCardItemByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetStockCardItemByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetStockCardItemByCondition, sizeof(struct __ns13__GetStockCardItemByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetStockCardItemByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStockCardItemByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStockCardItemByCondition(soap, "ns1:GetStockCardItemByCondition", &a->ns1__GetStockCardItemByCondition, ""))
				{	soap_flag_ns1__GetStockCardItemByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetStockCardItemByCondition(struct soap *soap, const struct __ns13__GetStockCardItemByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetStockCardItemByCondition(soap, tag?tag:"-ns13:GetStockCardItemByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetStockCardItemByCondition * SOAP_FMAC4 soap_get___ns13__GetStockCardItemByCondition(struct soap *soap, struct __ns13__GetStockCardItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetStockCardItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetStockCardItemByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetStockCardItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetStockCardItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetStockCardItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetStockCardItemByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetStockCardItemByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetStockCardItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetStockCardItemByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetStockCardItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetStockCardItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetStockCardItemByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetStockCardItemByCondition*)p = *(struct __ns13__GetStockCardItemByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetOtherCardList(struct soap *soap, struct __ns13__GetOtherCardList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherCardList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetOtherCardList(struct soap *soap, const struct __ns13__GetOtherCardList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetOtherCardList(soap, &a->ns1__GetOtherCardList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetOtherCardList(struct soap *soap, const char *tag, int id, const struct __ns13__GetOtherCardList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetOtherCardList(soap, "ns1:GetOtherCardList", -1, &a->ns1__GetOtherCardList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetOtherCardList * SOAP_FMAC4 soap_in___ns13__GetOtherCardList(struct soap *soap, const char *tag, struct __ns13__GetOtherCardList *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherCardList = 1;
	short soap_flag;
	a = (struct __ns13__GetOtherCardList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetOtherCardList, sizeof(struct __ns13__GetOtherCardList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetOtherCardList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherCardList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherCardList(soap, "ns1:GetOtherCardList", &a->ns1__GetOtherCardList, ""))
				{	soap_flag_ns1__GetOtherCardList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetOtherCardList(struct soap *soap, const struct __ns13__GetOtherCardList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetOtherCardList(soap, tag?tag:"-ns13:GetOtherCardList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetOtherCardList * SOAP_FMAC4 soap_get___ns13__GetOtherCardList(struct soap *soap, struct __ns13__GetOtherCardList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetOtherCardList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetOtherCardList * SOAP_FMAC2 soap_instantiate___ns13__GetOtherCardList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetOtherCardList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetOtherCardList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetOtherCardList);
		if (size)
			*size = sizeof(struct __ns13__GetOtherCardList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetOtherCardList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetOtherCardList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetOtherCardList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetOtherCardList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetOtherCardList %p -> %p\n", q, p));
	*(struct __ns13__GetOtherCardList*)p = *(struct __ns13__GetOtherCardList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, struct __ns13__GettSellOtherCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GettSellOtherCardRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const struct __ns13__GettSellOtherCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, &a->ns1__GettSellOtherCardRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, "ns1:GettSellOtherCardRecordHistoryByCondition", -1, &a->ns1__GettSellOtherCardRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GettSellOtherCardRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GettSellOtherCardRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GettSellOtherCardRecordHistoryByCondition, sizeof(struct __ns13__GettSellOtherCardRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GettSellOtherCardRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, "ns1:GettSellOtherCardRecordHistoryByCondition", &a->ns1__GettSellOtherCardRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GettSellOtherCardRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const struct __ns13__GettSellOtherCardRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GettSellOtherCardRecordHistoryByCondition(soap, tag?tag:"-ns13:GettSellOtherCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, struct __ns13__GettSellOtherCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GettSellOtherCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GettSellOtherCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GettSellOtherCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GettSellOtherCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GettSellOtherCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GettSellOtherCardRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GettSellOtherCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GettSellOtherCardRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GettSellOtherCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GettSellOtherCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GettSellOtherCardRecordHistoryByCondition*)p = *(struct __ns13__GettSellOtherCardRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, struct __ns13__GetSellOtherCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellOtherCardRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, const struct __ns13__GetSellOtherCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, &a->ns1__GetSellOtherCardRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetSellOtherCardRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, "ns1:GetSellOtherCardRecordByCondition", -1, &a->ns1__GetSellOtherCardRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_in___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, struct __ns13__GetSellOtherCardRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellOtherCardRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetSellOtherCardRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetSellOtherCardRecordByCondition, sizeof(struct __ns13__GetSellOtherCardRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetSellOtherCardRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellOtherCardRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, "ns1:GetSellOtherCardRecordByCondition", &a->ns1__GetSellOtherCardRecordByCondition, ""))
				{	soap_flag_ns1__GetSellOtherCardRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, const struct __ns13__GetSellOtherCardRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetSellOtherCardRecordByCondition(soap, tag?tag:"-ns13:GetSellOtherCardRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellOtherCardRecordByCondition * SOAP_FMAC4 soap_get___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, struct __ns13__GetSellOtherCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetSellOtherCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetSellOtherCardRecordByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetSellOtherCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetSellOtherCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellOtherCardRecordByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetSellOtherCardRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellOtherCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetSellOtherCardRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetSellOtherCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetSellOtherCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetSellOtherCardRecordByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetSellOtherCardRecordByCondition*)p = *(struct __ns13__GetSellOtherCardRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, struct __ns13__GettBusinessRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GettBusinessRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, const struct __ns13__GettBusinessRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, &a->ns1__GettBusinessRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, "ns1:GettBusinessRecordHistoryByCondition", -1, &a->ns1__GettBusinessRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GettBusinessRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GettBusinessRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GettBusinessRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GettBusinessRecordHistoryByCondition, sizeof(struct __ns13__GettBusinessRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GettBusinessRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GettBusinessRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, "ns1:GettBusinessRecordHistoryByCondition", &a->ns1__GettBusinessRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GettBusinessRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, const struct __ns13__GettBusinessRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GettBusinessRecordHistoryByCondition(soap, tag?tag:"-ns13:GettBusinessRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GettBusinessRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, struct __ns13__GettBusinessRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GettBusinessRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GettBusinessRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GettBusinessRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GettBusinessRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GettBusinessRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GettBusinessRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GettBusinessRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GettBusinessRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GettBusinessRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GettBusinessRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GettBusinessRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GettBusinessRecordHistoryByCondition*)p = *(struct __ns13__GettBusinessRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetBusinessRecordByCondition(struct soap *soap, struct __ns13__GetBusinessRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBusinessRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetBusinessRecordByCondition(struct soap *soap, const struct __ns13__GetBusinessRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetBusinessRecordByCondition(soap, &a->ns1__GetBusinessRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetBusinessRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetBusinessRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetBusinessRecordByCondition(soap, "ns1:GetBusinessRecordByCondition", -1, &a->ns1__GetBusinessRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetBusinessRecordByCondition * SOAP_FMAC4 soap_in___ns13__GetBusinessRecordByCondition(struct soap *soap, const char *tag, struct __ns13__GetBusinessRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetBusinessRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetBusinessRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetBusinessRecordByCondition, sizeof(struct __ns13__GetBusinessRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetBusinessRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBusinessRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetBusinessRecordByCondition(soap, "ns1:GetBusinessRecordByCondition", &a->ns1__GetBusinessRecordByCondition, ""))
				{	soap_flag_ns1__GetBusinessRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetBusinessRecordByCondition(struct soap *soap, const struct __ns13__GetBusinessRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetBusinessRecordByCondition(soap, tag?tag:"-ns13:GetBusinessRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetBusinessRecordByCondition * SOAP_FMAC4 soap_get___ns13__GetBusinessRecordByCondition(struct soap *soap, struct __ns13__GetBusinessRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetBusinessRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetBusinessRecordByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetBusinessRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetBusinessRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetBusinessRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetBusinessRecordByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetBusinessRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetBusinessRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetBusinessRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetBusinessRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetBusinessRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetBusinessRecordByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetBusinessRecordByCondition*)p = *(struct __ns13__GetBusinessRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, struct __ns13__GetSellCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellCardRecordHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, const struct __ns13__GetSellCardRecordHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, &a->ns1__GetSellCardRecordHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, "ns1:GetSellCardRecordHistoryByCondition", -1, &a->ns1__GetSellCardRecordHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GetSellCardRecordHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellCardRecordHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetSellCardRecordHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetSellCardRecordHistoryByCondition, sizeof(struct __ns13__GetSellCardRecordHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetSellCardRecordHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellCardRecordHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, "ns1:GetSellCardRecordHistoryByCondition", &a->ns1__GetSellCardRecordHistoryByCondition, ""))
				{	soap_flag_ns1__GetSellCardRecordHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, const struct __ns13__GetSellCardRecordHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetSellCardRecordHistoryByCondition(soap, tag?tag:"-ns13:GetSellCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellCardRecordHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, struct __ns13__GetSellCardRecordHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetSellCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetSellCardRecordHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetSellCardRecordHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetSellCardRecordHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellCardRecordHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetSellCardRecordHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellCardRecordHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetSellCardRecordHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetSellCardRecordHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetSellCardRecordHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetSellCardRecordHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetSellCardRecordHistoryByCondition*)p = *(struct __ns13__GetSellCardRecordHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetSellCardRecordByCondition(struct soap *soap, struct __ns13__GetSellCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSellCardRecordByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetSellCardRecordByCondition(struct soap *soap, const struct __ns13__GetSellCardRecordByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSellCardRecordByCondition(soap, &a->ns1__GetSellCardRecordByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetSellCardRecordByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetSellCardRecordByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSellCardRecordByCondition(soap, "ns1:GetSellCardRecordByCondition", -1, &a->ns1__GetSellCardRecordByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellCardRecordByCondition * SOAP_FMAC4 soap_in___ns13__GetSellCardRecordByCondition(struct soap *soap, const char *tag, struct __ns13__GetSellCardRecordByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetSellCardRecordByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetSellCardRecordByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetSellCardRecordByCondition, sizeof(struct __ns13__GetSellCardRecordByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetSellCardRecordByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSellCardRecordByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSellCardRecordByCondition(soap, "ns1:GetSellCardRecordByCondition", &a->ns1__GetSellCardRecordByCondition, ""))
				{	soap_flag_ns1__GetSellCardRecordByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetSellCardRecordByCondition(struct soap *soap, const struct __ns13__GetSellCardRecordByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetSellCardRecordByCondition(soap, tag?tag:"-ns13:GetSellCardRecordByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetSellCardRecordByCondition * SOAP_FMAC4 soap_get___ns13__GetSellCardRecordByCondition(struct soap *soap, struct __ns13__GetSellCardRecordByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetSellCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetSellCardRecordByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetSellCardRecordByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetSellCardRecordByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetSellCardRecordByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellCardRecordByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetSellCardRecordByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetSellCardRecordByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetSellCardRecordByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetSellCardRecordByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetSellCardRecordByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetSellCardRecordByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetSellCardRecordByCondition*)p = *(struct __ns13__GetSellCardRecordByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetCardService(struct soap *soap, struct __ns13__GetCardService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCardService = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetCardService(struct soap *soap, const struct __ns13__GetCardService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCardService(soap, &a->ns1__GetCardService);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetCardService(struct soap *soap, const char *tag, int id, const struct __ns13__GetCardService *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCardService(soap, "ns1:GetCardService", -1, &a->ns1__GetCardService, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetCardService * SOAP_FMAC4 soap_in___ns13__GetCardService(struct soap *soap, const char *tag, struct __ns13__GetCardService *a, const char *type)
{
	size_t soap_flag_ns1__GetCardService = 1;
	short soap_flag;
	a = (struct __ns13__GetCardService *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetCardService, sizeof(struct __ns13__GetCardService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetCardService(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCardService && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCardService(soap, "ns1:GetCardService", &a->ns1__GetCardService, ""))
				{	soap_flag_ns1__GetCardService--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetCardService(struct soap *soap, const struct __ns13__GetCardService *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetCardService(soap, tag?tag:"-ns13:GetCardService", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetCardService * SOAP_FMAC4 soap_get___ns13__GetCardService(struct soap *soap, struct __ns13__GetCardService *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetCardService * SOAP_FMAC2 soap_instantiate___ns13__GetCardService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetCardService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetCardService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetCardService);
		if (size)
			*size = sizeof(struct __ns13__GetCardService);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetCardService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetCardService);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetCardService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetCardService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetCardService %p -> %p\n", q, p));
	*(struct __ns13__GetCardService*)p = *(struct __ns13__GetCardService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, struct __ns13__GetPhoneNoItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoItemAndHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const struct __ns13__GetPhoneNoItemAndHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, &a->ns1__GetPhoneNoItemAndHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, "ns1:GetPhoneNoItemAndHistoryByCondition", -1, &a->ns1__GetPhoneNoItemAndHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GetPhoneNoItemAndHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetPhoneNoItemAndHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetPhoneNoItemAndHistoryByCondition, sizeof(struct __ns13__GetPhoneNoItemAndHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetPhoneNoItemAndHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, "ns1:GetPhoneNoItemAndHistoryByCondition", &a->ns1__GetPhoneNoItemAndHistoryByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoItemAndHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const struct __ns13__GetPhoneNoItemAndHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetPhoneNoItemAndHistoryByCondition(soap, tag?tag:"-ns13:GetPhoneNoItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, struct __ns13__GetPhoneNoItemAndHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetPhoneNoItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetPhoneNoItemAndHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetPhoneNoItemAndHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetPhoneNoItemAndHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoItemAndHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetPhoneNoItemAndHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoItemAndHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetPhoneNoItemAndHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetPhoneNoItemAndHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetPhoneNoItemAndHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetPhoneNoItemAndHistoryByCondition*)p = *(struct __ns13__GetPhoneNoItemAndHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetPhoneNoItemByCondition(struct soap *soap, struct __ns13__GetPhoneNoItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoItemByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetPhoneNoItemByCondition(struct soap *soap, const struct __ns13__GetPhoneNoItemByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoItemByCondition(soap, &a->ns1__GetPhoneNoItemByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetPhoneNoItemByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoItemByCondition(soap, "ns1:GetPhoneNoItemByCondition", -1, &a->ns1__GetPhoneNoItemByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_in___ns13__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, struct __ns13__GetPhoneNoItemByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoItemByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetPhoneNoItemByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetPhoneNoItemByCondition, sizeof(struct __ns13__GetPhoneNoItemByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetPhoneNoItemByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoItemByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoItemByCondition(soap, "ns1:GetPhoneNoItemByCondition", &a->ns1__GetPhoneNoItemByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoItemByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetPhoneNoItemByCondition(struct soap *soap, const struct __ns13__GetPhoneNoItemByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetPhoneNoItemByCondition(soap, tag?tag:"-ns13:GetPhoneNoItemByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoItemByCondition * SOAP_FMAC4 soap_get___ns13__GetPhoneNoItemByCondition(struct soap *soap, struct __ns13__GetPhoneNoItemByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetPhoneNoItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetPhoneNoItemByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetPhoneNoItemByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetPhoneNoItemByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetPhoneNoItemByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoItemByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetPhoneNoItemByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoItemByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetPhoneNoItemByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetPhoneNoItemByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetPhoneNoItemByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetPhoneNoItemByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetPhoneNoItemByCondition*)p = *(struct __ns13__GetPhoneNoItemByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, struct __ns13__GetPayMiniCardHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayMiniCardHistoryByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, const struct __ns13__GetPayMiniCardHistoryByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, &a->ns1__GetPayMiniCardHistoryByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, "ns1:GetPayMiniCardHistoryByCondition", -1, &a->ns1__GetPayMiniCardHistoryByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_in___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, struct __ns13__GetPayMiniCardHistoryByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayMiniCardHistoryByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetPayMiniCardHistoryByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetPayMiniCardHistoryByCondition, sizeof(struct __ns13__GetPayMiniCardHistoryByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetPayMiniCardHistoryByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayMiniCardHistoryByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, "ns1:GetPayMiniCardHistoryByCondition", &a->ns1__GetPayMiniCardHistoryByCondition, ""))
				{	soap_flag_ns1__GetPayMiniCardHistoryByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, const struct __ns13__GetPayMiniCardHistoryByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetPayMiniCardHistoryByCondition(soap, tag?tag:"-ns13:GetPayMiniCardHistoryByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPayMiniCardHistoryByCondition * SOAP_FMAC4 soap_get___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, struct __ns13__GetPayMiniCardHistoryByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetPayMiniCardHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetPayMiniCardHistoryByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetPayMiniCardHistoryByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetPayMiniCardHistoryByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPayMiniCardHistoryByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetPayMiniCardHistoryByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPayMiniCardHistoryByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetPayMiniCardHistoryByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetPayMiniCardHistoryByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetPayMiniCardHistoryByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetPayMiniCardHistoryByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetPayMiniCardHistoryByCondition*)p = *(struct __ns13__GetPayMiniCardHistoryByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetPayMiniCardByCondition(struct soap *soap, struct __ns13__GetPayMiniCardByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPayMiniCardByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetPayMiniCardByCondition(struct soap *soap, const struct __ns13__GetPayMiniCardByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPayMiniCardByCondition(soap, &a->ns1__GetPayMiniCardByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetPayMiniCardByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetPayMiniCardByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPayMiniCardByCondition(soap, "ns1:GetPayMiniCardByCondition", -1, &a->ns1__GetPayMiniCardByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPayMiniCardByCondition * SOAP_FMAC4 soap_in___ns13__GetPayMiniCardByCondition(struct soap *soap, const char *tag, struct __ns13__GetPayMiniCardByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPayMiniCardByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetPayMiniCardByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetPayMiniCardByCondition, sizeof(struct __ns13__GetPayMiniCardByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetPayMiniCardByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPayMiniCardByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPayMiniCardByCondition(soap, "ns1:GetPayMiniCardByCondition", &a->ns1__GetPayMiniCardByCondition, ""))
				{	soap_flag_ns1__GetPayMiniCardByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetPayMiniCardByCondition(struct soap *soap, const struct __ns13__GetPayMiniCardByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetPayMiniCardByCondition(soap, tag?tag:"-ns13:GetPayMiniCardByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPayMiniCardByCondition * SOAP_FMAC4 soap_get___ns13__GetPayMiniCardByCondition(struct soap *soap, struct __ns13__GetPayMiniCardByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetPayMiniCardByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetPayMiniCardByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetPayMiniCardByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetPayMiniCardByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetPayMiniCardByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPayMiniCardByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetPayMiniCardByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPayMiniCardByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetPayMiniCardByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetPayMiniCardByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetPayMiniCardByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetPayMiniCardByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetPayMiniCardByCondition*)p = *(struct __ns13__GetPayMiniCardByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetMiniCardRecord(struct soap *soap, struct __ns13__GetMiniCardRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMiniCardRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetMiniCardRecord(struct soap *soap, const struct __ns13__GetMiniCardRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetMiniCardRecord(soap, &a->ns1__GetMiniCardRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetMiniCardRecord(struct soap *soap, const char *tag, int id, const struct __ns13__GetMiniCardRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMiniCardRecord(soap, "ns1:GetMiniCardRecord", -1, &a->ns1__GetMiniCardRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetMiniCardRecord * SOAP_FMAC4 soap_in___ns13__GetMiniCardRecord(struct soap *soap, const char *tag, struct __ns13__GetMiniCardRecord *a, const char *type)
{
	size_t soap_flag_ns1__GetMiniCardRecord = 1;
	short soap_flag;
	a = (struct __ns13__GetMiniCardRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetMiniCardRecord, sizeof(struct __ns13__GetMiniCardRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetMiniCardRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMiniCardRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetMiniCardRecord(soap, "ns1:GetMiniCardRecord", &a->ns1__GetMiniCardRecord, ""))
				{	soap_flag_ns1__GetMiniCardRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetMiniCardRecord(struct soap *soap, const struct __ns13__GetMiniCardRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetMiniCardRecord(soap, tag?tag:"-ns13:GetMiniCardRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetMiniCardRecord * SOAP_FMAC4 soap_get___ns13__GetMiniCardRecord(struct soap *soap, struct __ns13__GetMiniCardRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetMiniCardRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetMiniCardRecord * SOAP_FMAC2 soap_instantiate___ns13__GetMiniCardRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetMiniCardRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetMiniCardRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetMiniCardRecord);
		if (size)
			*size = sizeof(struct __ns13__GetMiniCardRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetMiniCardRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetMiniCardRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetMiniCardRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetMiniCardRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetMiniCardRecord %p -> %p\n", q, p));
	*(struct __ns13__GetMiniCardRecord*)p = *(struct __ns13__GetMiniCardRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__SellOhterCard(struct soap *soap, struct __ns13__SellOhterCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SellOhterCard = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__SellOhterCard(struct soap *soap, const struct __ns13__SellOhterCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SellOhterCard(soap, &a->ns1__SellOhterCard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__SellOhterCard(struct soap *soap, const char *tag, int id, const struct __ns13__SellOhterCard *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SellOhterCard(soap, "ns1:SellOhterCard", -1, &a->ns1__SellOhterCard, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SellOhterCard * SOAP_FMAC4 soap_in___ns13__SellOhterCard(struct soap *soap, const char *tag, struct __ns13__SellOhterCard *a, const char *type)
{
	size_t soap_flag_ns1__SellOhterCard = 1;
	short soap_flag;
	a = (struct __ns13__SellOhterCard *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__SellOhterCard, sizeof(struct __ns13__SellOhterCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__SellOhterCard(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SellOhterCard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SellOhterCard(soap, "ns1:SellOhterCard", &a->ns1__SellOhterCard, ""))
				{	soap_flag_ns1__SellOhterCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__SellOhterCard(struct soap *soap, const struct __ns13__SellOhterCard *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__SellOhterCard(soap, tag?tag:"-ns13:SellOhterCard", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SellOhterCard * SOAP_FMAC4 soap_get___ns13__SellOhterCard(struct soap *soap, struct __ns13__SellOhterCard *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__SellOhterCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__SellOhterCard * SOAP_FMAC2 soap_instantiate___ns13__SellOhterCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__SellOhterCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__SellOhterCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SellOhterCard);
		if (size)
			*size = sizeof(struct __ns13__SellOhterCard);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SellOhterCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__SellOhterCard);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__SellOhterCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__SellOhterCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__SellOhterCard %p -> %p\n", q, p));
	*(struct __ns13__SellOhterCard*)p = *(struct __ns13__SellOhterCard*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__SellNo(struct soap *soap, struct __ns13__SellNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SellNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__SellNo(struct soap *soap, const struct __ns13__SellNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SellNo(soap, &a->ns1__SellNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__SellNo(struct soap *soap, const char *tag, int id, const struct __ns13__SellNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SellNo(soap, "ns1:SellNo", -1, &a->ns1__SellNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SellNo * SOAP_FMAC4 soap_in___ns13__SellNo(struct soap *soap, const char *tag, struct __ns13__SellNo *a, const char *type)
{
	size_t soap_flag_ns1__SellNo = 1;
	short soap_flag;
	a = (struct __ns13__SellNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__SellNo, sizeof(struct __ns13__SellNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__SellNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SellNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SellNo(soap, "ns1:SellNo", &a->ns1__SellNo, ""))
				{	soap_flag_ns1__SellNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__SellNo(struct soap *soap, const struct __ns13__SellNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__SellNo(soap, tag?tag:"-ns13:SellNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SellNo * SOAP_FMAC4 soap_get___ns13__SellNo(struct soap *soap, struct __ns13__SellNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__SellNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__SellNo * SOAP_FMAC2 soap_instantiate___ns13__SellNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__SellNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__SellNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SellNo);
		if (size)
			*size = sizeof(struct __ns13__SellNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SellNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__SellNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__SellNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__SellNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__SellNo %p -> %p\n", q, p));
	*(struct __ns13__SellNo*)p = *(struct __ns13__SellNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__SubmitBusiness(struct soap *soap, struct __ns13__SubmitBusiness *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SubmitBusiness = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__SubmitBusiness(struct soap *soap, const struct __ns13__SubmitBusiness *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SubmitBusiness(soap, &a->ns1__SubmitBusiness);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__SubmitBusiness(struct soap *soap, const char *tag, int id, const struct __ns13__SubmitBusiness *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SubmitBusiness(soap, "ns1:SubmitBusiness", -1, &a->ns1__SubmitBusiness, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SubmitBusiness * SOAP_FMAC4 soap_in___ns13__SubmitBusiness(struct soap *soap, const char *tag, struct __ns13__SubmitBusiness *a, const char *type)
{
	size_t soap_flag_ns1__SubmitBusiness = 1;
	short soap_flag;
	a = (struct __ns13__SubmitBusiness *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__SubmitBusiness, sizeof(struct __ns13__SubmitBusiness), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__SubmitBusiness(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SubmitBusiness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SubmitBusiness(soap, "ns1:SubmitBusiness", &a->ns1__SubmitBusiness, ""))
				{	soap_flag_ns1__SubmitBusiness--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__SubmitBusiness(struct soap *soap, const struct __ns13__SubmitBusiness *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__SubmitBusiness(soap, tag?tag:"-ns13:SubmitBusiness", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__SubmitBusiness * SOAP_FMAC4 soap_get___ns13__SubmitBusiness(struct soap *soap, struct __ns13__SubmitBusiness *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__SubmitBusiness(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__SubmitBusiness * SOAP_FMAC2 soap_instantiate___ns13__SubmitBusiness(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__SubmitBusiness(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__SubmitBusiness, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SubmitBusiness);
		if (size)
			*size = sizeof(struct __ns13__SubmitBusiness);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__SubmitBusiness[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__SubmitBusiness);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__SubmitBusiness*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__SubmitBusiness(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__SubmitBusiness %p -> %p\n", q, p));
	*(struct __ns13__SubmitBusiness*)p = *(struct __ns13__SubmitBusiness*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__UnlockNo(struct soap *soap, struct __ns13__UnlockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnlockNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__UnlockNo(struct soap *soap, const struct __ns13__UnlockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UnlockNo(soap, &a->ns1__UnlockNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__UnlockNo(struct soap *soap, const char *tag, int id, const struct __ns13__UnlockNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__UnlockNo(soap, "ns1:UnlockNo", -1, &a->ns1__UnlockNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__UnlockNo * SOAP_FMAC4 soap_in___ns13__UnlockNo(struct soap *soap, const char *tag, struct __ns13__UnlockNo *a, const char *type)
{
	size_t soap_flag_ns1__UnlockNo = 1;
	short soap_flag;
	a = (struct __ns13__UnlockNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__UnlockNo, sizeof(struct __ns13__UnlockNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__UnlockNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnlockNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UnlockNo(soap, "ns1:UnlockNo", &a->ns1__UnlockNo, ""))
				{	soap_flag_ns1__UnlockNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__UnlockNo(struct soap *soap, const struct __ns13__UnlockNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__UnlockNo(soap, tag?tag:"-ns13:UnlockNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__UnlockNo * SOAP_FMAC4 soap_get___ns13__UnlockNo(struct soap *soap, struct __ns13__UnlockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__UnlockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__UnlockNo * SOAP_FMAC2 soap_instantiate___ns13__UnlockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__UnlockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__UnlockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__UnlockNo);
		if (size)
			*size = sizeof(struct __ns13__UnlockNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__UnlockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__UnlockNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__UnlockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__UnlockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__UnlockNo %p -> %p\n", q, p));
	*(struct __ns13__UnlockNo*)p = *(struct __ns13__UnlockNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__LockNo(struct soap *soap, struct __ns13__LockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LockNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__LockNo(struct soap *soap, const struct __ns13__LockNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__LockNo(soap, &a->ns1__LockNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__LockNo(struct soap *soap, const char *tag, int id, const struct __ns13__LockNo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__LockNo(soap, "ns1:LockNo", -1, &a->ns1__LockNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__LockNo * SOAP_FMAC4 soap_in___ns13__LockNo(struct soap *soap, const char *tag, struct __ns13__LockNo *a, const char *type)
{
	size_t soap_flag_ns1__LockNo = 1;
	short soap_flag;
	a = (struct __ns13__LockNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__LockNo, sizeof(struct __ns13__LockNo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__LockNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LockNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LockNo(soap, "ns1:LockNo", &a->ns1__LockNo, ""))
				{	soap_flag_ns1__LockNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__LockNo(struct soap *soap, const struct __ns13__LockNo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__LockNo(soap, tag?tag:"-ns13:LockNo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__LockNo * SOAP_FMAC4 soap_get___ns13__LockNo(struct soap *soap, struct __ns13__LockNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__LockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__LockNo * SOAP_FMAC2 soap_instantiate___ns13__LockNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__LockNo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__LockNo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__LockNo);
		if (size)
			*size = sizeof(struct __ns13__LockNo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__LockNo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__LockNo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__LockNo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__LockNo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__LockNo %p -> %p\n", q, p));
	*(struct __ns13__LockNo*)p = *(struct __ns13__LockNo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetMyNoSection(struct soap *soap, struct __ns13__GetMyNoSection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMyNoSection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetMyNoSection(struct soap *soap, const struct __ns13__GetMyNoSection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetMyNoSection(soap, &a->ns1__GetMyNoSection);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetMyNoSection(struct soap *soap, const char *tag, int id, const struct __ns13__GetMyNoSection *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMyNoSection(soap, "ns1:GetMyNoSection", -1, &a->ns1__GetMyNoSection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetMyNoSection * SOAP_FMAC4 soap_in___ns13__GetMyNoSection(struct soap *soap, const char *tag, struct __ns13__GetMyNoSection *a, const char *type)
{
	size_t soap_flag_ns1__GetMyNoSection = 1;
	short soap_flag;
	a = (struct __ns13__GetMyNoSection *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetMyNoSection, sizeof(struct __ns13__GetMyNoSection), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetMyNoSection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMyNoSection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetMyNoSection(soap, "ns1:GetMyNoSection", &a->ns1__GetMyNoSection, ""))
				{	soap_flag_ns1__GetMyNoSection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetMyNoSection(struct soap *soap, const struct __ns13__GetMyNoSection *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetMyNoSection(soap, tag?tag:"-ns13:GetMyNoSection", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetMyNoSection * SOAP_FMAC4 soap_get___ns13__GetMyNoSection(struct soap *soap, struct __ns13__GetMyNoSection *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetMyNoSection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetMyNoSection * SOAP_FMAC2 soap_instantiate___ns13__GetMyNoSection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetMyNoSection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetMyNoSection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetMyNoSection);
		if (size)
			*size = sizeof(struct __ns13__GetMyNoSection);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetMyNoSection[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetMyNoSection);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetMyNoSection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetMyNoSection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetMyNoSection %p -> %p\n", q, p));
	*(struct __ns13__GetMyNoSection*)p = *(struct __ns13__GetMyNoSection*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetPhoneNoByCondition(struct soap *soap, struct __ns13__GetPhoneNoByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPhoneNoByCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetPhoneNoByCondition(struct soap *soap, const struct __ns13__GetPhoneNoByCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPhoneNoByCondition(soap, &a->ns1__GetPhoneNoByCondition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetPhoneNoByCondition(struct soap *soap, const char *tag, int id, const struct __ns13__GetPhoneNoByCondition *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPhoneNoByCondition(soap, "ns1:GetPhoneNoByCondition", -1, &a->ns1__GetPhoneNoByCondition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoByCondition * SOAP_FMAC4 soap_in___ns13__GetPhoneNoByCondition(struct soap *soap, const char *tag, struct __ns13__GetPhoneNoByCondition *a, const char *type)
{
	size_t soap_flag_ns1__GetPhoneNoByCondition = 1;
	short soap_flag;
	a = (struct __ns13__GetPhoneNoByCondition *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetPhoneNoByCondition, sizeof(struct __ns13__GetPhoneNoByCondition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetPhoneNoByCondition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPhoneNoByCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPhoneNoByCondition(soap, "ns1:GetPhoneNoByCondition", &a->ns1__GetPhoneNoByCondition, ""))
				{	soap_flag_ns1__GetPhoneNoByCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetPhoneNoByCondition(struct soap *soap, const struct __ns13__GetPhoneNoByCondition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetPhoneNoByCondition(soap, tag?tag:"-ns13:GetPhoneNoByCondition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetPhoneNoByCondition * SOAP_FMAC4 soap_get___ns13__GetPhoneNoByCondition(struct soap *soap, struct __ns13__GetPhoneNoByCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetPhoneNoByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__GetPhoneNoByCondition * SOAP_FMAC2 soap_instantiate___ns13__GetPhoneNoByCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetPhoneNoByCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetPhoneNoByCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoByCondition);
		if (size)
			*size = sizeof(struct __ns13__GetPhoneNoByCondition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__GetPhoneNoByCondition[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetPhoneNoByCondition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetPhoneNoByCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetPhoneNoByCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetPhoneNoByCondition %p -> %p\n", q, p));
	*(struct __ns13__GetPhoneNoByCondition*)p = *(struct __ns13__GetPhoneNoByCondition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__BuyMiniCard(struct soap *soap, struct __ns13__BuyMiniCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BuyMiniCard = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__BuyMiniCard(struct soap *soap, const struct __ns13__BuyMiniCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__BuyMiniCard(soap, &a->ns1__BuyMiniCard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__BuyMiniCard(struct soap *soap, const char *tag, int id, const struct __ns13__BuyMiniCard *a, const char *type)
{
	if (soap_out_PointerTo_ns1__BuyMiniCard(soap, "ns1:BuyMiniCard", -1, &a->ns1__BuyMiniCard, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__BuyMiniCard * SOAP_FMAC4 soap_in___ns13__BuyMiniCard(struct soap *soap, const char *tag, struct __ns13__BuyMiniCard *a, const char *type)
{
	size_t soap_flag_ns1__BuyMiniCard = 1;
	short soap_flag;
	a = (struct __ns13__BuyMiniCard *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__BuyMiniCard, sizeof(struct __ns13__BuyMiniCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__BuyMiniCard(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BuyMiniCard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BuyMiniCard(soap, "ns1:BuyMiniCard", &a->ns1__BuyMiniCard, ""))
				{	soap_flag_ns1__BuyMiniCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__BuyMiniCard(struct soap *soap, const struct __ns13__BuyMiniCard *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__BuyMiniCard(soap, tag?tag:"-ns13:BuyMiniCard", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__BuyMiniCard * SOAP_FMAC4 soap_get___ns13__BuyMiniCard(struct soap *soap, struct __ns13__BuyMiniCard *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__BuyMiniCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns13__BuyMiniCard * SOAP_FMAC2 soap_instantiate___ns13__BuyMiniCard(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__BuyMiniCard(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__BuyMiniCard, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__BuyMiniCard);
		if (size)
			*size = sizeof(struct __ns13__BuyMiniCard);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns13__BuyMiniCard[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__BuyMiniCard);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__BuyMiniCard*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__BuyMiniCard(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__BuyMiniCard %p -> %p\n", q, p));
	*(struct __ns13__BuyMiniCard*)p = *(struct __ns13__BuyMiniCard*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns12__queryPhoneNOInfo(struct soap *soap, struct __ns12__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPhoneNOInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns12__queryPhoneNOInfo(struct soap *soap, const struct __ns12__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPhoneNOInfo(soap, &a->ns1__queryPhoneNOInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns12__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, const struct __ns12__queryPhoneNOInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", -1, &a->ns1__queryPhoneNOInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns12__queryPhoneNOInfo * SOAP_FMAC4 soap_in___ns12__queryPhoneNOInfo(struct soap *soap, const char *tag, struct __ns12__queryPhoneNOInfo *a, const char *type)
{
	size_t soap_flag_ns1__queryPhoneNOInfo = 1;
	short soap_flag;
	a = (struct __ns12__queryPhoneNOInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns12__queryPhoneNOInfo, sizeof(struct __ns12__queryPhoneNOInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns12__queryPhoneNOInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPhoneNOInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", &a->ns1__queryPhoneNOInfo, ""))
				{	soap_flag_ns1__queryPhoneNOInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns12__queryPhoneNOInfo(struct soap *soap, const struct __ns12__queryPhoneNOInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns12__queryPhoneNOInfo(soap, tag?tag:"-ns12:queryPhoneNOInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns12__queryPhoneNOInfo * SOAP_FMAC4 soap_get___ns12__queryPhoneNOInfo(struct soap *soap, struct __ns12__queryPhoneNOInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns12__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns12__queryPhoneNOInfo * SOAP_FMAC2 soap_instantiate___ns12__queryPhoneNOInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns12__queryPhoneNOInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns12__queryPhoneNOInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns12__queryPhoneNOInfo);
		if (size)
			*size = sizeof(struct __ns12__queryPhoneNOInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns12__queryPhoneNOInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns12__queryPhoneNOInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns12__queryPhoneNOInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns12__queryPhoneNOInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns12__queryPhoneNOInfo %p -> %p\n", q, p));
	*(struct __ns12__queryPhoneNOInfo*)p = *(struct __ns12__queryPhoneNOInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__queryPhoneNOInfo(struct soap *soap, struct __ns11__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPhoneNOInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__queryPhoneNOInfo(struct soap *soap, const struct __ns11__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPhoneNOInfo(soap, &a->ns1__queryPhoneNOInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns11__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, const struct __ns11__queryPhoneNOInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", -1, &a->ns1__queryPhoneNOInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__queryPhoneNOInfo * SOAP_FMAC4 soap_in___ns11__queryPhoneNOInfo(struct soap *soap, const char *tag, struct __ns11__queryPhoneNOInfo *a, const char *type)
{
	size_t soap_flag_ns1__queryPhoneNOInfo = 1;
	short soap_flag;
	a = (struct __ns11__queryPhoneNOInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__queryPhoneNOInfo, sizeof(struct __ns11__queryPhoneNOInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns11__queryPhoneNOInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPhoneNOInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", &a->ns1__queryPhoneNOInfo, ""))
				{	soap_flag_ns1__queryPhoneNOInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__queryPhoneNOInfo(struct soap *soap, const struct __ns11__queryPhoneNOInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns11__queryPhoneNOInfo(soap, tag?tag:"-ns11:queryPhoneNOInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__queryPhoneNOInfo * SOAP_FMAC4 soap_get___ns11__queryPhoneNOInfo(struct soap *soap, struct __ns11__queryPhoneNOInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns11__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__queryPhoneNOInfo * SOAP_FMAC2 soap_instantiate___ns11__queryPhoneNOInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__queryPhoneNOInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__queryPhoneNOInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns11__queryPhoneNOInfo);
		if (size)
			*size = sizeof(struct __ns11__queryPhoneNOInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns11__queryPhoneNOInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns11__queryPhoneNOInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__queryPhoneNOInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__queryPhoneNOInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__queryPhoneNOInfo %p -> %p\n", q, p));
	*(struct __ns11__queryPhoneNOInfo*)p = *(struct __ns11__queryPhoneNOInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__queryPhoneNOInfo(struct soap *soap, struct __ns10__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPhoneNOInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__queryPhoneNOInfo(struct soap *soap, const struct __ns10__queryPhoneNOInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPhoneNOInfo(soap, &a->ns1__queryPhoneNOInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns10__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, const struct __ns10__queryPhoneNOInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", -1, &a->ns1__queryPhoneNOInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__queryPhoneNOInfo * SOAP_FMAC4 soap_in___ns10__queryPhoneNOInfo(struct soap *soap, const char *tag, struct __ns10__queryPhoneNOInfo *a, const char *type)
{
	size_t soap_flag_ns1__queryPhoneNOInfo = 1;
	short soap_flag;
	a = (struct __ns10__queryPhoneNOInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns10__queryPhoneNOInfo, sizeof(struct __ns10__queryPhoneNOInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns10__queryPhoneNOInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPhoneNOInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, "ns1:queryPhoneNOInfo", &a->ns1__queryPhoneNOInfo, ""))
				{	soap_flag_ns1__queryPhoneNOInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__queryPhoneNOInfo(struct soap *soap, const struct __ns10__queryPhoneNOInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns10__queryPhoneNOInfo(soap, tag?tag:"-ns10:queryPhoneNOInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__queryPhoneNOInfo * SOAP_FMAC4 soap_get___ns10__queryPhoneNOInfo(struct soap *soap, struct __ns10__queryPhoneNOInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns10__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns10__queryPhoneNOInfo * SOAP_FMAC2 soap_instantiate___ns10__queryPhoneNOInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns10__queryPhoneNOInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns10__queryPhoneNOInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns10__queryPhoneNOInfo);
		if (size)
			*size = sizeof(struct __ns10__queryPhoneNOInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns10__queryPhoneNOInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns10__queryPhoneNOInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns10__queryPhoneNOInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns10__queryPhoneNOInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns10__queryPhoneNOInfo %p -> %p\n", q, p));
	*(struct __ns10__queryPhoneNOInfo*)p = *(struct __ns10__queryPhoneNOInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClientVersionResponse(struct soap *soap, _ns1__GetClientVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClientVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClientVersionResponse(struct soap *soap, const char *tag, int id, _ns1__GetClientVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClientVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClientVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClientVersionResponse(struct soap *soap, const char *tag, _ns1__GetClientVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClientVersionResponse **)soap_malloc(soap, sizeof(_ns1__GetClientVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClientVersionResponse *)soap_instantiate__ns1__GetClientVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClientVersionResponse ** p = (_ns1__GetClientVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClientVersionResponse, sizeof(_ns1__GetClientVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClientVersionResponse(struct soap *soap, _ns1__GetClientVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClientVersionResponse);
	if (soap_out_PointerTo_ns1__GetClientVersionResponse(soap, tag?tag:"ns1:GetClientVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetClientVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClientVersionResponse(struct soap *soap, _ns1__GetClientVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClientVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClientVersion(struct soap *soap, _ns1__GetClientVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClientVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClientVersion(struct soap *soap, const char *tag, int id, _ns1__GetClientVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClientVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClientVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClientVersion(struct soap *soap, const char *tag, _ns1__GetClientVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClientVersion **)soap_malloc(soap, sizeof(_ns1__GetClientVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClientVersion *)soap_instantiate__ns1__GetClientVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClientVersion ** p = (_ns1__GetClientVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClientVersion, sizeof(_ns1__GetClientVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClientVersion(struct soap *soap, _ns1__GetClientVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClientVersion);
	if (soap_out_PointerTo_ns1__GetClientVersion(soap, tag?tag:"ns1:GetClientVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetClientVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClientVersion(struct soap *soap, _ns1__GetClientVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClientVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteCompanyAccountResponse(struct soap *soap, _ns1__DeleteCompanyAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteCompanyAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteCompanyAccountResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteCompanyAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteCompanyAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__DeleteCompanyAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteCompanyAccountResponse **)soap_malloc(soap, sizeof(_ns1__DeleteCompanyAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteCompanyAccountResponse *)soap_instantiate__ns1__DeleteCompanyAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteCompanyAccountResponse ** p = (_ns1__DeleteCompanyAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteCompanyAccountResponse, sizeof(_ns1__DeleteCompanyAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteCompanyAccountResponse(struct soap *soap, _ns1__DeleteCompanyAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccountResponse);
	if (soap_out_PointerTo_ns1__DeleteCompanyAccountResponse(soap, tag?tag:"ns1:DeleteCompanyAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteCompanyAccountResponse(struct soap *soap, _ns1__DeleteCompanyAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteCompanyAccount(struct soap *soap, _ns1__DeleteCompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteCompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteCompanyAccount(struct soap *soap, const char *tag, int id, _ns1__DeleteCompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteCompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccount ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteCompanyAccount(struct soap *soap, const char *tag, _ns1__DeleteCompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteCompanyAccount **)soap_malloc(soap, sizeof(_ns1__DeleteCompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteCompanyAccount *)soap_instantiate__ns1__DeleteCompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteCompanyAccount ** p = (_ns1__DeleteCompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteCompanyAccount, sizeof(_ns1__DeleteCompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteCompanyAccount(struct soap *soap, _ns1__DeleteCompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteCompanyAccount);
	if (soap_out_PointerTo_ns1__DeleteCompanyAccount(soap, tag?tag:"ns1:DeleteCompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteCompanyAccount ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteCompanyAccount(struct soap *soap, _ns1__DeleteCompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateCompanyAccountResponse(struct soap *soap, _ns1__UpdateCompanyAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateCompanyAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateCompanyAccountResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateCompanyAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateCompanyAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__UpdateCompanyAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateCompanyAccountResponse **)soap_malloc(soap, sizeof(_ns1__UpdateCompanyAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateCompanyAccountResponse *)soap_instantiate__ns1__UpdateCompanyAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateCompanyAccountResponse ** p = (_ns1__UpdateCompanyAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateCompanyAccountResponse, sizeof(_ns1__UpdateCompanyAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateCompanyAccountResponse(struct soap *soap, _ns1__UpdateCompanyAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccountResponse);
	if (soap_out_PointerTo_ns1__UpdateCompanyAccountResponse(soap, tag?tag:"ns1:UpdateCompanyAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateCompanyAccountResponse(struct soap *soap, _ns1__UpdateCompanyAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateCompanyAccount(struct soap *soap, _ns1__UpdateCompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateCompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateCompanyAccount(struct soap *soap, const char *tag, int id, _ns1__UpdateCompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateCompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccount ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateCompanyAccount(struct soap *soap, const char *tag, _ns1__UpdateCompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateCompanyAccount **)soap_malloc(soap, sizeof(_ns1__UpdateCompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateCompanyAccount *)soap_instantiate__ns1__UpdateCompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateCompanyAccount ** p = (_ns1__UpdateCompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateCompanyAccount, sizeof(_ns1__UpdateCompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateCompanyAccount(struct soap *soap, _ns1__UpdateCompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateCompanyAccount);
	if (soap_out_PointerTo_ns1__UpdateCompanyAccount(soap, tag?tag:"ns1:UpdateCompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateCompanyAccount ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateCompanyAccount(struct soap *soap, _ns1__UpdateCompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddCompanyAccountResponse(struct soap *soap, _ns1__AddCompanyAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddCompanyAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddCompanyAccountResponse(struct soap *soap, const char *tag, int id, _ns1__AddCompanyAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddCompanyAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__AddCompanyAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddCompanyAccountResponse **)soap_malloc(soap, sizeof(_ns1__AddCompanyAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddCompanyAccountResponse *)soap_instantiate__ns1__AddCompanyAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddCompanyAccountResponse ** p = (_ns1__AddCompanyAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddCompanyAccountResponse, sizeof(_ns1__AddCompanyAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddCompanyAccountResponse(struct soap *soap, _ns1__AddCompanyAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddCompanyAccountResponse);
	if (soap_out_PointerTo_ns1__AddCompanyAccountResponse(soap, tag?tag:"ns1:AddCompanyAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddCompanyAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddCompanyAccountResponse(struct soap *soap, _ns1__AddCompanyAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddCompanyAccount(struct soap *soap, _ns1__AddCompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddCompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddCompanyAccount(struct soap *soap, const char *tag, int id, _ns1__AddCompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddCompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddCompanyAccount ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddCompanyAccount(struct soap *soap, const char *tag, _ns1__AddCompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddCompanyAccount **)soap_malloc(soap, sizeof(_ns1__AddCompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddCompanyAccount *)soap_instantiate__ns1__AddCompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddCompanyAccount ** p = (_ns1__AddCompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddCompanyAccount, sizeof(_ns1__AddCompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddCompanyAccount(struct soap *soap, _ns1__AddCompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddCompanyAccount);
	if (soap_out_PointerTo_ns1__AddCompanyAccount(soap, tag?tag:"ns1:AddCompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddCompanyAccount ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddCompanyAccount(struct soap *soap, _ns1__AddCompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCompanyAccountResponse(struct soap *soap, _ns1__GetCompanyAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCompanyAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCompanyAccountResponse(struct soap *soap, const char *tag, int id, _ns1__GetCompanyAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCompanyAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCompanyAccountResponse(struct soap *soap, const char *tag, _ns1__GetCompanyAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCompanyAccountResponse **)soap_malloc(soap, sizeof(_ns1__GetCompanyAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCompanyAccountResponse *)soap_instantiate__ns1__GetCompanyAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCompanyAccountResponse ** p = (_ns1__GetCompanyAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCompanyAccountResponse, sizeof(_ns1__GetCompanyAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCompanyAccountResponse(struct soap *soap, _ns1__GetCompanyAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCompanyAccountResponse);
	if (soap_out_PointerTo_ns1__GetCompanyAccountResponse(soap, tag?tag:"ns1:GetCompanyAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCompanyAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCompanyAccountResponse(struct soap *soap, _ns1__GetCompanyAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCompanyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCompanyAccount(struct soap *soap, _ns1__GetCompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCompanyAccount(struct soap *soap, const char *tag, int id, _ns1__GetCompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCompanyAccount ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCompanyAccount(struct soap *soap, const char *tag, _ns1__GetCompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCompanyAccount **)soap_malloc(soap, sizeof(_ns1__GetCompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCompanyAccount *)soap_instantiate__ns1__GetCompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCompanyAccount ** p = (_ns1__GetCompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCompanyAccount, sizeof(_ns1__GetCompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCompanyAccount(struct soap *soap, _ns1__GetCompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCompanyAccount);
	if (soap_out_PointerTo_ns1__GetCompanyAccount(soap, tag?tag:"ns1:GetCompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCompanyAccount ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCompanyAccount(struct soap *soap, _ns1__GetCompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateCompanyInfoResponse(struct soap *soap, _ns1__UpdateCompanyInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateCompanyInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateCompanyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateCompanyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateCompanyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateCompanyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdateCompanyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateCompanyInfoResponse **)soap_malloc(soap, sizeof(_ns1__UpdateCompanyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateCompanyInfoResponse *)soap_instantiate__ns1__UpdateCompanyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateCompanyInfoResponse ** p = (_ns1__UpdateCompanyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateCompanyInfoResponse, sizeof(_ns1__UpdateCompanyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateCompanyInfoResponse(struct soap *soap, _ns1__UpdateCompanyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfoResponse);
	if (soap_out_PointerTo_ns1__UpdateCompanyInfoResponse(soap, tag?tag:"ns1:UpdateCompanyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateCompanyInfoResponse(struct soap *soap, _ns1__UpdateCompanyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateCompanyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateCompanyInfo(struct soap *soap, _ns1__UpdateCompanyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateCompanyInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateCompanyInfo(struct soap *soap, const char *tag, int id, _ns1__UpdateCompanyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateCompanyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateCompanyInfo(struct soap *soap, const char *tag, _ns1__UpdateCompanyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateCompanyInfo **)soap_malloc(soap, sizeof(_ns1__UpdateCompanyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateCompanyInfo *)soap_instantiate__ns1__UpdateCompanyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateCompanyInfo ** p = (_ns1__UpdateCompanyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateCompanyInfo, sizeof(_ns1__UpdateCompanyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateCompanyInfo(struct soap *soap, _ns1__UpdateCompanyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateCompanyInfo);
	if (soap_out_PointerTo_ns1__UpdateCompanyInfo(soap, tag?tag:"ns1:UpdateCompanyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateCompanyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateCompanyInfo(struct soap *soap, _ns1__UpdateCompanyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCompanyInfoResponse(struct soap *soap, _ns1__GetCompanyInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCompanyInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCompanyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetCompanyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCompanyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCompanyInfoResponse(struct soap *soap, const char *tag, _ns1__GetCompanyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCompanyInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetCompanyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCompanyInfoResponse *)soap_instantiate__ns1__GetCompanyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCompanyInfoResponse ** p = (_ns1__GetCompanyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCompanyInfoResponse, sizeof(_ns1__GetCompanyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCompanyInfoResponse(struct soap *soap, _ns1__GetCompanyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCompanyInfoResponse);
	if (soap_out_PointerTo_ns1__GetCompanyInfoResponse(soap, tag?tag:"ns1:GetCompanyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCompanyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCompanyInfoResponse(struct soap *soap, _ns1__GetCompanyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCompanyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCompanyInfo(struct soap *soap, _ns1__GetCompanyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCompanyInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCompanyInfo(struct soap *soap, const char *tag, int id, _ns1__GetCompanyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCompanyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCompanyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCompanyInfo(struct soap *soap, const char *tag, _ns1__GetCompanyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCompanyInfo **)soap_malloc(soap, sizeof(_ns1__GetCompanyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCompanyInfo *)soap_instantiate__ns1__GetCompanyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCompanyInfo ** p = (_ns1__GetCompanyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCompanyInfo, sizeof(_ns1__GetCompanyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCompanyInfo(struct soap *soap, _ns1__GetCompanyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCompanyInfo);
	if (soap_out_PointerTo_ns1__GetCompanyInfo(soap, tag?tag:"ns1:GetCompanyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCompanyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCompanyInfo(struct soap *soap, _ns1__GetCompanyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeletePhoneNumberBelongResponse(struct soap *soap, _ns1__DeletePhoneNumberBelongResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeletePhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, _ns1__DeletePhoneNumberBelongResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelongResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeletePhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__DeletePhoneNumberBelongResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeletePhoneNumberBelongResponse **)soap_malloc(soap, sizeof(_ns1__DeletePhoneNumberBelongResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeletePhoneNumberBelongResponse *)soap_instantiate__ns1__DeletePhoneNumberBelongResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeletePhoneNumberBelongResponse ** p = (_ns1__DeletePhoneNumberBelongResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeletePhoneNumberBelongResponse, sizeof(_ns1__DeletePhoneNumberBelongResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeletePhoneNumberBelongResponse(struct soap *soap, _ns1__DeletePhoneNumberBelongResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelongResponse);
	if (soap_out_PointerTo_ns1__DeletePhoneNumberBelongResponse(soap, tag?tag:"ns1:DeletePhoneNumberBelongResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelongResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeletePhoneNumberBelongResponse(struct soap *soap, _ns1__DeletePhoneNumberBelongResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeletePhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeletePhoneNumberBelong(struct soap *soap, _ns1__DeletePhoneNumberBelong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeletePhoneNumberBelong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeletePhoneNumberBelong(struct soap *soap, const char *tag, int id, _ns1__DeletePhoneNumberBelong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeletePhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelong ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeletePhoneNumberBelong(struct soap *soap, const char *tag, _ns1__DeletePhoneNumberBelong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeletePhoneNumberBelong **)soap_malloc(soap, sizeof(_ns1__DeletePhoneNumberBelong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeletePhoneNumberBelong *)soap_instantiate__ns1__DeletePhoneNumberBelong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeletePhoneNumberBelong ** p = (_ns1__DeletePhoneNumberBelong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeletePhoneNumberBelong, sizeof(_ns1__DeletePhoneNumberBelong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeletePhoneNumberBelong(struct soap *soap, _ns1__DeletePhoneNumberBelong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeletePhoneNumberBelong);
	if (soap_out_PointerTo_ns1__DeletePhoneNumberBelong(soap, tag?tag:"ns1:DeletePhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeletePhoneNumberBelong ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeletePhoneNumberBelong(struct soap *soap, _ns1__DeletePhoneNumberBelong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeletePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPhoneNumberBelongResponse(struct soap *soap, _ns1__AddPhoneNumberBelongResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, _ns1__AddPhoneNumberBelongResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelongResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__AddPhoneNumberBelongResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPhoneNumberBelongResponse **)soap_malloc(soap, sizeof(_ns1__AddPhoneNumberBelongResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPhoneNumberBelongResponse *)soap_instantiate__ns1__AddPhoneNumberBelongResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPhoneNumberBelongResponse ** p = (_ns1__AddPhoneNumberBelongResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPhoneNumberBelongResponse, sizeof(_ns1__AddPhoneNumberBelongResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPhoneNumberBelongResponse(struct soap *soap, _ns1__AddPhoneNumberBelongResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelongResponse);
	if (soap_out_PointerTo_ns1__AddPhoneNumberBelongResponse(soap, tag?tag:"ns1:AddPhoneNumberBelongResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelongResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPhoneNumberBelongResponse(struct soap *soap, _ns1__AddPhoneNumberBelongResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPhoneNumberBelong(struct soap *soap, _ns1__AddPhoneNumberBelong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPhoneNumberBelong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPhoneNumberBelong(struct soap *soap, const char *tag, int id, _ns1__AddPhoneNumberBelong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelong ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPhoneNumberBelong(struct soap *soap, const char *tag, _ns1__AddPhoneNumberBelong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPhoneNumberBelong **)soap_malloc(soap, sizeof(_ns1__AddPhoneNumberBelong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPhoneNumberBelong *)soap_instantiate__ns1__AddPhoneNumberBelong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPhoneNumberBelong ** p = (_ns1__AddPhoneNumberBelong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPhoneNumberBelong, sizeof(_ns1__AddPhoneNumberBelong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPhoneNumberBelong(struct soap *soap, _ns1__AddPhoneNumberBelong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPhoneNumberBelong);
	if (soap_out_PointerTo_ns1__AddPhoneNumberBelong(soap, tag?tag:"ns1:AddPhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddPhoneNumberBelong ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPhoneNumberBelong(struct soap *soap, _ns1__AddPhoneNumberBelong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, _ns1__UpdatePhoneNumberBelongResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, const char *tag, int id, _ns1__UpdatePhoneNumberBelongResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelongResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, const char *tag, _ns1__UpdatePhoneNumberBelongResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePhoneNumberBelongResponse **)soap_malloc(soap, sizeof(_ns1__UpdatePhoneNumberBelongResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePhoneNumberBelongResponse *)soap_instantiate__ns1__UpdatePhoneNumberBelongResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatePhoneNumberBelongResponse ** p = (_ns1__UpdatePhoneNumberBelongResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePhoneNumberBelongResponse, sizeof(_ns1__UpdatePhoneNumberBelongResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, _ns1__UpdatePhoneNumberBelongResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelongResponse);
	if (soap_out_PointerTo_ns1__UpdatePhoneNumberBelongResponse(soap, tag?tag:"ns1:UpdatePhoneNumberBelongResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelongResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePhoneNumberBelongResponse(struct soap *soap, _ns1__UpdatePhoneNumberBelongResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePhoneNumberBelongResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePhoneNumberBelong(struct soap *soap, _ns1__UpdatePhoneNumberBelong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePhoneNumberBelong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, int id, _ns1__UpdatePhoneNumberBelong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelong ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePhoneNumberBelong(struct soap *soap, const char *tag, _ns1__UpdatePhoneNumberBelong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePhoneNumberBelong **)soap_malloc(soap, sizeof(_ns1__UpdatePhoneNumberBelong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePhoneNumberBelong *)soap_instantiate__ns1__UpdatePhoneNumberBelong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatePhoneNumberBelong ** p = (_ns1__UpdatePhoneNumberBelong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePhoneNumberBelong, sizeof(_ns1__UpdatePhoneNumberBelong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePhoneNumberBelong(struct soap *soap, _ns1__UpdatePhoneNumberBelong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatePhoneNumberBelong);
	if (soap_out_PointerTo_ns1__UpdatePhoneNumberBelong(soap, tag?tag:"ns1:UpdatePhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePhoneNumberBelong ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePhoneNumberBelong(struct soap *soap, _ns1__UpdatePhoneNumberBelong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, _ns1__GetPhoneNumberBelongByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNumberBelongByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNumberBelongByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNumberBelongByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPhoneNumberBelongByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNumberBelongByConditionResponse *)soap_instantiate__ns1__GetPhoneNumberBelongByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNumberBelongByConditionResponse ** p = (_ns1__GetPhoneNumberBelongByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNumberBelongByConditionResponse, sizeof(_ns1__GetPhoneNumberBelongByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, _ns1__GetPhoneNumberBelongByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(soap, tag?tag:"ns1:GetPhoneNumberBelongByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(struct soap *soap, _ns1__GetPhoneNumberBelongByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNumberBelongByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNumberBelongByCondition(struct soap *soap, _ns1__GetPhoneNumberBelongByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNumberBelongByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNumberBelongByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNumberBelongByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNumberBelongByCondition **)soap_malloc(soap, sizeof(_ns1__GetPhoneNumberBelongByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNumberBelongByCondition *)soap_instantiate__ns1__GetPhoneNumberBelongByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNumberBelongByCondition ** p = (_ns1__GetPhoneNumberBelongByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNumberBelongByCondition, sizeof(_ns1__GetPhoneNumberBelongByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNumberBelongByCondition(struct soap *soap, _ns1__GetPhoneNumberBelongByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNumberBelongByCondition);
	if (soap_out_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, tag?tag:"ns1:GetPhoneNumberBelongByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNumberBelongByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNumberBelongByCondition(struct soap *soap, _ns1__GetPhoneNumberBelongByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNumberBelongByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeletetReturnProportionResponse(struct soap *soap, _ns1__DeletetReturnProportionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeletetReturnProportionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeletetReturnProportionResponse(struct soap *soap, const char *tag, int id, _ns1__DeletetReturnProportionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeletetReturnProportionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeletetReturnProportionResponse(struct soap *soap, const char *tag, _ns1__DeletetReturnProportionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeletetReturnProportionResponse **)soap_malloc(soap, sizeof(_ns1__DeletetReturnProportionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeletetReturnProportionResponse *)soap_instantiate__ns1__DeletetReturnProportionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeletetReturnProportionResponse ** p = (_ns1__DeletetReturnProportionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeletetReturnProportionResponse, sizeof(_ns1__DeletetReturnProportionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeletetReturnProportionResponse(struct soap *soap, _ns1__DeletetReturnProportionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeletetReturnProportionResponse);
	if (soap_out_PointerTo_ns1__DeletetReturnProportionResponse(soap, tag?tag:"ns1:DeletetReturnProportionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeletetReturnProportionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeletetReturnProportionResponse(struct soap *soap, _ns1__DeletetReturnProportionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeletetReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeletetReturnProportion(struct soap *soap, _ns1__DeletetReturnProportion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeletetReturnProportion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeletetReturnProportion(struct soap *soap, const char *tag, int id, _ns1__DeletetReturnProportion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeletetReturnProportion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeletetReturnProportion ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeletetReturnProportion(struct soap *soap, const char *tag, _ns1__DeletetReturnProportion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeletetReturnProportion **)soap_malloc(soap, sizeof(_ns1__DeletetReturnProportion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeletetReturnProportion *)soap_instantiate__ns1__DeletetReturnProportion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeletetReturnProportion ** p = (_ns1__DeletetReturnProportion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeletetReturnProportion, sizeof(_ns1__DeletetReturnProportion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeletetReturnProportion(struct soap *soap, _ns1__DeletetReturnProportion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeletetReturnProportion);
	if (soap_out_PointerTo_ns1__DeletetReturnProportion(soap, tag?tag:"ns1:DeletetReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeletetReturnProportion ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeletetReturnProportion(struct soap *soap, _ns1__DeletetReturnProportion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeletetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatetReturnProportionResponse(struct soap *soap, _ns1__UpdatetReturnProportionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatetReturnProportionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatetReturnProportionResponse(struct soap *soap, const char *tag, int id, _ns1__UpdatetReturnProportionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatetReturnProportionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatetReturnProportionResponse(struct soap *soap, const char *tag, _ns1__UpdatetReturnProportionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatetReturnProportionResponse **)soap_malloc(soap, sizeof(_ns1__UpdatetReturnProportionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatetReturnProportionResponse *)soap_instantiate__ns1__UpdatetReturnProportionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatetReturnProportionResponse ** p = (_ns1__UpdatetReturnProportionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatetReturnProportionResponse, sizeof(_ns1__UpdatetReturnProportionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatetReturnProportionResponse(struct soap *soap, _ns1__UpdatetReturnProportionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportionResponse);
	if (soap_out_PointerTo_ns1__UpdatetReturnProportionResponse(soap, tag?tag:"ns1:UpdatetReturnProportionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatetReturnProportionResponse(struct soap *soap, _ns1__UpdatetReturnProportionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatetReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatetReturnProportion(struct soap *soap, _ns1__UpdatetReturnProportion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatetReturnProportion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatetReturnProportion(struct soap *soap, const char *tag, int id, _ns1__UpdatetReturnProportion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatetReturnProportion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportion ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatetReturnProportion(struct soap *soap, const char *tag, _ns1__UpdatetReturnProportion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatetReturnProportion **)soap_malloc(soap, sizeof(_ns1__UpdatetReturnProportion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatetReturnProportion *)soap_instantiate__ns1__UpdatetReturnProportion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatetReturnProportion ** p = (_ns1__UpdatetReturnProportion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatetReturnProportion, sizeof(_ns1__UpdatetReturnProportion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatetReturnProportion(struct soap *soap, _ns1__UpdatetReturnProportion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatetReturnProportion);
	if (soap_out_PointerTo_ns1__UpdatetReturnProportion(soap, tag?tag:"ns1:UpdatetReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatetReturnProportion ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatetReturnProportion(struct soap *soap, _ns1__UpdatetReturnProportion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatetReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddtReturnProportionResponse(struct soap *soap, _ns1__AddtReturnProportionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddtReturnProportionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddtReturnProportionResponse(struct soap *soap, const char *tag, int id, _ns1__AddtReturnProportionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddtReturnProportionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddtReturnProportionResponse(struct soap *soap, const char *tag, _ns1__AddtReturnProportionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddtReturnProportionResponse **)soap_malloc(soap, sizeof(_ns1__AddtReturnProportionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddtReturnProportionResponse *)soap_instantiate__ns1__AddtReturnProportionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddtReturnProportionResponse ** p = (_ns1__AddtReturnProportionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddtReturnProportionResponse, sizeof(_ns1__AddtReturnProportionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddtReturnProportionResponse(struct soap *soap, _ns1__AddtReturnProportionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddtReturnProportionResponse);
	if (soap_out_PointerTo_ns1__AddtReturnProportionResponse(soap, tag?tag:"ns1:AddtReturnProportionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddtReturnProportionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddtReturnProportionResponse(struct soap *soap, _ns1__AddtReturnProportionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddtReturnProportionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddtReturnProportion(struct soap *soap, _ns1__AddtReturnProportion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddtReturnProportion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddtReturnProportion(struct soap *soap, const char *tag, int id, _ns1__AddtReturnProportion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddtReturnProportion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddtReturnProportion ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddtReturnProportion(struct soap *soap, const char *tag, _ns1__AddtReturnProportion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddtReturnProportion **)soap_malloc(soap, sizeof(_ns1__AddtReturnProportion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddtReturnProportion *)soap_instantiate__ns1__AddtReturnProportion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddtReturnProportion ** p = (_ns1__AddtReturnProportion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddtReturnProportion, sizeof(_ns1__AddtReturnProportion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddtReturnProportion(struct soap *soap, _ns1__AddtReturnProportion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddtReturnProportion);
	if (soap_out_PointerTo_ns1__AddtReturnProportion(soap, tag?tag:"ns1:AddtReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddtReturnProportion ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddtReturnProportion(struct soap *soap, _ns1__AddtReturnProportion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddtReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnProportionRecordResponse(struct soap *soap, _ns1__GetReturnProportionRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnProportionRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnProportionRecordResponse(struct soap *soap, const char *tag, int id, _ns1__GetReturnProportionRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnProportionRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnProportionRecordResponse(struct soap *soap, const char *tag, _ns1__GetReturnProportionRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnProportionRecordResponse **)soap_malloc(soap, sizeof(_ns1__GetReturnProportionRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnProportionRecordResponse *)soap_instantiate__ns1__GetReturnProportionRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnProportionRecordResponse ** p = (_ns1__GetReturnProportionRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnProportionRecordResponse, sizeof(_ns1__GetReturnProportionRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnProportionRecordResponse(struct soap *soap, _ns1__GetReturnProportionRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecordResponse);
	if (soap_out_PointerTo_ns1__GetReturnProportionRecordResponse(soap, tag?tag:"ns1:GetReturnProportionRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnProportionRecordResponse(struct soap *soap, _ns1__GetReturnProportionRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnProportionRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnProportionRecord(struct soap *soap, _ns1__GetReturnProportionRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnProportionRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnProportionRecord(struct soap *soap, const char *tag, int id, _ns1__GetReturnProportionRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnProportionRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnProportionRecord(struct soap *soap, const char *tag, _ns1__GetReturnProportionRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnProportionRecord **)soap_malloc(soap, sizeof(_ns1__GetReturnProportionRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnProportionRecord *)soap_instantiate__ns1__GetReturnProportionRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnProportionRecord ** p = (_ns1__GetReturnProportionRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnProportionRecord, sizeof(_ns1__GetReturnProportionRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnProportionRecord(struct soap *soap, _ns1__GetReturnProportionRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnProportionRecord);
	if (soap_out_PointerTo_ns1__GetReturnProportionRecord(soap, tag?tag:"ns1:GetReturnProportionRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnProportionRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnProportionRecord(struct soap *soap, _ns1__GetReturnProportionRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnProportionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InserNoticeToSomeOneResponse(struct soap *soap, _ns1__InserNoticeToSomeOneResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InserNoticeToSomeOneResponse(struct soap *soap, const char *tag, int id, _ns1__InserNoticeToSomeOneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOneResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InserNoticeToSomeOneResponse(struct soap *soap, const char *tag, _ns1__InserNoticeToSomeOneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InserNoticeToSomeOneResponse **)soap_malloc(soap, sizeof(_ns1__InserNoticeToSomeOneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InserNoticeToSomeOneResponse *)soap_instantiate__ns1__InserNoticeToSomeOneResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InserNoticeToSomeOneResponse ** p = (_ns1__InserNoticeToSomeOneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InserNoticeToSomeOneResponse, sizeof(_ns1__InserNoticeToSomeOneResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InserNoticeToSomeOneResponse(struct soap *soap, _ns1__InserNoticeToSomeOneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOneResponse);
	if (soap_out_PointerTo_ns1__InserNoticeToSomeOneResponse(soap, tag?tag:"ns1:InserNoticeToSomeOneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOneResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InserNoticeToSomeOneResponse(struct soap *soap, _ns1__InserNoticeToSomeOneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InserNoticeToSomeOneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InserNoticeToSomeOne(struct soap *soap, _ns1__InserNoticeToSomeOne *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InserNoticeToSomeOne))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InserNoticeToSomeOne(struct soap *soap, const char *tag, int id, _ns1__InserNoticeToSomeOne *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InserNoticeToSomeOne);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOne ** SOAP_FMAC4 soap_in_PointerTo_ns1__InserNoticeToSomeOne(struct soap *soap, const char *tag, _ns1__InserNoticeToSomeOne **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InserNoticeToSomeOne **)soap_malloc(soap, sizeof(_ns1__InserNoticeToSomeOne *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InserNoticeToSomeOne *)soap_instantiate__ns1__InserNoticeToSomeOne(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InserNoticeToSomeOne ** p = (_ns1__InserNoticeToSomeOne **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InserNoticeToSomeOne, sizeof(_ns1__InserNoticeToSomeOne), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InserNoticeToSomeOne(struct soap *soap, _ns1__InserNoticeToSomeOne *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InserNoticeToSomeOne);
	if (soap_out_PointerTo_ns1__InserNoticeToSomeOne(soap, tag?tag:"ns1:InserNoticeToSomeOne", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InserNoticeToSomeOne ** SOAP_FMAC4 soap_get_PointerTo_ns1__InserNoticeToSomeOne(struct soap *soap, _ns1__InserNoticeToSomeOne **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InserNoticeToSomeOne(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteNoticeItemResponse(struct soap *soap, _ns1__DeleteNoticeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteNoticeItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteNoticeItemResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteNoticeItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteNoticeItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteNoticeItemResponse(struct soap *soap, const char *tag, _ns1__DeleteNoticeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteNoticeItemResponse **)soap_malloc(soap, sizeof(_ns1__DeleteNoticeItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteNoticeItemResponse *)soap_instantiate__ns1__DeleteNoticeItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteNoticeItemResponse ** p = (_ns1__DeleteNoticeItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteNoticeItemResponse, sizeof(_ns1__DeleteNoticeItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteNoticeItemResponse(struct soap *soap, _ns1__DeleteNoticeItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteNoticeItemResponse);
	if (soap_out_PointerTo_ns1__DeleteNoticeItemResponse(soap, tag?tag:"ns1:DeleteNoticeItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteNoticeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteNoticeItemResponse(struct soap *soap, _ns1__DeleteNoticeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteNoticeItem(struct soap *soap, _ns1__DeleteNoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteNoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteNoticeItem(struct soap *soap, const char *tag, int id, _ns1__DeleteNoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteNoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteNoticeItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteNoticeItem(struct soap *soap, const char *tag, _ns1__DeleteNoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteNoticeItem **)soap_malloc(soap, sizeof(_ns1__DeleteNoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteNoticeItem *)soap_instantiate__ns1__DeleteNoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteNoticeItem ** p = (_ns1__DeleteNoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteNoticeItem, sizeof(_ns1__DeleteNoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteNoticeItem(struct soap *soap, _ns1__DeleteNoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteNoticeItem);
	if (soap_out_PointerTo_ns1__DeleteNoticeItem(soap, tag?tag:"ns1:DeleteNoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteNoticeItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteNoticeItem(struct soap *soap, _ns1__DeleteNoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateNoticeItemResponse(struct soap *soap, _ns1__UpdateNoticeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateNoticeItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateNoticeItemResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateNoticeItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateNoticeItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateNoticeItemResponse(struct soap *soap, const char *tag, _ns1__UpdateNoticeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateNoticeItemResponse **)soap_malloc(soap, sizeof(_ns1__UpdateNoticeItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateNoticeItemResponse *)soap_instantiate__ns1__UpdateNoticeItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateNoticeItemResponse ** p = (_ns1__UpdateNoticeItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateNoticeItemResponse, sizeof(_ns1__UpdateNoticeItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateNoticeItemResponse(struct soap *soap, _ns1__UpdateNoticeItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateNoticeItemResponse);
	if (soap_out_PointerTo_ns1__UpdateNoticeItemResponse(soap, tag?tag:"ns1:UpdateNoticeItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateNoticeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateNoticeItemResponse(struct soap *soap, _ns1__UpdateNoticeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateNoticeItem(struct soap *soap, _ns1__UpdateNoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateNoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateNoticeItem(struct soap *soap, const char *tag, int id, _ns1__UpdateNoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateNoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateNoticeItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateNoticeItem(struct soap *soap, const char *tag, _ns1__UpdateNoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateNoticeItem **)soap_malloc(soap, sizeof(_ns1__UpdateNoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateNoticeItem *)soap_instantiate__ns1__UpdateNoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateNoticeItem ** p = (_ns1__UpdateNoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateNoticeItem, sizeof(_ns1__UpdateNoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateNoticeItem(struct soap *soap, _ns1__UpdateNoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateNoticeItem);
	if (soap_out_PointerTo_ns1__UpdateNoticeItem(soap, tag?tag:"ns1:UpdateNoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateNoticeItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateNoticeItem(struct soap *soap, _ns1__UpdateNoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, _ns1__AddNoticeItemToSomeoneResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, const char *tag, int id, _ns1__AddNoticeItemToSomeoneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeoneResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, const char *tag, _ns1__AddNoticeItemToSomeoneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddNoticeItemToSomeoneResponse **)soap_malloc(soap, sizeof(_ns1__AddNoticeItemToSomeoneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddNoticeItemToSomeoneResponse *)soap_instantiate__ns1__AddNoticeItemToSomeoneResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddNoticeItemToSomeoneResponse ** p = (_ns1__AddNoticeItemToSomeoneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddNoticeItemToSomeoneResponse, sizeof(_ns1__AddNoticeItemToSomeoneResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, _ns1__AddNoticeItemToSomeoneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeoneResponse);
	if (soap_out_PointerTo_ns1__AddNoticeItemToSomeoneResponse(soap, tag?tag:"ns1:AddNoticeItemToSomeoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeoneResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddNoticeItemToSomeoneResponse(struct soap *soap, _ns1__AddNoticeItemToSomeoneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddNoticeItemToSomeoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddNoticeItemToSomeone(struct soap *soap, _ns1__AddNoticeItemToSomeone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddNoticeItemToSomeone))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddNoticeItemToSomeone(struct soap *soap, const char *tag, int id, _ns1__AddNoticeItemToSomeone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddNoticeItemToSomeone);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeone ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddNoticeItemToSomeone(struct soap *soap, const char *tag, _ns1__AddNoticeItemToSomeone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddNoticeItemToSomeone **)soap_malloc(soap, sizeof(_ns1__AddNoticeItemToSomeone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddNoticeItemToSomeone *)soap_instantiate__ns1__AddNoticeItemToSomeone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddNoticeItemToSomeone ** p = (_ns1__AddNoticeItemToSomeone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddNoticeItemToSomeone, sizeof(_ns1__AddNoticeItemToSomeone), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddNoticeItemToSomeone(struct soap *soap, _ns1__AddNoticeItemToSomeone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddNoticeItemToSomeone);
	if (soap_out_PointerTo_ns1__AddNoticeItemToSomeone(soap, tag?tag:"ns1:AddNoticeItemToSomeone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddNoticeItemToSomeone ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddNoticeItemToSomeone(struct soap *soap, _ns1__AddNoticeItemToSomeone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddNoticeItemToSomeone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddNoticeItemResponse(struct soap *soap, _ns1__AddNoticeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddNoticeItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddNoticeItemResponse(struct soap *soap, const char *tag, int id, _ns1__AddNoticeItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddNoticeItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddNoticeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddNoticeItemResponse(struct soap *soap, const char *tag, _ns1__AddNoticeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddNoticeItemResponse **)soap_malloc(soap, sizeof(_ns1__AddNoticeItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddNoticeItemResponse *)soap_instantiate__ns1__AddNoticeItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddNoticeItemResponse ** p = (_ns1__AddNoticeItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddNoticeItemResponse, sizeof(_ns1__AddNoticeItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddNoticeItemResponse(struct soap *soap, _ns1__AddNoticeItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddNoticeItemResponse);
	if (soap_out_PointerTo_ns1__AddNoticeItemResponse(soap, tag?tag:"ns1:AddNoticeItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddNoticeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddNoticeItemResponse(struct soap *soap, _ns1__AddNoticeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddNoticeItem(struct soap *soap, _ns1__AddNoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddNoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddNoticeItem(struct soap *soap, const char *tag, int id, _ns1__AddNoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddNoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddNoticeItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddNoticeItem(struct soap *soap, const char *tag, _ns1__AddNoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddNoticeItem **)soap_malloc(soap, sizeof(_ns1__AddNoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddNoticeItem *)soap_instantiate__ns1__AddNoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddNoticeItem ** p = (_ns1__AddNoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddNoticeItem, sizeof(_ns1__AddNoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddNoticeItem(struct soap *soap, _ns1__AddNoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddNoticeItem);
	if (soap_out_PointerTo_ns1__AddNoticeItem(soap, tag?tag:"ns1:AddNoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddNoticeItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddNoticeItem(struct soap *soap, _ns1__AddNoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlertNoticeListResponse(struct soap *soap, _ns1__GetAlertNoticeListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlertNoticeListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlertNoticeListResponse(struct soap *soap, const char *tag, int id, _ns1__GetAlertNoticeListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlertNoticeListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlertNoticeListResponse(struct soap *soap, const char *tag, _ns1__GetAlertNoticeListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlertNoticeListResponse **)soap_malloc(soap, sizeof(_ns1__GetAlertNoticeListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlertNoticeListResponse *)soap_instantiate__ns1__GetAlertNoticeListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlertNoticeListResponse ** p = (_ns1__GetAlertNoticeListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlertNoticeListResponse, sizeof(_ns1__GetAlertNoticeListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlertNoticeListResponse(struct soap *soap, _ns1__GetAlertNoticeListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlertNoticeListResponse);
	if (soap_out_PointerTo_ns1__GetAlertNoticeListResponse(soap, tag?tag:"ns1:GetAlertNoticeListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlertNoticeListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlertNoticeListResponse(struct soap *soap, _ns1__GetAlertNoticeListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlertNoticeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlertNoticeList(struct soap *soap, _ns1__GetAlertNoticeList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlertNoticeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlertNoticeList(struct soap *soap, const char *tag, int id, _ns1__GetAlertNoticeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlertNoticeList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlertNoticeList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlertNoticeList(struct soap *soap, const char *tag, _ns1__GetAlertNoticeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlertNoticeList **)soap_malloc(soap, sizeof(_ns1__GetAlertNoticeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlertNoticeList *)soap_instantiate__ns1__GetAlertNoticeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlertNoticeList ** p = (_ns1__GetAlertNoticeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlertNoticeList, sizeof(_ns1__GetAlertNoticeList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlertNoticeList(struct soap *soap, _ns1__GetAlertNoticeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlertNoticeList);
	if (soap_out_PointerTo_ns1__GetAlertNoticeList(soap, tag?tag:"ns1:GetAlertNoticeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlertNoticeList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlertNoticeList(struct soap *soap, _ns1__GetAlertNoticeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlertNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeItemResponse(struct soap *soap, _ns1__GetNoticeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeItemResponse(struct soap *soap, const char *tag, int id, _ns1__GetNoticeItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeItemResponse(struct soap *soap, const char *tag, _ns1__GetNoticeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeItemResponse **)soap_malloc(soap, sizeof(_ns1__GetNoticeItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeItemResponse *)soap_instantiate__ns1__GetNoticeItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeItemResponse ** p = (_ns1__GetNoticeItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeItemResponse, sizeof(_ns1__GetNoticeItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeItemResponse(struct soap *soap, _ns1__GetNoticeItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeItemResponse);
	if (soap_out_PointerTo_ns1__GetNoticeItemResponse(soap, tag?tag:"ns1:GetNoticeItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeItemResponse(struct soap *soap, _ns1__GetNoticeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeItem(struct soap *soap, _ns1__GetNoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeItem(struct soap *soap, const char *tag, int id, _ns1__GetNoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeItem(struct soap *soap, const char *tag, _ns1__GetNoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeItem **)soap_malloc(soap, sizeof(_ns1__GetNoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeItem *)soap_instantiate__ns1__GetNoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeItem ** p = (_ns1__GetNoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeItem, sizeof(_ns1__GetNoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeItem(struct soap *soap, _ns1__GetNoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeItem);
	if (soap_out_PointerTo_ns1__GetNoticeItem(soap, tag?tag:"ns1:GetNoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeItem(struct soap *soap, _ns1__GetNoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeListByConditionResponse(struct soap *soap, _ns1__GetNoticeListByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeListByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeListByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetNoticeListByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeListByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeListByConditionResponse(struct soap *soap, const char *tag, _ns1__GetNoticeListByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeListByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetNoticeListByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeListByConditionResponse *)soap_instantiate__ns1__GetNoticeListByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeListByConditionResponse ** p = (_ns1__GetNoticeListByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeListByConditionResponse, sizeof(_ns1__GetNoticeListByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeListByConditionResponse(struct soap *soap, _ns1__GetNoticeListByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeListByConditionResponse);
	if (soap_out_PointerTo_ns1__GetNoticeListByConditionResponse(soap, tag?tag:"ns1:GetNoticeListByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeListByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeListByConditionResponse(struct soap *soap, _ns1__GetNoticeListByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeListByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeListByCondition(struct soap *soap, _ns1__GetNoticeListByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeListByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeListByCondition(struct soap *soap, const char *tag, int id, _ns1__GetNoticeListByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeListByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeListByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeListByCondition(struct soap *soap, const char *tag, _ns1__GetNoticeListByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeListByCondition **)soap_malloc(soap, sizeof(_ns1__GetNoticeListByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeListByCondition *)soap_instantiate__ns1__GetNoticeListByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeListByCondition ** p = (_ns1__GetNoticeListByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeListByCondition, sizeof(_ns1__GetNoticeListByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeListByCondition(struct soap *soap, _ns1__GetNoticeListByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeListByCondition);
	if (soap_out_PointerTo_ns1__GetNoticeListByCondition(soap, tag?tag:"ns1:GetNoticeListByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeListByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeListByCondition(struct soap *soap, _ns1__GetNoticeListByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeListByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeListResponse(struct soap *soap, _ns1__GetNoticeListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeListResponse(struct soap *soap, const char *tag, int id, _ns1__GetNoticeListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeListResponse(struct soap *soap, const char *tag, _ns1__GetNoticeListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeListResponse **)soap_malloc(soap, sizeof(_ns1__GetNoticeListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeListResponse *)soap_instantiate__ns1__GetNoticeListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeListResponse ** p = (_ns1__GetNoticeListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeListResponse, sizeof(_ns1__GetNoticeListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeListResponse(struct soap *soap, _ns1__GetNoticeListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeListResponse);
	if (soap_out_PointerTo_ns1__GetNoticeListResponse(soap, tag?tag:"ns1:GetNoticeListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeListResponse(struct soap *soap, _ns1__GetNoticeListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetNoticeList(struct soap *soap, _ns1__GetNoticeList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetNoticeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetNoticeList(struct soap *soap, const char *tag, int id, _ns1__GetNoticeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetNoticeList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetNoticeList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetNoticeList(struct soap *soap, const char *tag, _ns1__GetNoticeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetNoticeList **)soap_malloc(soap, sizeof(_ns1__GetNoticeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetNoticeList *)soap_instantiate__ns1__GetNoticeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetNoticeList ** p = (_ns1__GetNoticeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetNoticeList, sizeof(_ns1__GetNoticeList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetNoticeList(struct soap *soap, _ns1__GetNoticeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetNoticeList);
	if (soap_out_PointerTo_ns1__GetNoticeList(soap, tag?tag:"ns1:GetNoticeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetNoticeList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetNoticeList(struct soap *soap, _ns1__GetNoticeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetNoticeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTableStatisticsResponse(struct soap *soap, _ns1__GetTableStatisticsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTableStatisticsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTableStatisticsResponse(struct soap *soap, const char *tag, int id, _ns1__GetTableStatisticsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTableStatisticsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTableStatisticsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTableStatisticsResponse(struct soap *soap, const char *tag, _ns1__GetTableStatisticsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTableStatisticsResponse **)soap_malloc(soap, sizeof(_ns1__GetTableStatisticsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTableStatisticsResponse *)soap_instantiate__ns1__GetTableStatisticsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTableStatisticsResponse ** p = (_ns1__GetTableStatisticsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTableStatisticsResponse, sizeof(_ns1__GetTableStatisticsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTableStatisticsResponse(struct soap *soap, _ns1__GetTableStatisticsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTableStatisticsResponse);
	if (soap_out_PointerTo_ns1__GetTableStatisticsResponse(soap, tag?tag:"ns1:GetTableStatisticsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTableStatisticsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTableStatisticsResponse(struct soap *soap, _ns1__GetTableStatisticsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTableStatisticsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTableStatistics(struct soap *soap, _ns1__GetTableStatistics *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTableStatistics))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTableStatistics(struct soap *soap, const char *tag, int id, _ns1__GetTableStatistics *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTableStatistics);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTableStatistics ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTableStatistics(struct soap *soap, const char *tag, _ns1__GetTableStatistics **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTableStatistics **)soap_malloc(soap, sizeof(_ns1__GetTableStatistics *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTableStatistics *)soap_instantiate__ns1__GetTableStatistics(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTableStatistics ** p = (_ns1__GetTableStatistics **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTableStatistics, sizeof(_ns1__GetTableStatistics), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTableStatistics(struct soap *soap, _ns1__GetTableStatistics *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTableStatistics);
	if (soap_out_PointerTo_ns1__GetTableStatistics(soap, tag?tag:"ns1:GetTableStatistics", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTableStatistics ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTableStatistics(struct soap *soap, _ns1__GetTableStatistics **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateFunctionRightResponse(struct soap *soap, _ns1__UpdateFunctionRightResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateFunctionRightResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateFunctionRightResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateFunctionRightResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateFunctionRightResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRightResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateFunctionRightResponse(struct soap *soap, const char *tag, _ns1__UpdateFunctionRightResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateFunctionRightResponse **)soap_malloc(soap, sizeof(_ns1__UpdateFunctionRightResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateFunctionRightResponse *)soap_instantiate__ns1__UpdateFunctionRightResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateFunctionRightResponse ** p = (_ns1__UpdateFunctionRightResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateFunctionRightResponse, sizeof(_ns1__UpdateFunctionRightResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateFunctionRightResponse(struct soap *soap, _ns1__UpdateFunctionRightResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateFunctionRightResponse);
	if (soap_out_PointerTo_ns1__UpdateFunctionRightResponse(soap, tag?tag:"ns1:UpdateFunctionRightResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateFunctionRightResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateFunctionRightResponse(struct soap *soap, _ns1__UpdateFunctionRightResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateFunctionRightResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateFunctionRight(struct soap *soap, _ns1__UpdateFunctionRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateFunctionRight))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateFunctionRight(struct soap *soap, const char *tag, int id, _ns1__UpdateFunctionRight *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateFunctionRight);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateFunctionRight ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateFunctionRight(struct soap *soap, const char *tag, _ns1__UpdateFunctionRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateFunctionRight **)soap_malloc(soap, sizeof(_ns1__UpdateFunctionRight *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateFunctionRight *)soap_instantiate__ns1__UpdateFunctionRight(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateFunctionRight ** p = (_ns1__UpdateFunctionRight **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateFunctionRight, sizeof(_ns1__UpdateFunctionRight), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateFunctionRight(struct soap *soap, _ns1__UpdateFunctionRight *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateFunctionRight);
	if (soap_out_PointerTo_ns1__UpdateFunctionRight(soap, tag?tag:"ns1:UpdateFunctionRight", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateFunctionRight ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateFunctionRight(struct soap *soap, _ns1__UpdateFunctionRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateFunctionRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateUserFunctionListResponse(struct soap *soap, _ns1__UpdateUserFunctionListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateUserFunctionListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateUserFunctionListResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateUserFunctionListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateUserFunctionListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateUserFunctionListResponse(struct soap *soap, const char *tag, _ns1__UpdateUserFunctionListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateUserFunctionListResponse **)soap_malloc(soap, sizeof(_ns1__UpdateUserFunctionListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateUserFunctionListResponse *)soap_instantiate__ns1__UpdateUserFunctionListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateUserFunctionListResponse ** p = (_ns1__UpdateUserFunctionListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateUserFunctionListResponse, sizeof(_ns1__UpdateUserFunctionListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateUserFunctionListResponse(struct soap *soap, _ns1__UpdateUserFunctionListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionListResponse);
	if (soap_out_PointerTo_ns1__UpdateUserFunctionListResponse(soap, tag?tag:"ns1:UpdateUserFunctionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateUserFunctionListResponse(struct soap *soap, _ns1__UpdateUserFunctionListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateUserFunctionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateUserFunctionList(struct soap *soap, _ns1__UpdateUserFunctionList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateUserFunctionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateUserFunctionList(struct soap *soap, const char *tag, int id, _ns1__UpdateUserFunctionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateUserFunctionList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionList ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateUserFunctionList(struct soap *soap, const char *tag, _ns1__UpdateUserFunctionList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateUserFunctionList **)soap_malloc(soap, sizeof(_ns1__UpdateUserFunctionList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateUserFunctionList *)soap_instantiate__ns1__UpdateUserFunctionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateUserFunctionList ** p = (_ns1__UpdateUserFunctionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateUserFunctionList, sizeof(_ns1__UpdateUserFunctionList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateUserFunctionList(struct soap *soap, _ns1__UpdateUserFunctionList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateUserFunctionList);
	if (soap_out_PointerTo_ns1__UpdateUserFunctionList(soap, tag?tag:"ns1:UpdateUserFunctionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateUserFunctionList ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateUserFunctionList(struct soap *soap, _ns1__UpdateUserFunctionList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateUserFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFunctionListResponse(struct soap *soap, _ns1__GetFunctionListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFunctionListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFunctionListResponse(struct soap *soap, const char *tag, int id, _ns1__GetFunctionListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFunctionListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetFunctionListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFunctionListResponse(struct soap *soap, const char *tag, _ns1__GetFunctionListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFunctionListResponse **)soap_malloc(soap, sizeof(_ns1__GetFunctionListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFunctionListResponse *)soap_instantiate__ns1__GetFunctionListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetFunctionListResponse ** p = (_ns1__GetFunctionListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFunctionListResponse, sizeof(_ns1__GetFunctionListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFunctionListResponse(struct soap *soap, _ns1__GetFunctionListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetFunctionListResponse);
	if (soap_out_PointerTo_ns1__GetFunctionListResponse(soap, tag?tag:"ns1:GetFunctionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFunctionListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFunctionListResponse(struct soap *soap, _ns1__GetFunctionListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFunctionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFunctionList(struct soap *soap, _ns1__GetFunctionList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFunctionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFunctionList(struct soap *soap, const char *tag, int id, _ns1__GetFunctionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFunctionList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetFunctionList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFunctionList(struct soap *soap, const char *tag, _ns1__GetFunctionList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFunctionList **)soap_malloc(soap, sizeof(_ns1__GetFunctionList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFunctionList *)soap_instantiate__ns1__GetFunctionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetFunctionList ** p = (_ns1__GetFunctionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFunctionList, sizeof(_ns1__GetFunctionList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFunctionList(struct soap *soap, _ns1__GetFunctionList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetFunctionList);
	if (soap_out_PointerTo_ns1__GetFunctionList(soap, tag?tag:"ns1:GetFunctionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFunctionList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFunctionList(struct soap *soap, _ns1__GetFunctionList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFunctionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDicContentByCategoryResponse(struct soap *soap, _ns1__UpdateDicContentByCategoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDicContentByCategoryResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateDicContentByCategoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategoryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDicContentByCategoryResponse(struct soap *soap, const char *tag, _ns1__UpdateDicContentByCategoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDicContentByCategoryResponse **)soap_malloc(soap, sizeof(_ns1__UpdateDicContentByCategoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDicContentByCategoryResponse *)soap_instantiate__ns1__UpdateDicContentByCategoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateDicContentByCategoryResponse ** p = (_ns1__UpdateDicContentByCategoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateDicContentByCategoryResponse, sizeof(_ns1__UpdateDicContentByCategoryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDicContentByCategoryResponse(struct soap *soap, _ns1__UpdateDicContentByCategoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategoryResponse);
	if (soap_out_PointerTo_ns1__UpdateDicContentByCategoryResponse(soap, tag?tag:"ns1:UpdateDicContentByCategoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategoryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDicContentByCategoryResponse(struct soap *soap, _ns1__UpdateDicContentByCategoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDicContentByCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDicContentByCategory(struct soap *soap, _ns1__UpdateDicContentByCategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateDicContentByCategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDicContentByCategory(struct soap *soap, const char *tag, int id, _ns1__UpdateDicContentByCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateDicContentByCategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategory ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDicContentByCategory(struct soap *soap, const char *tag, _ns1__UpdateDicContentByCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDicContentByCategory **)soap_malloc(soap, sizeof(_ns1__UpdateDicContentByCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDicContentByCategory *)soap_instantiate__ns1__UpdateDicContentByCategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateDicContentByCategory ** p = (_ns1__UpdateDicContentByCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateDicContentByCategory, sizeof(_ns1__UpdateDicContentByCategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDicContentByCategory(struct soap *soap, _ns1__UpdateDicContentByCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateDicContentByCategory);
	if (soap_out_PointerTo_ns1__UpdateDicContentByCategory(soap, tag?tag:"ns1:UpdateDicContentByCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDicContentByCategory ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDicContentByCategory(struct soap *soap, _ns1__UpdateDicContentByCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDicContentByCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteDicContentResponse(struct soap *soap, _ns1__DeleteDicContentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteDicContentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteDicContentResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteDicContentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteDicContentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteDicContentResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteDicContentResponse(struct soap *soap, const char *tag, _ns1__DeleteDicContentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteDicContentResponse **)soap_malloc(soap, sizeof(_ns1__DeleteDicContentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteDicContentResponse *)soap_instantiate__ns1__DeleteDicContentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteDicContentResponse ** p = (_ns1__DeleteDicContentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteDicContentResponse, sizeof(_ns1__DeleteDicContentResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteDicContentResponse(struct soap *soap, _ns1__DeleteDicContentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteDicContentResponse);
	if (soap_out_PointerTo_ns1__DeleteDicContentResponse(soap, tag?tag:"ns1:DeleteDicContentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteDicContentResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteDicContentResponse(struct soap *soap, _ns1__DeleteDicContentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteDicContent(struct soap *soap, _ns1__DeleteDicContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteDicContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteDicContent(struct soap *soap, const char *tag, int id, _ns1__DeleteDicContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteDicContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteDicContent ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteDicContent(struct soap *soap, const char *tag, _ns1__DeleteDicContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteDicContent **)soap_malloc(soap, sizeof(_ns1__DeleteDicContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteDicContent *)soap_instantiate__ns1__DeleteDicContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteDicContent ** p = (_ns1__DeleteDicContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteDicContent, sizeof(_ns1__DeleteDicContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteDicContent(struct soap *soap, _ns1__DeleteDicContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteDicContent);
	if (soap_out_PointerTo_ns1__DeleteDicContent(soap, tag?tag:"ns1:DeleteDicContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteDicContent ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteDicContent(struct soap *soap, _ns1__DeleteDicContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDicContentResponse(struct soap *soap, _ns1__UpdateDicContentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateDicContentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDicContentResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateDicContentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateDicContentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDicContentResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDicContentResponse(struct soap *soap, const char *tag, _ns1__UpdateDicContentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDicContentResponse **)soap_malloc(soap, sizeof(_ns1__UpdateDicContentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDicContentResponse *)soap_instantiate__ns1__UpdateDicContentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateDicContentResponse ** p = (_ns1__UpdateDicContentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateDicContentResponse, sizeof(_ns1__UpdateDicContentResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDicContentResponse(struct soap *soap, _ns1__UpdateDicContentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateDicContentResponse);
	if (soap_out_PointerTo_ns1__UpdateDicContentResponse(soap, tag?tag:"ns1:UpdateDicContentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDicContentResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDicContentResponse(struct soap *soap, _ns1__UpdateDicContentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDicContent(struct soap *soap, _ns1__UpdateDicContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateDicContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDicContent(struct soap *soap, const char *tag, int id, _ns1__UpdateDicContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateDicContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDicContent ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDicContent(struct soap *soap, const char *tag, _ns1__UpdateDicContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDicContent **)soap_malloc(soap, sizeof(_ns1__UpdateDicContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDicContent *)soap_instantiate__ns1__UpdateDicContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateDicContent ** p = (_ns1__UpdateDicContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateDicContent, sizeof(_ns1__UpdateDicContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDicContent(struct soap *soap, _ns1__UpdateDicContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateDicContent);
	if (soap_out_PointerTo_ns1__UpdateDicContent(soap, tag?tag:"ns1:UpdateDicContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDicContent ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDicContent(struct soap *soap, _ns1__UpdateDicContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsertDicContentResponse(struct soap *soap, _ns1__InsertDicContentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsertDicContentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsertDicContentResponse(struct soap *soap, const char *tag, int id, _ns1__InsertDicContentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsertDicContentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InsertDicContentResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsertDicContentResponse(struct soap *soap, const char *tag, _ns1__InsertDicContentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsertDicContentResponse **)soap_malloc(soap, sizeof(_ns1__InsertDicContentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsertDicContentResponse *)soap_instantiate__ns1__InsertDicContentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InsertDicContentResponse ** p = (_ns1__InsertDicContentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsertDicContentResponse, sizeof(_ns1__InsertDicContentResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsertDicContentResponse(struct soap *soap, _ns1__InsertDicContentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InsertDicContentResponse);
	if (soap_out_PointerTo_ns1__InsertDicContentResponse(soap, tag?tag:"ns1:InsertDicContentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsertDicContentResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsertDicContentResponse(struct soap *soap, _ns1__InsertDicContentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsertDicContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsertDicContent(struct soap *soap, _ns1__InsertDicContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsertDicContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsertDicContent(struct soap *soap, const char *tag, int id, _ns1__InsertDicContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsertDicContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InsertDicContent ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsertDicContent(struct soap *soap, const char *tag, _ns1__InsertDicContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsertDicContent **)soap_malloc(soap, sizeof(_ns1__InsertDicContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsertDicContent *)soap_instantiate__ns1__InsertDicContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InsertDicContent ** p = (_ns1__InsertDicContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsertDicContent, sizeof(_ns1__InsertDicContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsertDicContent(struct soap *soap, _ns1__InsertDicContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InsertDicContent);
	if (soap_out_PointerTo_ns1__InsertDicContent(soap, tag?tag:"ns1:InsertDicContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsertDicContent ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsertDicContent(struct soap *soap, _ns1__InsertDicContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsertDicContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCategoryResponse(struct soap *soap, _ns1__GetAllCategoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCategoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCategoryResponse(struct soap *soap, const char *tag, int id, _ns1__GetAllCategoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCategoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCategoryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCategoryResponse(struct soap *soap, const char *tag, _ns1__GetAllCategoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCategoryResponse **)soap_malloc(soap, sizeof(_ns1__GetAllCategoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCategoryResponse *)soap_instantiate__ns1__GetAllCategoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCategoryResponse ** p = (_ns1__GetAllCategoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCategoryResponse, sizeof(_ns1__GetAllCategoryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCategoryResponse(struct soap *soap, _ns1__GetAllCategoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCategoryResponse);
	if (soap_out_PointerTo_ns1__GetAllCategoryResponse(soap, tag?tag:"ns1:GetAllCategoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCategoryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCategoryResponse(struct soap *soap, _ns1__GetAllCategoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCategory(struct soap *soap, _ns1__GetAllCategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCategory(struct soap *soap, const char *tag, int id, _ns1__GetAllCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCategory ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCategory(struct soap *soap, const char *tag, _ns1__GetAllCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCategory **)soap_malloc(soap, sizeof(_ns1__GetAllCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCategory *)soap_instantiate__ns1__GetAllCategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCategory ** p = (_ns1__GetAllCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCategory, sizeof(_ns1__GetAllCategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCategory(struct soap *soap, _ns1__GetAllCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCategory);
	if (soap_out_PointerTo_ns1__GetAllCategory(soap, tag?tag:"ns1:GetAllCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCategory ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCategory(struct soap *soap, _ns1__GetAllCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDicContentByConditionResponse(struct soap *soap, _ns1__GetDicContentByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDicContentByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDicContentByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetDicContentByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDicContentByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDicContentByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDicContentByConditionResponse(struct soap *soap, const char *tag, _ns1__GetDicContentByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDicContentByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetDicContentByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDicContentByConditionResponse *)soap_instantiate__ns1__GetDicContentByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDicContentByConditionResponse ** p = (_ns1__GetDicContentByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDicContentByConditionResponse, sizeof(_ns1__GetDicContentByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDicContentByConditionResponse(struct soap *soap, _ns1__GetDicContentByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDicContentByConditionResponse);
	if (soap_out_PointerTo_ns1__GetDicContentByConditionResponse(soap, tag?tag:"ns1:GetDicContentByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDicContentByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDicContentByConditionResponse(struct soap *soap, _ns1__GetDicContentByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDicContentByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDicContentByCondition(struct soap *soap, _ns1__GetDicContentByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDicContentByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDicContentByCondition(struct soap *soap, const char *tag, int id, _ns1__GetDicContentByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDicContentByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDicContentByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDicContentByCondition(struct soap *soap, const char *tag, _ns1__GetDicContentByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDicContentByCondition **)soap_malloc(soap, sizeof(_ns1__GetDicContentByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDicContentByCondition *)soap_instantiate__ns1__GetDicContentByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDicContentByCondition ** p = (_ns1__GetDicContentByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDicContentByCondition, sizeof(_ns1__GetDicContentByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDicContentByCondition(struct soap *soap, _ns1__GetDicContentByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDicContentByCondition);
	if (soap_out_PointerTo_ns1__GetDicContentByCondition(soap, tag?tag:"ns1:GetDicContentByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDicContentByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDicContentByCondition(struct soap *soap, _ns1__GetDicContentByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDicContentByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAcountPaymentRecordResponse(struct soap *soap, _ns1__GetAcountPaymentRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAcountPaymentRecordResponse(struct soap *soap, const char *tag, int id, _ns1__GetAcountPaymentRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAcountPaymentRecordResponse(struct soap *soap, const char *tag, _ns1__GetAcountPaymentRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAcountPaymentRecordResponse **)soap_malloc(soap, sizeof(_ns1__GetAcountPaymentRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAcountPaymentRecordResponse *)soap_instantiate__ns1__GetAcountPaymentRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAcountPaymentRecordResponse ** p = (_ns1__GetAcountPaymentRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAcountPaymentRecordResponse, sizeof(_ns1__GetAcountPaymentRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAcountPaymentRecordResponse(struct soap *soap, _ns1__GetAcountPaymentRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecordResponse);
	if (soap_out_PointerTo_ns1__GetAcountPaymentRecordResponse(soap, tag?tag:"ns1:GetAcountPaymentRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAcountPaymentRecordResponse(struct soap *soap, _ns1__GetAcountPaymentRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAcountPaymentRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAcountPaymentRecord(struct soap *soap, _ns1__GetAcountPaymentRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAcountPaymentRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAcountPaymentRecord(struct soap *soap, const char *tag, int id, _ns1__GetAcountPaymentRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAcountPaymentRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAcountPaymentRecord(struct soap *soap, const char *tag, _ns1__GetAcountPaymentRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAcountPaymentRecord **)soap_malloc(soap, sizeof(_ns1__GetAcountPaymentRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAcountPaymentRecord *)soap_instantiate__ns1__GetAcountPaymentRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAcountPaymentRecord ** p = (_ns1__GetAcountPaymentRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAcountPaymentRecord, sizeof(_ns1__GetAcountPaymentRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAcountPaymentRecord(struct soap *soap, _ns1__GetAcountPaymentRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAcountPaymentRecord);
	if (soap_out_PointerTo_ns1__GetAcountPaymentRecord(soap, tag?tag:"ns1:GetAcountPaymentRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAcountPaymentRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAcountPaymentRecord(struct soap *soap, _ns1__GetAcountPaymentRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAcountPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnRecordDealResponse(struct soap *soap, _ns1__GetReturnRecordDealResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnRecordDealResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnRecordDealResponse(struct soap *soap, const char *tag, int id, _ns1__GetReturnRecordDealResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnRecordDealResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDealResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnRecordDealResponse(struct soap *soap, const char *tag, _ns1__GetReturnRecordDealResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnRecordDealResponse **)soap_malloc(soap, sizeof(_ns1__GetReturnRecordDealResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnRecordDealResponse *)soap_instantiate__ns1__GetReturnRecordDealResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnRecordDealResponse ** p = (_ns1__GetReturnRecordDealResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnRecordDealResponse, sizeof(_ns1__GetReturnRecordDealResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnRecordDealResponse(struct soap *soap, _ns1__GetReturnRecordDealResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnRecordDealResponse);
	if (soap_out_PointerTo_ns1__GetReturnRecordDealResponse(soap, tag?tag:"ns1:GetReturnRecordDealResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnRecordDealResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnRecordDealResponse(struct soap *soap, _ns1__GetReturnRecordDealResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnRecordDealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnRecordDeal(struct soap *soap, _ns1__GetReturnRecordDeal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnRecordDeal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnRecordDeal(struct soap *soap, const char *tag, int id, _ns1__GetReturnRecordDeal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnRecordDeal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordDeal ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnRecordDeal(struct soap *soap, const char *tag, _ns1__GetReturnRecordDeal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnRecordDeal **)soap_malloc(soap, sizeof(_ns1__GetReturnRecordDeal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnRecordDeal *)soap_instantiate__ns1__GetReturnRecordDeal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnRecordDeal ** p = (_ns1__GetReturnRecordDeal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnRecordDeal, sizeof(_ns1__GetReturnRecordDeal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnRecordDeal(struct soap *soap, _ns1__GetReturnRecordDeal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnRecordDeal);
	if (soap_out_PointerTo_ns1__GetReturnRecordDeal(soap, tag?tag:"ns1:GetReturnRecordDeal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnRecordDeal ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnRecordDeal(struct soap *soap, _ns1__GetReturnRecordDeal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnRecordDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnRecordResponse(struct soap *soap, _ns1__GetReturnRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnRecordResponse(struct soap *soap, const char *tag, int id, _ns1__GetReturnRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnRecordResponse(struct soap *soap, const char *tag, _ns1__GetReturnRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnRecordResponse **)soap_malloc(soap, sizeof(_ns1__GetReturnRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnRecordResponse *)soap_instantiate__ns1__GetReturnRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnRecordResponse ** p = (_ns1__GetReturnRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnRecordResponse, sizeof(_ns1__GetReturnRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnRecordResponse(struct soap *soap, _ns1__GetReturnRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnRecordResponse);
	if (soap_out_PointerTo_ns1__GetReturnRecordResponse(soap, tag?tag:"ns1:GetReturnRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnRecordResponse(struct soap *soap, _ns1__GetReturnRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnRecord(struct soap *soap, _ns1__GetReturnRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnRecord(struct soap *soap, const char *tag, int id, _ns1__GetReturnRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnRecord(struct soap *soap, const char *tag, _ns1__GetReturnRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnRecord **)soap_malloc(soap, sizeof(_ns1__GetReturnRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnRecord *)soap_instantiate__ns1__GetReturnRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnRecord ** p = (_ns1__GetReturnRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnRecord, sizeof(_ns1__GetReturnRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnRecord(struct soap *soap, _ns1__GetReturnRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnRecord);
	if (soap_out_PointerTo_ns1__GetReturnRecord(soap, tag?tag:"ns1:GetReturnRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnRecord(struct soap *soap, _ns1__GetReturnRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserFunctionResponse(struct soap *soap, _ns1__GetUserFunctionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserFunctionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserFunctionResponse(struct soap *soap, const char *tag, int id, _ns1__GetUserFunctionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserFunctionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserFunctionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserFunctionResponse(struct soap *soap, const char *tag, _ns1__GetUserFunctionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserFunctionResponse **)soap_malloc(soap, sizeof(_ns1__GetUserFunctionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserFunctionResponse *)soap_instantiate__ns1__GetUserFunctionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserFunctionResponse ** p = (_ns1__GetUserFunctionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserFunctionResponse, sizeof(_ns1__GetUserFunctionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserFunctionResponse(struct soap *soap, _ns1__GetUserFunctionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserFunctionResponse);
	if (soap_out_PointerTo_ns1__GetUserFunctionResponse(soap, tag?tag:"ns1:GetUserFunctionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserFunctionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserFunctionResponse(struct soap *soap, _ns1__GetUserFunctionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserFunctionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserFunction(struct soap *soap, _ns1__GetUserFunction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserFunction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserFunction(struct soap *soap, const char *tag, int id, _ns1__GetUserFunction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserFunction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserFunction ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserFunction(struct soap *soap, const char *tag, _ns1__GetUserFunction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserFunction **)soap_malloc(soap, sizeof(_ns1__GetUserFunction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserFunction *)soap_instantiate__ns1__GetUserFunction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserFunction ** p = (_ns1__GetUserFunction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserFunction, sizeof(_ns1__GetUserFunction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserFunction(struct soap *soap, _ns1__GetUserFunction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserFunction);
	if (soap_out_PointerTo_ns1__GetUserFunction(soap, tag?tag:"ns1:GetUserFunction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserFunction ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserFunction(struct soap *soap, _ns1__GetUserFunction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetWorkNameListResponse(struct soap *soap, _ns1__GetWorkNameListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetWorkNameListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetWorkNameListResponse(struct soap *soap, const char *tag, int id, _ns1__GetWorkNameListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetWorkNameListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetWorkNameListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetWorkNameListResponse(struct soap *soap, const char *tag, _ns1__GetWorkNameListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetWorkNameListResponse **)soap_malloc(soap, sizeof(_ns1__GetWorkNameListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetWorkNameListResponse *)soap_instantiate__ns1__GetWorkNameListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetWorkNameListResponse ** p = (_ns1__GetWorkNameListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetWorkNameListResponse, sizeof(_ns1__GetWorkNameListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetWorkNameListResponse(struct soap *soap, _ns1__GetWorkNameListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetWorkNameListResponse);
	if (soap_out_PointerTo_ns1__GetWorkNameListResponse(soap, tag?tag:"ns1:GetWorkNameListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetWorkNameListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetWorkNameListResponse(struct soap *soap, _ns1__GetWorkNameListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetWorkNameListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetWorkNameList(struct soap *soap, _ns1__GetWorkNameList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetWorkNameList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetWorkNameList(struct soap *soap, const char *tag, int id, _ns1__GetWorkNameList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetWorkNameList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetWorkNameList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetWorkNameList(struct soap *soap, const char *tag, _ns1__GetWorkNameList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetWorkNameList **)soap_malloc(soap, sizeof(_ns1__GetWorkNameList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetWorkNameList *)soap_instantiate__ns1__GetWorkNameList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetWorkNameList ** p = (_ns1__GetWorkNameList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetWorkNameList, sizeof(_ns1__GetWorkNameList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetWorkNameList(struct soap *soap, _ns1__GetWorkNameList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetWorkNameList);
	if (soap_out_PointerTo_ns1__GetWorkNameList(soap, tag?tag:"ns1:GetWorkNameList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetWorkNameList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetWorkNameList(struct soap *soap, _ns1__GetWorkNameList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetWorkNameList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CharegeReturnedMoneyResponse(struct soap *soap, _ns1__CharegeReturnedMoneyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CharegeReturnedMoneyResponse(struct soap *soap, const char *tag, int id, _ns1__CharegeReturnedMoneyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoneyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CharegeReturnedMoneyResponse(struct soap *soap, const char *tag, _ns1__CharegeReturnedMoneyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CharegeReturnedMoneyResponse **)soap_malloc(soap, sizeof(_ns1__CharegeReturnedMoneyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CharegeReturnedMoneyResponse *)soap_instantiate__ns1__CharegeReturnedMoneyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CharegeReturnedMoneyResponse ** p = (_ns1__CharegeReturnedMoneyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CharegeReturnedMoneyResponse, sizeof(_ns1__CharegeReturnedMoneyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CharegeReturnedMoneyResponse(struct soap *soap, _ns1__CharegeReturnedMoneyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoneyResponse);
	if (soap_out_PointerTo_ns1__CharegeReturnedMoneyResponse(soap, tag?tag:"ns1:CharegeReturnedMoneyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoneyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CharegeReturnedMoneyResponse(struct soap *soap, _ns1__CharegeReturnedMoneyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CharegeReturnedMoneyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CharegeReturnedMoney(struct soap *soap, _ns1__CharegeReturnedMoney *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CharegeReturnedMoney))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CharegeReturnedMoney(struct soap *soap, const char *tag, int id, _ns1__CharegeReturnedMoney *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CharegeReturnedMoney);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoney ** SOAP_FMAC4 soap_in_PointerTo_ns1__CharegeReturnedMoney(struct soap *soap, const char *tag, _ns1__CharegeReturnedMoney **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CharegeReturnedMoney **)soap_malloc(soap, sizeof(_ns1__CharegeReturnedMoney *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CharegeReturnedMoney *)soap_instantiate__ns1__CharegeReturnedMoney(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CharegeReturnedMoney ** p = (_ns1__CharegeReturnedMoney **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CharegeReturnedMoney, sizeof(_ns1__CharegeReturnedMoney), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CharegeReturnedMoney(struct soap *soap, _ns1__CharegeReturnedMoney *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CharegeReturnedMoney);
	if (soap_out_PointerTo_ns1__CharegeReturnedMoney(soap, tag?tag:"ns1:CharegeReturnedMoney", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CharegeReturnedMoney ** SOAP_FMAC4 soap_get_PointerTo_ns1__CharegeReturnedMoney(struct soap *soap, _ns1__CharegeReturnedMoney **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CharegeReturnedMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnInfoResponse(struct soap *soap, _ns1__GetReturnInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetReturnInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnInfoResponse(struct soap *soap, const char *tag, _ns1__GetReturnInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetReturnInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnInfoResponse *)soap_instantiate__ns1__GetReturnInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnInfoResponse ** p = (_ns1__GetReturnInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnInfoResponse, sizeof(_ns1__GetReturnInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnInfoResponse(struct soap *soap, _ns1__GetReturnInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnInfoResponse);
	if (soap_out_PointerTo_ns1__GetReturnInfoResponse(soap, tag?tag:"ns1:GetReturnInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnInfoResponse(struct soap *soap, _ns1__GetReturnInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReturnInfo(struct soap *soap, _ns1__GetReturnInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReturnInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReturnInfo(struct soap *soap, const char *tag, int id, _ns1__GetReturnInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReturnInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReturnInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReturnInfo(struct soap *soap, const char *tag, _ns1__GetReturnInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReturnInfo **)soap_malloc(soap, sizeof(_ns1__GetReturnInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReturnInfo *)soap_instantiate__ns1__GetReturnInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReturnInfo ** p = (_ns1__GetReturnInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReturnInfo, sizeof(_ns1__GetReturnInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReturnInfo(struct soap *soap, _ns1__GetReturnInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetReturnInfo);
	if (soap_out_PointerTo_ns1__GetReturnInfo(soap, tag?tag:"ns1:GetReturnInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReturnInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReturnInfo(struct soap *soap, _ns1__GetReturnInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddAcountPaymentResponse(struct soap *soap, _ns1__AddAcountPaymentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddAcountPaymentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddAcountPaymentResponse(struct soap *soap, const char *tag, int id, _ns1__AddAcountPaymentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddAcountPaymentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddAcountPaymentResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddAcountPaymentResponse(struct soap *soap, const char *tag, _ns1__AddAcountPaymentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddAcountPaymentResponse **)soap_malloc(soap, sizeof(_ns1__AddAcountPaymentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddAcountPaymentResponse *)soap_instantiate__ns1__AddAcountPaymentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddAcountPaymentResponse ** p = (_ns1__AddAcountPaymentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddAcountPaymentResponse, sizeof(_ns1__AddAcountPaymentResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddAcountPaymentResponse(struct soap *soap, _ns1__AddAcountPaymentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddAcountPaymentResponse);
	if (soap_out_PointerTo_ns1__AddAcountPaymentResponse(soap, tag?tag:"ns1:AddAcountPaymentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddAcountPaymentResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddAcountPaymentResponse(struct soap *soap, _ns1__AddAcountPaymentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddAcountPaymentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddAcountPayment(struct soap *soap, _ns1__AddAcountPayment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddAcountPayment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddAcountPayment(struct soap *soap, const char *tag, int id, _ns1__AddAcountPayment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddAcountPayment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddAcountPayment ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddAcountPayment(struct soap *soap, const char *tag, _ns1__AddAcountPayment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddAcountPayment **)soap_malloc(soap, sizeof(_ns1__AddAcountPayment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddAcountPayment *)soap_instantiate__ns1__AddAcountPayment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddAcountPayment ** p = (_ns1__AddAcountPayment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddAcountPayment, sizeof(_ns1__AddAcountPayment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddAcountPayment(struct soap *soap, _ns1__AddAcountPayment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddAcountPayment);
	if (soap_out_PointerTo_ns1__AddAcountPayment(soap, tag?tag:"ns1:AddAcountPayment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddAcountPayment ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddAcountPayment(struct soap *soap, _ns1__AddAcountPayment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddAcountPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AlterUserInfoResponse(struct soap *soap, _ns1__AlterUserInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AlterUserInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AlterUserInfoResponse(struct soap *soap, const char *tag, int id, _ns1__AlterUserInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AlterUserInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AlterUserInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AlterUserInfoResponse(struct soap *soap, const char *tag, _ns1__AlterUserInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AlterUserInfoResponse **)soap_malloc(soap, sizeof(_ns1__AlterUserInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AlterUserInfoResponse *)soap_instantiate__ns1__AlterUserInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AlterUserInfoResponse ** p = (_ns1__AlterUserInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AlterUserInfoResponse, sizeof(_ns1__AlterUserInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AlterUserInfoResponse(struct soap *soap, _ns1__AlterUserInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AlterUserInfoResponse);
	if (soap_out_PointerTo_ns1__AlterUserInfoResponse(soap, tag?tag:"ns1:AlterUserInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AlterUserInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AlterUserInfoResponse(struct soap *soap, _ns1__AlterUserInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AlterUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AlterUserInfo(struct soap *soap, _ns1__AlterUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AlterUserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AlterUserInfo(struct soap *soap, const char *tag, int id, _ns1__AlterUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AlterUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AlterUserInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__AlterUserInfo(struct soap *soap, const char *tag, _ns1__AlterUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AlterUserInfo **)soap_malloc(soap, sizeof(_ns1__AlterUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AlterUserInfo *)soap_instantiate__ns1__AlterUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AlterUserInfo ** p = (_ns1__AlterUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AlterUserInfo, sizeof(_ns1__AlterUserInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AlterUserInfo(struct soap *soap, _ns1__AlterUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AlterUserInfo);
	if (soap_out_PointerTo_ns1__AlterUserInfo(soap, tag?tag:"ns1:AlterUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AlterUserInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__AlterUserInfo(struct soap *soap, _ns1__AlterUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AlterUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AlterPswResponse(struct soap *soap, _ns1__AlterPswResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AlterPswResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AlterPswResponse(struct soap *soap, const char *tag, int id, _ns1__AlterPswResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AlterPswResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AlterPswResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AlterPswResponse(struct soap *soap, const char *tag, _ns1__AlterPswResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AlterPswResponse **)soap_malloc(soap, sizeof(_ns1__AlterPswResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AlterPswResponse *)soap_instantiate__ns1__AlterPswResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AlterPswResponse ** p = (_ns1__AlterPswResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AlterPswResponse, sizeof(_ns1__AlterPswResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AlterPswResponse(struct soap *soap, _ns1__AlterPswResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AlterPswResponse);
	if (soap_out_PointerTo_ns1__AlterPswResponse(soap, tag?tag:"ns1:AlterPswResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AlterPswResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AlterPswResponse(struct soap *soap, _ns1__AlterPswResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AlterPswResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AlterPsw(struct soap *soap, _ns1__AlterPsw *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AlterPsw))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AlterPsw(struct soap *soap, const char *tag, int id, _ns1__AlterPsw *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AlterPsw);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AlterPsw ** SOAP_FMAC4 soap_in_PointerTo_ns1__AlterPsw(struct soap *soap, const char *tag, _ns1__AlterPsw **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AlterPsw **)soap_malloc(soap, sizeof(_ns1__AlterPsw *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AlterPsw *)soap_instantiate__ns1__AlterPsw(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AlterPsw ** p = (_ns1__AlterPsw **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AlterPsw, sizeof(_ns1__AlterPsw), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AlterPsw(struct soap *soap, _ns1__AlterPsw *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AlterPsw);
	if (soap_out_PointerTo_ns1__AlterPsw(soap, tag?tag:"ns1:AlterPsw", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AlterPsw ** SOAP_FMAC4 soap_get_PointerTo_ns1__AlterPsw(struct soap *soap, _ns1__AlterPsw **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AlterPsw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RegisterUserResponse(struct soap *soap, _ns1__RegisterUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RegisterUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RegisterUserResponse(struct soap *soap, const char *tag, int id, _ns1__RegisterUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RegisterUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RegisterUserResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RegisterUserResponse(struct soap *soap, const char *tag, _ns1__RegisterUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RegisterUserResponse **)soap_malloc(soap, sizeof(_ns1__RegisterUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RegisterUserResponse *)soap_instantiate__ns1__RegisterUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RegisterUserResponse ** p = (_ns1__RegisterUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RegisterUserResponse, sizeof(_ns1__RegisterUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RegisterUserResponse(struct soap *soap, _ns1__RegisterUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RegisterUserResponse);
	if (soap_out_PointerTo_ns1__RegisterUserResponse(soap, tag?tag:"ns1:RegisterUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RegisterUserResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RegisterUserResponse(struct soap *soap, _ns1__RegisterUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RegisterUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RegisterUser(struct soap *soap, _ns1__RegisterUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RegisterUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RegisterUser(struct soap *soap, const char *tag, int id, _ns1__RegisterUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RegisterUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RegisterUser ** SOAP_FMAC4 soap_in_PointerTo_ns1__RegisterUser(struct soap *soap, const char *tag, _ns1__RegisterUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RegisterUser **)soap_malloc(soap, sizeof(_ns1__RegisterUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RegisterUser *)soap_instantiate__ns1__RegisterUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RegisterUser ** p = (_ns1__RegisterUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RegisterUser, sizeof(_ns1__RegisterUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RegisterUser(struct soap *soap, _ns1__RegisterUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RegisterUser);
	if (soap_out_PointerTo_ns1__RegisterUser(soap, tag?tag:"ns1:RegisterUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RegisterUser ** SOAP_FMAC4 soap_get_PointerTo_ns1__RegisterUser(struct soap *soap, _ns1__RegisterUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RegisterUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserInfoResponse(struct soap *soap, _ns1__GetUserInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetUserInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserInfoResponse(struct soap *soap, const char *tag, _ns1__GetUserInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetUserInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserInfoResponse *)soap_instantiate__ns1__GetUserInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserInfoResponse ** p = (_ns1__GetUserInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserInfoResponse, sizeof(_ns1__GetUserInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserInfoResponse(struct soap *soap, _ns1__GetUserInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserInfoResponse);
	if (soap_out_PointerTo_ns1__GetUserInfoResponse(soap, tag?tag:"ns1:GetUserInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserInfoResponse(struct soap *soap, _ns1__GetUserInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserInfo(struct soap *soap, _ns1__GetUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserInfo(struct soap *soap, const char *tag, int id, _ns1__GetUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserInfo(struct soap *soap, const char *tag, _ns1__GetUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserInfo **)soap_malloc(soap, sizeof(_ns1__GetUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserInfo *)soap_instantiate__ns1__GetUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserInfo ** p = (_ns1__GetUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserInfo, sizeof(_ns1__GetUserInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserInfo(struct soap *soap, _ns1__GetUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserInfo);
	if (soap_out_PointerTo_ns1__GetUserInfo(soap, tag?tag:"ns1:GetUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserInfo(struct soap *soap, _ns1__GetUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TestLoginResponse(struct soap *soap, _ns1__TestLoginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TestLoginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TestLoginResponse(struct soap *soap, const char *tag, int id, _ns1__TestLoginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TestLoginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__TestLoginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__TestLoginResponse(struct soap *soap, const char *tag, _ns1__TestLoginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TestLoginResponse **)soap_malloc(soap, sizeof(_ns1__TestLoginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TestLoginResponse *)soap_instantiate__ns1__TestLoginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__TestLoginResponse ** p = (_ns1__TestLoginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TestLoginResponse, sizeof(_ns1__TestLoginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TestLoginResponse(struct soap *soap, _ns1__TestLoginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TestLoginResponse);
	if (soap_out_PointerTo_ns1__TestLoginResponse(soap, tag?tag:"ns1:TestLoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TestLoginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__TestLoginResponse(struct soap *soap, _ns1__TestLoginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TestLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TestLogin(struct soap *soap, _ns1__TestLogin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TestLogin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TestLogin(struct soap *soap, const char *tag, int id, _ns1__TestLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TestLogin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__TestLogin ** SOAP_FMAC4 soap_in_PointerTo_ns1__TestLogin(struct soap *soap, const char *tag, _ns1__TestLogin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TestLogin **)soap_malloc(soap, sizeof(_ns1__TestLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TestLogin *)soap_instantiate__ns1__TestLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__TestLogin ** p = (_ns1__TestLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TestLogin, sizeof(_ns1__TestLogin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TestLogin(struct soap *soap, _ns1__TestLogin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__TestLogin);
	if (soap_out_PointerTo_ns1__TestLogin(soap, tag?tag:"ns1:TestLogin", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TestLogin ** SOAP_FMAC4 soap_get_PointerTo_ns1__TestLogin(struct soap *soap, _ns1__TestLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TestLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loggoutResponse(struct soap *soap, _ns1__loggoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loggoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loggoutResponse(struct soap *soap, const char *tag, int id, _ns1__loggoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loggoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loggoutResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__loggoutResponse(struct soap *soap, const char *tag, _ns1__loggoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loggoutResponse **)soap_malloc(soap, sizeof(_ns1__loggoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loggoutResponse *)soap_instantiate__ns1__loggoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__loggoutResponse ** p = (_ns1__loggoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loggoutResponse, sizeof(_ns1__loggoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loggoutResponse(struct soap *soap, _ns1__loggoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__loggoutResponse);
	if (soap_out_PointerTo_ns1__loggoutResponse(soap, tag?tag:"ns1:loggoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loggoutResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__loggoutResponse(struct soap *soap, _ns1__loggoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loggoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loggout(struct soap *soap, _ns1__loggout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loggout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loggout(struct soap *soap, const char *tag, int id, _ns1__loggout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loggout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loggout ** SOAP_FMAC4 soap_in_PointerTo_ns1__loggout(struct soap *soap, const char *tag, _ns1__loggout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loggout **)soap_malloc(soap, sizeof(_ns1__loggout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loggout *)soap_instantiate__ns1__loggout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__loggout ** p = (_ns1__loggout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loggout, sizeof(_ns1__loggout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loggout(struct soap *soap, _ns1__loggout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__loggout);
	if (soap_out_PointerTo_ns1__loggout(soap, tag?tag:"ns1:loggout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loggout ** SOAP_FMAC4 soap_get_PointerTo_ns1__loggout(struct soap *soap, _ns1__loggout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loggout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HelloWorldResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HelloWorldResponse(struct soap *soap, const char *tag, int id, _ns1__HelloWorldResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HelloWorldResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__HelloWorldResponse(struct soap *soap, const char *tag, _ns1__HelloWorldResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__HelloWorldResponse **)soap_malloc(soap, sizeof(_ns1__HelloWorldResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__HelloWorldResponse *)soap_instantiate__ns1__HelloWorldResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__HelloWorldResponse ** p = (_ns1__HelloWorldResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__HelloWorldResponse);
	if (soap_out_PointerTo_ns1__HelloWorldResponse(soap, tag?tag:"ns1:HelloWorldResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HelloWorldResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__HelloWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HelloWorld))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, int id, _ns1__HelloWorld *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HelloWorld);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_in_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__HelloWorld **)soap_malloc(soap, sizeof(_ns1__HelloWorld *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__HelloWorld *)soap_instantiate__ns1__HelloWorld(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__HelloWorld ** p = (_ns1__HelloWorld **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__HelloWorld);
	if (soap_out_PointerTo_ns1__HelloWorld(soap, tag?tag:"ns1:HelloWorld", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_get_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayPublicTelHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayPublicTelHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayPublicTelHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayPublicTelHistoryByConditionResponse *)soap_instantiate__ns1__GetPayPublicTelHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayPublicTelHistoryByConditionResponse ** p = (_ns1__GetPayPublicTelHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByConditionResponse, sizeof(_ns1__GetPayPublicTelHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag?tag:"ns1:GetPayPublicTelHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayPublicTelHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, _ns1__GetPayPublicTelHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayPublicTelHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayPublicTelHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayPublicTelHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayPublicTelHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayPublicTelHistoryByCondition *)soap_instantiate__ns1__GetPayPublicTelHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayPublicTelHistoryByCondition ** p = (_ns1__GetPayPublicTelHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayPublicTelHistoryByCondition, sizeof(_ns1__GetPayPublicTelHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, _ns1__GetPayPublicTelHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayPublicTelHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, tag?tag:"ns1:GetPayPublicTelHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayPublicTelHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayPublicTelHistoryByCondition(struct soap *soap, _ns1__GetPayPublicTelHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayPublicTelHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayPublicTelByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayPublicTelByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayPublicTelByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayPublicTelByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayPublicTelByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayPublicTelByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayPublicTelByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayPublicTelByConditionResponse *)soap_instantiate__ns1__GetPayPublicTelByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayPublicTelByConditionResponse ** p = (_ns1__GetPayPublicTelByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayPublicTelByConditionResponse, sizeof(_ns1__GetPayPublicTelByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayPublicTelByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayPublicTelByConditionResponse(soap, tag?tag:"ns1:GetPayPublicTelByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayPublicTelByConditionResponse(struct soap *soap, _ns1__GetPayPublicTelByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayPublicTelByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayPublicTelByCondition(struct soap *soap, _ns1__GetPayPublicTelByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayPublicTelByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayPublicTelByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayPublicTelByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayPublicTelByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayPublicTelByCondition(struct soap *soap, const char *tag, _ns1__GetPayPublicTelByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayPublicTelByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayPublicTelByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayPublicTelByCondition *)soap_instantiate__ns1__GetPayPublicTelByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayPublicTelByCondition ** p = (_ns1__GetPayPublicTelByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayPublicTelByCondition, sizeof(_ns1__GetPayPublicTelByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayPublicTelByCondition(struct soap *soap, _ns1__GetPayPublicTelByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayPublicTelByCondition);
	if (soap_out_PointerTo_ns1__GetPayPublicTelByCondition(soap, tag?tag:"ns1:GetPayPublicTelByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayPublicTelByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayPublicTelByCondition(struct soap *soap, _ns1__GetPayPublicTelByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayPublicTelByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, _ns1__GetPayGameHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayGameHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayGameHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayGameHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayGameHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayGameHistoryByConditionResponse *)soap_instantiate__ns1__GetPayGameHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayGameHistoryByConditionResponse ** p = (_ns1__GetPayGameHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayGameHistoryByConditionResponse, sizeof(_ns1__GetPayGameHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, _ns1__GetPayGameHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayGameHistoryByConditionResponse(soap, tag?tag:"ns1:GetPayGameHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayGameHistoryByConditionResponse(struct soap *soap, _ns1__GetPayGameHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayGameHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayGameHistoryByCondition(struct soap *soap, _ns1__GetPayGameHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayGameHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayGameHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayGameHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayGameHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayGameHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayGameHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayGameHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayGameHistoryByCondition *)soap_instantiate__ns1__GetPayGameHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayGameHistoryByCondition ** p = (_ns1__GetPayGameHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayGameHistoryByCondition, sizeof(_ns1__GetPayGameHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayGameHistoryByCondition(struct soap *soap, _ns1__GetPayGameHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayGameHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPayGameHistoryByCondition(soap, tag?tag:"ns1:GetPayGameHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayGameHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayGameHistoryByCondition(struct soap *soap, _ns1__GetPayGameHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayGameHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayGameByConditionResponse(struct soap *soap, _ns1__GetPayGameByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayGameByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayGameByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayGameByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayGameByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayGameByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayGameByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayGameByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayGameByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayGameByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayGameByConditionResponse *)soap_instantiate__ns1__GetPayGameByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayGameByConditionResponse ** p = (_ns1__GetPayGameByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayGameByConditionResponse, sizeof(_ns1__GetPayGameByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayGameByConditionResponse(struct soap *soap, _ns1__GetPayGameByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayGameByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayGameByConditionResponse(soap, tag?tag:"ns1:GetPayGameByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayGameByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayGameByConditionResponse(struct soap *soap, _ns1__GetPayGameByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayGameByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayGameByCondition(struct soap *soap, _ns1__GetPayGameByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayGameByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayGameByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayGameByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayGameByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayGameByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayGameByCondition(struct soap *soap, const char *tag, _ns1__GetPayGameByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayGameByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayGameByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayGameByCondition *)soap_instantiate__ns1__GetPayGameByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayGameByCondition ** p = (_ns1__GetPayGameByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayGameByCondition, sizeof(_ns1__GetPayGameByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayGameByCondition(struct soap *soap, _ns1__GetPayGameByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayGameByCondition);
	if (soap_out_PointerTo_ns1__GetPayGameByCondition(soap, tag?tag:"ns1:GetPayGameByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayGameByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayGameByCondition(struct soap *soap, _ns1__GetPayGameByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayGameByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, _ns1__GetPayInternetHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayInternetHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayInternetHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayInternetHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayInternetHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayInternetHistoryByConditionResponse *)soap_instantiate__ns1__GetPayInternetHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayInternetHistoryByConditionResponse ** p = (_ns1__GetPayInternetHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayInternetHistoryByConditionResponse, sizeof(_ns1__GetPayInternetHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, _ns1__GetPayInternetHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(soap, tag?tag:"ns1:GetPayInternetHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(struct soap *soap, _ns1__GetPayInternetHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayInternetHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayInternetHistoryByCondition(struct soap *soap, _ns1__GetPayInternetHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayInternetHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayInternetHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayInternetHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayInternetHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayInternetHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayInternetHistoryByCondition *)soap_instantiate__ns1__GetPayInternetHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayInternetHistoryByCondition ** p = (_ns1__GetPayInternetHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayInternetHistoryByCondition, sizeof(_ns1__GetPayInternetHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayInternetHistoryByCondition(struct soap *soap, _ns1__GetPayInternetHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayInternetHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, tag?tag:"ns1:GetPayInternetHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayInternetHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayInternetHistoryByCondition(struct soap *soap, _ns1__GetPayInternetHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayInternetHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayInternetByConditionResponse(struct soap *soap, _ns1__GetPayInternetByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayInternetByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayInternetByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayInternetByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayInternetByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayInternetByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayInternetByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayInternetByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayInternetByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayInternetByConditionResponse *)soap_instantiate__ns1__GetPayInternetByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayInternetByConditionResponse ** p = (_ns1__GetPayInternetByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayInternetByConditionResponse, sizeof(_ns1__GetPayInternetByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayInternetByConditionResponse(struct soap *soap, _ns1__GetPayInternetByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayInternetByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayInternetByConditionResponse(soap, tag?tag:"ns1:GetPayInternetByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayInternetByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayInternetByConditionResponse(struct soap *soap, _ns1__GetPayInternetByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayInternetByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayInternetByCondition(struct soap *soap, _ns1__GetPayInternetByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayInternetByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayInternetByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayInternetByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayInternetByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayInternetByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayInternetByCondition(struct soap *soap, const char *tag, _ns1__GetPayInternetByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayInternetByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayInternetByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayInternetByCondition *)soap_instantiate__ns1__GetPayInternetByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayInternetByCondition ** p = (_ns1__GetPayInternetByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayInternetByCondition, sizeof(_ns1__GetPayInternetByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayInternetByCondition(struct soap *soap, _ns1__GetPayInternetByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayInternetByCondition);
	if (soap_out_PointerTo_ns1__GetPayInternetByCondition(soap, tag?tag:"ns1:GetPayInternetByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayInternetByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayInternetByCondition(struct soap *soap, _ns1__GetPayInternetByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayInternetByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPaymentOrPaymentHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPaymentOrPaymentHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentOrPaymentHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentOrPaymentHistoryByConditionResponse *)soap_instantiate__ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentOrPaymentHistoryByConditionResponse ** p = (_ns1__GetPaymentOrPaymentHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByConditionResponse, sizeof(_ns1__GetPaymentOrPaymentHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag?tag:"ns1:GetPaymentOrPaymentHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPaymentOrPaymentHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPaymentOrPaymentHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentOrPaymentHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentOrPaymentHistoryByCondition *)soap_instantiate__ns1__GetPaymentOrPaymentHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentOrPaymentHistoryByCondition ** p = (_ns1__GetPaymentOrPaymentHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentOrPaymentHistoryByCondition, sizeof(_ns1__GetPaymentOrPaymentHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag?tag:"ns1:GetPaymentOrPaymentHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentOrPaymentHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(struct soap *soap, _ns1__GetPaymentOrPaymentHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentOrPaymentHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, _ns1__GetTransactionStaticsByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetTransactionStaticsByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, const char *tag, _ns1__GetTransactionStaticsByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTransactionStaticsByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetTransactionStaticsByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTransactionStaticsByConditionResponse *)soap_instantiate__ns1__GetTransactionStaticsByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTransactionStaticsByConditionResponse ** p = (_ns1__GetTransactionStaticsByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTransactionStaticsByConditionResponse, sizeof(_ns1__GetTransactionStaticsByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, _ns1__GetTransactionStaticsByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByConditionResponse);
	if (soap_out_PointerTo_ns1__GetTransactionStaticsByConditionResponse(soap, tag?tag:"ns1:GetTransactionStaticsByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTransactionStaticsByConditionResponse(struct soap *soap, _ns1__GetTransactionStaticsByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTransactionStaticsByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTransactionStaticsByCondition(struct soap *soap, _ns1__GetTransactionStaticsByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTransactionStaticsByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, int id, _ns1__GetTransactionStaticsByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTransactionStaticsByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTransactionStaticsByCondition(struct soap *soap, const char *tag, _ns1__GetTransactionStaticsByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTransactionStaticsByCondition **)soap_malloc(soap, sizeof(_ns1__GetTransactionStaticsByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTransactionStaticsByCondition *)soap_instantiate__ns1__GetTransactionStaticsByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTransactionStaticsByCondition ** p = (_ns1__GetTransactionStaticsByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTransactionStaticsByCondition, sizeof(_ns1__GetTransactionStaticsByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTransactionStaticsByCondition(struct soap *soap, _ns1__GetTransactionStaticsByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTransactionStaticsByCondition);
	if (soap_out_PointerTo_ns1__GetTransactionStaticsByCondition(soap, tag?tag:"ns1:GetTransactionStaticsByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTransactionStaticsByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTransactionStaticsByCondition(struct soap *soap, _ns1__GetTransactionStaticsByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTransactionStaticsByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTransactionByConditionResponse(struct soap *soap, _ns1__GetTransactionByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTransactionByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTransactionByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetTransactionByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTransactionByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTransactionByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTransactionByConditionResponse(struct soap *soap, const char *tag, _ns1__GetTransactionByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTransactionByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetTransactionByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTransactionByConditionResponse *)soap_instantiate__ns1__GetTransactionByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTransactionByConditionResponse ** p = (_ns1__GetTransactionByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTransactionByConditionResponse, sizeof(_ns1__GetTransactionByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTransactionByConditionResponse(struct soap *soap, _ns1__GetTransactionByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTransactionByConditionResponse);
	if (soap_out_PointerTo_ns1__GetTransactionByConditionResponse(soap, tag?tag:"ns1:GetTransactionByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTransactionByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTransactionByConditionResponse(struct soap *soap, _ns1__GetTransactionByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTransactionByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTransactionByCondition(struct soap *soap, _ns1__GetTransactionByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTransactionByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTransactionByCondition(struct soap *soap, const char *tag, int id, _ns1__GetTransactionByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTransactionByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetTransactionByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTransactionByCondition(struct soap *soap, const char *tag, _ns1__GetTransactionByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTransactionByCondition **)soap_malloc(soap, sizeof(_ns1__GetTransactionByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTransactionByCondition *)soap_instantiate__ns1__GetTransactionByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetTransactionByCondition ** p = (_ns1__GetTransactionByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTransactionByCondition, sizeof(_ns1__GetTransactionByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTransactionByCondition(struct soap *soap, _ns1__GetTransactionByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetTransactionByCondition);
	if (soap_out_PointerTo_ns1__GetTransactionByCondition(soap, tag?tag:"ns1:GetTransactionByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTransactionByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTransactionByCondition(struct soap *soap, _ns1__GetTransactionByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTransactionByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentItemResponse(struct soap *soap, _ns1__GetPaymentItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentItemResponse(struct soap *soap, const char *tag, int id, _ns1__GetPaymentItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentItemResponse(struct soap *soap, const char *tag, _ns1__GetPaymentItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentItemResponse **)soap_malloc(soap, sizeof(_ns1__GetPaymentItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentItemResponse *)soap_instantiate__ns1__GetPaymentItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentItemResponse ** p = (_ns1__GetPaymentItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentItemResponse, sizeof(_ns1__GetPaymentItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentItemResponse(struct soap *soap, _ns1__GetPaymentItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentItemResponse);
	if (soap_out_PointerTo_ns1__GetPaymentItemResponse(soap, tag?tag:"ns1:GetPaymentItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentItemResponse(struct soap *soap, _ns1__GetPaymentItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentItem(struct soap *soap, _ns1__GetPaymentItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentItem(struct soap *soap, const char *tag, int id, _ns1__GetPaymentItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentItem(struct soap *soap, const char *tag, _ns1__GetPaymentItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentItem **)soap_malloc(soap, sizeof(_ns1__GetPaymentItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentItem *)soap_instantiate__ns1__GetPaymentItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentItem ** p = (_ns1__GetPaymentItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentItem, sizeof(_ns1__GetPaymentItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentItem(struct soap *soap, _ns1__GetPaymentItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentItem);
	if (soap_out_PointerTo_ns1__GetPaymentItem(soap, tag?tag:"ns1:GetPaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentItem(struct soap *soap, _ns1__GetPaymentItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentRecordResponse(struct soap *soap, _ns1__GetPaymentRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentRecordResponse(struct soap *soap, const char *tag, int id, _ns1__GetPaymentRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentRecordResponse(struct soap *soap, const char *tag, _ns1__GetPaymentRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentRecordResponse **)soap_malloc(soap, sizeof(_ns1__GetPaymentRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentRecordResponse *)soap_instantiate__ns1__GetPaymentRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentRecordResponse ** p = (_ns1__GetPaymentRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentRecordResponse, sizeof(_ns1__GetPaymentRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentRecordResponse(struct soap *soap, _ns1__GetPaymentRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentRecordResponse);
	if (soap_out_PointerTo_ns1__GetPaymentRecordResponse(soap, tag?tag:"ns1:GetPaymentRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentRecordResponse(struct soap *soap, _ns1__GetPaymentRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPaymentRecord(struct soap *soap, _ns1__GetPaymentRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPaymentRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPaymentRecord(struct soap *soap, const char *tag, int id, _ns1__GetPaymentRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPaymentRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPaymentRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPaymentRecord(struct soap *soap, const char *tag, _ns1__GetPaymentRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPaymentRecord **)soap_malloc(soap, sizeof(_ns1__GetPaymentRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPaymentRecord *)soap_instantiate__ns1__GetPaymentRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPaymentRecord ** p = (_ns1__GetPaymentRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPaymentRecord, sizeof(_ns1__GetPaymentRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPaymentRecord(struct soap *soap, _ns1__GetPaymentRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPaymentRecord);
	if (soap_out_PointerTo_ns1__GetPaymentRecord(soap, tag?tag:"ns1:GetPaymentRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPaymentRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPaymentRecord(struct soap *soap, _ns1__GetPaymentRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPaymentRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayPublicTelResponse(struct soap *soap, _ns1__PayPublicTelResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayPublicTelResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayPublicTelResponse(struct soap *soap, const char *tag, int id, _ns1__PayPublicTelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayPublicTelResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayPublicTelResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayPublicTelResponse(struct soap *soap, const char *tag, _ns1__PayPublicTelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayPublicTelResponse **)soap_malloc(soap, sizeof(_ns1__PayPublicTelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayPublicTelResponse *)soap_instantiate__ns1__PayPublicTelResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayPublicTelResponse ** p = (_ns1__PayPublicTelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayPublicTelResponse, sizeof(_ns1__PayPublicTelResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayPublicTelResponse(struct soap *soap, _ns1__PayPublicTelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayPublicTelResponse);
	if (soap_out_PointerTo_ns1__PayPublicTelResponse(soap, tag?tag:"ns1:PayPublicTelResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayPublicTelResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayPublicTelResponse(struct soap *soap, _ns1__PayPublicTelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayPublicTelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayPublicTel(struct soap *soap, _ns1__PayPublicTel *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayPublicTel))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayPublicTel(struct soap *soap, const char *tag, int id, _ns1__PayPublicTel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayPublicTel);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayPublicTel ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayPublicTel(struct soap *soap, const char *tag, _ns1__PayPublicTel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayPublicTel **)soap_malloc(soap, sizeof(_ns1__PayPublicTel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayPublicTel *)soap_instantiate__ns1__PayPublicTel(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayPublicTel ** p = (_ns1__PayPublicTel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayPublicTel, sizeof(_ns1__PayPublicTel), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayPublicTel(struct soap *soap, _ns1__PayPublicTel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayPublicTel);
	if (soap_out_PointerTo_ns1__PayPublicTel(soap, tag?tag:"ns1:PayPublicTel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayPublicTel ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayPublicTel(struct soap *soap, _ns1__PayPublicTel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayPublicTel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayGameResponse(struct soap *soap, _ns1__PayGameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayGameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayGameResponse(struct soap *soap, const char *tag, int id, _ns1__PayGameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayGameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayGameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayGameResponse(struct soap *soap, const char *tag, _ns1__PayGameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayGameResponse **)soap_malloc(soap, sizeof(_ns1__PayGameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayGameResponse *)soap_instantiate__ns1__PayGameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayGameResponse ** p = (_ns1__PayGameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayGameResponse, sizeof(_ns1__PayGameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayGameResponse(struct soap *soap, _ns1__PayGameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayGameResponse);
	if (soap_out_PointerTo_ns1__PayGameResponse(soap, tag?tag:"ns1:PayGameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayGameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayGameResponse(struct soap *soap, _ns1__PayGameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayGameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayGame(struct soap *soap, _ns1__PayGame *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayGame))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayGame(struct soap *soap, const char *tag, int id, _ns1__PayGame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayGame);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayGame ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayGame(struct soap *soap, const char *tag, _ns1__PayGame **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayGame **)soap_malloc(soap, sizeof(_ns1__PayGame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayGame *)soap_instantiate__ns1__PayGame(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayGame ** p = (_ns1__PayGame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayGame, sizeof(_ns1__PayGame), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayGame(struct soap *soap, _ns1__PayGame *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayGame);
	if (soap_out_PointerTo_ns1__PayGame(soap, tag?tag:"ns1:PayGame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayGame ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayGame(struct soap *soap, _ns1__PayGame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayGame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RequstInternetRollbackResponse(struct soap *soap, _ns1__RequstInternetRollbackResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RequstInternetRollbackResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RequstInternetRollbackResponse(struct soap *soap, const char *tag, int id, _ns1__RequstInternetRollbackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RequstInternetRollbackResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollbackResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RequstInternetRollbackResponse(struct soap *soap, const char *tag, _ns1__RequstInternetRollbackResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RequstInternetRollbackResponse **)soap_malloc(soap, sizeof(_ns1__RequstInternetRollbackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RequstInternetRollbackResponse *)soap_instantiate__ns1__RequstInternetRollbackResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RequstInternetRollbackResponse ** p = (_ns1__RequstInternetRollbackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RequstInternetRollbackResponse, sizeof(_ns1__RequstInternetRollbackResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RequstInternetRollbackResponse(struct soap *soap, _ns1__RequstInternetRollbackResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RequstInternetRollbackResponse);
	if (soap_out_PointerTo_ns1__RequstInternetRollbackResponse(soap, tag?tag:"ns1:RequstInternetRollbackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RequstInternetRollbackResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RequstInternetRollbackResponse(struct soap *soap, _ns1__RequstInternetRollbackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RequstInternetRollbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RequstInternetRollback(struct soap *soap, _ns1__RequstInternetRollback *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RequstInternetRollback))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RequstInternetRollback(struct soap *soap, const char *tag, int id, _ns1__RequstInternetRollback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RequstInternetRollback);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RequstInternetRollback ** SOAP_FMAC4 soap_in_PointerTo_ns1__RequstInternetRollback(struct soap *soap, const char *tag, _ns1__RequstInternetRollback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RequstInternetRollback **)soap_malloc(soap, sizeof(_ns1__RequstInternetRollback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RequstInternetRollback *)soap_instantiate__ns1__RequstInternetRollback(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RequstInternetRollback ** p = (_ns1__RequstInternetRollback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RequstInternetRollback, sizeof(_ns1__RequstInternetRollback), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RequstInternetRollback(struct soap *soap, _ns1__RequstInternetRollback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RequstInternetRollback);
	if (soap_out_PointerTo_ns1__RequstInternetRollback(soap, tag?tag:"ns1:RequstInternetRollback", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RequstInternetRollback ** SOAP_FMAC4 soap_get_PointerTo_ns1__RequstInternetRollback(struct soap *soap, _ns1__RequstInternetRollback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RequstInternetRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayInternetWithListResponse(struct soap *soap, _ns1__PayInternetWithListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayInternetWithListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayInternetWithListResponse(struct soap *soap, const char *tag, int id, _ns1__PayInternetWithListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayInternetWithListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayInternetWithListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayInternetWithListResponse(struct soap *soap, const char *tag, _ns1__PayInternetWithListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayInternetWithListResponse **)soap_malloc(soap, sizeof(_ns1__PayInternetWithListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayInternetWithListResponse *)soap_instantiate__ns1__PayInternetWithListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayInternetWithListResponse ** p = (_ns1__PayInternetWithListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayInternetWithListResponse, sizeof(_ns1__PayInternetWithListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayInternetWithListResponse(struct soap *soap, _ns1__PayInternetWithListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayInternetWithListResponse);
	if (soap_out_PointerTo_ns1__PayInternetWithListResponse(soap, tag?tag:"ns1:PayInternetWithListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayInternetWithListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayInternetWithListResponse(struct soap *soap, _ns1__PayInternetWithListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayInternetWithListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayInternetWithList(struct soap *soap, _ns1__PayInternetWithList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayInternetWithList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayInternetWithList(struct soap *soap, const char *tag, int id, _ns1__PayInternetWithList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayInternetWithList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayInternetWithList ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayInternetWithList(struct soap *soap, const char *tag, _ns1__PayInternetWithList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayInternetWithList **)soap_malloc(soap, sizeof(_ns1__PayInternetWithList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayInternetWithList *)soap_instantiate__ns1__PayInternetWithList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayInternetWithList ** p = (_ns1__PayInternetWithList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayInternetWithList, sizeof(_ns1__PayInternetWithList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayInternetWithList(struct soap *soap, _ns1__PayInternetWithList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayInternetWithList);
	if (soap_out_PointerTo_ns1__PayInternetWithList(soap, tag?tag:"ns1:PayInternetWithList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayInternetWithList ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayInternetWithList(struct soap *soap, _ns1__PayInternetWithList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayInternetWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayInternetResponse(struct soap *soap, _ns1__PayInternetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayInternetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayInternetResponse(struct soap *soap, const char *tag, int id, _ns1__PayInternetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayInternetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayInternetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayInternetResponse(struct soap *soap, const char *tag, _ns1__PayInternetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayInternetResponse **)soap_malloc(soap, sizeof(_ns1__PayInternetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayInternetResponse *)soap_instantiate__ns1__PayInternetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayInternetResponse ** p = (_ns1__PayInternetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayInternetResponse, sizeof(_ns1__PayInternetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayInternetResponse(struct soap *soap, _ns1__PayInternetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayInternetResponse);
	if (soap_out_PointerTo_ns1__PayInternetResponse(soap, tag?tag:"ns1:PayInternetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayInternetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayInternetResponse(struct soap *soap, _ns1__PayInternetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayInternetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayInternet(struct soap *soap, _ns1__PayInternet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayInternet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayInternet(struct soap *soap, const char *tag, int id, _ns1__PayInternet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayInternet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayInternet ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayInternet(struct soap *soap, const char *tag, _ns1__PayInternet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayInternet **)soap_malloc(soap, sizeof(_ns1__PayInternet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayInternet *)soap_instantiate__ns1__PayInternet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayInternet ** p = (_ns1__PayInternet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayInternet, sizeof(_ns1__PayInternet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayInternet(struct soap *soap, _ns1__PayInternet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayInternet);
	if (soap_out_PointerTo_ns1__PayInternet(soap, tag?tag:"ns1:PayInternet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayInternet ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayInternet(struct soap *soap, _ns1__PayInternet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayInternet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RequstRollbackResponse(struct soap *soap, _ns1__RequstRollbackResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RequstRollbackResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RequstRollbackResponse(struct soap *soap, const char *tag, int id, _ns1__RequstRollbackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RequstRollbackResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RequstRollbackResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RequstRollbackResponse(struct soap *soap, const char *tag, _ns1__RequstRollbackResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RequstRollbackResponse **)soap_malloc(soap, sizeof(_ns1__RequstRollbackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RequstRollbackResponse *)soap_instantiate__ns1__RequstRollbackResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RequstRollbackResponse ** p = (_ns1__RequstRollbackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RequstRollbackResponse, sizeof(_ns1__RequstRollbackResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RequstRollbackResponse(struct soap *soap, _ns1__RequstRollbackResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RequstRollbackResponse);
	if (soap_out_PointerTo_ns1__RequstRollbackResponse(soap, tag?tag:"ns1:RequstRollbackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RequstRollbackResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RequstRollbackResponse(struct soap *soap, _ns1__RequstRollbackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RequstRollbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RequstRollback(struct soap *soap, _ns1__RequstRollback *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RequstRollback))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RequstRollback(struct soap *soap, const char *tag, int id, _ns1__RequstRollback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RequstRollback);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RequstRollback ** SOAP_FMAC4 soap_in_PointerTo_ns1__RequstRollback(struct soap *soap, const char *tag, _ns1__RequstRollback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RequstRollback **)soap_malloc(soap, sizeof(_ns1__RequstRollback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RequstRollback *)soap_instantiate__ns1__RequstRollback(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RequstRollback ** p = (_ns1__RequstRollback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RequstRollback, sizeof(_ns1__RequstRollback), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RequstRollback(struct soap *soap, _ns1__RequstRollback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RequstRollback);
	if (soap_out_PointerTo_ns1__RequstRollback(soap, tag?tag:"ns1:RequstRollback", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RequstRollback ** SOAP_FMAC4 soap_get_PointerTo_ns1__RequstRollback(struct soap *soap, _ns1__RequstRollback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RequstRollback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayMoneyWithListResponse(struct soap *soap, _ns1__PayMoneyWithListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayMoneyWithListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayMoneyWithListResponse(struct soap *soap, const char *tag, int id, _ns1__PayMoneyWithListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayMoneyWithListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayMoneyWithListResponse(struct soap *soap, const char *tag, _ns1__PayMoneyWithListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayMoneyWithListResponse **)soap_malloc(soap, sizeof(_ns1__PayMoneyWithListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayMoneyWithListResponse *)soap_instantiate__ns1__PayMoneyWithListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayMoneyWithListResponse ** p = (_ns1__PayMoneyWithListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayMoneyWithListResponse, sizeof(_ns1__PayMoneyWithListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayMoneyWithListResponse(struct soap *soap, _ns1__PayMoneyWithListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayMoneyWithListResponse);
	if (soap_out_PointerTo_ns1__PayMoneyWithListResponse(soap, tag?tag:"ns1:PayMoneyWithListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayMoneyWithListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayMoneyWithListResponse(struct soap *soap, _ns1__PayMoneyWithListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayMoneyWithListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayMoneyWithList(struct soap *soap, _ns1__PayMoneyWithList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayMoneyWithList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayMoneyWithList(struct soap *soap, const char *tag, int id, _ns1__PayMoneyWithList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayMoneyWithList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayMoneyWithList ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayMoneyWithList(struct soap *soap, const char *tag, _ns1__PayMoneyWithList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayMoneyWithList **)soap_malloc(soap, sizeof(_ns1__PayMoneyWithList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayMoneyWithList *)soap_instantiate__ns1__PayMoneyWithList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayMoneyWithList ** p = (_ns1__PayMoneyWithList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayMoneyWithList, sizeof(_ns1__PayMoneyWithList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayMoneyWithList(struct soap *soap, _ns1__PayMoneyWithList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayMoneyWithList);
	if (soap_out_PointerTo_ns1__PayMoneyWithList(soap, tag?tag:"ns1:PayMoneyWithList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayMoneyWithList ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayMoneyWithList(struct soap *soap, _ns1__PayMoneyWithList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayMoneyWithList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayMoneyResponse(struct soap *soap, _ns1__PayMoneyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayMoneyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayMoneyResponse(struct soap *soap, const char *tag, int id, _ns1__PayMoneyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayMoneyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayMoneyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayMoneyResponse(struct soap *soap, const char *tag, _ns1__PayMoneyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayMoneyResponse **)soap_malloc(soap, sizeof(_ns1__PayMoneyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayMoneyResponse *)soap_instantiate__ns1__PayMoneyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayMoneyResponse ** p = (_ns1__PayMoneyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayMoneyResponse, sizeof(_ns1__PayMoneyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayMoneyResponse(struct soap *soap, _ns1__PayMoneyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayMoneyResponse);
	if (soap_out_PointerTo_ns1__PayMoneyResponse(soap, tag?tag:"ns1:PayMoneyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayMoneyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayMoneyResponse(struct soap *soap, _ns1__PayMoneyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayMoneyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PayMoney(struct soap *soap, _ns1__PayMoney *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PayMoney))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PayMoney(struct soap *soap, const char *tag, int id, _ns1__PayMoney *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PayMoney);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PayMoney ** SOAP_FMAC4 soap_in_PointerTo_ns1__PayMoney(struct soap *soap, const char *tag, _ns1__PayMoney **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PayMoney **)soap_malloc(soap, sizeof(_ns1__PayMoney *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PayMoney *)soap_instantiate__ns1__PayMoney(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PayMoney ** p = (_ns1__PayMoney **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PayMoney, sizeof(_ns1__PayMoney), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PayMoney(struct soap *soap, _ns1__PayMoney *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PayMoney);
	if (soap_out_PointerTo_ns1__PayMoney(soap, tag?tag:"ns1:PayMoney", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PayMoney ** SOAP_FMAC4 soap_get_PointerTo_ns1__PayMoney(struct soap *soap, _ns1__PayMoney **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PayMoney(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLocationResponse(struct soap *soap, _ns1__GetLocationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLocationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLocationResponse(struct soap *soap, const char *tag, int id, _ns1__GetLocationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLocationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLocationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLocationResponse(struct soap *soap, const char *tag, _ns1__GetLocationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLocationResponse **)soap_malloc(soap, sizeof(_ns1__GetLocationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLocationResponse *)soap_instantiate__ns1__GetLocationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLocationResponse ** p = (_ns1__GetLocationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLocationResponse, sizeof(_ns1__GetLocationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLocationResponse(struct soap *soap, _ns1__GetLocationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLocationResponse);
	if (soap_out_PointerTo_ns1__GetLocationResponse(soap, tag?tag:"ns1:GetLocationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLocationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLocationResponse(struct soap *soap, _ns1__GetLocationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLocation(struct soap *soap, _ns1__GetLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLocation(struct soap *soap, const char *tag, int id, _ns1__GetLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLocation ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLocation(struct soap *soap, const char *tag, _ns1__GetLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLocation **)soap_malloc(soap, sizeof(_ns1__GetLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLocation *)soap_instantiate__ns1__GetLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLocation ** p = (_ns1__GetLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLocation, sizeof(_ns1__GetLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLocation(struct soap *soap, _ns1__GetLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLocation);
	if (soap_out_PointerTo_ns1__GetLocation(soap, tag?tag:"ns1:GetLocation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLocation ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLocation(struct soap *soap, _ns1__GetLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetStockCardItemAndHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetStockCardItemAndHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetStockCardItemAndHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStockCardItemAndHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStockCardItemAndHistoryByConditionResponse *)soap_instantiate__ns1__GetStockCardItemAndHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStockCardItemAndHistoryByConditionResponse ** p = (_ns1__GetStockCardItemAndHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByConditionResponse, sizeof(_ns1__GetStockCardItemAndHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetStockCardItemAndHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag?tag:"ns1:GetStockCardItemAndHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetStockCardItemAndHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, _ns1__GetStockCardItemAndHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetStockCardItemAndHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetStockCardItemAndHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStockCardItemAndHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetStockCardItemAndHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStockCardItemAndHistoryByCondition *)soap_instantiate__ns1__GetStockCardItemAndHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStockCardItemAndHistoryByCondition ** p = (_ns1__GetStockCardItemAndHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStockCardItemAndHistoryByCondition, sizeof(_ns1__GetStockCardItemAndHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, _ns1__GetStockCardItemAndHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStockCardItemAndHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, tag?tag:"ns1:GetStockCardItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStockCardItemAndHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(struct soap *soap, _ns1__GetStockCardItemAndHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStockCardItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStockCardItemByConditionResponse(struct soap *soap, _ns1__GetStockCardItemByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStockCardItemByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetStockCardItemByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStockCardItemByConditionResponse(struct soap *soap, const char *tag, _ns1__GetStockCardItemByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStockCardItemByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetStockCardItemByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStockCardItemByConditionResponse *)soap_instantiate__ns1__GetStockCardItemByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStockCardItemByConditionResponse ** p = (_ns1__GetStockCardItemByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStockCardItemByConditionResponse, sizeof(_ns1__GetStockCardItemByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStockCardItemByConditionResponse(struct soap *soap, _ns1__GetStockCardItemByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStockCardItemByConditionResponse);
	if (soap_out_PointerTo_ns1__GetStockCardItemByConditionResponse(soap, tag?tag:"ns1:GetStockCardItemByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStockCardItemByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStockCardItemByConditionResponse(struct soap *soap, _ns1__GetStockCardItemByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStockCardItemByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStockCardItemByCondition(struct soap *soap, _ns1__GetStockCardItemByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStockCardItemByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStockCardItemByCondition(struct soap *soap, const char *tag, int id, _ns1__GetStockCardItemByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStockCardItemByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStockCardItemByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStockCardItemByCondition(struct soap *soap, const char *tag, _ns1__GetStockCardItemByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStockCardItemByCondition **)soap_malloc(soap, sizeof(_ns1__GetStockCardItemByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStockCardItemByCondition *)soap_instantiate__ns1__GetStockCardItemByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStockCardItemByCondition ** p = (_ns1__GetStockCardItemByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStockCardItemByCondition, sizeof(_ns1__GetStockCardItemByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStockCardItemByCondition(struct soap *soap, _ns1__GetStockCardItemByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStockCardItemByCondition);
	if (soap_out_PointerTo_ns1__GetStockCardItemByCondition(soap, tag?tag:"ns1:GetStockCardItemByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStockCardItemByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStockCardItemByCondition(struct soap *soap, _ns1__GetStockCardItemByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStockCardItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOtherCardListResponse(struct soap *soap, _ns1__GetOtherCardListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOtherCardListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOtherCardListResponse(struct soap *soap, const char *tag, int id, _ns1__GetOtherCardListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOtherCardListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOtherCardListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOtherCardListResponse(struct soap *soap, const char *tag, _ns1__GetOtherCardListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOtherCardListResponse **)soap_malloc(soap, sizeof(_ns1__GetOtherCardListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOtherCardListResponse *)soap_instantiate__ns1__GetOtherCardListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOtherCardListResponse ** p = (_ns1__GetOtherCardListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOtherCardListResponse, sizeof(_ns1__GetOtherCardListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOtherCardListResponse(struct soap *soap, _ns1__GetOtherCardListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetOtherCardListResponse);
	if (soap_out_PointerTo_ns1__GetOtherCardListResponse(soap, tag?tag:"ns1:GetOtherCardListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOtherCardListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOtherCardListResponse(struct soap *soap, _ns1__GetOtherCardListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOtherCardListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOtherCardList(struct soap *soap, _ns1__GetOtherCardList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOtherCardList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOtherCardList(struct soap *soap, const char *tag, int id, _ns1__GetOtherCardList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOtherCardList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOtherCardList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOtherCardList(struct soap *soap, const char *tag, _ns1__GetOtherCardList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOtherCardList **)soap_malloc(soap, sizeof(_ns1__GetOtherCardList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOtherCardList *)soap_instantiate__ns1__GetOtherCardList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOtherCardList ** p = (_ns1__GetOtherCardList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOtherCardList, sizeof(_ns1__GetOtherCardList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOtherCardList(struct soap *soap, _ns1__GetOtherCardList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetOtherCardList);
	if (soap_out_PointerTo_ns1__GetOtherCardList(soap, tag?tag:"ns1:GetOtherCardList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOtherCardList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOtherCardList(struct soap *soap, _ns1__GetOtherCardList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOtherCardList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GettSellOtherCardRecordHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GettSellOtherCardRecordHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GettSellOtherCardRecordHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GettSellOtherCardRecordHistoryByConditionResponse *)soap_instantiate__ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GettSellOtherCardRecordHistoryByConditionResponse ** p = (_ns1__GettSellOtherCardRecordHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByConditionResponse, sizeof(_ns1__GettSellOtherCardRecordHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag?tag:"ns1:GettSellOtherCardRecordHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GettSellOtherCardRecordHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GettSellOtherCardRecordHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GettSellOtherCardRecordHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GettSellOtherCardRecordHistoryByCondition *)soap_instantiate__ns1__GettSellOtherCardRecordHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GettSellOtherCardRecordHistoryByCondition ** p = (_ns1__GettSellOtherCardRecordHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GettSellOtherCardRecordHistoryByCondition, sizeof(_ns1__GettSellOtherCardRecordHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition);
	if (soap_out_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag?tag:"ns1:GettSellOtherCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GettSellOtherCardRecordHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(struct soap *soap, _ns1__GettSellOtherCardRecordHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GettSellOtherCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellOtherCardRecordByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetSellOtherCardRecordByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellOtherCardRecordByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellOtherCardRecordByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetSellOtherCardRecordByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellOtherCardRecordByConditionResponse *)soap_instantiate__ns1__GetSellOtherCardRecordByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellOtherCardRecordByConditionResponse ** p = (_ns1__GetSellOtherCardRecordByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellOtherCardRecordByConditionResponse, sizeof(_ns1__GetSellOtherCardRecordByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellOtherCardRecordByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse);
	if (soap_out_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(soap, tag?tag:"ns1:GetSellOtherCardRecordByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellOtherCardRecordByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellOtherCardRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellOtherCardRecordByCondition(struct soap *soap, _ns1__GetSellOtherCardRecordByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, int id, _ns1__GetSellOtherCardRecordByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellOtherCardRecordByCondition(struct soap *soap, const char *tag, _ns1__GetSellOtherCardRecordByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellOtherCardRecordByCondition **)soap_malloc(soap, sizeof(_ns1__GetSellOtherCardRecordByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellOtherCardRecordByCondition *)soap_instantiate__ns1__GetSellOtherCardRecordByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellOtherCardRecordByCondition ** p = (_ns1__GetSellOtherCardRecordByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellOtherCardRecordByCondition, sizeof(_ns1__GetSellOtherCardRecordByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellOtherCardRecordByCondition(struct soap *soap, _ns1__GetSellOtherCardRecordByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellOtherCardRecordByCondition);
	if (soap_out_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, tag?tag:"ns1:GetSellOtherCardRecordByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellOtherCardRecordByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellOtherCardRecordByCondition(struct soap *soap, _ns1__GetSellOtherCardRecordByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellOtherCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettBusinessRecordHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GettBusinessRecordHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GettBusinessRecordHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GettBusinessRecordHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GettBusinessRecordHistoryByConditionResponse *)soap_instantiate__ns1__GettBusinessRecordHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GettBusinessRecordHistoryByConditionResponse ** p = (_ns1__GettBusinessRecordHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByConditionResponse, sizeof(_ns1__GettBusinessRecordHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettBusinessRecordHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag?tag:"ns1:GettBusinessRecordHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(struct soap *soap, _ns1__GettBusinessRecordHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GettBusinessRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, _ns1__GettBusinessRecordHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GettBusinessRecordHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GettBusinessRecordHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GettBusinessRecordHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GettBusinessRecordHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GettBusinessRecordHistoryByCondition *)soap_instantiate__ns1__GettBusinessRecordHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GettBusinessRecordHistoryByCondition ** p = (_ns1__GettBusinessRecordHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GettBusinessRecordHistoryByCondition, sizeof(_ns1__GettBusinessRecordHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, _ns1__GettBusinessRecordHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GettBusinessRecordHistoryByCondition);
	if (soap_out_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, tag?tag:"ns1:GettBusinessRecordHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GettBusinessRecordHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GettBusinessRecordHistoryByCondition(struct soap *soap, _ns1__GettBusinessRecordHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GettBusinessRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBusinessRecordByConditionResponse(struct soap *soap, _ns1__GetBusinessRecordByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBusinessRecordByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetBusinessRecordByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBusinessRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetBusinessRecordByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBusinessRecordByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetBusinessRecordByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBusinessRecordByConditionResponse *)soap_instantiate__ns1__GetBusinessRecordByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBusinessRecordByConditionResponse ** p = (_ns1__GetBusinessRecordByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBusinessRecordByConditionResponse, sizeof(_ns1__GetBusinessRecordByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBusinessRecordByConditionResponse(struct soap *soap, _ns1__GetBusinessRecordByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByConditionResponse);
	if (soap_out_PointerTo_ns1__GetBusinessRecordByConditionResponse(soap, tag?tag:"ns1:GetBusinessRecordByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBusinessRecordByConditionResponse(struct soap *soap, _ns1__GetBusinessRecordByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBusinessRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBusinessRecordByCondition(struct soap *soap, _ns1__GetBusinessRecordByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBusinessRecordByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBusinessRecordByCondition(struct soap *soap, const char *tag, int id, _ns1__GetBusinessRecordByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBusinessRecordByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBusinessRecordByCondition(struct soap *soap, const char *tag, _ns1__GetBusinessRecordByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBusinessRecordByCondition **)soap_malloc(soap, sizeof(_ns1__GetBusinessRecordByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBusinessRecordByCondition *)soap_instantiate__ns1__GetBusinessRecordByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBusinessRecordByCondition ** p = (_ns1__GetBusinessRecordByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBusinessRecordByCondition, sizeof(_ns1__GetBusinessRecordByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBusinessRecordByCondition(struct soap *soap, _ns1__GetBusinessRecordByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBusinessRecordByCondition);
	if (soap_out_PointerTo_ns1__GetBusinessRecordByCondition(soap, tag?tag:"ns1:GetBusinessRecordByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBusinessRecordByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBusinessRecordByCondition(struct soap *soap, _ns1__GetBusinessRecordByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBusinessRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetSellCardRecordHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellCardRecordHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellCardRecordHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellCardRecordHistoryByConditionResponse *)soap_instantiate__ns1__GetSellCardRecordHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellCardRecordHistoryByConditionResponse ** p = (_ns1__GetSellCardRecordHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByConditionResponse, sizeof(_ns1__GetSellCardRecordHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag?tag:"ns1:GetSellCardRecordHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellCardRecordHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, _ns1__GetSellCardRecordHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetSellCardRecordHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetSellCardRecordHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellCardRecordHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetSellCardRecordHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellCardRecordHistoryByCondition *)soap_instantiate__ns1__GetSellCardRecordHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellCardRecordHistoryByCondition ** p = (_ns1__GetSellCardRecordHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellCardRecordHistoryByCondition, sizeof(_ns1__GetSellCardRecordHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, _ns1__GetSellCardRecordHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellCardRecordHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, tag?tag:"ns1:GetSellCardRecordHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellCardRecordHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellCardRecordHistoryByCondition(struct soap *soap, _ns1__GetSellCardRecordHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellCardRecordHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellCardRecordByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetSellCardRecordByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellCardRecordByConditionResponse(struct soap *soap, const char *tag, _ns1__GetSellCardRecordByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellCardRecordByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetSellCardRecordByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellCardRecordByConditionResponse *)soap_instantiate__ns1__GetSellCardRecordByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellCardRecordByConditionResponse ** p = (_ns1__GetSellCardRecordByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellCardRecordByConditionResponse, sizeof(_ns1__GetSellCardRecordByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByConditionResponse);
	if (soap_out_PointerTo_ns1__GetSellCardRecordByConditionResponse(soap, tag?tag:"ns1:GetSellCardRecordByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellCardRecordByConditionResponse(struct soap *soap, _ns1__GetSellCardRecordByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellCardRecordByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSellCardRecordByCondition(struct soap *soap, _ns1__GetSellCardRecordByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSellCardRecordByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSellCardRecordByCondition(struct soap *soap, const char *tag, int id, _ns1__GetSellCardRecordByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSellCardRecordByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSellCardRecordByCondition(struct soap *soap, const char *tag, _ns1__GetSellCardRecordByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSellCardRecordByCondition **)soap_malloc(soap, sizeof(_ns1__GetSellCardRecordByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSellCardRecordByCondition *)soap_instantiate__ns1__GetSellCardRecordByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSellCardRecordByCondition ** p = (_ns1__GetSellCardRecordByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSellCardRecordByCondition, sizeof(_ns1__GetSellCardRecordByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSellCardRecordByCondition(struct soap *soap, _ns1__GetSellCardRecordByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSellCardRecordByCondition);
	if (soap_out_PointerTo_ns1__GetSellCardRecordByCondition(soap, tag?tag:"ns1:GetSellCardRecordByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSellCardRecordByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSellCardRecordByCondition(struct soap *soap, _ns1__GetSellCardRecordByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSellCardRecordByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCardServiceResponse(struct soap *soap, _ns1__GetCardServiceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCardServiceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCardServiceResponse(struct soap *soap, const char *tag, int id, _ns1__GetCardServiceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCardServiceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCardServiceResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCardServiceResponse(struct soap *soap, const char *tag, _ns1__GetCardServiceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCardServiceResponse **)soap_malloc(soap, sizeof(_ns1__GetCardServiceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCardServiceResponse *)soap_instantiate__ns1__GetCardServiceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCardServiceResponse ** p = (_ns1__GetCardServiceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCardServiceResponse, sizeof(_ns1__GetCardServiceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCardServiceResponse(struct soap *soap, _ns1__GetCardServiceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCardServiceResponse);
	if (soap_out_PointerTo_ns1__GetCardServiceResponse(soap, tag?tag:"ns1:GetCardServiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCardServiceResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCardServiceResponse(struct soap *soap, _ns1__GetCardServiceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCardServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCardService(struct soap *soap, _ns1__GetCardService *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCardService))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCardService(struct soap *soap, const char *tag, int id, _ns1__GetCardService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCardService);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCardService ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCardService(struct soap *soap, const char *tag, _ns1__GetCardService **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCardService **)soap_malloc(soap, sizeof(_ns1__GetCardService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCardService *)soap_instantiate__ns1__GetCardService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCardService ** p = (_ns1__GetCardService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCardService, sizeof(_ns1__GetCardService), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCardService(struct soap *soap, _ns1__GetCardService *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCardService);
	if (soap_out_PointerTo_ns1__GetCardService(soap, tag?tag:"ns1:GetCardService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCardService ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCardService(struct soap *soap, _ns1__GetCardService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoItemAndHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemAndHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoItemAndHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoItemAndHistoryByConditionResponse *)soap_instantiate__ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoItemAndHistoryByConditionResponse ** p = (_ns1__GetPhoneNoItemAndHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByConditionResponse, sizeof(_ns1__GetPhoneNoItemAndHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag?tag:"ns1:GetPhoneNoItemAndHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoItemAndHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemAndHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoItemAndHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoItemAndHistoryByCondition *)soap_instantiate__ns1__GetPhoneNoItemAndHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoItemAndHistoryByCondition ** p = (_ns1__GetPhoneNoItemAndHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoItemAndHistoryByCondition, sizeof(_ns1__GetPhoneNoItemAndHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag?tag:"ns1:GetPhoneNoItemAndHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemAndHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(struct soap *soap, _ns1__GetPhoneNoItemAndHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoItemAndHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoItemByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoItemByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoItemByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoItemByConditionResponse *)soap_instantiate__ns1__GetPhoneNoItemByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoItemByConditionResponse ** p = (_ns1__GetPhoneNoItemByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoItemByConditionResponse, sizeof(_ns1__GetPhoneNoItemByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPhoneNoItemByConditionResponse(soap, tag?tag:"ns1:GetPhoneNoItemByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoItemByConditionResponse(struct soap *soap, _ns1__GetPhoneNoItemByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoItemByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoItemByCondition(struct soap *soap, _ns1__GetPhoneNoItemByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoItemByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoItemByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoItemByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoItemByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoItemByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoItemByCondition **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoItemByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoItemByCondition *)soap_instantiate__ns1__GetPhoneNoItemByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoItemByCondition ** p = (_ns1__GetPhoneNoItemByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoItemByCondition, sizeof(_ns1__GetPhoneNoItemByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoItemByCondition(struct soap *soap, _ns1__GetPhoneNoItemByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoItemByCondition);
	if (soap_out_PointerTo_ns1__GetPhoneNoItemByCondition(soap, tag?tag:"ns1:GetPhoneNoItemByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoItemByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoItemByCondition(struct soap *soap, _ns1__GetPhoneNoItemByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoItemByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardHistoryByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayMiniCardHistoryByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayMiniCardHistoryByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayMiniCardHistoryByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayMiniCardHistoryByConditionResponse *)soap_instantiate__ns1__GetPayMiniCardHistoryByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayMiniCardHistoryByConditionResponse ** p = (_ns1__GetPayMiniCardHistoryByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByConditionResponse, sizeof(_ns1__GetPayMiniCardHistoryByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardHistoryByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag?tag:"ns1:GetPayMiniCardHistoryByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardHistoryByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayMiniCardHistoryByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, _ns1__GetPayMiniCardHistoryByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayMiniCardHistoryByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, const char *tag, _ns1__GetPayMiniCardHistoryByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayMiniCardHistoryByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayMiniCardHistoryByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayMiniCardHistoryByCondition *)soap_instantiate__ns1__GetPayMiniCardHistoryByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayMiniCardHistoryByCondition ** p = (_ns1__GetPayMiniCardHistoryByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayMiniCardHistoryByCondition, sizeof(_ns1__GetPayMiniCardHistoryByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, _ns1__GetPayMiniCardHistoryByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayMiniCardHistoryByCondition);
	if (soap_out_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, tag?tag:"ns1:GetPayMiniCardHistoryByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayMiniCardHistoryByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayMiniCardHistoryByCondition(struct soap *soap, _ns1__GetPayMiniCardHistoryByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayMiniCardHistoryByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayMiniCardByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayMiniCardByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPayMiniCardByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayMiniCardByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPayMiniCardByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayMiniCardByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPayMiniCardByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayMiniCardByConditionResponse *)soap_instantiate__ns1__GetPayMiniCardByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayMiniCardByConditionResponse ** p = (_ns1__GetPayMiniCardByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayMiniCardByConditionResponse, sizeof(_ns1__GetPayMiniCardByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayMiniCardByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPayMiniCardByConditionResponse(soap, tag?tag:"ns1:GetPayMiniCardByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayMiniCardByConditionResponse(struct soap *soap, _ns1__GetPayMiniCardByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayMiniCardByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPayMiniCardByCondition(struct soap *soap, _ns1__GetPayMiniCardByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPayMiniCardByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPayMiniCardByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPayMiniCardByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPayMiniCardByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPayMiniCardByCondition(struct soap *soap, const char *tag, _ns1__GetPayMiniCardByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPayMiniCardByCondition **)soap_malloc(soap, sizeof(_ns1__GetPayMiniCardByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPayMiniCardByCondition *)soap_instantiate__ns1__GetPayMiniCardByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPayMiniCardByCondition ** p = (_ns1__GetPayMiniCardByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPayMiniCardByCondition, sizeof(_ns1__GetPayMiniCardByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPayMiniCardByCondition(struct soap *soap, _ns1__GetPayMiniCardByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPayMiniCardByCondition);
	if (soap_out_PointerTo_ns1__GetPayMiniCardByCondition(soap, tag?tag:"ns1:GetPayMiniCardByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPayMiniCardByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPayMiniCardByCondition(struct soap *soap, _ns1__GetPayMiniCardByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPayMiniCardByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMiniCardRecordResponse(struct soap *soap, _ns1__GetMiniCardRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMiniCardRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMiniCardRecordResponse(struct soap *soap, const char *tag, int id, _ns1__GetMiniCardRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMiniCardRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMiniCardRecordResponse(struct soap *soap, const char *tag, _ns1__GetMiniCardRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMiniCardRecordResponse **)soap_malloc(soap, sizeof(_ns1__GetMiniCardRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMiniCardRecordResponse *)soap_instantiate__ns1__GetMiniCardRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetMiniCardRecordResponse ** p = (_ns1__GetMiniCardRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMiniCardRecordResponse, sizeof(_ns1__GetMiniCardRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMiniCardRecordResponse(struct soap *soap, _ns1__GetMiniCardRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetMiniCardRecordResponse);
	if (soap_out_PointerTo_ns1__GetMiniCardRecordResponse(soap, tag?tag:"ns1:GetMiniCardRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMiniCardRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMiniCardRecordResponse(struct soap *soap, _ns1__GetMiniCardRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMiniCardRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMiniCardRecord(struct soap *soap, _ns1__GetMiniCardRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMiniCardRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMiniCardRecord(struct soap *soap, const char *tag, int id, _ns1__GetMiniCardRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMiniCardRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetMiniCardRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMiniCardRecord(struct soap *soap, const char *tag, _ns1__GetMiniCardRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMiniCardRecord **)soap_malloc(soap, sizeof(_ns1__GetMiniCardRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMiniCardRecord *)soap_instantiate__ns1__GetMiniCardRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetMiniCardRecord ** p = (_ns1__GetMiniCardRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMiniCardRecord, sizeof(_ns1__GetMiniCardRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMiniCardRecord(struct soap *soap, _ns1__GetMiniCardRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetMiniCardRecord);
	if (soap_out_PointerTo_ns1__GetMiniCardRecord(soap, tag?tag:"ns1:GetMiniCardRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMiniCardRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMiniCardRecord(struct soap *soap, _ns1__GetMiniCardRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMiniCardRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SellOhterCardResponse(struct soap *soap, _ns1__SellOhterCardResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SellOhterCardResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SellOhterCardResponse(struct soap *soap, const char *tag, int id, _ns1__SellOhterCardResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SellOhterCardResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SellOhterCardResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SellOhterCardResponse(struct soap *soap, const char *tag, _ns1__SellOhterCardResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SellOhterCardResponse **)soap_malloc(soap, sizeof(_ns1__SellOhterCardResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SellOhterCardResponse *)soap_instantiate__ns1__SellOhterCardResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SellOhterCardResponse ** p = (_ns1__SellOhterCardResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SellOhterCardResponse, sizeof(_ns1__SellOhterCardResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SellOhterCardResponse(struct soap *soap, _ns1__SellOhterCardResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SellOhterCardResponse);
	if (soap_out_PointerTo_ns1__SellOhterCardResponse(soap, tag?tag:"ns1:SellOhterCardResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SellOhterCardResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SellOhterCardResponse(struct soap *soap, _ns1__SellOhterCardResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SellOhterCardResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SellOhterCard(struct soap *soap, _ns1__SellOhterCard *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SellOhterCard))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SellOhterCard(struct soap *soap, const char *tag, int id, _ns1__SellOhterCard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SellOhterCard);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SellOhterCard ** SOAP_FMAC4 soap_in_PointerTo_ns1__SellOhterCard(struct soap *soap, const char *tag, _ns1__SellOhterCard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SellOhterCard **)soap_malloc(soap, sizeof(_ns1__SellOhterCard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SellOhterCard *)soap_instantiate__ns1__SellOhterCard(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SellOhterCard ** p = (_ns1__SellOhterCard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SellOhterCard, sizeof(_ns1__SellOhterCard), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SellOhterCard(struct soap *soap, _ns1__SellOhterCard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SellOhterCard);
	if (soap_out_PointerTo_ns1__SellOhterCard(soap, tag?tag:"ns1:SellOhterCard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SellOhterCard ** SOAP_FMAC4 soap_get_PointerTo_ns1__SellOhterCard(struct soap *soap, _ns1__SellOhterCard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SellOhterCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SellNoResponse(struct soap *soap, _ns1__SellNoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SellNoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SellNoResponse(struct soap *soap, const char *tag, int id, _ns1__SellNoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SellNoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SellNoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SellNoResponse(struct soap *soap, const char *tag, _ns1__SellNoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SellNoResponse **)soap_malloc(soap, sizeof(_ns1__SellNoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SellNoResponse *)soap_instantiate__ns1__SellNoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SellNoResponse ** p = (_ns1__SellNoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SellNoResponse, sizeof(_ns1__SellNoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SellNoResponse(struct soap *soap, _ns1__SellNoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SellNoResponse);
	if (soap_out_PointerTo_ns1__SellNoResponse(soap, tag?tag:"ns1:SellNoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SellNoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SellNoResponse(struct soap *soap, _ns1__SellNoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SellNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SellNo(struct soap *soap, _ns1__SellNo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SellNo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SellNo(struct soap *soap, const char *tag, int id, _ns1__SellNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SellNo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SellNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__SellNo(struct soap *soap, const char *tag, _ns1__SellNo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SellNo **)soap_malloc(soap, sizeof(_ns1__SellNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SellNo *)soap_instantiate__ns1__SellNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SellNo ** p = (_ns1__SellNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SellNo, sizeof(_ns1__SellNo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SellNo(struct soap *soap, _ns1__SellNo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SellNo);
	if (soap_out_PointerTo_ns1__SellNo(soap, tag?tag:"ns1:SellNo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SellNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__SellNo(struct soap *soap, _ns1__SellNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SellNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubmitBusinessResponse(struct soap *soap, _ns1__SubmitBusinessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubmitBusinessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubmitBusinessResponse(struct soap *soap, const char *tag, int id, _ns1__SubmitBusinessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubmitBusinessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubmitBusinessResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubmitBusinessResponse(struct soap *soap, const char *tag, _ns1__SubmitBusinessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubmitBusinessResponse **)soap_malloc(soap, sizeof(_ns1__SubmitBusinessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubmitBusinessResponse *)soap_instantiate__ns1__SubmitBusinessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SubmitBusinessResponse ** p = (_ns1__SubmitBusinessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubmitBusinessResponse, sizeof(_ns1__SubmitBusinessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubmitBusinessResponse(struct soap *soap, _ns1__SubmitBusinessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubmitBusinessResponse);
	if (soap_out_PointerTo_ns1__SubmitBusinessResponse(soap, tag?tag:"ns1:SubmitBusinessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SubmitBusinessResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubmitBusinessResponse(struct soap *soap, _ns1__SubmitBusinessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubmitBusinessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubmitBusiness(struct soap *soap, _ns1__SubmitBusiness *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubmitBusiness))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubmitBusiness(struct soap *soap, const char *tag, int id, _ns1__SubmitBusiness *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubmitBusiness);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubmitBusiness ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubmitBusiness(struct soap *soap, const char *tag, _ns1__SubmitBusiness **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubmitBusiness **)soap_malloc(soap, sizeof(_ns1__SubmitBusiness *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubmitBusiness *)soap_instantiate__ns1__SubmitBusiness(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SubmitBusiness ** p = (_ns1__SubmitBusiness **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubmitBusiness, sizeof(_ns1__SubmitBusiness), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubmitBusiness(struct soap *soap, _ns1__SubmitBusiness *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubmitBusiness);
	if (soap_out_PointerTo_ns1__SubmitBusiness(soap, tag?tag:"ns1:SubmitBusiness", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SubmitBusiness ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubmitBusiness(struct soap *soap, _ns1__SubmitBusiness **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubmitBusiness(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UnlockNoResponse(struct soap *soap, _ns1__UnlockNoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UnlockNoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UnlockNoResponse(struct soap *soap, const char *tag, int id, _ns1__UnlockNoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UnlockNoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UnlockNoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UnlockNoResponse(struct soap *soap, const char *tag, _ns1__UnlockNoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UnlockNoResponse **)soap_malloc(soap, sizeof(_ns1__UnlockNoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UnlockNoResponse *)soap_instantiate__ns1__UnlockNoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UnlockNoResponse ** p = (_ns1__UnlockNoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UnlockNoResponse, sizeof(_ns1__UnlockNoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UnlockNoResponse(struct soap *soap, _ns1__UnlockNoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UnlockNoResponse);
	if (soap_out_PointerTo_ns1__UnlockNoResponse(soap, tag?tag:"ns1:UnlockNoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UnlockNoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UnlockNoResponse(struct soap *soap, _ns1__UnlockNoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UnlockNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UnlockNo(struct soap *soap, _ns1__UnlockNo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UnlockNo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UnlockNo(struct soap *soap, const char *tag, int id, _ns1__UnlockNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UnlockNo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UnlockNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UnlockNo(struct soap *soap, const char *tag, _ns1__UnlockNo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UnlockNo **)soap_malloc(soap, sizeof(_ns1__UnlockNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UnlockNo *)soap_instantiate__ns1__UnlockNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UnlockNo ** p = (_ns1__UnlockNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UnlockNo, sizeof(_ns1__UnlockNo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UnlockNo(struct soap *soap, _ns1__UnlockNo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UnlockNo);
	if (soap_out_PointerTo_ns1__UnlockNo(soap, tag?tag:"ns1:UnlockNo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UnlockNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UnlockNo(struct soap *soap, _ns1__UnlockNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UnlockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LockNoResponse(struct soap *soap, _ns1__LockNoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LockNoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LockNoResponse(struct soap *soap, const char *tag, int id, _ns1__LockNoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LockNoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LockNoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LockNoResponse(struct soap *soap, const char *tag, _ns1__LockNoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LockNoResponse **)soap_malloc(soap, sizeof(_ns1__LockNoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LockNoResponse *)soap_instantiate__ns1__LockNoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LockNoResponse ** p = (_ns1__LockNoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LockNoResponse, sizeof(_ns1__LockNoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LockNoResponse(struct soap *soap, _ns1__LockNoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LockNoResponse);
	if (soap_out_PointerTo_ns1__LockNoResponse(soap, tag?tag:"ns1:LockNoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LockNoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LockNoResponse(struct soap *soap, _ns1__LockNoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LockNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LockNo(struct soap *soap, _ns1__LockNo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LockNo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LockNo(struct soap *soap, const char *tag, int id, _ns1__LockNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LockNo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LockNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__LockNo(struct soap *soap, const char *tag, _ns1__LockNo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LockNo **)soap_malloc(soap, sizeof(_ns1__LockNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LockNo *)soap_instantiate__ns1__LockNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LockNo ** p = (_ns1__LockNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LockNo, sizeof(_ns1__LockNo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LockNo(struct soap *soap, _ns1__LockNo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LockNo);
	if (soap_out_PointerTo_ns1__LockNo(soap, tag?tag:"ns1:LockNo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LockNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__LockNo(struct soap *soap, _ns1__LockNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LockNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMyNoSectionResponse(struct soap *soap, _ns1__GetMyNoSectionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMyNoSectionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMyNoSectionResponse(struct soap *soap, const char *tag, int id, _ns1__GetMyNoSectionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMyNoSectionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetMyNoSectionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMyNoSectionResponse(struct soap *soap, const char *tag, _ns1__GetMyNoSectionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMyNoSectionResponse **)soap_malloc(soap, sizeof(_ns1__GetMyNoSectionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMyNoSectionResponse *)soap_instantiate__ns1__GetMyNoSectionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetMyNoSectionResponse ** p = (_ns1__GetMyNoSectionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMyNoSectionResponse, sizeof(_ns1__GetMyNoSectionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMyNoSectionResponse(struct soap *soap, _ns1__GetMyNoSectionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetMyNoSectionResponse);
	if (soap_out_PointerTo_ns1__GetMyNoSectionResponse(soap, tag?tag:"ns1:GetMyNoSectionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMyNoSectionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMyNoSectionResponse(struct soap *soap, _ns1__GetMyNoSectionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMyNoSectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMyNoSection(struct soap *soap, _ns1__GetMyNoSection *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMyNoSection))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMyNoSection(struct soap *soap, const char *tag, int id, _ns1__GetMyNoSection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMyNoSection);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetMyNoSection ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMyNoSection(struct soap *soap, const char *tag, _ns1__GetMyNoSection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMyNoSection **)soap_malloc(soap, sizeof(_ns1__GetMyNoSection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMyNoSection *)soap_instantiate__ns1__GetMyNoSection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetMyNoSection ** p = (_ns1__GetMyNoSection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMyNoSection, sizeof(_ns1__GetMyNoSection), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMyNoSection(struct soap *soap, _ns1__GetMyNoSection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetMyNoSection);
	if (soap_out_PointerTo_ns1__GetMyNoSection(soap, tag?tag:"ns1:GetMyNoSection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMyNoSection ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMyNoSection(struct soap *soap, _ns1__GetMyNoSection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMyNoSection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoByConditionResponse(struct soap *soap, _ns1__GetPhoneNoByConditionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoByConditionResponse(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoByConditionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByConditionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoByConditionResponse(struct soap *soap, const char *tag, _ns1__GetPhoneNoByConditionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoByConditionResponse **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoByConditionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoByConditionResponse *)soap_instantiate__ns1__GetPhoneNoByConditionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoByConditionResponse ** p = (_ns1__GetPhoneNoByConditionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoByConditionResponse, sizeof(_ns1__GetPhoneNoByConditionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoByConditionResponse(struct soap *soap, _ns1__GetPhoneNoByConditionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoByConditionResponse);
	if (soap_out_PointerTo_ns1__GetPhoneNoByConditionResponse(soap, tag?tag:"ns1:GetPhoneNoByConditionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoByConditionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoByConditionResponse(struct soap *soap, _ns1__GetPhoneNoByConditionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoByConditionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPhoneNoByCondition(struct soap *soap, _ns1__GetPhoneNoByCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPhoneNoByCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPhoneNoByCondition(struct soap *soap, const char *tag, int id, _ns1__GetPhoneNoByCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPhoneNoByCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPhoneNoByCondition ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPhoneNoByCondition(struct soap *soap, const char *tag, _ns1__GetPhoneNoByCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPhoneNoByCondition **)soap_malloc(soap, sizeof(_ns1__GetPhoneNoByCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPhoneNoByCondition *)soap_instantiate__ns1__GetPhoneNoByCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPhoneNoByCondition ** p = (_ns1__GetPhoneNoByCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPhoneNoByCondition, sizeof(_ns1__GetPhoneNoByCondition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPhoneNoByCondition(struct soap *soap, _ns1__GetPhoneNoByCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPhoneNoByCondition);
	if (soap_out_PointerTo_ns1__GetPhoneNoByCondition(soap, tag?tag:"ns1:GetPhoneNoByCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPhoneNoByCondition ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPhoneNoByCondition(struct soap *soap, _ns1__GetPhoneNoByCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPhoneNoByCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BuyMiniCardResponse(struct soap *soap, _ns1__BuyMiniCardResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BuyMiniCardResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BuyMiniCardResponse(struct soap *soap, const char *tag, int id, _ns1__BuyMiniCardResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BuyMiniCardResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BuyMiniCardResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__BuyMiniCardResponse(struct soap *soap, const char *tag, _ns1__BuyMiniCardResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BuyMiniCardResponse **)soap_malloc(soap, sizeof(_ns1__BuyMiniCardResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BuyMiniCardResponse *)soap_instantiate__ns1__BuyMiniCardResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__BuyMiniCardResponse ** p = (_ns1__BuyMiniCardResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BuyMiniCardResponse, sizeof(_ns1__BuyMiniCardResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BuyMiniCardResponse(struct soap *soap, _ns1__BuyMiniCardResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__BuyMiniCardResponse);
	if (soap_out_PointerTo_ns1__BuyMiniCardResponse(soap, tag?tag:"ns1:BuyMiniCardResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BuyMiniCardResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__BuyMiniCardResponse(struct soap *soap, _ns1__BuyMiniCardResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BuyMiniCardResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BuyMiniCard(struct soap *soap, _ns1__BuyMiniCard *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BuyMiniCard))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BuyMiniCard(struct soap *soap, const char *tag, int id, _ns1__BuyMiniCard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BuyMiniCard);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BuyMiniCard ** SOAP_FMAC4 soap_in_PointerTo_ns1__BuyMiniCard(struct soap *soap, const char *tag, _ns1__BuyMiniCard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BuyMiniCard **)soap_malloc(soap, sizeof(_ns1__BuyMiniCard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BuyMiniCard *)soap_instantiate__ns1__BuyMiniCard(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__BuyMiniCard ** p = (_ns1__BuyMiniCard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BuyMiniCard, sizeof(_ns1__BuyMiniCard), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BuyMiniCard(struct soap *soap, _ns1__BuyMiniCard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__BuyMiniCard);
	if (soap_out_PointerTo_ns1__BuyMiniCard(soap, tag?tag:"ns1:BuyMiniCard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BuyMiniCard ** SOAP_FMAC4 soap_get_PointerTo_ns1__BuyMiniCard(struct soap *soap, _ns1__BuyMiniCard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BuyMiniCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPhoneNOInfoResponse(struct soap *soap, _ns1__queryPhoneNOInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPhoneNOInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPhoneNOInfoResponse(struct soap *soap, const char *tag, int id, _ns1__queryPhoneNOInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPhoneNOInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPhoneNOInfoResponse(struct soap *soap, const char *tag, _ns1__queryPhoneNOInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__queryPhoneNOInfoResponse **)soap_malloc(soap, sizeof(_ns1__queryPhoneNOInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__queryPhoneNOInfoResponse *)soap_instantiate__ns1__queryPhoneNOInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__queryPhoneNOInfoResponse ** p = (_ns1__queryPhoneNOInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPhoneNOInfoResponse, sizeof(_ns1__queryPhoneNOInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPhoneNOInfoResponse(struct soap *soap, _ns1__queryPhoneNOInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfoResponse);
	if (soap_out_PointerTo_ns1__queryPhoneNOInfoResponse(soap, tag?tag:"ns1:queryPhoneNOInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPhoneNOInfoResponse(struct soap *soap, _ns1__queryPhoneNOInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPhoneNOInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPhoneNOInfo(struct soap *soap, _ns1__queryPhoneNOInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPhoneNOInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPhoneNOInfo(struct soap *soap, const char *tag, int id, _ns1__queryPhoneNOInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPhoneNOInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPhoneNOInfo(struct soap *soap, const char *tag, _ns1__queryPhoneNOInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__queryPhoneNOInfo **)soap_malloc(soap, sizeof(_ns1__queryPhoneNOInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__queryPhoneNOInfo *)soap_instantiate__ns1__queryPhoneNOInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__queryPhoneNOInfo ** p = (_ns1__queryPhoneNOInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPhoneNOInfo, sizeof(_ns1__queryPhoneNOInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPhoneNOInfo(struct soap *soap, _ns1__queryPhoneNOInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPhoneNOInfo);
	if (soap_out_PointerTo_ns1__queryPhoneNOInfo(soap, tag?tag:"ns1:queryPhoneNOInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__queryPhoneNOInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPhoneNOInfo(struct soap *soap, _ns1__queryPhoneNOInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPhoneNOInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfStockCardItem(struct soap *soap, ns1__ArrayOfStockCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfStockCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfStockCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfStockCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfStockCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfStockCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfStockCardItem(struct soap *soap, const char *tag, ns1__ArrayOfStockCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfStockCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfStockCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfStockCardItem *)soap_instantiate_ns1__ArrayOfStockCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfStockCardItem ** p = (ns1__ArrayOfStockCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfStockCardItem, sizeof(ns1__ArrayOfStockCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfStockCardItem(struct soap *soap, ns1__ArrayOfStockCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfStockCardItem);
	if (soap_out_PointerTons1__ArrayOfStockCardItem(soap, tag?tag:"ns1:ArrayOfStockCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfStockCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfStockCardItem(struct soap *soap, ns1__ArrayOfStockCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfStockCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfOtherCardItem(struct soap *soap, ns1__ArrayOfOtherCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfOtherCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfOtherCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfOtherCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfOtherCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfOtherCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfOtherCardItem(struct soap *soap, const char *tag, ns1__ArrayOfOtherCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfOtherCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfOtherCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfOtherCardItem *)soap_instantiate_ns1__ArrayOfOtherCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfOtherCardItem ** p = (ns1__ArrayOfOtherCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfOtherCardItem, sizeof(ns1__ArrayOfOtherCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfOtherCardItem(struct soap *soap, ns1__ArrayOfOtherCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfOtherCardItem);
	if (soap_out_PointerTons1__ArrayOfOtherCardItem(soap, tag?tag:"ns1:ArrayOfOtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfOtherCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfOtherCardItem(struct soap *soap, ns1__ArrayOfOtherCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSellOtherCardItem(struct soap *soap, ns1__ArrayOfSellOtherCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSellOtherCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfSellOtherCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSellOtherCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSellOtherCardItem(struct soap *soap, const char *tag, ns1__ArrayOfSellOtherCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSellOtherCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfSellOtherCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSellOtherCardItem *)soap_instantiate_ns1__ArrayOfSellOtherCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSellOtherCardItem ** p = (ns1__ArrayOfSellOtherCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSellOtherCardItem, sizeof(ns1__ArrayOfSellOtherCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSellOtherCardItem(struct soap *soap, ns1__ArrayOfSellOtherCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSellOtherCardItem);
	if (soap_out_PointerTons1__ArrayOfSellOtherCardItem(soap, tag?tag:"ns1:ArrayOfSellOtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSellOtherCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSellOtherCardItem(struct soap *soap, ns1__ArrayOfSellOtherCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSellOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfBusinessItem(struct soap *soap, ns1__ArrayOfBusinessItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfBusinessItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfBusinessItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfBusinessItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfBusinessItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfBusinessItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfBusinessItem(struct soap *soap, const char *tag, ns1__ArrayOfBusinessItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfBusinessItem **)soap_malloc(soap, sizeof(ns1__ArrayOfBusinessItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfBusinessItem *)soap_instantiate_ns1__ArrayOfBusinessItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfBusinessItem ** p = (ns1__ArrayOfBusinessItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfBusinessItem, sizeof(ns1__ArrayOfBusinessItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfBusinessItem(struct soap *soap, ns1__ArrayOfBusinessItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfBusinessItem);
	if (soap_out_PointerTons1__ArrayOfBusinessItem(soap, tag?tag:"ns1:ArrayOfBusinessItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfBusinessItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfBusinessItem(struct soap *soap, ns1__ArrayOfBusinessItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfBusinessItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSellCardItem(struct soap *soap, ns1__ArrayOfSellCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSellCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSellCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfSellCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSellCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSellCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSellCardItem(struct soap *soap, const char *tag, ns1__ArrayOfSellCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSellCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfSellCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSellCardItem *)soap_instantiate_ns1__ArrayOfSellCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSellCardItem ** p = (ns1__ArrayOfSellCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSellCardItem, sizeof(ns1__ArrayOfSellCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSellCardItem(struct soap *soap, ns1__ArrayOfSellCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSellCardItem);
	if (soap_out_PointerTons1__ArrayOfSellCardItem(soap, tag?tag:"ns1:ArrayOfSellCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSellCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSellCardItem(struct soap *soap, ns1__ArrayOfSellCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSellCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCardService(struct soap *soap, ns1__ArrayOfCardService *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfCardService))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCardService(struct soap *soap, const char *tag, int id, ns1__ArrayOfCardService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfCardService);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfCardService ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCardService(struct soap *soap, const char *tag, ns1__ArrayOfCardService **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCardService **)soap_malloc(soap, sizeof(ns1__ArrayOfCardService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCardService *)soap_instantiate_ns1__ArrayOfCardService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfCardService ** p = (ns1__ArrayOfCardService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfCardService, sizeof(ns1__ArrayOfCardService), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCardService(struct soap *soap, ns1__ArrayOfCardService *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfCardService);
	if (soap_out_PointerTons1__ArrayOfCardService(soap, tag?tag:"ns1:ArrayOfCardService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfCardService ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCardService(struct soap *soap, ns1__ArrayOfCardService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPayMiniCardItem(struct soap *soap, ns1__ArrayOfPayMiniCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPayMiniCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPayMiniCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPayMiniCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPayMiniCardItem(struct soap *soap, const char *tag, ns1__ArrayOfPayMiniCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPayMiniCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPayMiniCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPayMiniCardItem *)soap_instantiate_ns1__ArrayOfPayMiniCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPayMiniCardItem ** p = (ns1__ArrayOfPayMiniCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPayMiniCardItem, sizeof(ns1__ArrayOfPayMiniCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPayMiniCardItem(struct soap *soap, ns1__ArrayOfPayMiniCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPayMiniCardItem);
	if (soap_out_PointerTons1__ArrayOfPayMiniCardItem(soap, tag?tag:"ns1:ArrayOfPayMiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPayMiniCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPayMiniCardItem(struct soap *soap, ns1__ArrayOfPayMiniCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPayMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfMiniCardItem(struct soap *soap, ns1__ArrayOfMiniCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfMiniCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfMiniCardItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfMiniCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfMiniCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfMiniCardItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfMiniCardItem(struct soap *soap, const char *tag, ns1__ArrayOfMiniCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfMiniCardItem **)soap_malloc(soap, sizeof(ns1__ArrayOfMiniCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfMiniCardItem *)soap_instantiate_ns1__ArrayOfMiniCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfMiniCardItem ** p = (ns1__ArrayOfMiniCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfMiniCardItem, sizeof(ns1__ArrayOfMiniCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfMiniCardItem(struct soap *soap, ns1__ArrayOfMiniCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfMiniCardItem);
	if (soap_out_PointerTons1__ArrayOfMiniCardItem(soap, tag?tag:"ns1:ArrayOfMiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfMiniCardItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfMiniCardItem(struct soap *soap, ns1__ArrayOfMiniCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfString ** p = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneNoList(struct soap *soap, ns1__PhoneNoList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneNoList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneNoList(struct soap *soap, const char *tag, int id, ns1__PhoneNoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PhoneNoList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PhoneNoList ** SOAP_FMAC4 soap_in_PointerTons1__PhoneNoList(struct soap *soap, const char *tag, ns1__PhoneNoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNoList **)soap_malloc(soap, sizeof(ns1__PhoneNoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PhoneNoList *)soap_instantiate_ns1__PhoneNoList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PhoneNoList ** p = (ns1__PhoneNoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PhoneNoList, sizeof(ns1__PhoneNoList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneNoList(struct soap *soap, ns1__PhoneNoList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PhoneNoList);
	if (soap_out_PointerTons1__PhoneNoList(soap, tag?tag:"ns1:PhoneNoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNoList ** SOAP_FMAC4 soap_get_PointerTons1__PhoneNoList(struct soap *soap, ns1__PhoneNoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneNoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Result(struct soap *soap, ns1__Result *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Result))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Result(struct soap *soap, const char *tag, int id, ns1__Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Result);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Result ** SOAP_FMAC4 soap_in_PointerTons1__Result(struct soap *soap, const char *tag, ns1__Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Result **)soap_malloc(soap, sizeof(ns1__Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Result *)soap_instantiate_ns1__Result(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Result ** p = (ns1__Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Result, sizeof(ns1__Result), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Result(struct soap *soap, ns1__Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Result);
	if (soap_out_PointerTons1__Result(soap, tag?tag:"ns1:Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Result ** SOAP_FMAC4 soap_get_PointerTons1__Result(struct soap *soap, ns1__Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCompanyAccount(struct soap *soap, ns1__ArrayOfCompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfCompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCompanyAccount(struct soap *soap, const char *tag, int id, ns1__ArrayOfCompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfCompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfCompanyAccount ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCompanyAccount(struct soap *soap, const char *tag, ns1__ArrayOfCompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCompanyAccount **)soap_malloc(soap, sizeof(ns1__ArrayOfCompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCompanyAccount *)soap_instantiate_ns1__ArrayOfCompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfCompanyAccount ** p = (ns1__ArrayOfCompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfCompanyAccount, sizeof(ns1__ArrayOfCompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCompanyAccount(struct soap *soap, ns1__ArrayOfCompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfCompanyAccount);
	if (soap_out_PointerTons1__ArrayOfCompanyAccount(soap, tag?tag:"ns1:ArrayOfCompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfCompanyAccount ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCompanyAccount(struct soap *soap, ns1__ArrayOfCompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CompanyInfo(struct soap *soap, ns1__CompanyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CompanyInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CompanyInfo(struct soap *soap, const char *tag, int id, ns1__CompanyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CompanyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CompanyInfo ** SOAP_FMAC4 soap_in_PointerTons1__CompanyInfo(struct soap *soap, const char *tag, ns1__CompanyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CompanyInfo **)soap_malloc(soap, sizeof(ns1__CompanyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CompanyInfo *)soap_instantiate_ns1__CompanyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CompanyInfo ** p = (ns1__CompanyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CompanyInfo, sizeof(ns1__CompanyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CompanyInfo(struct soap *soap, ns1__CompanyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CompanyInfo);
	if (soap_out_PointerTons1__CompanyInfo(soap, tag?tag:"ns1:CompanyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CompanyInfo ** SOAP_FMAC4 soap_get_PointerTons1__CompanyInfo(struct soap *soap, ns1__CompanyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CompanyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPhoneNumberBelong(struct soap *soap, ns1__ArrayOfPhoneNumberBelong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPhoneNumberBelong(struct soap *soap, const char *tag, int id, ns1__ArrayOfPhoneNumberBelong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNumberBelong ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPhoneNumberBelong(struct soap *soap, const char *tag, ns1__ArrayOfPhoneNumberBelong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPhoneNumberBelong **)soap_malloc(soap, sizeof(ns1__ArrayOfPhoneNumberBelong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPhoneNumberBelong *)soap_instantiate_ns1__ArrayOfPhoneNumberBelong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPhoneNumberBelong ** p = (ns1__ArrayOfPhoneNumberBelong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPhoneNumberBelong, sizeof(ns1__ArrayOfPhoneNumberBelong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPhoneNumberBelong(struct soap *soap, ns1__ArrayOfPhoneNumberBelong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPhoneNumberBelong);
	if (soap_out_PointerTons1__ArrayOfPhoneNumberBelong(soap, tag?tag:"ns1:ArrayOfPhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNumberBelong ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPhoneNumberBelong(struct soap *soap, ns1__ArrayOfPhoneNumberBelong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfReturnProportion(struct soap *soap, ns1__ArrayOfReturnProportion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfReturnProportion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfReturnProportion(struct soap *soap, const char *tag, int id, ns1__ArrayOfReturnProportion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfReturnProportion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnProportion ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfReturnProportion(struct soap *soap, const char *tag, ns1__ArrayOfReturnProportion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfReturnProportion **)soap_malloc(soap, sizeof(ns1__ArrayOfReturnProportion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfReturnProportion *)soap_instantiate_ns1__ArrayOfReturnProportion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfReturnProportion ** p = (ns1__ArrayOfReturnProportion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfReturnProportion, sizeof(ns1__ArrayOfReturnProportion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfReturnProportion(struct soap *soap, ns1__ArrayOfReturnProportion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfReturnProportion);
	if (soap_out_PointerTons1__ArrayOfReturnProportion(soap, tag?tag:"ns1:ArrayOfReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfReturnProportion ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfReturnProportion(struct soap *soap, ns1__ArrayOfReturnProportion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Notice(struct soap *soap, ns1__Notice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Notice))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Notice(struct soap *soap, const char *tag, int id, ns1__Notice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Notice);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Notice ** SOAP_FMAC4 soap_in_PointerTons1__Notice(struct soap *soap, const char *tag, ns1__Notice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Notice **)soap_malloc(soap, sizeof(ns1__Notice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Notice *)soap_instantiate_ns1__Notice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Notice ** p = (ns1__Notice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Notice, sizeof(ns1__Notice), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Notice(struct soap *soap, ns1__Notice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Notice);
	if (soap_out_PointerTons1__Notice(soap, tag?tag:"ns1:Notice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Notice ** SOAP_FMAC4 soap_get_PointerTons1__Notice(struct soap *soap, ns1__Notice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Notice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TableStatistics(struct soap *soap, ns1__TableStatistics *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TableStatistics))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TableStatistics(struct soap *soap, const char *tag, int id, ns1__TableStatistics *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TableStatistics);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TableStatistics ** SOAP_FMAC4 soap_in_PointerTons1__TableStatistics(struct soap *soap, const char *tag, ns1__TableStatistics **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TableStatistics **)soap_malloc(soap, sizeof(ns1__TableStatistics *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TableStatistics *)soap_instantiate_ns1__TableStatistics(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TableStatistics ** p = (ns1__TableStatistics **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TableStatistics, sizeof(ns1__TableStatistics), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TableStatistics(struct soap *soap, ns1__TableStatistics *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TableStatistics);
	if (soap_out_PointerTons1__TableStatistics(soap, tag?tag:"ns1:TableStatistics", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TableStatistics ** SOAP_FMAC4 soap_get_PointerTons1__TableStatistics(struct soap *soap, ns1__TableStatistics **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TableStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDIC_USCORECategory(struct soap *soap, ns1__ArrayOfDIC_USCORECategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDIC_USCORECategory(struct soap *soap, const char *tag, int id, ns1__ArrayOfDIC_USCORECategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCORECategory ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDIC_USCORECategory(struct soap *soap, const char *tag, ns1__ArrayOfDIC_USCORECategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDIC_USCORECategory **)soap_malloc(soap, sizeof(ns1__ArrayOfDIC_USCORECategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDIC_USCORECategory *)soap_instantiate_ns1__ArrayOfDIC_USCORECategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfDIC_USCORECategory ** p = (ns1__ArrayOfDIC_USCORECategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDIC_USCORECategory, sizeof(ns1__ArrayOfDIC_USCORECategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDIC_USCORECategory(struct soap *soap, ns1__ArrayOfDIC_USCORECategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDIC_USCORECategory);
	if (soap_out_PointerTons1__ArrayOfDIC_USCORECategory(soap, tag?tag:"ns1:ArrayOfDIC_Category", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCORECategory ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDIC_USCORECategory(struct soap *soap, ns1__ArrayOfDIC_USCORECategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDIC_USCORECategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDIC_USCOREContent(struct soap *soap, ns1__ArrayOfDIC_USCOREContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDIC_USCOREContent(struct soap *soap, const char *tag, int id, ns1__ArrayOfDIC_USCOREContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCOREContent ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDIC_USCOREContent(struct soap *soap, const char *tag, ns1__ArrayOfDIC_USCOREContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDIC_USCOREContent **)soap_malloc(soap, sizeof(ns1__ArrayOfDIC_USCOREContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDIC_USCOREContent *)soap_instantiate_ns1__ArrayOfDIC_USCOREContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfDIC_USCOREContent ** p = (ns1__ArrayOfDIC_USCOREContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDIC_USCOREContent, sizeof(ns1__ArrayOfDIC_USCOREContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDIC_USCOREContent(struct soap *soap, ns1__ArrayOfDIC_USCOREContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDIC_USCOREContent);
	if (soap_out_PointerTons1__ArrayOfDIC_USCOREContent(soap, tag?tag:"ns1:ArrayOfDIC_Content", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDIC_USCOREContent ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDIC_USCOREContent(struct soap *soap, ns1__ArrayOfDIC_USCOREContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDIC_USCOREContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAcountPaymentItem(struct soap *soap, ns1__ArrayOfAcountPaymentItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAcountPaymentItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfAcountPaymentItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfAcountPaymentItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAcountPaymentItem(struct soap *soap, const char *tag, ns1__ArrayOfAcountPaymentItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAcountPaymentItem **)soap_malloc(soap, sizeof(ns1__ArrayOfAcountPaymentItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAcountPaymentItem *)soap_instantiate_ns1__ArrayOfAcountPaymentItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfAcountPaymentItem ** p = (ns1__ArrayOfAcountPaymentItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAcountPaymentItem, sizeof(ns1__ArrayOfAcountPaymentItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAcountPaymentItem(struct soap *soap, ns1__ArrayOfAcountPaymentItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfAcountPaymentItem);
	if (soap_out_PointerTons1__ArrayOfAcountPaymentItem(soap, tag?tag:"ns1:ArrayOfAcountPaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAcountPaymentItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAcountPaymentItem(struct soap *soap, ns1__ArrayOfAcountPaymentItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAcountPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfReturnedItem(struct soap *soap, ns1__ArrayOfReturnedItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfReturnedItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfReturnedItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfReturnedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfReturnedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnedItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfReturnedItem(struct soap *soap, const char *tag, ns1__ArrayOfReturnedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfReturnedItem **)soap_malloc(soap, sizeof(ns1__ArrayOfReturnedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfReturnedItem *)soap_instantiate_ns1__ArrayOfReturnedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfReturnedItem ** p = (ns1__ArrayOfReturnedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfReturnedItem, sizeof(ns1__ArrayOfReturnedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfReturnedItem(struct soap *soap, ns1__ArrayOfReturnedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfReturnedItem);
	if (soap_out_PointerTons1__ArrayOfReturnedItem(soap, tag?tag:"ns1:ArrayOfReturnedItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfReturnedItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfReturnedItem(struct soap *soap, ns1__ArrayOfReturnedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfReturnedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSystemFunction(struct soap *soap, ns1__ArrayOfSystemFunction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSystemFunction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSystemFunction(struct soap *soap, const char *tag, int id, ns1__ArrayOfSystemFunction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSystemFunction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSystemFunction ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSystemFunction(struct soap *soap, const char *tag, ns1__ArrayOfSystemFunction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSystemFunction **)soap_malloc(soap, sizeof(ns1__ArrayOfSystemFunction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSystemFunction *)soap_instantiate_ns1__ArrayOfSystemFunction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSystemFunction ** p = (ns1__ArrayOfSystemFunction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSystemFunction, sizeof(ns1__ArrayOfSystemFunction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSystemFunction(struct soap *soap, ns1__ArrayOfSystemFunction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSystemFunction);
	if (soap_out_PointerTons1__ArrayOfSystemFunction(soap, tag?tag:"ns1:ArrayOfSystemFunction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSystemFunction ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSystemFunction(struct soap *soap, ns1__ArrayOfSystemFunction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSystemFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfWorker(struct soap *soap, ns1__ArrayOfWorker *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfWorker))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfWorker(struct soap *soap, const char *tag, int id, ns1__ArrayOfWorker *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfWorker);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfWorker ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfWorker(struct soap *soap, const char *tag, ns1__ArrayOfWorker **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfWorker **)soap_malloc(soap, sizeof(ns1__ArrayOfWorker *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfWorker *)soap_instantiate_ns1__ArrayOfWorker(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfWorker ** p = (ns1__ArrayOfWorker **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfWorker, sizeof(ns1__ArrayOfWorker), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfWorker(struct soap *soap, ns1__ArrayOfWorker *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfWorker);
	if (soap_out_PointerTons1__ArrayOfWorker(soap, tag?tag:"ns1:ArrayOfWorker", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfWorker ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfWorker(struct soap *soap, ns1__ArrayOfWorker **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfWorker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnInfo(struct soap *soap, ns1__ReturnInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnInfo(struct soap *soap, const char *tag, int id, ns1__ReturnInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReturnInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReturnInfo ** SOAP_FMAC4 soap_in_PointerTons1__ReturnInfo(struct soap *soap, const char *tag, ns1__ReturnInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnInfo **)soap_malloc(soap, sizeof(ns1__ReturnInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReturnInfo *)soap_instantiate_ns1__ReturnInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ReturnInfo ** p = (ns1__ReturnInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReturnInfo, sizeof(ns1__ReturnInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnInfo(struct soap *soap, ns1__ReturnInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReturnInfo);
	if (soap_out_PointerTons1__ReturnInfo(soap, tag?tag:"ns1:ReturnInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnInfo ** SOAP_FMAC4 soap_get_PointerTons1__ReturnInfo(struct soap *soap, ns1__ReturnInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__User(struct soap *soap, ns1__User *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__User))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__User(struct soap *soap, const char *tag, int id, ns1__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__User);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__User ** SOAP_FMAC4 soap_in_PointerTons1__User(struct soap *soap, const char *tag, ns1__User **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__User **)soap_malloc(soap, sizeof(ns1__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__User *)soap_instantiate_ns1__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__User ** p = (ns1__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__User, sizeof(ns1__User), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__User(struct soap *soap, ns1__User *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__User);
	if (soap_out_PointerTons1__User(soap, tag?tag:"ns1:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__User ** SOAP_FMAC4 soap_get_PointerTons1__User(struct soap *soap, ns1__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPayPublicTelItem(struct soap *soap, ns1__ArrayOfPayPublicTelItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPayPublicTelItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPayPublicTelItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPayPublicTelItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPayPublicTelItem(struct soap *soap, const char *tag, ns1__ArrayOfPayPublicTelItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPayPublicTelItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPayPublicTelItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPayPublicTelItem *)soap_instantiate_ns1__ArrayOfPayPublicTelItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPayPublicTelItem ** p = (ns1__ArrayOfPayPublicTelItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPayPublicTelItem, sizeof(ns1__ArrayOfPayPublicTelItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPayPublicTelItem(struct soap *soap, ns1__ArrayOfPayPublicTelItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPayPublicTelItem);
	if (soap_out_PointerTons1__ArrayOfPayPublicTelItem(soap, tag?tag:"ns1:ArrayOfPayPublicTelItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPayPublicTelItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPayPublicTelItem(struct soap *soap, ns1__ArrayOfPayPublicTelItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPayPublicTelItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPayGameItem(struct soap *soap, ns1__ArrayOfPayGameItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPayGameItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPayGameItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPayGameItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPayGameItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPayGameItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPayGameItem(struct soap *soap, const char *tag, ns1__ArrayOfPayGameItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPayGameItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPayGameItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPayGameItem *)soap_instantiate_ns1__ArrayOfPayGameItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPayGameItem ** p = (ns1__ArrayOfPayGameItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPayGameItem, sizeof(ns1__ArrayOfPayGameItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPayGameItem(struct soap *soap, ns1__ArrayOfPayGameItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPayGameItem);
	if (soap_out_PointerTons1__ArrayOfPayGameItem(soap, tag?tag:"ns1:ArrayOfPayGameItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPayGameItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPayGameItem(struct soap *soap, ns1__ArrayOfPayGameItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPayGameItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPayInternetItem(struct soap *soap, ns1__ArrayOfPayInternetItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPayInternetItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPayInternetItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPayInternetItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPayInternetItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPayInternetItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPayInternetItem(struct soap *soap, const char *tag, ns1__ArrayOfPayInternetItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPayInternetItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPayInternetItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPayInternetItem *)soap_instantiate_ns1__ArrayOfPayInternetItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPayInternetItem ** p = (ns1__ArrayOfPayInternetItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPayInternetItem, sizeof(ns1__ArrayOfPayInternetItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPayInternetItem(struct soap *soap, ns1__ArrayOfPayInternetItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPayInternetItem);
	if (soap_out_PointerTons1__ArrayOfPayInternetItem(soap, tag?tag:"ns1:ArrayOfPayInternetItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPayInternetItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPayInternetItem(struct soap *soap, ns1__ArrayOfPayInternetItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPayInternetItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTransStaticsItem(struct soap *soap, ns1__ArrayOfTransStaticsItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTransStaticsItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTransStaticsItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfTransStaticsItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTransStaticsItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfTransStaticsItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTransStaticsItem(struct soap *soap, const char *tag, ns1__ArrayOfTransStaticsItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfTransStaticsItem **)soap_malloc(soap, sizeof(ns1__ArrayOfTransStaticsItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfTransStaticsItem *)soap_instantiate_ns1__ArrayOfTransStaticsItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfTransStaticsItem ** p = (ns1__ArrayOfTransStaticsItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTransStaticsItem, sizeof(ns1__ArrayOfTransStaticsItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTransStaticsItem(struct soap *soap, ns1__ArrayOfTransStaticsItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTransStaticsItem);
	if (soap_out_PointerTons1__ArrayOfTransStaticsItem(soap, tag?tag:"ns1:ArrayOfTransStaticsItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfTransStaticsItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTransStaticsItem(struct soap *soap, ns1__ArrayOfTransStaticsItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTransStaticsItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTransaction(struct soap *soap, ns1__ArrayOfTransaction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTransaction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTransaction(struct soap *soap, const char *tag, int id, ns1__ArrayOfTransaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTransaction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfTransaction ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTransaction(struct soap *soap, const char *tag, ns1__ArrayOfTransaction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfTransaction **)soap_malloc(soap, sizeof(ns1__ArrayOfTransaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfTransaction *)soap_instantiate_ns1__ArrayOfTransaction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfTransaction ** p = (ns1__ArrayOfTransaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTransaction, sizeof(ns1__ArrayOfTransaction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTransaction(struct soap *soap, ns1__ArrayOfTransaction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTransaction);
	if (soap_out_PointerTons1__ArrayOfTransaction(soap, tag?tag:"ns1:ArrayOfTransaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfTransaction ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTransaction(struct soap *soap, ns1__ArrayOfTransaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPaymentItem(struct soap *soap, ns1__ArrayOfPaymentItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPaymentItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPaymentItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPaymentItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPaymentItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPaymentItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPaymentItem(struct soap *soap, const char *tag, ns1__ArrayOfPaymentItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPaymentItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPaymentItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPaymentItem *)soap_instantiate_ns1__ArrayOfPaymentItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPaymentItem ** p = (ns1__ArrayOfPaymentItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPaymentItem, sizeof(ns1__ArrayOfPaymentItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPaymentItem(struct soap *soap, ns1__ArrayOfPaymentItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPaymentItem);
	if (soap_out_PointerTons1__ArrayOfPaymentItem(soap, tag?tag:"ns1:ArrayOfPaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPaymentItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPaymentItem(struct soap *soap, ns1__ArrayOfPaymentItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayWithListResult(struct soap *soap, ns1__PayWithListResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayWithListResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayWithListResult(struct soap *soap, const char *tag, int id, ns1__PayWithListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayWithListResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayWithListResult ** SOAP_FMAC4 soap_in_PointerTons1__PayWithListResult(struct soap *soap, const char *tag, ns1__PayWithListResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayWithListResult **)soap_malloc(soap, sizeof(ns1__PayWithListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayWithListResult *)soap_instantiate_ns1__PayWithListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayWithListResult ** p = (ns1__PayWithListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayWithListResult, sizeof(ns1__PayWithListResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayWithListResult(struct soap *soap, ns1__PayWithListResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayWithListResult);
	if (soap_out_PointerTons1__PayWithListResult(soap, tag?tag:"ns1:PayWithListResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayWithListResult ** SOAP_FMAC4 soap_get_PointerTons1__PayWithListResult(struct soap *soap, ns1__PayWithListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayWithListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__StockCardItem))
		soap_serialize_PointerTons1__StockCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__StockCardItem(struct soap *soap, const char *tag, int id, ns1__StockCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__StockCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__StockCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__StockCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__StockCardItem(struct soap *soap, const char *tag, ns1__StockCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StockCardItem ***)soap_malloc(soap, sizeof(ns1__StockCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__StockCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__StockCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__StockCardItem, sizeof(ns1__StockCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__StockCardItem);
	if (soap_out_PointerToPointerTons1__StockCardItem(soap, tag?tag:"ns1:StockCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StockCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__StockCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StockCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StockCardItem(struct soap *soap, const char *tag, int id, ns1__StockCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StockCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StockCardItem ** SOAP_FMAC4 soap_in_PointerTons1__StockCardItem(struct soap *soap, const char *tag, ns1__StockCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StockCardItem **)soap_malloc(soap, sizeof(ns1__StockCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StockCardItem *)soap_instantiate_ns1__StockCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StockCardItem ** p = (ns1__StockCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StockCardItem, sizeof(ns1__StockCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StockCardItem);
	if (soap_out_PointerTons1__StockCardItem(soap, tag?tag:"ns1:StockCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StockCardItem ** SOAP_FMAC4 soap_get_PointerTons1__StockCardItem(struct soap *soap, ns1__StockCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StockCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__OtherCardItem))
		soap_serialize_PointerTons1__OtherCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__OtherCardItem(struct soap *soap, const char *tag, int id, ns1__OtherCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__OtherCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__OtherCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__OtherCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__OtherCardItem(struct soap *soap, const char *tag, ns1__OtherCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtherCardItem ***)soap_malloc(soap, sizeof(ns1__OtherCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__OtherCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__OtherCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__OtherCardItem, sizeof(ns1__OtherCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__OtherCardItem);
	if (soap_out_PointerToPointerTons1__OtherCardItem(soap, tag?tag:"ns1:OtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtherCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__OtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OtherCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtherCardItem(struct soap *soap, const char *tag, int id, ns1__OtherCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtherCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OtherCardItem ** SOAP_FMAC4 soap_in_PointerTons1__OtherCardItem(struct soap *soap, const char *tag, ns1__OtherCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtherCardItem **)soap_malloc(soap, sizeof(ns1__OtherCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OtherCardItem *)soap_instantiate_ns1__OtherCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OtherCardItem ** p = (ns1__OtherCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtherCardItem, sizeof(ns1__OtherCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OtherCardItem);
	if (soap_out_PointerTons1__OtherCardItem(soap, tag?tag:"ns1:OtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtherCardItem ** SOAP_FMAC4 soap_get_PointerTons1__OtherCardItem(struct soap *soap, ns1__OtherCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SellOtherCardItem))
		soap_serialize_PointerTons1__SellOtherCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SellOtherCardItem(struct soap *soap, const char *tag, int id, ns1__SellOtherCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SellOtherCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SellOtherCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SellOtherCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SellOtherCardItem(struct soap *soap, const char *tag, ns1__SellOtherCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellOtherCardItem ***)soap_malloc(soap, sizeof(ns1__SellOtherCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SellOtherCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SellOtherCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SellOtherCardItem, sizeof(ns1__SellOtherCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SellOtherCardItem);
	if (soap_out_PointerToPointerTons1__SellOtherCardItem(soap, tag?tag:"ns1:SellOtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SellOtherCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SellOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellOtherCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellOtherCardItem(struct soap *soap, const char *tag, int id, ns1__SellOtherCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellOtherCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellOtherCardItem ** SOAP_FMAC4 soap_in_PointerTons1__SellOtherCardItem(struct soap *soap, const char *tag, ns1__SellOtherCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellOtherCardItem **)soap_malloc(soap, sizeof(ns1__SellOtherCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellOtherCardItem *)soap_instantiate_ns1__SellOtherCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellOtherCardItem ** p = (ns1__SellOtherCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellOtherCardItem, sizeof(ns1__SellOtherCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellOtherCardItem);
	if (soap_out_PointerTons1__SellOtherCardItem(soap, tag?tag:"ns1:SellOtherCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SellOtherCardItem ** SOAP_FMAC4 soap_get_PointerTons1__SellOtherCardItem(struct soap *soap, ns1__SellOtherCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellOtherCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__BusinessItem))
		soap_serialize_PointerTons1__BusinessItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__BusinessItem(struct soap *soap, const char *tag, int id, ns1__BusinessItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__BusinessItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__BusinessItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__BusinessItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__BusinessItem(struct soap *soap, const char *tag, ns1__BusinessItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BusinessItem ***)soap_malloc(soap, sizeof(ns1__BusinessItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__BusinessItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__BusinessItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__BusinessItem, sizeof(ns1__BusinessItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__BusinessItem);
	if (soap_out_PointerToPointerTons1__BusinessItem(soap, tag?tag:"ns1:BusinessItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BusinessItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__BusinessItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BusinessItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BusinessItem(struct soap *soap, const char *tag, int id, ns1__BusinessItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BusinessItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BusinessItem ** SOAP_FMAC4 soap_in_PointerTons1__BusinessItem(struct soap *soap, const char *tag, ns1__BusinessItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BusinessItem **)soap_malloc(soap, sizeof(ns1__BusinessItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BusinessItem *)soap_instantiate_ns1__BusinessItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BusinessItem ** p = (ns1__BusinessItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BusinessItem, sizeof(ns1__BusinessItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BusinessItem);
	if (soap_out_PointerTons1__BusinessItem(soap, tag?tag:"ns1:BusinessItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BusinessItem ** SOAP_FMAC4 soap_get_PointerTons1__BusinessItem(struct soap *soap, ns1__BusinessItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BusinessItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SellCardItem))
		soap_serialize_PointerTons1__SellCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SellCardItem(struct soap *soap, const char *tag, int id, ns1__SellCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SellCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SellCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SellCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SellCardItem(struct soap *soap, const char *tag, ns1__SellCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellCardItem ***)soap_malloc(soap, sizeof(ns1__SellCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SellCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SellCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SellCardItem, sizeof(ns1__SellCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SellCardItem);
	if (soap_out_PointerToPointerTons1__SellCardItem(soap, tag?tag:"ns1:SellCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SellCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SellCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SellCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SellCardItem(struct soap *soap, const char *tag, int id, ns1__SellCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SellCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SellCardItem ** SOAP_FMAC4 soap_in_PointerTons1__SellCardItem(struct soap *soap, const char *tag, ns1__SellCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SellCardItem **)soap_malloc(soap, sizeof(ns1__SellCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SellCardItem *)soap_instantiate_ns1__SellCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SellCardItem ** p = (ns1__SellCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SellCardItem, sizeof(ns1__SellCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SellCardItem);
	if (soap_out_PointerTons1__SellCardItem(soap, tag?tag:"ns1:SellCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SellCardItem ** SOAP_FMAC4 soap_get_PointerTons1__SellCardItem(struct soap *soap, ns1__SellCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SellCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CardService(struct soap *soap, ns1__CardService **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CardService))
		soap_serialize_PointerTons1__CardService(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CardService(struct soap *soap, const char *tag, int id, ns1__CardService **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CardService);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CardService(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CardService *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CardService(struct soap *soap, const char *tag, ns1__CardService ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CardService ***)soap_malloc(soap, sizeof(ns1__CardService **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CardService(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CardService ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CardService, sizeof(ns1__CardService *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CardService(struct soap *soap, ns1__CardService **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CardService);
	if (soap_out_PointerToPointerTons1__CardService(soap, tag?tag:"ns1:CardService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CardService *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CardService(struct soap *soap, ns1__CardService ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CardService(struct soap *soap, ns1__CardService *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CardService))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CardService(struct soap *soap, const char *tag, int id, ns1__CardService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CardService);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CardService ** SOAP_FMAC4 soap_in_PointerTons1__CardService(struct soap *soap, const char *tag, ns1__CardService **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CardService **)soap_malloc(soap, sizeof(ns1__CardService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CardService *)soap_instantiate_ns1__CardService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CardService ** p = (ns1__CardService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CardService, sizeof(ns1__CardService), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CardService(struct soap *soap, ns1__CardService *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CardService);
	if (soap_out_PointerTons1__CardService(soap, tag?tag:"ns1:CardService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CardService ** SOAP_FMAC4 soap_get_PointerTons1__CardService(struct soap *soap, ns1__CardService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CardService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PayMiniCardItem))
		soap_serialize_PointerTons1__PayMiniCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PayMiniCardItem(struct soap *soap, const char *tag, int id, ns1__PayMiniCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PayMiniCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PayMiniCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PayMiniCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PayMiniCardItem(struct soap *soap, const char *tag, ns1__PayMiniCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayMiniCardItem ***)soap_malloc(soap, sizeof(ns1__PayMiniCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PayMiniCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PayMiniCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PayMiniCardItem, sizeof(ns1__PayMiniCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PayMiniCardItem);
	if (soap_out_PointerToPointerTons1__PayMiniCardItem(soap, tag?tag:"ns1:PayMiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayMiniCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PayMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayMiniCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayMiniCardItem(struct soap *soap, const char *tag, int id, ns1__PayMiniCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayMiniCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayMiniCardItem ** SOAP_FMAC4 soap_in_PointerTons1__PayMiniCardItem(struct soap *soap, const char *tag, ns1__PayMiniCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayMiniCardItem **)soap_malloc(soap, sizeof(ns1__PayMiniCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayMiniCardItem *)soap_instantiate_ns1__PayMiniCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayMiniCardItem ** p = (ns1__PayMiniCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayMiniCardItem, sizeof(ns1__PayMiniCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayMiniCardItem);
	if (soap_out_PointerTons1__PayMiniCardItem(soap, tag?tag:"ns1:PayMiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayMiniCardItem ** SOAP_FMAC4 soap_get_PointerTons1__PayMiniCardItem(struct soap *soap, ns1__PayMiniCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayMiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MiniCardItem))
		soap_serialize_PointerTons1__MiniCardItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MiniCardItem(struct soap *soap, const char *tag, int id, ns1__MiniCardItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MiniCardItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MiniCardItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MiniCardItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MiniCardItem(struct soap *soap, const char *tag, ns1__MiniCardItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MiniCardItem ***)soap_malloc(soap, sizeof(ns1__MiniCardItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MiniCardItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MiniCardItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MiniCardItem, sizeof(ns1__MiniCardItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MiniCardItem);
	if (soap_out_PointerToPointerTons1__MiniCardItem(soap, tag?tag:"ns1:MiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MiniCardItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MiniCardItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MiniCardItem(struct soap *soap, const char *tag, int id, ns1__MiniCardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MiniCardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MiniCardItem ** SOAP_FMAC4 soap_in_PointerTons1__MiniCardItem(struct soap *soap, const char *tag, ns1__MiniCardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MiniCardItem **)soap_malloc(soap, sizeof(ns1__MiniCardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MiniCardItem *)soap_instantiate_ns1__MiniCardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MiniCardItem ** p = (ns1__MiniCardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MiniCardItem, sizeof(ns1__MiniCardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MiniCardItem);
	if (soap_out_PointerTons1__MiniCardItem(soap, tag?tag:"ns1:MiniCardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MiniCardItem ** SOAP_FMAC4 soap_get_PointerTons1__MiniCardItem(struct soap *soap, ns1__MiniCardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MiniCardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PhoneNoItem))
		soap_serialize_PointerTons1__PhoneNoItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PhoneNoItem(struct soap *soap, const char *tag, int id, ns1__PhoneNoItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PhoneNoItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PhoneNoItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PhoneNoItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PhoneNoItem(struct soap *soap, const char *tag, ns1__PhoneNoItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNoItem ***)soap_malloc(soap, sizeof(ns1__PhoneNoItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PhoneNoItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNoItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PhoneNoItem, sizeof(ns1__PhoneNoItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PhoneNoItem);
	if (soap_out_PointerToPointerTons1__PhoneNoItem(soap, tag?tag:"ns1:PhoneNoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNoItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PhoneNoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneNoItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneNoItem(struct soap *soap, const char *tag, int id, ns1__PhoneNoItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PhoneNoItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PhoneNoItem ** SOAP_FMAC4 soap_in_PointerTons1__PhoneNoItem(struct soap *soap, const char *tag, ns1__PhoneNoItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNoItem **)soap_malloc(soap, sizeof(ns1__PhoneNoItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PhoneNoItem *)soap_instantiate_ns1__PhoneNoItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PhoneNoItem ** p = (ns1__PhoneNoItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PhoneNoItem, sizeof(ns1__PhoneNoItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PhoneNoItem);
	if (soap_out_PointerTons1__PhoneNoItem(soap, tag?tag:"ns1:PhoneNoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNoItem ** SOAP_FMAC4 soap_get_PointerTons1__PhoneNoItem(struct soap *soap, ns1__PhoneNoItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneNoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPhoneNoItem(struct soap *soap, ns1__ArrayOfPhoneNoItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPhoneNoItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPhoneNoItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPhoneNoItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPhoneNoItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNoItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPhoneNoItem(struct soap *soap, const char *tag, ns1__ArrayOfPhoneNoItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPhoneNoItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPhoneNoItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPhoneNoItem *)soap_instantiate_ns1__ArrayOfPhoneNoItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPhoneNoItem ** p = (ns1__ArrayOfPhoneNoItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPhoneNoItem, sizeof(ns1__ArrayOfPhoneNoItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPhoneNoItem(struct soap *soap, ns1__ArrayOfPhoneNoItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPhoneNoItem);
	if (soap_out_PointerTons1__ArrayOfPhoneNoItem(soap, tag?tag:"ns1:ArrayOfPhoneNoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPhoneNoItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPhoneNoItem(struct soap *soap, ns1__ArrayOfPhoneNoItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPhoneNoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CompanyAccount))
		soap_serialize_PointerTons1__CompanyAccount(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CompanyAccount(struct soap *soap, const char *tag, int id, ns1__CompanyAccount **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CompanyAccount);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CompanyAccount(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CompanyAccount *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CompanyAccount(struct soap *soap, const char *tag, ns1__CompanyAccount ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CompanyAccount ***)soap_malloc(soap, sizeof(ns1__CompanyAccount **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CompanyAccount(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CompanyAccount ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CompanyAccount, sizeof(ns1__CompanyAccount *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CompanyAccount);
	if (soap_out_PointerToPointerTons1__CompanyAccount(soap, tag?tag:"ns1:CompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CompanyAccount *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CompanyAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CompanyAccount(struct soap *soap, const char *tag, int id, ns1__CompanyAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CompanyAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CompanyAccount ** SOAP_FMAC4 soap_in_PointerTons1__CompanyAccount(struct soap *soap, const char *tag, ns1__CompanyAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CompanyAccount **)soap_malloc(soap, sizeof(ns1__CompanyAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CompanyAccount *)soap_instantiate_ns1__CompanyAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CompanyAccount ** p = (ns1__CompanyAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CompanyAccount, sizeof(ns1__CompanyAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CompanyAccount);
	if (soap_out_PointerTons1__CompanyAccount(soap, tag?tag:"ns1:CompanyAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CompanyAccount ** SOAP_FMAC4 soap_get_PointerTons1__CompanyAccount(struct soap *soap, ns1__CompanyAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CompanyAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PhoneNumberBelong))
		soap_serialize_PointerTons1__PhoneNumberBelong(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PhoneNumberBelong(struct soap *soap, const char *tag, int id, ns1__PhoneNumberBelong **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PhoneNumberBelong(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PhoneNumberBelong *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PhoneNumberBelong(struct soap *soap, const char *tag, ns1__PhoneNumberBelong ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNumberBelong ***)soap_malloc(soap, sizeof(ns1__PhoneNumberBelong **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PhoneNumberBelong(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNumberBelong ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PhoneNumberBelong, sizeof(ns1__PhoneNumberBelong *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PhoneNumberBelong);
	if (soap_out_PointerToPointerTons1__PhoneNumberBelong(soap, tag?tag:"ns1:PhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNumberBelong *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneNumberBelong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneNumberBelong(struct soap *soap, const char *tag, int id, ns1__PhoneNumberBelong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PhoneNumberBelong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PhoneNumberBelong ** SOAP_FMAC4 soap_in_PointerTons1__PhoneNumberBelong(struct soap *soap, const char *tag, ns1__PhoneNumberBelong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNumberBelong **)soap_malloc(soap, sizeof(ns1__PhoneNumberBelong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PhoneNumberBelong *)soap_instantiate_ns1__PhoneNumberBelong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PhoneNumberBelong ** p = (ns1__PhoneNumberBelong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PhoneNumberBelong, sizeof(ns1__PhoneNumberBelong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PhoneNumberBelong);
	if (soap_out_PointerTons1__PhoneNumberBelong(soap, tag?tag:"ns1:PhoneNumberBelong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNumberBelong ** SOAP_FMAC4 soap_get_PointerTons1__PhoneNumberBelong(struct soap *soap, ns1__PhoneNumberBelong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneNumberBelong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ReturnProportion))
		soap_serialize_PointerTons1__ReturnProportion(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ReturnProportion(struct soap *soap, const char *tag, int id, ns1__ReturnProportion **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ReturnProportion);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ReturnProportion(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ReturnProportion *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ReturnProportion(struct soap *soap, const char *tag, ns1__ReturnProportion ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnProportion ***)soap_malloc(soap, sizeof(ns1__ReturnProportion **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ReturnProportion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ReturnProportion ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ReturnProportion, sizeof(ns1__ReturnProportion *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ReturnProportion);
	if (soap_out_PointerToPointerTons1__ReturnProportion(soap, tag?tag:"ns1:ReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnProportion *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnProportion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnProportion(struct soap *soap, const char *tag, int id, ns1__ReturnProportion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReturnProportion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReturnProportion ** SOAP_FMAC4 soap_in_PointerTons1__ReturnProportion(struct soap *soap, const char *tag, ns1__ReturnProportion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnProportion **)soap_malloc(soap, sizeof(ns1__ReturnProportion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReturnProportion *)soap_instantiate_ns1__ReturnProportion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ReturnProportion ** p = (ns1__ReturnProportion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReturnProportion, sizeof(ns1__ReturnProportion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReturnProportion);
	if (soap_out_PointerTons1__ReturnProportion(soap, tag?tag:"ns1:ReturnProportion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnProportion ** SOAP_FMAC4 soap_get_PointerTons1__ReturnProportion(struct soap *soap, ns1__ReturnProportion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnProportion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__NoticeItem))
		soap_serialize_PointerTons1__NoticeItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__NoticeItem(struct soap *soap, const char *tag, int id, ns1__NoticeItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__NoticeItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__NoticeItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__NoticeItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__NoticeItem(struct soap *soap, const char *tag, ns1__NoticeItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoticeItem ***)soap_malloc(soap, sizeof(ns1__NoticeItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__NoticeItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__NoticeItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__NoticeItem, sizeof(ns1__NoticeItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__NoticeItem);
	if (soap_out_PointerToPointerTons1__NoticeItem(soap, tag?tag:"ns1:NoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoticeItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__NoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoticeItem(struct soap *soap, const char *tag, int id, ns1__NoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoticeItem ** SOAP_FMAC4 soap_in_PointerTons1__NoticeItem(struct soap *soap, const char *tag, ns1__NoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoticeItem **)soap_malloc(soap, sizeof(ns1__NoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoticeItem *)soap_instantiate_ns1__NoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoticeItem ** p = (ns1__NoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoticeItem, sizeof(ns1__NoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoticeItem);
	if (soap_out_PointerTons1__NoticeItem(soap, tag?tag:"ns1:NoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoticeItem ** SOAP_FMAC4 soap_get_PointerTons1__NoticeItem(struct soap *soap, ns1__NoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNoticeItem(struct soap *soap, ns1__ArrayOfNoticeItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfNoticeItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNoticeItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfNoticeItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfNoticeItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfNoticeItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNoticeItem(struct soap *soap, const char *tag, ns1__ArrayOfNoticeItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfNoticeItem **)soap_malloc(soap, sizeof(ns1__ArrayOfNoticeItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfNoticeItem *)soap_instantiate_ns1__ArrayOfNoticeItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfNoticeItem ** p = (ns1__ArrayOfNoticeItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfNoticeItem, sizeof(ns1__ArrayOfNoticeItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNoticeItem(struct soap *soap, ns1__ArrayOfNoticeItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfNoticeItem);
	if (soap_out_PointerTons1__ArrayOfNoticeItem(soap, tag?tag:"ns1:ArrayOfNoticeItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfNoticeItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNoticeItem(struct soap *soap, ns1__ArrayOfNoticeItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNoticeItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DIC_USCORECategory))
		soap_serialize_PointerTons1__DIC_USCORECategory(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DIC_USCORECategory(struct soap *soap, const char *tag, int id, ns1__DIC_USCORECategory **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DIC_USCORECategory);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DIC_USCORECategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DIC_USCORECategory *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DIC_USCORECategory(struct soap *soap, const char *tag, ns1__DIC_USCORECategory ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DIC_USCORECategory ***)soap_malloc(soap, sizeof(ns1__DIC_USCORECategory **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DIC_USCORECategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DIC_USCORECategory ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DIC_USCORECategory, sizeof(ns1__DIC_USCORECategory *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DIC_USCORECategory);
	if (soap_out_PointerToPointerTons1__DIC_USCORECategory(soap, tag?tag:"ns1:DIC_Category", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DIC_USCORECategory *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DIC_USCORECategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DIC_USCORECategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DIC_USCORECategory(struct soap *soap, const char *tag, int id, ns1__DIC_USCORECategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DIC_USCORECategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DIC_USCORECategory ** SOAP_FMAC4 soap_in_PointerTons1__DIC_USCORECategory(struct soap *soap, const char *tag, ns1__DIC_USCORECategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DIC_USCORECategory **)soap_malloc(soap, sizeof(ns1__DIC_USCORECategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DIC_USCORECategory *)soap_instantiate_ns1__DIC_USCORECategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DIC_USCORECategory ** p = (ns1__DIC_USCORECategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DIC_USCORECategory, sizeof(ns1__DIC_USCORECategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DIC_USCORECategory);
	if (soap_out_PointerTons1__DIC_USCORECategory(soap, tag?tag:"ns1:DIC_Category", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DIC_USCORECategory ** SOAP_FMAC4 soap_get_PointerTons1__DIC_USCORECategory(struct soap *soap, ns1__DIC_USCORECategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DIC_USCORECategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DIC_USCOREContent))
		soap_serialize_PointerTons1__DIC_USCOREContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DIC_USCOREContent(struct soap *soap, const char *tag, int id, ns1__DIC_USCOREContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DIC_USCOREContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DIC_USCOREContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DIC_USCOREContent *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DIC_USCOREContent(struct soap *soap, const char *tag, ns1__DIC_USCOREContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DIC_USCOREContent ***)soap_malloc(soap, sizeof(ns1__DIC_USCOREContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DIC_USCOREContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DIC_USCOREContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DIC_USCOREContent, sizeof(ns1__DIC_USCOREContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DIC_USCOREContent);
	if (soap_out_PointerToPointerTons1__DIC_USCOREContent(soap, tag?tag:"ns1:DIC_Content", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DIC_USCOREContent *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DIC_USCOREContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DIC_USCOREContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DIC_USCOREContent(struct soap *soap, const char *tag, int id, ns1__DIC_USCOREContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DIC_USCOREContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DIC_USCOREContent ** SOAP_FMAC4 soap_in_PointerTons1__DIC_USCOREContent(struct soap *soap, const char *tag, ns1__DIC_USCOREContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DIC_USCOREContent **)soap_malloc(soap, sizeof(ns1__DIC_USCOREContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DIC_USCOREContent *)soap_instantiate_ns1__DIC_USCOREContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DIC_USCOREContent ** p = (ns1__DIC_USCOREContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DIC_USCOREContent, sizeof(ns1__DIC_USCOREContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DIC_USCOREContent);
	if (soap_out_PointerTons1__DIC_USCOREContent(soap, tag?tag:"ns1:DIC_Content", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DIC_USCOREContent ** SOAP_FMAC4 soap_get_PointerTons1__DIC_USCOREContent(struct soap *soap, ns1__DIC_USCOREContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DIC_USCOREContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AcountPaymentItem))
		soap_serialize_PointerTons1__AcountPaymentItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AcountPaymentItem(struct soap *soap, const char *tag, int id, ns1__AcountPaymentItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AcountPaymentItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AcountPaymentItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AcountPaymentItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AcountPaymentItem(struct soap *soap, const char *tag, ns1__AcountPaymentItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AcountPaymentItem ***)soap_malloc(soap, sizeof(ns1__AcountPaymentItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AcountPaymentItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AcountPaymentItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AcountPaymentItem, sizeof(ns1__AcountPaymentItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AcountPaymentItem);
	if (soap_out_PointerToPointerTons1__AcountPaymentItem(soap, tag?tag:"ns1:AcountPaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AcountPaymentItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AcountPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AcountPaymentItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AcountPaymentItem(struct soap *soap, const char *tag, int id, ns1__AcountPaymentItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AcountPaymentItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AcountPaymentItem ** SOAP_FMAC4 soap_in_PointerTons1__AcountPaymentItem(struct soap *soap, const char *tag, ns1__AcountPaymentItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AcountPaymentItem **)soap_malloc(soap, sizeof(ns1__AcountPaymentItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AcountPaymentItem *)soap_instantiate_ns1__AcountPaymentItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AcountPaymentItem ** p = (ns1__AcountPaymentItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AcountPaymentItem, sizeof(ns1__AcountPaymentItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AcountPaymentItem);
	if (soap_out_PointerTons1__AcountPaymentItem(soap, tag?tag:"ns1:AcountPaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AcountPaymentItem ** SOAP_FMAC4 soap_get_PointerTons1__AcountPaymentItem(struct soap *soap, ns1__AcountPaymentItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AcountPaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ReturnedItem))
		soap_serialize_PointerTons1__ReturnedItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ReturnedItem(struct soap *soap, const char *tag, int id, ns1__ReturnedItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ReturnedItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ReturnedItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ReturnedItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ReturnedItem(struct soap *soap, const char *tag, ns1__ReturnedItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnedItem ***)soap_malloc(soap, sizeof(ns1__ReturnedItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ReturnedItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ReturnedItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ReturnedItem, sizeof(ns1__ReturnedItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ReturnedItem);
	if (soap_out_PointerToPointerTons1__ReturnedItem(soap, tag?tag:"ns1:ReturnedItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnedItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ReturnedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnedItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnedItem(struct soap *soap, const char *tag, int id, ns1__ReturnedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReturnedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReturnedItem ** SOAP_FMAC4 soap_in_PointerTons1__ReturnedItem(struct soap *soap, const char *tag, ns1__ReturnedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnedItem **)soap_malloc(soap, sizeof(ns1__ReturnedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReturnedItem *)soap_instantiate_ns1__ReturnedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ReturnedItem ** p = (ns1__ReturnedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReturnedItem, sizeof(ns1__ReturnedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReturnedItem);
	if (soap_out_PointerTons1__ReturnedItem(soap, tag?tag:"ns1:ReturnedItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnedItem ** SOAP_FMAC4 soap_get_PointerTons1__ReturnedItem(struct soap *soap, ns1__ReturnedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SystemFunction))
		soap_serialize_PointerTons1__SystemFunction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SystemFunction(struct soap *soap, const char *tag, int id, ns1__SystemFunction **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SystemFunction);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SystemFunction(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SystemFunction *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SystemFunction(struct soap *soap, const char *tag, ns1__SystemFunction ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SystemFunction ***)soap_malloc(soap, sizeof(ns1__SystemFunction **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SystemFunction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SystemFunction ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SystemFunction, sizeof(ns1__SystemFunction *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SystemFunction);
	if (soap_out_PointerToPointerTons1__SystemFunction(soap, tag?tag:"ns1:SystemFunction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SystemFunction *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SystemFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SystemFunction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SystemFunction(struct soap *soap, const char *tag, int id, ns1__SystemFunction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SystemFunction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SystemFunction ** SOAP_FMAC4 soap_in_PointerTons1__SystemFunction(struct soap *soap, const char *tag, ns1__SystemFunction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SystemFunction **)soap_malloc(soap, sizeof(ns1__SystemFunction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SystemFunction *)soap_instantiate_ns1__SystemFunction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SystemFunction ** p = (ns1__SystemFunction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SystemFunction, sizeof(ns1__SystemFunction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SystemFunction);
	if (soap_out_PointerTons1__SystemFunction(soap, tag?tag:"ns1:SystemFunction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SystemFunction ** SOAP_FMAC4 soap_get_PointerTons1__SystemFunction(struct soap *soap, ns1__SystemFunction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SystemFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Worker(struct soap *soap, ns1__Worker **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Worker))
		soap_serialize_PointerTons1__Worker(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Worker(struct soap *soap, const char *tag, int id, ns1__Worker **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Worker);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Worker(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Worker *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Worker(struct soap *soap, const char *tag, ns1__Worker ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Worker ***)soap_malloc(soap, sizeof(ns1__Worker **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Worker(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Worker ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Worker, sizeof(ns1__Worker *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Worker(struct soap *soap, ns1__Worker **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Worker);
	if (soap_out_PointerToPointerTons1__Worker(soap, tag?tag:"ns1:Worker", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Worker *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Worker(struct soap *soap, ns1__Worker ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Worker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Worker(struct soap *soap, ns1__Worker *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Worker))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Worker(struct soap *soap, const char *tag, int id, ns1__Worker *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Worker);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Worker ** SOAP_FMAC4 soap_in_PointerTons1__Worker(struct soap *soap, const char *tag, ns1__Worker **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Worker **)soap_malloc(soap, sizeof(ns1__Worker *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Worker *)soap_instantiate_ns1__Worker(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Worker ** p = (ns1__Worker **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Worker, sizeof(ns1__Worker), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Worker(struct soap *soap, ns1__Worker *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Worker);
	if (soap_out_PointerTons1__Worker(soap, tag?tag:"ns1:Worker", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Worker ** SOAP_FMAC4 soap_get_PointerTons1__Worker(struct soap *soap, ns1__Worker **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Worker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ReturnInfoItem))
		soap_serialize_PointerTons1__ReturnInfoItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ReturnInfoItem(struct soap *soap, const char *tag, int id, ns1__ReturnInfoItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ReturnInfoItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ReturnInfoItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ReturnInfoItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ReturnInfoItem(struct soap *soap, const char *tag, ns1__ReturnInfoItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnInfoItem ***)soap_malloc(soap, sizeof(ns1__ReturnInfoItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ReturnInfoItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ReturnInfoItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ReturnInfoItem, sizeof(ns1__ReturnInfoItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ReturnInfoItem);
	if (soap_out_PointerToPointerTons1__ReturnInfoItem(soap, tag?tag:"ns1:ReturnInfoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnInfoItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ReturnInfoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnInfoItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnInfoItem(struct soap *soap, const char *tag, int id, ns1__ReturnInfoItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReturnInfoItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReturnInfoItem ** SOAP_FMAC4 soap_in_PointerTons1__ReturnInfoItem(struct soap *soap, const char *tag, ns1__ReturnInfoItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReturnInfoItem **)soap_malloc(soap, sizeof(ns1__ReturnInfoItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReturnInfoItem *)soap_instantiate_ns1__ReturnInfoItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ReturnInfoItem ** p = (ns1__ReturnInfoItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReturnInfoItem, sizeof(ns1__ReturnInfoItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReturnInfoItem);
	if (soap_out_PointerTons1__ReturnInfoItem(soap, tag?tag:"ns1:ReturnInfoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReturnInfoItem ** SOAP_FMAC4 soap_get_PointerTons1__ReturnInfoItem(struct soap *soap, ns1__ReturnInfoItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnInfoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfReturnInfoItem(struct soap *soap, ns1__ArrayOfReturnInfoItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfReturnInfoItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfReturnInfoItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfReturnInfoItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfReturnInfoItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfReturnInfoItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfReturnInfoItem(struct soap *soap, const char *tag, ns1__ArrayOfReturnInfoItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfReturnInfoItem **)soap_malloc(soap, sizeof(ns1__ArrayOfReturnInfoItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfReturnInfoItem *)soap_instantiate_ns1__ArrayOfReturnInfoItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfReturnInfoItem ** p = (ns1__ArrayOfReturnInfoItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfReturnInfoItem, sizeof(ns1__ArrayOfReturnInfoItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfReturnInfoItem(struct soap *soap, ns1__ArrayOfReturnInfoItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfReturnInfoItem);
	if (soap_out_PointerTons1__ArrayOfReturnInfoItem(soap, tag?tag:"ns1:ArrayOfReturnInfoItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfReturnInfoItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfReturnInfoItem(struct soap *soap, ns1__ArrayOfReturnInfoItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfReturnInfoItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PayPublicTelItem))
		soap_serialize_PointerTons1__PayPublicTelItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PayPublicTelItem(struct soap *soap, const char *tag, int id, ns1__PayPublicTelItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PayPublicTelItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PayPublicTelItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PayPublicTelItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PayPublicTelItem(struct soap *soap, const char *tag, ns1__PayPublicTelItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayPublicTelItem ***)soap_malloc(soap, sizeof(ns1__PayPublicTelItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PayPublicTelItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PayPublicTelItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PayPublicTelItem, sizeof(ns1__PayPublicTelItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PayPublicTelItem);
	if (soap_out_PointerToPointerTons1__PayPublicTelItem(soap, tag?tag:"ns1:PayPublicTelItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayPublicTelItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PayPublicTelItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayPublicTelItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayPublicTelItem(struct soap *soap, const char *tag, int id, ns1__PayPublicTelItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayPublicTelItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayPublicTelItem ** SOAP_FMAC4 soap_in_PointerTons1__PayPublicTelItem(struct soap *soap, const char *tag, ns1__PayPublicTelItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayPublicTelItem **)soap_malloc(soap, sizeof(ns1__PayPublicTelItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayPublicTelItem *)soap_instantiate_ns1__PayPublicTelItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayPublicTelItem ** p = (ns1__PayPublicTelItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayPublicTelItem, sizeof(ns1__PayPublicTelItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayPublicTelItem);
	if (soap_out_PointerTons1__PayPublicTelItem(soap, tag?tag:"ns1:PayPublicTelItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayPublicTelItem ** SOAP_FMAC4 soap_get_PointerTons1__PayPublicTelItem(struct soap *soap, ns1__PayPublicTelItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayPublicTelItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PayGameItem))
		soap_serialize_PointerTons1__PayGameItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PayGameItem(struct soap *soap, const char *tag, int id, ns1__PayGameItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PayGameItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PayGameItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PayGameItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PayGameItem(struct soap *soap, const char *tag, ns1__PayGameItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayGameItem ***)soap_malloc(soap, sizeof(ns1__PayGameItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PayGameItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PayGameItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PayGameItem, sizeof(ns1__PayGameItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PayGameItem);
	if (soap_out_PointerToPointerTons1__PayGameItem(soap, tag?tag:"ns1:PayGameItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayGameItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PayGameItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayGameItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayGameItem(struct soap *soap, const char *tag, int id, ns1__PayGameItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayGameItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayGameItem ** SOAP_FMAC4 soap_in_PointerTons1__PayGameItem(struct soap *soap, const char *tag, ns1__PayGameItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayGameItem **)soap_malloc(soap, sizeof(ns1__PayGameItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayGameItem *)soap_instantiate_ns1__PayGameItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayGameItem ** p = (ns1__PayGameItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayGameItem, sizeof(ns1__PayGameItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayGameItem);
	if (soap_out_PointerTons1__PayGameItem(soap, tag?tag:"ns1:PayGameItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayGameItem ** SOAP_FMAC4 soap_get_PointerTons1__PayGameItem(struct soap *soap, ns1__PayGameItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayGameItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PayInternetItem))
		soap_serialize_PointerTons1__PayInternetItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PayInternetItem(struct soap *soap, const char *tag, int id, ns1__PayInternetItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PayInternetItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PayInternetItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PayInternetItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PayInternetItem(struct soap *soap, const char *tag, ns1__PayInternetItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayInternetItem ***)soap_malloc(soap, sizeof(ns1__PayInternetItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PayInternetItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PayInternetItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PayInternetItem, sizeof(ns1__PayInternetItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PayInternetItem);
	if (soap_out_PointerToPointerTons1__PayInternetItem(soap, tag?tag:"ns1:PayInternetItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayInternetItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PayInternetItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayInternetItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayInternetItem(struct soap *soap, const char *tag, int id, ns1__PayInternetItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayInternetItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayInternetItem ** SOAP_FMAC4 soap_in_PointerTons1__PayInternetItem(struct soap *soap, const char *tag, ns1__PayInternetItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayInternetItem **)soap_malloc(soap, sizeof(ns1__PayInternetItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayInternetItem *)soap_instantiate_ns1__PayInternetItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayInternetItem ** p = (ns1__PayInternetItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayInternetItem, sizeof(ns1__PayInternetItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayInternetItem);
	if (soap_out_PointerTons1__PayInternetItem(soap, tag?tag:"ns1:PayInternetItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayInternetItem ** SOAP_FMAC4 soap_get_PointerTons1__PayInternetItem(struct soap *soap, ns1__PayInternetItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayInternetItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TransStaticsItem))
		soap_serialize_PointerTons1__TransStaticsItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TransStaticsItem(struct soap *soap, const char *tag, int id, ns1__TransStaticsItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TransStaticsItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TransStaticsItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TransStaticsItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TransStaticsItem(struct soap *soap, const char *tag, ns1__TransStaticsItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TransStaticsItem ***)soap_malloc(soap, sizeof(ns1__TransStaticsItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TransStaticsItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TransStaticsItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__TransStaticsItem, sizeof(ns1__TransStaticsItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__TransStaticsItem);
	if (soap_out_PointerToPointerTons1__TransStaticsItem(soap, tag?tag:"ns1:TransStaticsItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TransStaticsItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TransStaticsItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TransStaticsItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TransStaticsItem(struct soap *soap, const char *tag, int id, ns1__TransStaticsItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TransStaticsItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TransStaticsItem ** SOAP_FMAC4 soap_in_PointerTons1__TransStaticsItem(struct soap *soap, const char *tag, ns1__TransStaticsItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TransStaticsItem **)soap_malloc(soap, sizeof(ns1__TransStaticsItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TransStaticsItem *)soap_instantiate_ns1__TransStaticsItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TransStaticsItem ** p = (ns1__TransStaticsItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TransStaticsItem, sizeof(ns1__TransStaticsItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TransStaticsItem);
	if (soap_out_PointerTons1__TransStaticsItem(soap, tag?tag:"ns1:TransStaticsItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TransStaticsItem ** SOAP_FMAC4 soap_get_PointerTons1__TransStaticsItem(struct soap *soap, ns1__TransStaticsItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TransStaticsItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Transaction(struct soap *soap, ns1__Transaction **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Transaction))
		soap_serialize_PointerTons1__Transaction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Transaction(struct soap *soap, const char *tag, int id, ns1__Transaction **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Transaction);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Transaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Transaction *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Transaction(struct soap *soap, const char *tag, ns1__Transaction ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Transaction ***)soap_malloc(soap, sizeof(ns1__Transaction **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Transaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Transaction ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Transaction, sizeof(ns1__Transaction *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Transaction(struct soap *soap, ns1__Transaction **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Transaction);
	if (soap_out_PointerToPointerTons1__Transaction(soap, tag?tag:"ns1:Transaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Transaction *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Transaction(struct soap *soap, ns1__Transaction ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Transaction(struct soap *soap, ns1__Transaction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Transaction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Transaction(struct soap *soap, const char *tag, int id, ns1__Transaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Transaction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Transaction ** SOAP_FMAC4 soap_in_PointerTons1__Transaction(struct soap *soap, const char *tag, ns1__Transaction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Transaction **)soap_malloc(soap, sizeof(ns1__Transaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Transaction *)soap_instantiate_ns1__Transaction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Transaction ** p = (ns1__Transaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Transaction, sizeof(ns1__Transaction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Transaction(struct soap *soap, ns1__Transaction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Transaction);
	if (soap_out_PointerTons1__Transaction(soap, tag?tag:"ns1:Transaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Transaction ** SOAP_FMAC4 soap_get_PointerTons1__Transaction(struct soap *soap, ns1__Transaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PaymentItem))
		soap_serialize_PointerTons1__PaymentItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PaymentItem(struct soap *soap, const char *tag, int id, ns1__PaymentItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PaymentItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PaymentItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PaymentItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PaymentItem(struct soap *soap, const char *tag, ns1__PaymentItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentItem ***)soap_malloc(soap, sizeof(ns1__PaymentItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PaymentItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PaymentItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PaymentItem, sizeof(ns1__PaymentItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PaymentItem);
	if (soap_out_PointerToPointerTons1__PaymentItem(soap, tag?tag:"ns1:PaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PaymentItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PaymentItem(struct soap *soap, const char *tag, int id, ns1__PaymentItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PaymentItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PaymentItem ** SOAP_FMAC4 soap_in_PointerTons1__PaymentItem(struct soap *soap, const char *tag, ns1__PaymentItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PaymentItem **)soap_malloc(soap, sizeof(ns1__PaymentItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PaymentItem *)soap_instantiate_ns1__PaymentItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PaymentItem ** p = (ns1__PaymentItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PaymentItem, sizeof(ns1__PaymentItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PaymentItem);
	if (soap_out_PointerTons1__PaymentItem(soap, tag?tag:"ns1:PaymentItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PaymentItem ** SOAP_FMAC4 soap_get_PointerTons1__PaymentItem(struct soap *soap, ns1__PaymentItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PaymentItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PayWithListItem))
		soap_serialize_PointerTons1__PayWithListItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PayWithListItem(struct soap *soap, const char *tag, int id, ns1__PayWithListItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PayWithListItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PayWithListItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PayWithListItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PayWithListItem(struct soap *soap, const char *tag, ns1__PayWithListItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayWithListItem ***)soap_malloc(soap, sizeof(ns1__PayWithListItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PayWithListItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PayWithListItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PayWithListItem, sizeof(ns1__PayWithListItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PayWithListItem);
	if (soap_out_PointerToPointerTons1__PayWithListItem(soap, tag?tag:"ns1:PayWithListItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayWithListItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PayWithListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PayWithListItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PayWithListItem(struct soap *soap, const char *tag, int id, ns1__PayWithListItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PayWithListItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PayWithListItem ** SOAP_FMAC4 soap_in_PointerTons1__PayWithListItem(struct soap *soap, const char *tag, ns1__PayWithListItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PayWithListItem **)soap_malloc(soap, sizeof(ns1__PayWithListItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PayWithListItem *)soap_instantiate_ns1__PayWithListItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PayWithListItem ** p = (ns1__PayWithListItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PayWithListItem, sizeof(ns1__PayWithListItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PayWithListItem);
	if (soap_out_PointerTons1__PayWithListItem(soap, tag?tag:"ns1:PayWithListItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PayWithListItem ** SOAP_FMAC4 soap_get_PointerTons1__PayWithListItem(struct soap *soap, ns1__PayWithListItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PayWithListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPayWithListItem(struct soap *soap, ns1__ArrayOfPayWithListItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPayWithListItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPayWithListItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfPayWithListItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPayWithListItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPayWithListItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPayWithListItem(struct soap *soap, const char *tag, ns1__ArrayOfPayWithListItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPayWithListItem **)soap_malloc(soap, sizeof(ns1__ArrayOfPayWithListItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPayWithListItem *)soap_instantiate_ns1__ArrayOfPayWithListItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPayWithListItem ** p = (ns1__ArrayOfPayWithListItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPayWithListItem, sizeof(ns1__ArrayOfPayWithListItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPayWithListItem(struct soap *soap, ns1__ArrayOfPayWithListItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPayWithListItem);
	if (soap_out_PointerTons1__ArrayOfPayWithListItem(soap, tag?tag:"ns1:ArrayOfPayWithListItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPayWithListItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPayWithListItem(struct soap *soap, ns1__ArrayOfPayWithListItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPayWithListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__guid(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__guid);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__guid(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__guid, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__guid(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__guid);
	if (soap_out_ns2__guid(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__guid(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
